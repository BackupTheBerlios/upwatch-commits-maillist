From raarts at mail.berlios.de  Fri Jul 21 22:32:44 2006
From: raarts at mail.berlios.de (raarts at BerliOS)
Date: Fri, 21 Jul 2006 22:32:44 +0200
Subject: [Upwatch-commits] r631 - upwatch
Message-ID: <200607212032.k6LKWiRq024800@sheep.berlios.de>

Author: raarts
Date: 2006-07-21 22:32:44 +0200 (Fri, 21 Jul 2006)
New Revision: 631

Added:
   upwatch/libdbi/
Log:
Create separate tree for libdbi support


Copied: upwatch/libdbi (from rev 514, upwatch/trunk)



From wijnand at mail.berlios.de  Wed Jul 26 18:12:53 2006
From: wijnand at mail.berlios.de (wijnand at BerliOS)
Date: Wed, 26 Jul 2006 18:12:53 +0200
Subject: [Upwatch-commits] r634 - upwatch/trunk/uw_httpget
Message-ID: <200607261612.k6QGCrtF019759@sheep.berlios.de>

Author: wijnand
Date: 2006-07-26 18:12:53 +0200 (Wed, 26 Jul 2006)
New Revision: 634

Modified:
   upwatch/trunk/uw_httpget/uw_httpget.conf
Log:
Fix default uw_httpget.conf


Modified: upwatch/trunk/uw_httpget/uw_httpget.conf
===================================================================
--- upwatch/trunk/uw_httpget/uw_httpget.conf	2006-07-21 23:12:45 UTC (rev 633)
+++ upwatch/trunk/uw_httpget/uw_httpget.conf	2006-07-26 16:12:53 UTC (rev 634)
@@ -1,5 +1,3 @@
 # log to logfile
 #logfile /var/log/upwatch/uw_httpget.log
-
-
-
+output uw_send



From raarts at mail.berlios.de  Fri Jul 21 22:35:43 2006
From: raarts at mail.berlios.de (raarts at BerliOS)
Date: Fri, 21 Jul 2006 22:35:43 +0200
Subject: [Upwatch-commits] r632 - in upwatch/libdbi: . common
	compat/bb/bbhimport doc st-1.4 upwatch uw_accept uw_acceptbb
	uw_dns uw_httpget uw_imap uw_investigate uw_mssql uw_mysql
	uw_mysqlstats uw_null uw_ping uw_pop3 uw_postgresql
	uw_process uw_purple uw_route uw_send uw_setip uw_smtp
	uw_snmpget uw_syncprobes uw_sysstat uw_tcpconnect
Message-ID: <200607212035.k6LKZhah024996@sheep.berlios.de>

Author: raarts
Date: 2006-07-21 22:34:40 +0200 (Fri, 21 Jul 2006)
New Revision: 632

Modified:
   upwatch/libdbi/Makefile.am
   upwatch/libdbi/Makefile.am.common
   upwatch/libdbi/common/db.c
   upwatch/libdbi/common/dbase_options.def
   upwatch/libdbi/common/main.c
   upwatch/libdbi/common/probe.tpl
   upwatch/libdbi/compat/bb/bbhimport/Makefile.am
   upwatch/libdbi/compat/bb/bbhimport/run.c
   upwatch/libdbi/configure.ac
   upwatch/libdbi/doc/installation.xml
   upwatch/libdbi/doc/program-guide.html
   upwatch/libdbi/doc/program-guide.txt
   upwatch/libdbi/st-1.4/st.spec
   upwatch/libdbi/upwatch-spec.spec
   upwatch/libdbi/upwatch/Makefile.am
   upwatch/libdbi/upwatch/compat.h
   upwatch/libdbi/upwatch/db.h
   upwatch/libdbi/upwatch/pr_bb.c
   upwatch/libdbi/upwatch/pr_bb_cpu.c
   upwatch/libdbi/upwatch/pr_hwstat.c
   upwatch/libdbi/upwatch/pr_iptraf.c
   upwatch/libdbi/upwatch/pr_process.c
   upwatch/libdbi/upwatch/pr_sysstat.c
   upwatch/libdbi/upwatch/probe.h
   upwatch/libdbi/upwatch/spool.c
   upwatch/libdbi/upwatch/spool.h
   upwatch/libdbi/uw_accept/Makefile.am
   upwatch/libdbi/uw_accept/run.c
   upwatch/libdbi/uw_accept/uw_accept.def
   upwatch/libdbi/uw_acceptbb/Makefile.am
   upwatch/libdbi/uw_acceptbb/uw_acceptbb.def
   upwatch/libdbi/uw_dns/Makefile.am
   upwatch/libdbi/uw_dns/run.c
   upwatch/libdbi/uw_dns/uw_dns.def
   upwatch/libdbi/uw_httpget/Makefile.am
   upwatch/libdbi/uw_httpget/run.c
   upwatch/libdbi/uw_httpget/uw_httpget.def
   upwatch/libdbi/uw_imap/Makefile.am
   upwatch/libdbi/uw_imap/run.c
   upwatch/libdbi/uw_imap/uw_imap.def
   upwatch/libdbi/uw_investigate/cmd_options.def
   upwatch/libdbi/uw_mssql/Makefile.am
   upwatch/libdbi/uw_mssql/run.c
   upwatch/libdbi/uw_mssql/uw_mssql.def
   upwatch/libdbi/uw_mysql/Makefile.am
   upwatch/libdbi/uw_mysql/run.c
   upwatch/libdbi/uw_mysql/uw_mysql.def
   upwatch/libdbi/uw_mysqlstats/Makefile.am
   upwatch/libdbi/uw_mysqlstats/run.c
   upwatch/libdbi/uw_mysqlstats/uw_mysqlstats.def
   upwatch/libdbi/uw_null/Makefile.am
   upwatch/libdbi/uw_ping/Makefile.am
   upwatch/libdbi/uw_ping/run.c
   upwatch/libdbi/uw_ping/uw_ping.def
   upwatch/libdbi/uw_pop3/Makefile.am
   upwatch/libdbi/uw_pop3/run.c
   upwatch/libdbi/uw_pop3/uw_pop3.def
   upwatch/libdbi/uw_postgresql/Makefile.am
   upwatch/libdbi/uw_postgresql/run.c
   upwatch/libdbi/uw_postgresql/uw_postgresql.def
   upwatch/libdbi/uw_process/Makefile.am
   upwatch/libdbi/uw_process/bb_cpu.c
   upwatch/libdbi/uw_process/generic_ct.c
   upwatch/libdbi/uw_process/httpget.c
   upwatch/libdbi/uw_process/hwstat.c
   upwatch/libdbi/uw_process/imap.c
   upwatch/libdbi/uw_process/insertcache.c
   upwatch/libdbi/uw_process/iptraf.c
   upwatch/libdbi/uw_process/mssql.c
   upwatch/libdbi/uw_process/mysql.c
   upwatch/libdbi/uw_process/mysqlstats.c
   upwatch/libdbi/uw_process/notify.c
   upwatch/libdbi/uw_process/ping.c
   upwatch/libdbi/uw_process/pop3.c
   upwatch/libdbi/uw_process/postgresql.c
   upwatch/libdbi/uw_process/process.c
   upwatch/libdbi/uw_process/run.c
   upwatch/libdbi/uw_process/snmpget.c
   upwatch/libdbi/uw_process/sysstat.c
   upwatch/libdbi/uw_process/tcpconnect.c
   upwatch/libdbi/uw_process/uw_process.def
   upwatch/libdbi/uw_process/uw_process_glob.h
   upwatch/libdbi/uw_process/uw_tnot.def
   upwatch/libdbi/uw_purple/Makefile.am
   upwatch/libdbi/uw_purple/run.c
   upwatch/libdbi/uw_purple/uw_purple.def
   upwatch/libdbi/uw_route/Makefile.am
   upwatch/libdbi/uw_route/uw_route.def
   upwatch/libdbi/uw_send/Makefile.am
   upwatch/libdbi/uw_setip/Makefile.am
   upwatch/libdbi/uw_setip/run.c
   upwatch/libdbi/uw_setip/uw_setip.def
   upwatch/libdbi/uw_smtp/Makefile.am
   upwatch/libdbi/uw_smtp/run.c
   upwatch/libdbi/uw_smtp/uw_smtp.def
   upwatch/libdbi/uw_snmpget/Makefile.am
   upwatch/libdbi/uw_snmpget/run.c
   upwatch/libdbi/uw_snmpget/uw_snmpget.def
   upwatch/libdbi/uw_syncprobes/Makefile.am
   upwatch/libdbi/uw_syncprobes/run.c
   upwatch/libdbi/uw_syncprobes/uw_syncprobes.def
   upwatch/libdbi/uw_sysstat/Makefile.am
   upwatch/libdbi/uw_tcpconnect/Makefile.am
   upwatch/libdbi/uw_tcpconnect/run.c
   upwatch/libdbi/uw_tcpconnect/uw_tcpconnect.def
Log:
First try at supporting libdbi - stll lots of loose ends


Modified: upwatch/libdbi/Makefile.am
===================================================================
--- upwatch/libdbi/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,6 +8,10 @@
 UW_IPTRAF = uw_iptraf
 endif
 
+if HAVE_LIBMYSQL
+UW_MYSQL = uw_mysql uw_mysqlstats
+endif
+
 if HAVE_LIBPQ
 UW_POSTGRESQL = uw_postgresql
 endif
@@ -20,6 +24,10 @@
 UW_MSSQL = uw_mssql
 endif
 
+if XMBMON
+XMBMON = xmbmon203
+endif
+
 # variables to build installable packages
 # packages are:
 # base (includes docs, utils, uw_sysstat, uw_null and uw_send).
@@ -29,8 +37,8 @@
 CLIENTLIST = uw_send uw_sysstat uw_null
 # order is important here: uw_process should be last
 SERVERLIST = uw_acceptbb uw_accept uw_purple uw_route uw_syncprobes uw_setip uw_process
-MONITORLIST = uw_httpget uw_dns uw_ping uw_mysql uw_mysqlstats uw_pop3 uw_smtp uw_tcpconnect uw_imap \
- ${UW_POSTGRESQL} ${UW_SNMPGET} ${UW_MSSQL}
+MONITORLIST = uw_httpget uw_dns uw_ping uw_pop3 uw_smtp uw_tcpconnect uw_imap \
+ ${UW_MYSQL} ${UW_POSTGRESQL} ${UW_SNMPGET} ${UW_MSSQL}
 IPTRAFLIST = uw_iptraf
 EXTRALIST = ${IPTRAFLIST}
 
@@ -39,6 +47,7 @@
 if ENABLE_SERVER
 SERVERPROG = ${SERVERLIST}
 ENABLE_SERVER = --enable-server
+COMPAT = compat
 endif
 
 if ENABLE_MONITORS
@@ -53,10 +62,6 @@
 
 EXTRAPROG = ${IPTRAFPROG}
 
-if XMBMON
-XMBMON = xmbmon203
-endif
-
 CONFARGS = --enable-client $(ENABLE_SERVER) $(ENABLE_MONITOR) $(ENABLE_IPTRAF)
 
 # order is important: SERVERPROG should be last
@@ -65,11 +70,11 @@
 export PROGNAMES MONITORPROG CLIENTPROG SERVERPROG EXTRAPROG
 export TOP_SRCDIR = $(top_srcdir)
 
-if ENABLE_SERVER
-SUBDIRS = upwatch st-1.4 ${XMBMON} libstatgrab ${PROGNAMES} compat util scripts config common
-else
-SUBDIRS = upwatch st-1.4 ${XMBMON} libstatgrab ${PROGNAMES} util scripts config common 
-endif
+SUBDIRS = upwatch st-1.4 ${XMBMON} libstatgrab uw_send uw_sysstat uw_null \
+  uw_httpget uw_dns uw_ping uw_pop3 uw_smtp uw_tcpconnect uw_imap \
+  uw_mysql uw_mysqlstats uw_postgresql uw_snmpget uw_mssql uw_iptraf \
+  uw_acceptbb uw_accept uw_purple uw_route uw_syncprobes uw_setip uw_process \
+  ${COMPAT} util scripts config common
 
 DIST_SUBDIRS = ${SUBDIRS} doc
 

Modified: upwatch/libdbi/Makefile.am.common
===================================================================
--- upwatch/libdbi/Makefile.am.common	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/Makefile.am.common	2006-07-21 20:34:40 UTC (rev 632)
@@ -32,11 +32,11 @@
 
 %_main.o: $(top_srcdir)/common/main.c $(@:%_main.o=%.def) $(CMDDEF)
 	$(COMPILE) -include $(@:%_main.o=%.h) -o $@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ \
-		@MYSQL_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) -c $(top_srcdir)/common/main.c
+		@LIBOPTS_CFLAGS@ $(AM_CFLAGS) -c $(top_srcdir)/common/main.c
 
 %_db.o: $(top_srcdir)/common/db.c $(@:%_db.o=%.def) $(CMDDEF)
 	$(COMPILE) -include $(@:%_db.o=%.h) -o $@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ \
-		@MYSQL_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) -c $(top_srcdir)/common/db.c
+		@LIBOPTS_CFLAGS@ $(AM_CFLAGS) -c $(top_srcdir)/common/db.c
 
 %.c %.h: %.def
 	autogen -b $(<:%.def=%) $(AGDEFINES) $(GENINCL) $<

Modified: upwatch/libdbi/common/db.c
===================================================================
--- upwatch/libdbi/common/db.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/common/db.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -1,6 +1,5 @@
 #include "config.h"
-#include <mysql.h>
-#include <mysqld_error.h>
+#include <dbi/dbi.h>
 #include <stdarg.h>
 #include <generic.h>
 
@@ -8,74 +7,75 @@
 #include "dmalloc.h"
 #endif
 
-#ifndef HAVE_MYSQL_REAL_ESCAPE
-unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length)
-{
-  return(mysql_escape_string(to, from, length));
-}
-#endif
-
-
 /****************************
  database functions. 
  NOTE: Don't use with multithreaded programs!
  ***************************/
-void close_database(MYSQL *mysql)
+void close_database(dbi_conn conn)
 {
-  if (mysql) {
-    //my_transaction("rollback");
-    mysql_close(mysql);
-  }
+  dbi_conn_close(conn);
 }
 
-MYSQL *open_database(char *dbhost, int dbport, char *dbname, char *dbuser, char *dbpasswd)
+dbi_conn open_database(const char *dbtype, const char *dbhost, const char *dbport, const char *dbname, const char *dbuser, const char *dbpasswd)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
-  mysql = mysql_init(NULL);
-  mysql_options(mysql, MYSQL_OPT_COMPRESS, 0);
-  if (!mysql_real_connect(mysql, dbhost, dbuser, dbpasswd, dbname, dbport, NULL, 0)) {
+  conn = dbi_conn_new(dbtype);
+
+  dbi_conn_set_option(conn, "host", dbhost);
+  dbi_conn_set_option(conn, "port", dbport);
+  dbi_conn_set_option(conn, "username", dbuser);
+  dbi_conn_set_option(conn, "password", dbpasswd);
+  dbi_conn_set_option(conn, "dbname", dbname);
+  dbi_conn_set_option(conn, "encoding", "UTF-8");
+
+  if (dbi_conn_connect(conn) < 0) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
     LOG(LOG_ERR, "%s dbhost=%s,dbport=%d,dbname=%s,dbuser=%s,dbpasswd=%s",
-           mysql_error(mysql), dbhost, dbport, dbname, dbuser, dbpasswd);
+           errmsg, dbhost, dbport, dbname, dbuser, dbpasswd);
     return(NULL);
   }
-  return(mysql);
+  return(conn);
 }
 
-MYSQL_RES *my_rawquery(MYSQL *mysql, int log_dupes, char *qry)
+dbi_result db_rawquery(dbi_conn conn, int log_dupes, const char *qry)
 {
-  MYSQL_RES *result;
+  dbi_result result;
 
   if (debug > 4) {
     LOGRAW(LOG_DEBUG, qry);
   }
-  if (mysql_query(mysql, qry)) {
+  result = dbi_conn_query(conn, qry);
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+/*
     switch (mysql_errno(mysql)) {
     case ER_DUP_ENTRY:
         if (!log_dupes) break;
     default:
-      LOG(LOG_WARNING, "%s:[%u] %s", qry, mysql_errno(mysql), mysql_error(mysql));
+*/
+    LOG(LOG_WARNING, "%s: %s", qry, errmsg);
+/*
       break;
     }
+*/
     return(NULL);
   }
-  result = mysql_store_result(mysql);
-  if (mysql_errno(mysql)) {
-    LOG(LOG_WARNING, "%s: [%u] %s", qry, mysql_errno(mysql), mysql_error(mysql));
-  }
   return(result);
 }
 
-MYSQL_RES *my_query(MYSQL *mysql, int log_dupes, char *fmt, ...)
+dbi_result db_query(dbi_conn conn, int log_dupes, const char *fmt, ...)
 {
 static char qry[65536]; // max query size for us
   va_list arg;
 
-  if (!mysql) return(NULL);
+  if (conn) return(NULL);
 
   va_start(arg, fmt);
   vsnprintf(qry, sizeof(qry)-1, fmt, arg);
   va_end(arg);
-  return my_rawquery(mysql, log_dupes, qry);
+  return db_rawquery(conn, log_dupes, qry);
 }
 

Modified: upwatch/libdbi/common/dbase_options.def
===================================================================
--- upwatch/libdbi/common/dbase_options.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/common/dbase_options.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -27,8 +27,8 @@
 flag = {
     must-set;
     name      = dbport;
-    arg_type  = numeric;   /* option argument indication  */
-    arg-default = 3306;
+    arg_type  = string;   /* option argument indication  */
+    arg-default = "3306";
     descrip   = "Port number on database host";
     doc       = 
 'Port number to connect to';

Modified: upwatch/libdbi/common/main.c
===================================================================
--- upwatch/libdbi/common/main.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/common/main.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -92,7 +92,7 @@
 
   if (OPT_VALUE_STDERR)  _log2stderr  = TRUE;
   if (OPT_VALUE_SYSLOG)  _log2syslog  = TRUE;
-  if (HAVE_OPT(LOGFILE)) _logfilename = OPT_ARG(LOGFILE);
+  if (HAVE_OPT(LOGFILE)) _logfilename = (char *) OPT_ARG(LOGFILE);
 
   LOG(LOG_NOTICE, "start (Version %s-%s, date %s %s)", VERSION, RELEASE, __DATE__, __TIME__);
   LOG(LOG_INFO, "using GCC %s", __VERSION__);

Modified: upwatch/libdbi/common/probe.tpl
===================================================================
--- upwatch/libdbi/common/probe.tpl	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/common/probe.tpl	2006-07-21 20:34:40 UTC (rev 632)
@@ -94,6 +94,7 @@
 ENDIF +][+
 ESAC type +][+ ENDFOR def+]
   PRIMARY KEY  (id),
+  KEY tbldomid (tblid, domid, id),
   KEY server (server),
   KEY notify (notify),
   KEY ipaddress (ipaddress),

Modified: upwatch/libdbi/compat/bb/bbhimport/Makefile.am
===================================================================
--- upwatch/libdbi/compat/bb/bbhimport/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/compat/bb/bbhimport/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -5,8 +5,8 @@
 man_MANS = bbhimport.1
 
 bbhimport_SOURCES = run.c bbhimport.h bbhimport.c
-bbhimport_CFLAGS = @MYSQL_CFLAGS@ @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-bbhimport_LDADD = bbhimport_$(DB_O) bbhimport_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBGLIB2_LIBS@ @MYSQL_LIBS@
+bbhimport_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+bbhimport_LDADD = bbhimport_$(DB_O) bbhimport_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBGLIB2_LIBS@ @LIBDBI_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c)
 INCLUDES = -I$(top_srcdir)/upwatch 

Modified: upwatch/libdbi/compat/bb/bbhimport/run.c
===================================================================
--- upwatch/libdbi/compat/bb/bbhimport/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/compat/bb/bbhimport/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -9,7 +9,7 @@
 #include "../../../probes.enum"
 } probeidx;
 
-void process(MYSQL *mysql, char *ip, char *hostname, char *args);
+void process(dbi_conn conn, char *ip, char *hostname, char *args);
 
 int init(void)
 {
@@ -23,16 +23,16 @@
   FILE *in;
   char buffer[4096];
   int count = 0;
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!HAVE_OPT(INPUT)) {
     fprintf(stderr, "parameter -I is required\n");
     return 0;
   }
 
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (!mysql) {
+  if (!conn) {
     printf("Can't open database\n");
     return 0;
   }
@@ -56,54 +56,53 @@
       arg = strtok(NULL, " \t");
     }
     count++;
-    process(mysql, ip, hostname, arg ? arg : "");
+    process(conn, ip, hostname, arg ? arg : "");
   }
   fclose(in);
-  close_database(mysql);
+  close_database(conn);
   return count;
 }
 
-void process(MYSQL *mysql, char *ip, char *hostname, char *args)
+void process(dbi_conn conn, char *ip, char *hostname, char *args)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   int serverid;
   char *p;
 
-  result = my_query(mysql, 0, "select %s from %s where %s = '%s'", 
+  result = db_query(conn, 0, "select %s from %s where %s = '%s'", 
        OPT_ARG(SERVER_TABLE_ID_FIELD), OPT_ARG(SERVER_TABLE_NAME), 
        OPT_ARG(SERVER_TABLE_NAME_FIELD), hostname);
   if (!result) {
     printf("internal error. Stop.\n");
     exit(1);
   }
-  row = mysql_fetch_row(result);
-  if (!row || !row[0]) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  serverid = atoi(row[0]);
-  mysql_free_result(result);
+  serverid = dbi_result_get_uint_idx(result, 0);
+  dbi_result_free(result);
   if (!serverid) return;
 
   if (strstr(args, "noping") == NULL) {
     int rows;
 
-    result = my_query(mysql, 0, 
+    result = db_query(conn, 0, 
                       "select id from pr_ping_def where server = '%d' and ipaddress = '%s'",
                       serverid, ip);
     if (!result) {
       printf("internal error. Stop.\n");
       exit(1);
     }
-    rows = mysql_num_rows(result);
-    mysql_free_result(result);
+    rows = dbi_result_get_numrows(result);
+    dbi_result_free(result);
 
     if (rows == 0) { 
       printf("INSERT ping %s %s\n", ip, hostname);
-      my_query(mysql, 0, 
+      result = db_query(conn, 0, 
                "insert into pr_ping_def set server = '%d', ipaddress = '%s', description = '%s'",
                serverid, ip, hostname);
+      dbi_result_free(result);
     } else {
       printf("ALREADY THERE: ping %s %s\n", ip, hostname);
     }
@@ -129,21 +128,22 @@
     }
     URI[i] = 0;
 
-    result = my_query(mysql, 0,
+    result = db_query(conn, 0,
                       "select id from pr_httpget_def where server = '%d' and ipaddress = '%s' and "
                       "hostname = '%s' and uri = '%s'", serverid, ip, HostName, URI);
     if (!result) {
       printf("internal error. Stop.\n");
       exit(1);
     }
-    rows = mysql_num_rows(result);
-    mysql_free_result(result);
+    rows = dbi_result_get_numrows(result);
+    dbi_result_free(result);
 
     if (rows == 0) { 
       printf("INSERT httpget %s %s http://%s%s\n", ip, hostname, HostName, URI);
-      my_query(mysql, 0,
+      result = db_query(conn, 0,
                "insert into pr_httpget_def set server = '%d', ipaddress = '%s', description = '%s', "
                "hostname = '%s', uri = '%s'", serverid, ip, hostname, HostName, URI);
+      dbi_result_free(result);
     } else {
       printf("ALREADY THERE: httpget %s %s http://%s%s\n", ip, hostname, HostName, URI);
     }
@@ -152,21 +152,22 @@
   if ((p = strstr(args, "pop-3")) != NULL || (p = strstr(args, "pop3")) != NULL) {
     int rows;
 
-    result = my_query(mysql, 0,
+    result = db_query(conn, 0,
                       "select id from pr_pop3_def where server = '%d' and ipaddress = '%s'",
                       serverid, ip);
     if (!result) {
       printf("internal error. Stop.\n");
       exit(1);
     }
-    rows = mysql_num_rows(result);
-    mysql_free_result(result);
+    rows = dbi_result_get_numrows(result);
+    dbi_result_free(result);
 
     if (rows == 0) { 
       printf("INSERT pop-3 %s %s\n", ip, hostname);
-      my_query(mysql, 0,
+      result = db_query(conn, 0,
                "insert into pr_pop3_def set server = '%d', ipaddress = '%s', description = '%s'",
                serverid, ip, hostname);
+      dbi_result_free(result);
     } else {
       printf("ALREADY THERE: pop3 %s %s \n", ip, hostname);
     }
@@ -175,21 +176,22 @@
   if ((p = strstr(args, "imap")) != NULL) {
     int rows;
 
-    result = my_query(mysql, 0,
+    result = db_query(conn, 0,
                       "select id from pr_imap_def where server = '%d' and ipaddress = '%s'",
                       serverid, ip);
     if (!result) {
       printf("internal error. Stop.\n");
       exit(1);
     }
-    rows = mysql_num_rows(result);
-    mysql_free_result(result);
+    rows = dbi_result_get_numrows(result);
+    dbi_result_free(result);
 
     if (rows == 0) { 
       printf("INSERT imap %s %s\n", ip, hostname);
-      my_query(mysql, 0,
+      result = db_query(conn, 0,
                "insert into pr_imap_def set server = '%d', ipaddress = '%s', description = '%s'",
                serverid, ip, hostname);
+      dbi_result_free(result);
     } else {
       printf("ALREADY THERE: imap %s %s \n", ip, hostname);
     }

Modified: upwatch/libdbi/configure.ac
===================================================================
--- upwatch/libdbi/configure.ac	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/configure.ac	2006-07-21 20:34:40 UTC (rev 632)
@@ -35,6 +35,8 @@
     fi]
 )
 
+CFLAGS="${CFLAGS} -I/usr/include/autoopts"
+
 # ----------------------------------------------------------------------
 # Set some global things based on os type
 # ----------------------------------------------------------------------
@@ -291,6 +293,7 @@
 done
 
 AC_SUBST(LIBOPTS_CFLAGS)
+
 ################## MYSQL
 # path to libmysqlclient stuff:.
 AC_ARG_WITH(mysql-libs,
@@ -299,19 +302,6 @@
     [MYSQL_LIB_PREFIX=/usr/lib/mysql]
 )
 AC_SUBST(MYSQL_LIB_PREFIX)
-
-for libpath in /usr/lib/mysql $MYSQL_LIB_PREFIX /usr/local/lib/mysql /usr/lib /cygdrive/c/mysql/lib/opt /usr/pkg/lib/mysql
-do
-  for file in $libpath/libmysqlclient.so* $libpath/mysqlclient.lib
-  do
-    if test -f $file
-    then
-      MYSQL_LIBS="-L${libpath} -lmysqlclient"
-      break
-    fi
-  done
-done
-
 # path to mysql includes
 AC_ARG_WITH(mysql-include,
     [  --with-mysql-include=<path>        prefix of MySQL headers. Default /usr/include/mysql],
@@ -320,26 +310,36 @@
 )
 AC_SUBST(MYSQL_INC_PREFIX)
 
-for incpath in /usr/include/mysql $MYSQL_LIB_PREFIX /usr/local/include/mysql /cygdrive/c/mysql/include /usr/pkg/include/mysql
-do
-  if test -f $incpath/mysql.h
-  then
-    MYSQL_CFLAGS="-I${incpath}"
-  fi
-done
+if test x$enable_monitors = xyes
+then
+  for libpath in /usr/lib/mysql $MYSQL_LIB_PREFIX /usr/local/lib/mysql /usr/lib /cygdrive/c/mysql/lib/opt /usr/pkg/lib/mysql
+  do
+    for file in $libpath/libmysqlclient.so* $libpath/mysqlclient.lib
+    do
+      if test -f $file
+      then
+        MYSQL_LIBS="-L${libpath} -lmysqlclient"
+        break
+      fi
+    done
+  done
 
-if test "$enable_monitors" = "yes" -o "$enable_server" = "yes"
-then
-  if test -z "$MYSQL_LIBS"
-  then
-    AC_MSG_ERROR([Cannot find MySQL libraries, tell me where they are with --with-mysql-libs=])
-  fi
+  for incpath in /usr/include/mysql $MYSQL_LIB_PREFIX /usr/local/include/mysql /cygdrive/c/mysql/include /usr/pkg/include/mysql
+  do
+    if test -f $incpath/mysql.h
+    then
+      MYSQL_CFLAGS="-I${incpath}"
+    fi
+  done
+
   if test -z "$MYSQL_CFLAGS"
   then
-    AC_MSG_ERROR([Cannot find MySQL include files, tell me where they are with --with-mysql-include=])
+    HAVE_LIBMYSQL="0"
+  else
+    HAVE_LIBMYSQL="1"
   fi
 fi
-
+AM_CONDITIONAL(HAVE_LIBMYSQL, test $HAVE_LIBMYSQL -eq 1)
 AC_SUBST(MYSQL_CFLAGS)
 AC_SUBST(MYSQL_LIBS)
 
@@ -483,11 +483,13 @@
 AC_CHECK_LIB([curses], [initscr], [HAVE_LIBCURSES=1], [HAVE_LIBCURSES=0])
 if test $HAVE_LIBCURSES -eq 1
 then
+	AC_DEFINE(HAVE_LIBCURSES,1,[is libcurses available on this system])
         LIBCURSES_LIBS=-lcurses
 fi
 AC_CHECK_LIB([ncurses], [initscr], [HAVE_LIBNCURSES=1], [HAVE_LIBNCURSES=0])
 if test $HAVE_LIBNCURSES -eq 1
 then
+	AC_DEFINE(HAVE_LIBCURSES,1,[is libcurses available on this system])
         LIBCURSES_LIBS=-lncurses
 fi
 AM_CONDITIONAL(HAVE_CURSES, test ! -z $LIBCURSES_LIBS)
@@ -501,6 +503,7 @@
 AC_CHECK_LIB([pcap], [pcap_close], [HAVE_LIBPCAP=1], [HAVE_LIBPCAP=0])
 if test $HAVE_LIBPCAP -eq 1
 then
+	AC_DEFINE(HAVE_LIBPCAP,1,[is libpcap available on this system])
 	LIBPCAP_LIBS=-lpcap
 fi
 AM_CONDITIONAL(HAVE_LIBPCAP, test $HAVE_LIBPCAP -eq 1)
@@ -524,6 +527,18 @@
 AM_CONDITIONAL(HAVE_LIBCRYPTO, test $HAVE_LIBCRYPTO -eq 1)
 AC_SUBST(LIBCRYPTO_LIBS)
 
+# libdbi
+AC_CHECK_LIB([dbi], [dbi_conn_quote_string], [HAVE_LIBDBI=1], [HAVE_LIBDBI=0])
+if test $HAVE_LIBDBI -eq 1
+then
+	LIBDBI_LIBS=-ldbi
+else
+	AC_MSG_ERROR([Sorry, we need libdbi >= 0.8 to continue])
+fi
+AM_CONDITIONAL(HAVE_LIBDBI, test $HAVE_LIBDBI -eq 1)
+AC_SUBST(LIBDBI_LIBS)
+AC_SUBST(LIBDBI_CFLAGS)
+
 # snmp
 AC_CHECK_LIB([snmp], [snmp_errno], [HAVE_LIBSNMP=1], [HAVE_LIBSNMP=0], -lcrypto)
 if test $HAVE_LIBSNMP -eq 1
@@ -533,6 +548,7 @@
 	AC_CHECK_LIB([netsnmp], [snmp_errno], [HAVE_LIBSNMP=1], [HAVE_LIBSNMP=0], -lcrypto)
 	if test $HAVE_LIBSNMP -eq 1
 	then
+		AC_DEFINE(HAVE_LIBSNMP,1,[are the netsnmp libraries available on this system])
 		LIBSNMP_LIBS=-lnetsnmp
 	fi
 fi
@@ -557,6 +573,7 @@
 AC_CHECK_LIB([readline], [readline], [HAVE_LIBREADLINE=1], [HAVE_LIBREADLINE=0], -lncurses)
 if test $HAVE_LIBREADLINE -eq 1
 then
+	AC_DEFINE(HAVE_LIBREADLINE,1,[Is the readline library available on this system])
 	LIBREADLINE_LIBS=-lreadline
         AC_DEFINE(HAVE_LIBREADLINE,1,[Do we have the readline library])
 else 
@@ -575,6 +592,7 @@
 if test $HAVE_LIBTDS -eq 1
 then
 	LIBTDS_LIBS=-ltds
+	AC_DEFINE(HAVE_LIBTDS,1,[Is libtds available on this system])
 fi
 AM_CONDITIONAL(HAVE_LIBTDS, test $HAVE_LIBTDS -eq 1)
 AC_SUBST(LIBTDS_LIBS)
@@ -583,6 +601,7 @@
 AC_CHECK_LIB([pq], [PQclear], [HAVE_LIBPQ=1], [HAVE_LIBPQ=0])
 if test $HAVE_LIBPQ -eq 1
 then
+	AC_DEFINE(HAVE_LIBPQ,1,[Is postgres available on this system])
 	LIBPQ_LIBS=-lpq
 	LIBPQ_CFLAGS=""
 	if test -f /usr/include/pgsql/libpq-fe.h
@@ -630,7 +649,7 @@
 AC_FUNC_STAT
 AC_FUNC_STRFTIME
 AC_CHECK_FUNCS([alarm atexit dup2 gethostbyname gethostname gettimeofday inet_ntoa memset putenv regcomp select socket strchr strdup strerror strncasecmp strrchr strstr strtol strtoul tzset uname])
-AC_CHECK_LIB(mysqlclient, mysql_real_escape_string, AC_DEFINE(HAVE_MYSQL_REAL_ESCAPE,1,[Does mysql have real_escape]),,[$MYSQL_LIBS])
+AC_CHECK_LIB(dbi, dbi_result_get_uint, AC_DEFINE(HAVE_LIBDBI_GET_UINT,1,[Does libdbi have dbi_result_get_uint]),,[$DBI_LIBS])
 
 echo 
 echo "*********************************************************"
@@ -650,17 +669,22 @@
 then
   if test $HAVE_LIBSNMP -eq 0
   then
-    echo "* snmp libs (or openssl libs) not found, no SNMP support"
+    echo "* snmp libs (or openssl libs) not found, SNMP probes will not be built"
   fi
 
   if test $HAVE_LIBTDS -eq 0
   then
-    echo "* TDS lib not found, no MS-SQL support"
+    echo "* TDS lib not found, MS-SQL related probes will not be built"
   fi
 
+  if test $HAVE_LIBMYSQL -eq 0
+  then
+    echo "* MySQL not found, related probes not built"
+  fi
+
   if test $HAVE_LIBPQ -eq 0
   then
-    echo "* PostgreSQL not found, no PostgreSQL support"
+    echo "* PostgresSQL not found, related probes will not be built"
   fi
 fi
 
@@ -683,48 +707,50 @@
 
 if test "$enable_server" = "yes" -o "$enable_monitors" = "yes"
 then
-AC_CONFIG_FILES([st-1.4/Makefile])
+  AC_CONFIG_FILES([st-1.4/Makefile])
 fi
 
 # server 
 if test "$enable_server" = "yes"
 then
-AC_CONFIG_FILES([uw_setip/Makefile])
-AC_CONFIG_FILES([uw_accept/Makefile])
-AC_CONFIG_FILES([uw_acceptbb/Makefile])
-AC_CONFIG_FILES([uw_purple/Makefile])
-AC_CONFIG_FILES([uw_route/Makefile])
-AC_CONFIG_FILES([uw_process/Makefile])
-AC_CONFIG_FILES([uw_syncprobes/Makefile])
-AC_CONFIG_FILES([compat/Makefile])
-AC_CONFIG_FILES([compat/sometests/Makefile])
-AC_CONFIG_FILES([compat/sometests/setproctitle/Makefile])
-AC_CONFIG_FILES([compat/bb/Makefile])
-AC_CONFIG_FILES([compat/bb/bbhimport/Makefile])
+  AC_CONFIG_FILES([uw_setip/Makefile])
+  AC_CONFIG_FILES([uw_accept/Makefile])
+  AC_CONFIG_FILES([uw_acceptbb/Makefile])
+  AC_CONFIG_FILES([uw_purple/Makefile])
+  AC_CONFIG_FILES([uw_route/Makefile])
+  AC_CONFIG_FILES([uw_process/Makefile])
+  AC_CONFIG_FILES([uw_syncprobes/Makefile])
+  AC_CONFIG_FILES([compat/Makefile])
+  AC_CONFIG_FILES([compat/sometests/Makefile])
+  AC_CONFIG_FILES([compat/sometests/setproctitle/Makefile])
+  AC_CONFIG_FILES([compat/bb/Makefile])
+  AC_CONFIG_FILES([compat/bb/bbhimport/Makefile])
 fi
 
 # monitors
 if test "$enable_monitors" = "yes"
 then
-AC_CONFIG_FILES([uw_httpget/Makefile])
-AC_CONFIG_FILES([uw_dns/Makefile])
-AC_CONFIG_FILES([uw_ping/Makefile])
-AC_CONFIG_FILES([uw_mysql/Makefile])
-AC_CONFIG_FILES([uw_mysqlstats/Makefile])
-AC_CONFIG_FILES([uw_pop3/Makefile])
-AC_CONFIG_FILES([uw_smtp/Makefile])
-AC_CONFIG_FILES([uw_tcpconnect/Makefile])
-AC_CONFIG_FILES([uw_imap/Makefile])
-AC_CONFIG_FILES([uw_snmpget/Makefile])
-AC_CONFIG_FILES([uw_mssql/Makefile])
-AC_CONFIG_FILES([uw_postgresql/Makefile])
+  AC_CONFIG_FILES([uw_httpget/Makefile])
+  AC_CONFIG_FILES([uw_dns/Makefile])
+  AC_CONFIG_FILES([uw_ping/Makefile])
+  AC_CONFIG_FILES([uw_mysql/Makefile])
+  AC_CONFIG_FILES([uw_mysqlstats/Makefile])
+  AC_CONFIG_FILES([uw_pop3/Makefile])
+  AC_CONFIG_FILES([uw_smtp/Makefile])
+  AC_CONFIG_FILES([uw_tcpconnect/Makefile])
+  AC_CONFIG_FILES([uw_imap/Makefile])
+  AC_CONFIG_FILES([uw_snmpget/Makefile])
+  AC_CONFIG_FILES([uw_mssql/Makefile])
+  AC_CONFIG_FILES([uw_postgresql/Makefile])
 fi
 
 # extra
 if test "$enable_iptraf" = "yes"
 then
-AC_CONFIG_FILES([uw_iptraf/Makefile])
+if test $HAVE_LIBPCAP -eq 1; then
+  AC_CONFIG_FILES([uw_iptraf/Makefile])
 fi
+fi
 
 ( cd libstatgrab ; ./configure --disable-manpages --disable-examples \
   --disable-statgrab --disable-saidar --disable-shared ; cd .. )

Modified: upwatch/libdbi/doc/installation.xml
===================================================================
--- upwatch/libdbi/doc/installation.xml	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/doc/installation.xml	2006-07-21 20:34:40 UTC (rev 632)
@@ -119,13 +119,19 @@
         <title>Database</title>
         <para>You actually need to create two databases, one for the probes to read from, and one 
         for the results to be written to. The first database should be called upwatch, the other
-        one can be any name (in this example we use netland). Create the databases as follows. (You DO have a root 
-        password set for mysql don't you?)</para>
+        one can be any name (in this example we use netland). If you have a new database installation
+        create a password for the root account, and remove the anonymous accounts as follows:<para>
         <literallayout>
+           $ mysql -u root 
+           mysql> DELETE FROM mysql.user WHERE User = '';
+           mysql> SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpwd');
+        </literallayout></para>
+        <para>Now create the databases as follows.</para>
+        <literallayout>
            $ mysqladmin -u root --password=PASSWORD create upwatch
-           $ mysql -u root --password=PASSWORD upwatch &lt; upwatch-base.mysql
+           $ mysql -u root --password=PASSWORD upwatch &lt; /usr/share/doc/upwatch-xxx/upwatch-base.mysql
            $ mysqladmin -u root --password=PASSWORD create netland
-           $ mysql -u root --password=PASSWORD netland &lt; upwatch-full.mysql
+           $ mysql -u root --password=PASSWORD netland &lt; i/usr/share/doc/upwatch-xxx/upwatch-full.mysql
         </literallayout>
         <para>Of course you need to assign users and GRANT them access. We start with 
            the probes. We assume the probes are running on a separate host with ip address 192.168.1.23.
@@ -178,7 +184,7 @@
           dbtype mysql
           dbhost localhost
           dbport 3306
-          dbname dymos
+          dbname netland
           dbuser upwatch
           dbpasswd PASSWORD
         </literallayout>

Modified: upwatch/libdbi/doc/program-guide.html
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/doc/program-guide.txt
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/st-1.4/st.spec
===================================================================
--- upwatch/libdbi/st-1.4/st.spec	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/st-1.4/st.spec	2006-07-21 20:34:40 UTC (rev 632)
@@ -2,7 +2,7 @@
 Name:		st
 Version:	1.4
 Release:	1
-Copyright:	MPL 1.2 or GPL 2+
+License:	MPL 1.2 or GPL 2+
 Packager:	Wesley W. Terpstra <wesley at terpstra.ca>
 Source:		http://prdownloads.sourceforge.net/state-threads/st-%{version}.tar.gz
 Prefix:		/usr

Modified: upwatch/libdbi/upwatch/Makefile.am
===================================================================
--- upwatch/libdbi/upwatch/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -7,7 +7,7 @@
 endif
 
 if ENABLE_SERVER
-SERVER_SOURCE = pr_process.c pr_bb.c pr_bb_cpu.c pr_httpget.c pr_mysqlstats.c \
+SERVER_SOURCE = pr_bb.c pr_process.c pr_bb_cpu.c pr_httpget.c pr_mysqlstats.c \
  pr_ping.c pr_snmpget.c pr_sysstat.c pr_iptraf.c pr_generic.c pr_hwstat.c 
 endif
 
@@ -17,7 +17,7 @@
  findsaddr.h gnuc.h logregex.h probe.h
 
 if ENABLE_SERVER
-pr_process.c: probe.h
+pr_bb.c: probe.h
 
 probe.h: ../uw_acceptbb/probe.res_h  ../uw_httpget/probe.res_h \
  ../uw_imap/probe.res_h ../uw_iptraf/probe.res_h ../uw_mssql/probe.res_h ../uw_mysql/probe.res_h \
@@ -29,8 +29,8 @@
 endif
 
 libupwatch_a_SOURCES = $(sources)
-libupwatch_a_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @MYSQL_CFLAGS@ @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+libupwatch_a_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
 
 libupwatcht_a_SOURCES = $(sources)
-libupwatcht_a_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @MYSQL_CFLAGS@ @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) -DWITH_THREADS
+libupwatcht_a_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) -DWITH_THREADS
 

Modified: upwatch/libdbi/upwatch/compat.h
===================================================================
--- upwatch/libdbi/upwatch/compat.h	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/compat.h	2006-07-21 20:34:40 UTC (rev 632)
@@ -10,11 +10,5 @@
 #define INADDR_NONE ((unsigned long) -1)
 #endif
 
-#if defined(ENABLE_SERVER)
-#ifndef HAVE_MYSQL_REAL_ESCAPE
-unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length);
 #endif
-#endif
 
-#endif
-

Modified: upwatch/libdbi/upwatch/db.h
===================================================================
--- upwatch/libdbi/upwatch/db.h	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/db.h	2006-07-21 20:34:40 UTC (rev 632)
@@ -1,12 +1,16 @@
 #if !defined(__DB_H) 
 #define __DB_H
 
-#include <mysql.h>
-#include <mysqld_error.h>
+#include <dbi/dbi.h>
 
-MYSQL *open_database(char *dbhost, int dbport, char *dbname, char *dbuser, char *dbpasswd);
-void close_database(MYSQL *mysql);
-MYSQL_RES *my_query(MYSQL *mysql, int log_dupes, char *qry, ...);
-MYSQL_RES *my_rawquery(MYSQL *mysql, int log_dupes, char *qry);
+dbi_conn open_database(const char *dbtype, const char *dbhost, const char *dbport, const char *dbname, const char *dbuser, const char *dbpasswd);
+void close_database(dbi_conn conn);
+dbi_result db_query(dbi_conn conn, int log_dupes, const char *qry, ...);
+dbi_result db_rawquery(dbi_conn conn, int log_dupes, const char *qry);
 
+#ifndef HAVE_LIBDBI_GET_UINT
+#define dbi_result_get_uint(a,b)  dbi_result_get_ulong(a,b)
+#define dbi_result_get_uint_idx(a,b)  dbi_result_get_ulong_idx(a,b)
+#endif
+
 #endif /* __DB_H */

Modified: upwatch/libdbi/upwatch/pr_bb.c
===================================================================
--- upwatch/libdbi/upwatch/pr_bb.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/pr_bb.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,7 +8,7 @@
 #include "dmalloc.h"
 #endif
 
-char *query_server_by_name;
+const char *query_server_by_name;
 
 void bb_free_res(void *res)
 {
@@ -41,8 +41,7 @@
 {
   struct probe_def *def;
   struct bb_result *res = (struct bb_result *)t->res;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   def = g_malloc0(t->probe->def_size);
   def->stamp    = time(NULL);
@@ -52,7 +51,7 @@
 
   if (res->color == STAT_PURPLE && res->probeid) {
     // find the definition based on the probe id
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select id, contact, hide, email, delay from pr_bb_def "
                       "where  id = '%u'", res->probeid);
     if (!result) {
@@ -68,26 +67,25 @@
         g_free(def);
         return(NULL);
       }
-      result = my_query(t->probe->db, 0, query_server_by_name, res->hostname, res->hostname, 
+      result = db_query(t->probe->db, 0, query_server_by_name, res->hostname, res->hostname, 
                         res->hostname, res->hostname, res->hostname);
       if (!result) {
         g_free(def);
         return(NULL);
       }
-      row = mysql_fetch_row(result);
-      if (row && row[0]) {
-        res->server   = atoi(row[0]);
-      } else {
+      if (dbi_result_get_numrows(result) == 0) {
         LOG(LOG_WARNING, "%s:%u@%s: server %s not found", res->realm, res->stattime, t->fromhost, res->hostname);
-        mysql_free_result(result);
+        dbi_result_free(result);
         g_free(def);
         return(NULL);
       }
-      mysql_free_result(result);
+      dbi_result_next_row(result);
+      res->server = dbi_result_get_uint(result, "id");
+      dbi_result_free(result);
     }
 
     // first find the definition based on the serverid
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select id, contact, hide, email, delay from pr_bb_def "
                       "where  bbname = '%s' and server = '%u'", res->bbname, res->server);
     if (!result) {
@@ -95,53 +93,53 @@
       return(NULL);
     }
   }
-  if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
-    mysql_free_result(result);
-    result = my_query(t->probe->db, 0,
+  if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
+    dbi_result_free(result);
+    result = db_query(t->probe->db, 0,
                       "insert into pr_%s_def set server = '%u', ipaddress = '%s', " 
                       "       description = '%s', bbname = '%s'", 
                        res->name, res->server, res->ipaddress ? res->ipaddress : "", 
                        res->hostname, res->bbname);
-    mysql_free_result(result);
-    def->probeid = mysql_insert_id(t->probe->db);
+    dbi_result_free(result);
+    def->probeid = dbi_conn_sequence_last(t->probe->db, NULL);
     LOG(LOG_NOTICE, "%s:%u@%s: pr_bb_def %s created for %s, id = %u", 
         res->realm, res->stattime, t->fromhost, res->bbname, res->hostname, def->probeid);
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "select id, contact, hide, email, delay from pr_bb_def "
                     "where  bbname = '%s' and server = '%u'", res->bbname, res->server);
     if (!result) return(NULL);
   }
-  row = mysql_fetch_row(result);
-  if (!row || !row[0]) {
+  if (dbi_result_get_numrows(result) == 0) {
     LOG(LOG_NOTICE, "%s:%u@%s: no pr_%s_def found for server %u - skipped", 
          res->realm, res->stattime, t->fromhost, res->name, res->server);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return(NULL);
   }
 
-  if (row[0])  def->probeid = atoi(row[0]);
-  if (row[1])  def->contact = atoi(row[1]);
-  strcpy(def->hide, row[2] ? row[2] : "no");
-  strcpy(def->email, row[3] ? row[3] : "");
-  if (row[4]) def->delay = atoi(row[4]);
+  dbi_result_next_row(result);
+  def->probeid = dbi_result_get_uint(result, "id");
+  def->contact = dbi_result_get_uint(result, "contact");
+  strcpy(def->hide, dbi_result_get_string(result, "hide"));
+  strcpy(def->email, dbi_result_get_string(result, "email"));
+  def->delay = dbi_result_get_uint(result, "delay");
 
-  mysql_free_result(result);
+  dbi_result_free(result);
 
   // definition found, get the pr_status
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select color, stattime "
                     "from   pr_status "
                     "where  class = '%u' and probe = '%u'", t->probe->class, def->probeid);
   if (result) {
-    row = mysql_fetch_row(result);
-    if (row) {
-      if (row[0]) def->color   = atoi(row[0]);
-      if (row[1]) def->newest  = atoi(row[1]);
-    } else {
+    if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
       LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u (server %s) not found", 
                        res->realm, res->stattime, t->fromhost, res->name, def->probeid, res->hostname);
+    } else {
+      dbi_result_next_row(result);
+      def->color   = dbi_result_get_uint(result, "color");
+      def->newest  = dbi_result_get_uint(result, "stattime");
+      dbi_result_free(result);
     }
-    mysql_free_result(result);
   }
   if (!def->color) def->color = res->color;
   res->probeid = def->probeid;

Modified: upwatch/libdbi/upwatch/pr_bb_cpu.c
===================================================================
--- upwatch/libdbi/upwatch/pr_bb_cpu.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/pr_bb_cpu.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -63,26 +63,24 @@
 {
   struct probe_def *def;
   struct bb_cpu_result *res = (struct bb_cpu_result *)t->res;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   time_t now = time(NULL);
 
   if (res->color != STAT_PURPLE && res->server == 0) { 
     // first we find the serverid, this will be used to find the probe definition in the hashtable
-    result = my_query(t->probe->db, 0, query_server_by_name, res->hostname, res->hostname, 
+    result = db_query(t->probe->db, 0, query_server_by_name, res->hostname, res->hostname, 
                       res->hostname, res->hostname, res->hostname);
     if (!result) {
       return(NULL);
     }
-    row = mysql_fetch_row(result);
-    if (row && row[0]) {
-      res->server   = atoi(row[0]);
-    } else {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: server %s not found", res->realm, res->stattime, t->fromhost, res->hostname);
-      mysql_free_result(result);
+      dbi_result_free(result);
       return(NULL);
     }
-    mysql_free_result(result);
+    dbi_result_next_row(result);
+    res->server = dbi_result_get_uint_idx(result, 0);
+    dbi_result_free(result);
   }
 
   // look in the cache for the def
@@ -100,70 +98,71 @@
     strcpy(def->hide, "no");
 
     // first find the definition based on the serverid
-    result = my_query(t->probe->db, 0, "select id, yellow, red, contact, hide, email, delay "
+    result = db_query(t->probe->db, 0, "select id, yellow, red, contact, hide, email, delay "
                                     "from pr_%s_def where server = '%u'", 
                       res->name, res->server);
     if (!result) {
       g_free(def);
       return(NULL);
     }
-    if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
+    if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
       // no def record found? Create one. 
-      mysql_free_result(result);
-      result = my_query(t->probe->db, 0, 
+      dbi_result_free(result);
+      result = db_query(t->probe->db, 0, 
                         "insert into pr_%s_def set server = '%u', description = '%s'", 
                          res->name, res->server, res->hostname);
-      mysql_free_result(result);
-      def->probeid = mysql_insert_id(t->probe->db);
+      dbi_result_free(result);
+      def->probeid = dbi_conn_sequence_last(t->probe->db, NULL);
       LOG(LOG_NOTICE, "%s:%u@%s: pr_%s_def created for %s, id = %u", 
           res->realm, res->stattime, t->fromhost, res->name, res->hostname, def->probeid);
-      result = my_query(t->probe->db, 0, "select id, yellow, red, contact, hide, email, delay "
+      result = db_query(t->probe->db, 0, "select id, yellow, red, contact, hide, email, delay "
                                       "from pr_%s_def where id = '%u'", 
                         res->name, def->probeid);
     }
-    row = mysql_fetch_row(result);
-    if (!row || !row[0]) {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: no pr_%s_def found for server %u - skipped", 
           res->realm, res->stattime, t->fromhost, res->name, res->server);
-      mysql_free_result(result);
+      dbi_result_free(result);
       g_free(def);
       return(NULL);
     } 
-    if (row[0]) def->probeid = atoi(row[0]);
-    if (row[1]) def->yellow = atof(row[1]);
-    if (row[2]) def->red = atof(row[2]);
-    if (row[3]) def->contact = atof(row[3]);
-    strcpy(def->hide, row[4] ? row[4] : "no");
-    strcpy(def->email, row[5] ? row[5] : "");
-    if (row[6]) def->delay = atoi(row[6]);
+    dbi_result_next_row(result);
 
-    mysql_free_result(result);
-    result = my_query(t->probe->db, 0, 
+    def->probeid = dbi_result_get_uint(result, "id");
+    def->yellow = dbi_result_get_float(result, "yellow");
+    def->red = dbi_result_get_float(result, "red");
+    def->contact = dbi_result_get_uint(result, "contact");
+    strcpy(def->hide, dbi_result_get_string(result, "hide"));
+    strcpy(def->email, dbi_result_get_string(result, "email"));
+    def->delay = dbi_result_get_uint(result, "delay");
+    dbi_result_free(result);
+
+    result = db_query(t->probe->db, 0, 
                       "select color "
                       "from   pr_status "
                       "where  class = '%u' and probe = '%u'", t->probe->class, def->probeid);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row) {
-        if (row[0]) def->color   = atoi(row[0]);
-      } else {
+      if (dbi_result_get_numrows(result) == 0) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u not found", 
            res->realm, res->stattime, t->fromhost, res->name, def->probeid);
+      } else {
+        dbi_result_next_row(result);
+        def->color   = dbi_result_get_uint(result, "color");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
     }
     if (!def->color) def->color = res->color;
 
-    result = my_query(t->probe->db, 0, 
+    result = db_query(t->probe->db, 0, 
                       "select stattime from pr_%s_raw use index(probstat) "
                       "where probe = '%u' order by stattime desc limit 1",
                        res->name, def->probeid);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row && mysql_num_rows(result) > 0) {
-        if (row[0]) def->newest = atoi(row[0]);
+      if (dbi_result_get_numrows(result) > 0) {
+        dbi_result_next_row(result);
+        def->newest  = dbi_result_get_uint(result, "stattime");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
     }
     g_hash_table_insert(t->probe->cache, guintdup(def->server), def);
   }

Modified: upwatch/libdbi/upwatch/pr_hwstat.c
===================================================================
--- upwatch/libdbi/upwatch/pr_hwstat.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/pr_hwstat.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -79,26 +79,24 @@
 { 
   struct hwstat_def *def;
   struct hwstat_result *res = (struct hwstat_result *)t->res;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   time_t now = time(NULL);
 
   if (res->color == STAT_PURPLE) { // generated by uw_purple, which knows the probe id but not the serverid
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select server from pr_%s_def where id = '%u'", res->name, res->probeid);
     if (!result) return(NULL);
 
-    row = mysql_fetch_row(result);
-    if (row && row[0]) {
-      res->server = atoi(row[0]);
-    } else {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: %s def %u not found", 
           res->realm, res->stattime, t->fromhost, res->name, res->probeid);
-      mysql_free_result(result);
+      dbi_result_free(result);
       delete_pr_status(t, res->probeid);
       return(NULL);
     }
-    mysql_free_result(result);
+    dbi_result_next_row(result);
+    res->server = dbi_result_get_uint_idx(result, 0);
+    dbi_result_free(result);
   }
 
   def = g_hash_table_lookup(t->probe->cache, &res->server);
@@ -113,7 +111,7 @@
     strcpy(def->hide, "no");
     def->server = res->server;
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select id, contact, hide, email, delay, "
                       "       temp1_yellow, temp1_red, temp2_yellow, temp2_red, "
                       "       temp3_yellow, temp3_red, rot1_red, rot2_red, rot3_red, pgroup "
@@ -121,24 +119,26 @@
                       "where  server = '%u'", res->name, res->server);
     if (!result) return(NULL);
 
-    if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
-      mysql_free_result(result);
+    if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
+      dbi_result_free(result);
       if (!create) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_%s_def for server %u not found and not trusted - skipped", 
                          res->realm, res->stattime, t->fromhost, res->name, def->server);
         return(NULL);
       }
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "insert into pr_%s_def set server = '%d', "
                         "        ipaddress = '%s', description = '%s'", 
                         res->name, res->server, t->res->ipaddress ? t->res->ipaddress : "127.0.0.1", 
                         t->fromhost ? t->fromhost : "automatically added");
-      mysql_free_result(result);
-      if (mysql_affected_rows(t->probe->db) == 0) { // nothing was actually inserted
+      dbi_result_free(result);
+      if (dbi_result_get_numrows_affected(t->probe->db) == 0) { // nothing was actually inserted
+        const char *errmsg;
+        dbi_conn_error(t->probe->db, &errmsg);
         LOG(LOG_NOTICE, "insert missing pr_%s_def id %u: %s", 
-                         res->name, def->probeid, mysql_error(t->probe->db));
+                         res->name, def->probeid, errmsg);
       }
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "select id, contact, hide, email, delay, "
                         "       temp1_yellow, temp1_red, temp2_yellow, temp2_red, "
                         "       temp3_yellow, temp3_red, rot1_red, rot2_red, rot3_red, pgroup "
@@ -146,55 +146,57 @@
                         "where  server = '%u'", res->name, res->server);
       if (!result) return(NULL);
     }
-    row = mysql_fetch_row(result); 
-    if (!row || !row[0]) {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: no pr_%s_def found for server %u - skipped", 
           res->realm, res->stattime, t->fromhost, res->name, res->server);
-      mysql_free_result(result);
+      dbi_result_free(result);
       return(NULL);
     }
-    if (row[0]) def->probeid  = atoi(row[0]);
-    if (row[1]) def->contact  = atoi(row[1]);
-    strcpy(def->hide, row[2] ? row[2] : "no");
-    strcpy(def->email, row[3] ? row[3] : "");
-    if (row[4]) def->delay = atoi(row[4]);
-    if (row[5]) def->temp1_yellow = atoi(row[5]);
-    if (row[6]) def->temp1_red = atoi(row[6]);
-    if (row[7]) def->temp2_yellow = atoi(row[7]);
-    if (row[8]) def->temp2_red = atoi(row[8]);
-    if (row[9]) def->temp3_yellow = atoi(row[9]);
-    if (row[10]) def->temp3_red = atoi(row[10]);
-    if (row[11]) def->rot1_red = atoi(row[11]);
-    if (row[12]) def->rot2_red = atoi(row[12]);
-    if (row[13]) def->rot3_red = atoi(row[13]);
-    if (row[14]) def->pgroup = atoi(row[14]);
+    dbi_result_next_row(result);
 
-    mysql_free_result(result);
+    def->probeid = dbi_result_get_uint(result, "id");
+    def->contact = dbi_result_get_uint(result, "contact");
+    strcpy(def->hide, dbi_result_get_string(result, "hide"));
+    strcpy(def->email, dbi_result_get_string(result, "email"));
+    def->delay = dbi_result_get_uint(result, "delay");
+    def->temp1_yellow = dbi_result_get_uint(result, "temp1_yellow");
+    def->temp1_red = dbi_result_get_uint(result, "temp1_red");
+    def->temp2_yellow = dbi_result_get_uint(result, "temp2_yellow");
+    def->temp2_red = dbi_result_get_uint(result, "temp2_red");
+    def->temp3_yellow = dbi_result_get_uint(result, "temp3_yellow");
+    def->temp3_red = dbi_result_get_uint(result, "temp3_red");
+    def->rot1_red = dbi_result_get_uint(result, "rot1_red");
+    def->rot2_red = dbi_result_get_uint(result, "rot2_red");
+    def->rot3_red = dbi_result_get_uint(result, "rot3_red");
+    def->pgroup = dbi_result_get_uint(result, "pgroup");
+    dbi_result_free(result);
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select color "
                       "from   pr_status "
                       "where  class = '%d' and probe = '%d'", t->probe->class, def->probeid);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row) {
-        def->color   = atoi(row[0]); 
+      if (dbi_result_get_numrows(result) == 0) {
+        LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u not found",
+           res->realm, res->stattime, t->fromhost, res->name, def->probeid);
+      } else {
+        dbi_result_next_row(result);
+        def->color   = dbi_result_get_uint(result, "color");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
-    } 
+    }
+    if (!def->color) def->color = res->color;
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select stattime from pr_%s_raw use index(probstat) "
                       "where probe = '%u' order by stattime desc limit 1",
                        res->name, def->probeid);
     if (result) {
-      if (mysql_num_rows(result) > 0) {
-        row = mysql_fetch_row(result);
-        if (row && row[0]) {
-          def->newest = atoi(row[0]);
-        }
+      if (dbi_result_get_numrows(result) > 0) {
+        dbi_result_next_row(result);
+        def->newest  = dbi_result_get_uint(result, "stattime");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
     }
 
     g_hash_table_insert(t->probe->cache, guintdup(res->server), def);

Modified: upwatch/libdbi/upwatch/pr_iptraf.c
===================================================================
--- upwatch/libdbi/upwatch/pr_iptraf.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/pr_iptraf.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,7 +13,7 @@
 #include "dmalloc.h"
 #endif
 
-char *query_server_by_ip;
+const char *query_server_by_ip;
 
 //*******************************************************************
 // GET THE INFO FROM THE XML FILE
@@ -64,27 +64,26 @@
 {
   struct iptraf_def *def;
   struct iptraf_result *res = (struct iptraf_result *)t->res;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char buffer[10];
   time_t now = time(NULL);
 
   if (res->color == STAT_PURPLE) {
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select ipaddress from pr_%s_def where id = '%u'", res->name, res->probeid);
     if (!result) return(NULL);
 
-    row = mysql_fetch_row(result);
-    if (row && row[0]) {
-      res->ipaddress = strdup(row[0]);
-      inet_aton(res->ipaddress, &res->ipaddr);
-    } else {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: iptraf def %u not found", res->realm, res->stattime, t->fromhost, res->probeid);
-      mysql_free_result(result);
+      dbi_result_free(result);
       delete_pr_status(t, res->probeid);
       return(NULL);
     }
-    mysql_free_result(result);
+
+    dbi_result_next_row(result);
+    strcpy(res->ipaddress, dbi_result_get_string(result, "ipaddress"));
+    inet_aton(res->ipaddress, &res->ipaddr);
+    dbi_result_free(result);
   }
 
   def = g_hash_table_lookup(t->probe->cache, &res->ipaddr);
@@ -99,14 +98,14 @@
     def->stamp = now;
     strcpy(def->hide, "no");
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select id, server, yellow, red, contact, hide, email, delay, pgroup "
                       "from   pr_%s_def "
                       "where  ipaddress = '%s'", res->name, res->ipaddress);
     if (!result) return(NULL);
 
-    if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
-      mysql_free_result(result);
+    if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
+      dbi_result_free(result);
       if (!create) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_%s_def ip %s not found - skipped",
                          res->realm, res->stattime, t->fromhost, res->name, res->ipaddress);
@@ -118,112 +117,113 @@
         LOG(LOG_ERR, "No SQL query for how to find a server by ip address");
         return(NULL);
       }
-      result = my_query(t->probe->db, 0, query_server_by_ip, res->ipaddress, res->ipaddress,
+      result = db_query(t->probe->db, 0, query_server_by_ip, res->ipaddress, res->ipaddress,
                         res->ipaddress, res->ipaddress, res->ipaddress);
       if (!result) return(NULL);
-      row = mysql_fetch_row(result);
-      if (row && row[0]) {
-        res->server   = atoi(row[0]);
-      } else {
+
+      if (dbi_result_get_numrows(result) == 0) {
         LOG(LOG_NOTICE, "%s:%u@%s: iptraf for ip %s added without server id", 
             res->realm, res->stattime, t->fromhost, res->ipaddress);
         res->server = 1;
+      } else {
+        dbi_result_next_row(result);
+        res->server = dbi_result_get_uint_idx(result, 0);
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
 
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "insert into pr_%s_def set ipaddress = '%s', server = '%u', "
                         "        description = 'auto-added by system'",
                         res->name, res->ipaddress, res->server);
-      mysql_free_result(result);
-      if (mysql_affected_rows(t->probe->db) == 0) { // nothing was actually inserted
+      dbi_result_free(result);
+      if (dbi_result_get_numrows_affected(t->probe->db) == 0) { // nothing was actually inserted
+        const char *errmsg;
+        dbi_conn_error(t->probe->db, &errmsg);
         LOG(LOG_NOTICE, "%s:%u@%s: insert missing pr_%s_def id %s: %s", 
                          res->realm, res->stattime, t->fromhost, 
-                         res->name, res->ipaddress, mysql_error(t->probe->db));
+                         res->name, res->ipaddress, errmsg);
       } else {
         LOG(LOG_NOTICE, "%s:%u@%s: created pr_%s_def for ipaddress %s", 
                          res->realm, res->stattime, t->fromhost,
                          res->name, res->ipaddress);
       }
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "select id, server, yellow, red, contact, hide, email, delay, pgroup "
                         "from   pr_%s_def "
                         "where  ipaddress = '%s'", res->name, res->ipaddress);
       if (!result) return(NULL);
     }
   
-    row = mysql_fetch_row(result);
-    if (!row) {
-      mysql_free_result(result);
+    if (dbi_result_get_numrows(result) == 0) {
+      dbi_result_free(result);
       return(NULL);
     }
-    def->probeid  = atoi(row[0]);
-    def->server   = atoi(row[1]);
-    def->yellow   = atof(row[2]);
-    def->red      = atof(row[3]);
-    def->contact  = atof(row[4]);
-    strcpy(def->hide, row[5] ? row[5] : "no");
-    strcpy(def->email, row[6] ? row[6] : "");
-    if (row[7]) def->delay = atoi(row[7]);
-    if (row[8]) def->pgroup = atoi(row[8]);
+    dbi_result_next_row(result);
 
-    mysql_free_result(result);
+    def->probeid = dbi_result_get_uint(result, "id");
+    def->server = dbi_result_get_float(result, "server");
+    def->yellow = dbi_result_get_float(result, "yellow");
+    def->red = dbi_result_get_float(result, "red");
+    def->contact = dbi_result_get_uint(result, "contact");
+    strcpy(def->hide, dbi_result_get_string(result, "hide"));
+    strcpy(def->email, dbi_result_get_string(result, "email"));
+    def->delay = dbi_result_get_uint(result, "delay");
+    def->pgroup = dbi_result_get_uint(result, "pgroup");
+    dbi_result_free(result);
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select color "
                       "from   pr_status "
                       "where  class = '%d' and probe = '%d'", t->probe->class, def->probeid);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row) {
-        def->color   = atoi(row[0]);
-      } else {
+      if (dbi_result_get_numrows(result) == 0) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u (%s) not found", 
             res->realm, res->stattime, t->fromhost, res->name, def->probeid, res->ipaddress);
-        mysql_free_result(result);
-        result = my_query(t->probe->db, 0,
+        dbi_result_free(result);
+        result = db_query(t->probe->db, 0,
                           "insert into pr_status set class = '%d', probe = '%d', server = '%d'",
                           t->probe->class, def->probeid, def->server);
+      } else {
+        dbi_result_next_row(result);
+        def->color   = dbi_result_get_uint(result, "color");
       }
-      mysql_free_result(result);
-    } else {
-      LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u (%s) not found", 
-          res->realm, res->stattime, t->fromhost, res->name, def->probeid, res->ipaddress);
+      dbi_result_free(result);
     }
+    if (!def->color) def->color = res->color;
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select stattime from pr_%s_raw use index(probstat) "
                       "where probe = '%u' order by stattime desc limit 1",
                        res->name, def->probeid);
     if (result) {
-      if (mysql_num_rows(result) > 0) {
-        row = mysql_fetch_row(result);
-        if (row && row[0]) {
-          def->newest = atoi(row[0]);
-        }
+      if (dbi_result_get_numrows(result) > 0) {
+        dbi_result_next_row(result);
+        def->newest  = dbi_result_get_uint(result, "stattime");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
     }
 
     uw_slot(SLOT_DAY, res->stattime, &slotlow, &slothigh);
-    result = my_query(t->probe->db, 0,
-                      "select sum(incoming), sum(outgoing), max(color), avg(yellow), avg(red) "
+    result = db_query(t->probe->db, 0,
+                      "select sum(incoming) as slotday_in, sum(outgoing) as slotday_out, "
+                      "       max(color) as slotday_max_color, avg(yellow) as slotday_avg_yellow, "
+                      "       avg(red) as slotday_avg_red "
                       "from   pr_iptraf_raw use index(probstat) "
                       "where  probe = '%u' and stattime >= '%u' and stattime < '%u'",
                       def->probeid, slotlow, slothigh);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row) {
-        if (row[0]) def->slotday_in   = atoi(row[0]);
-        if (row[1]) def->slotday_out  = atoi(row[1]);
-        if (row[2]) def->slotday_max_color  = atoi(row[2]);
-        if (row[3]) def->slotday_avg_yellow = atof(row[3]);
-        if (row[4]) def->slotday_avg_red    = atof(row[4]);
+      if (dbi_result_get_numrows(result) > 0) {
+        dbi_result_next_row(result);
+        def->slotday_in  = dbi_result_get_uint(result, "slotday_in");
+        def->slotday_out = dbi_result_get_uint(result, "slotday_out");
+        def->slotday_max_color = dbi_result_get_uint(result, "slotday_max_color");
+        def->slotday_avg_yellow = dbi_result_get_uint(result, "slotday_avg_yellow");
+        def->slotday_avg_red = dbi_result_get_uint(result, "slotday_avg_red");
+        dbi_result_free(result);
+      } else {
+        LOG(LOG_NOTICE, "%s:%u@%s: raw record for %s id %u not found between %u and %u", 
+                        res->realm, res->stattime, t->fromhost, res->name, def->probeid, slotlow, slothigh);
       }
-      mysql_free_result(result);
-    } else {
-      LOG(LOG_NOTICE, "%s:%u@%s: raw record for %s id %u not found between %u and %u", 
-                      res->realm, res->stattime, t->fromhost, res->name, def->probeid, slotlow, slothigh);
     }
     if (def->slotday_avg_yellow == 0) {
       def->slotday_avg_yellow = def->yellow;

Modified: upwatch/libdbi/upwatch/pr_process.c
===================================================================
--- upwatch/libdbi/upwatch/pr_process.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/pr_process.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -29,7 +29,7 @@
 // GET THE INFO FROM THE XML FILE
 // Caller must free the pointer it returns
 //******************************************************************* 
-int set_result_value(trx *t, char *name, char *value)
+int set_result_value(trx *t, char *name, unsigned char *value)
 {
   xmlNodePtr cur = t->cur;
   int found = FALSE;
@@ -89,7 +89,7 @@
   }
 
   for (t->cur = t->cur->xmlChildrenNode; t->cur != NULL; t->cur = t->cur->next) {
-    char *p;
+    unsigned char *p;
 
     if (xmlIsBlankNode(t->cur)) continue;
     if ((!xmlStrcmp(t->cur->name, (const xmlChar *) "color")) && (xmlNsEqual(t->cur->ns, t->ns))) {
@@ -159,26 +159,25 @@
 
 void delete_pr_status(trx *t, int id)
 {
-  MYSQL_RES *result;
+  dbi_conn result;
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
            "delete from pr_status where class = '%u' and probe = '%u'",
            t->probe->class, id);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 //*******************************************************************
 // retrieve the definitions + status
 // get it from the cache. if there but too old: delete
-// in case of mysql-has-gone-away type errors, we keep on running, 
+// in case of server-has-gone-away type errors, we keep on running, 
 // it will be caught later-on.
 //*******************************************************************
 void *get_def(trx *t, int create)
 {
   struct probe_result *res = (struct probe_result *)t->res;
   struct probe_def *def;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   time_t now = time(NULL);
   char *def_fields = "ipaddress, description, server, yellow, red, contact, hide, email, delay, pgroup";
 
@@ -193,30 +192,30 @@
     def->stamp    = time(NULL);
     strcpy(def->hide, "no");
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select color "
                       "from   pr_status "
                       "where  class = '%u' and probe = '%u'", t->probe->class, res->probeid);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row) {
-        if (row[0]) def->color   = atoi(row[0]);
-      } else {
+      if (dbi_result_get_numrows(result) == 0) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u ip %s not found", 
             res->realm, res->stattime, t->fromhost, res->name, res->probeid, res->ipaddress);
+      } else {
+        dbi_result_next_row(result);
+        def->color = dbi_result_get_uint(result, "color");
       }
-      mysql_free_result(result);
+      dbi_result_free(result);
     }
 
     // Get the server, contact and yellow/red info from the def record. Note the yellow/red may 
     // have been changed by the user so need to be transported into the data files
-    result = my_query(t->probe->db, 0, "select %s from pr_%s_def where  id = '%u'", 
+    result = db_query(t->probe->db, 0, "select %s from pr_%s_def where  id = '%u'", 
                       t->probe->get_def_fields ? t->probe->get_def_fields : def_fields,
                       res->name, res->probeid);
     if (!result) return(NULL);
 
-    if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
-      mysql_free_result(result);
+    if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
+      dbi_result_free(result);
       if (!create) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_%s_def id %u not found - skipped",
                          res->realm, res->stattime, t->fromhost, res->name, res->probeid);
@@ -233,19 +232,21 @@
       // for it. We apparantly trust this result, so we can create the definition
       // ourselves. For that we need to fill in the server id and the ipaddress
       // and we look into the result if the is anything useful in there.
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "insert into pr_%s_def set server = '%d', "
                         "        ipaddress = '%s', description = '%s'",
                         res->name, res->server, res->ipaddress?res->ipaddress:"",
                         t->fromhost ? t->fromhost : "automatically added");
-      mysql_free_result(result);
-      res->probeid = mysql_insert_id(t->probe->db);
-      if (mysql_affected_rows(t->probe->db) == 0) { // nothing was actually inserted
+      dbi_result_free(result);
+      res->probeid = dbi_conn_sequence_last(t->probe->db, NULL);
+      if (dbi_result_get_numrows_affected(t->probe->db) == 0) { // nothing was actually inserted
+        const char *errmsg;
+        dbi_conn_error(t->probe->db, &errmsg);
         LOG(LOG_NOTICE, "%s:%u@%s: insert missing pr_%s_def id %u: %s", 
                          res->realm, res->stattime, t->fromhost,
-                         res->name, res->probeid, mysql_error(t->probe->db));
+                         res->name, res->probeid, errmsg);
       }
-      result = my_query(t->probe->db, 0, "select %s from pr_%s_def where  id = '%u'", 
+      result = db_query(t->probe->db, 0, "select %s from pr_%s_def where  id = '%u'", 
                         t->probe->get_def_fields ? t->probe->get_def_fields : def_fields,
                         res->name, res->probeid);
       if (!result) return(NULL);
@@ -253,34 +254,30 @@
     if (t->probe->set_def_fields) {
       t->probe->set_def_fields(t, def, result);
     } else {
-      row = mysql_fetch_row(result);
-      if (row) {
-        if (row[0]) def->ipaddress   = strdup(row[0]);
-        if (row[1]) def->description = strdup(row[1]);
-        if (row[2]) def->server    = atoi(row[2]);
-        if (row[3]) def->yellow    = atof(row[3]);
-        if (row[4]) def->red       = atof(row[4]);
-        if (row[5]) def->contact   = atof(row[5]);
-        strcpy(def->hide, row[6] ? row[6] : "no");
-        strcpy(def->email, row[7] ? row[7] : "");
-        if (row[8]) def->delay = atoi(row[8]);
-        if (row[9]) def->pgroup = atoi(row[9]);
-      }
+      dbi_result_next_row(result);
+      def->ipaddress   = dbi_result_get_string_copy(result, "ipaddress");
+      def->description = dbi_result_get_string_copy(result, "description");
+      def->server      = dbi_result_get_uint(result, "server");
+      def->yellow      = dbi_result_get_float(result, "yellow");
+      def->red         = dbi_result_get_float(result, "yellow");
+      def->contact     = dbi_result_get_uint(result, "contact");
+      strcpy(def->hide, dbi_result_get_string(result, "hide"));
+      strcpy(def->email, dbi_result_get_string_copy(result, "email"));
+      def->delay       = dbi_result_get_uint(result, "delay");
+      def->pgroup      = dbi_result_get_uint(result, "pgroup");
     }
-    mysql_free_result(result);
+    dbi_result_free(result);
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select stattime from pr_%s_raw use index(probstat) "
                       "where probe = '%u' order by stattime desc limit 1",
                        res->name, res->probeid);
     if (result) {
-      if (mysql_num_rows(result) > 0) {
-        row = mysql_fetch_row(result);
-        if (row && row[0]) {
-          def->newest = atoi(row[0]);
-        }
+      if (dbi_result_get_numrows(result) > 0) {
+        dbi_result_next_row(result);
+        def->newest = dbi_result_get_uint(result, "stattime");
       }
-      mysql_free_result(result);
+      dbi_result_free(result);
     }
 
     def->probeid = res->probeid;
@@ -302,8 +299,7 @@
 {
   struct probe_def *def;
   struct probe_result *res = (struct probe_result *)t->res;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   def = g_malloc0(t->probe->def_size);
   def->stamp    = time(NULL);
@@ -311,60 +307,60 @@
   strcpy(def->hide, "no");
 
   // first find the definition based on the serverid
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select id, contact, hide, email, delay from pr_%s_def "
                     "where  server = '%u'", res->name, res->server);
   if (!result) {
     g_free(def);
     return(NULL);
   }
-  if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
-    mysql_free_result(result);
-    result = my_query(t->probe->db, 0,
+  if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
+    dbi_result_free(result);
+    result = db_query(t->probe->db, 0,
                       "insert into pr_%s_def set server = '%u', ipaddress = '%s', " 
                       "       description = '%s'", 
                        res->name, res->server, res->ipaddress ? res->ipaddress : "", 
                        res->hostname);
-    mysql_free_result(result);
-    def->probeid = mysql_insert_id(t->probe->db);
+    dbi_result_free(result);
+    def->probeid = dbi_conn_sequence_last(t->probe->db, NULL);
     LOG(LOG_NOTICE, "%s:%u@%s: pr_%s_def created for %s, id = %u", 
         res->realm, res->stattime, t->fromhost, res->name, res->hostname, def->probeid);
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "select id, contact, hide, email, delay from pr_%s_def "
                     "where  server = '%u'", res->server, res->name);
     if (!result) return(NULL);
   }
-  row = mysql_fetch_row(result);
-  if (!row || !row[0]) {
+  if (dbi_result_get_numrows(result) == 0) {
     LOG(LOG_NOTICE, "%s:%u@%s: no pr_%s_def found for server %u - skipped", 
         res->realm, res->stattime, t->fromhost, res->name, res->server);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return(NULL);
   }
 
-  if (row[0])  def->probeid = atoi(row[0]);
-  if (row[1])  def->contact = atoi(row[1]);
-  strcpy(def->hide, row[2] ? row[2] : "no");
-  strcpy(def->email, row[3] ? row[3] : "");
-  if (row[4]) def->delay = atoi(row[4]);
+  dbi_result_next_row(result);
+  def->probeid = dbi_result_get_uint(result, "id");
+  def->contact = dbi_result_get_uint(result, "contact");
+  strcpy(def->hide, dbi_result_get_string(result, "hide"));
+  strcpy(def->email, dbi_result_get_string_copy(result, "email"));
+  def->delay       = dbi_result_get_uint(result, "delay");
 
-  mysql_free_result(result);
+  dbi_result_free(result);
 
   // definition found, get the pr_status
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select color, stattime "
                     "from   pr_status "
                     "where  class = '%u' and probe = '%u'", t->probe->class, def->probeid);
   if (result) {
-    row = mysql_fetch_row(result);
-    if (row) {
-      if (row[0]) def->color   = atoi(row[0]);
-      if (row[1]) def->newest  = atoi(row[1]);
-    } else {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u (server %s) not found", 
                        res->realm, res->stattime, t->fromhost, res->name, def->probeid, res->hostname);
+    } else {
+      dbi_result_next_row(result);
+      def->color = dbi_result_get_uint(result, "color");
+      def->newest = dbi_result_get_uint(result, "stattime");
     }
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
   if (!def->color) def->color = res->color;
 

Modified: upwatch/libdbi/upwatch/pr_sysstat.c
===================================================================
--- upwatch/libdbi/upwatch/pr_sysstat.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/pr_sysstat.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -83,26 +83,24 @@
 { 
   struct probe_def *def;
   struct sysstat_result *res = (struct sysstat_result *)t->res;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   time_t now = time(NULL);
 
   if (res->color == STAT_PURPLE) { // generated by uw_purple, which knows the probe id but not the serverid
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select server from pr_%s_def where id = '%u'", res->name, res->probeid);
     if (!result) return(NULL);
 
-    row = mysql_fetch_row(result);
-    if (row && row[0]) {
-      res->server = atoi(row[0]);
-    } else {
+    if (dbi_result_get_numrows(result) == 0) {
       LOG(LOG_NOTICE, "%s:%u@%s: %s def %u not found", 
           res->realm, res->stattime, t->fromhost, res->name, res->probeid);
-      mysql_free_result(result);
+      dbi_result_free(result);
       delete_pr_status(t, res->probeid);
       return(NULL);
     }
-    mysql_free_result(result);
+    dbi_result_next_row(result);
+    res->server = dbi_result_get_uint(result, "server");
+    dbi_result_free(result);
   }
 
   def = g_hash_table_lookup(t->probe->cache, &res->server);
@@ -117,78 +115,83 @@
     strcpy(def->hide, "no");
     def->server = res->server;
     
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select id, yellow, red, contact, hide, email, delay, pgroup "
                       "from   pr_%s_def "
                       "where  server = '%u'", res->name, res->server);
     if (!result) return(NULL);
 
-    if (mysql_num_rows(result) == 0) { // DEF RECORD NOT FOUND
-      mysql_free_result(result);
+    if (dbi_result_get_numrows(result) == 0) { // DEF RECORD NOT FOUND
+      dbi_result_free(result);
       if (!create) {
         LOG(LOG_NOTICE, "%s:%u@%s: pr_%s_def for server %u not found and not trusted - skipped", 
                          res->realm, res->stattime, t->fromhost, res->name, def->server);
         return(NULL);
       }
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "insert into pr_%s_def set server = '%d', "
                         "        ipaddress = '%s', description = '%s'", 
                         res->name, res->server, t->res->ipaddress ? t->res->ipaddress : "127.0.0.1", 
                         t->fromhost ? t->fromhost : "automatically added");
-      mysql_free_result(result);
-      if (mysql_affected_rows(t->probe->db) == 0) { // nothing was actually inserted
+      dbi_result_free(result);
+      if (dbi_result_get_numrows_affected(t->probe->db) == 0) { // nothing was actually inserted
+        const char *errmsg;
+        dbi_conn_error(t->probe->db, &errmsg);
         LOG(LOG_NOTICE, "%s:%u@%s: insert missing pr_%s_def id %u: %s", 
                          res->realm, res->stattime, t->fromhost,
-                         res->name, def->probeid, mysql_error(t->probe->db));
+                         res->name, def->probeid, errmsg);
       }
-      result = my_query(t->probe->db, 0,
+      result = db_query(t->probe->db, 0,
                         "select id, yellow, red, contact, hide, email, delay, pgroup "
                         "from   pr_%s_def "
                         "where  server = '%u'", res->name, res->server);
       if (!result) return(NULL);
     }
-    row = mysql_fetch_row(result); 
-    if (!row || !row[0]) {
-      LOG(LOG_NOTICE, "%s:%u@%s: no pr_%s_def found for server %u - skipped", 
+    if (dbi_result_get_numrows(result) == 0) {
+      LOG(LOG_NOTICE, "%s:%u@%s: no pr_%s_def found for server %u - skipped",
           res->realm, res->stattime, t->fromhost, res->name, res->server);
-      mysql_free_result(result);
+      dbi_result_free(result);
+      g_free(def);
       return(NULL);
     }
-    if (row[0]) def->probeid  = atoi(row[0]);
-    if (row[1]) def->yellow   = atoi(row[1]);
-    if (row[2]) def->red      = atoi(row[2]);
-    if (row[3]) def->contact  = atoi(row[3]);
-    strcpy(def->hide, row[4] ? row[4] : "no");
-    strcpy(def->email, row[5] ? row[5] : "");
-    if (row[6]) def->delay = atoi(row[6]);
-    if (row[7]) def->pgroup = atoi(row[7]);
+    dbi_result_next_row(result);
 
-    mysql_free_result(result);
+    def->probeid = dbi_result_get_uint(result, "id");
+    def->yellow = dbi_result_get_float(result, "yellow");
+    def->red = dbi_result_get_float(result, "red");
+    def->contact = dbi_result_get_uint(result, "contact");
+    strcpy(def->hide, dbi_result_get_string(result, "hide"));
+    strcpy(def->email, dbi_result_get_string(result, "email"));
+    def->delay = dbi_result_get_uint(result, "delay");
+    def->pgroup = dbi_result_get_uint(result, "pgroup");
+    dbi_result_free(result);
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select color "
                       "from   pr_status "
                       "where  class = '%d' and probe = '%d'", t->probe->class, def->probeid);
     if (result) {
-      row = mysql_fetch_row(result);
-      if (row) {
-        def->color   = atoi(row[0]); 
+      if (dbi_result_get_numrows(result) == 0) {
+        LOG(LOG_NOTICE, "%s:%u@%s: pr_status record for %s id %u not found",
+           res->realm, res->stattime, t->fromhost, res->name, def->probeid);
+      } else {
+        dbi_result_next_row(result);
+        def->color   = dbi_result_get_uint(result, "color");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
-    } 
+    }
+    if (!def->color) def->color = res->color;
 
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                       "select stattime from pr_%s_raw use index(probstat) "
                       "where probe = '%u' order by stattime desc limit 1",
                        res->name, def->probeid);
     if (result) {
-      if (mysql_num_rows(result) > 0) {
-        row = mysql_fetch_row(result);
-        if (row && row[0]) {
-          def->newest = atoi(row[0]);
-        }
+      if (dbi_result_get_numrows(result) > 0) {
+        dbi_result_next_row(result);
+        def->newest  = dbi_result_get_uint(result, "stattime");
+        dbi_result_free(result);
       }
-      mysql_free_result(result);
     }
 
     g_hash_table_insert(t->probe->cache, guintdup(res->server), def);

Modified: upwatch/libdbi/upwatch/probe.h
===================================================================
--- upwatch/libdbi/upwatch/probe.h	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/probe.h	2006-07-21 20:34:40 UTC (rev 632)
@@ -68,7 +68,7 @@
 #define STANDARD_MODULE_STRUCT \
   int class;					/* numberic probe class (id of record in probe table) */ \
   char *module_name; 				/* name of the module */ \
-  MYSQL *db;					/* database handle the methods should use */ \
+  dbi_conn db;					/* database handle the methods should use */ \
   int needs_cache;				/* true if this probe caches def records */ \
   GHashTable *cache;				/* cached definition records */ \
   GPtrArray *insertc;				/* cache for doing multi value insert statements */ \
@@ -88,7 +88,7 @@
   void (*get_from_xml)(trx *t);			/* process one child of the "result" node */ \
   int (*accept_result)(trx *t);			/* accept (and maybe convert) result */ \
   char *get_def_fields;				/* list of fields to be inserted into SQL get_def query */ \
-  void (*set_def_fields)(trx *t, struct probe_def *def, MYSQL_RES *result);/* convert MySQL ROW into probe_def */ \
+  void (*set_def_fields)(trx *t, struct probe_def *def, dbi_result result);/* convert result into probe_def */ \
   void *(*get_def)(trx *t, int create);		/* retrieve probe definition */ \
   void (*adjust_result)(trx *t);		/* adjust result: usually compute our own colors */ \
   int (*end_result)(trx *t);                    /* maybe do some cleanup for this result */  \
@@ -120,7 +120,7 @@
 
 extern module *modules[];
 
-int set_result_value(trx *t, char *name, char *value);
+int set_result_value(trx *t, char *name, unsigned char *value);
 int extract_info_from_xml(trx *t);
 int accept_result(trx *t);
 void *get_def(trx *t, int create);
@@ -140,7 +140,7 @@
 #include "../common/common.h"
 };
 
-extern char *query_server_by_name;
+extern const char *query_server_by_name;
 void bb_free_res(void *res);
 void bb_xml_result_node(trx *t);
 int bb_accept_result(module *probe, void *probe_res);
@@ -218,7 +218,7 @@
   float slotday_avg_red;    //
 };
 
-extern char *query_server_by_ip;
+extern const char *query_server_by_ip;
 void iptraf_xml_result_node(trx *t);
 void iptraf_get_from_xml(trx *t);
 void *iptraf_get_def(trx *t, int create);

Modified: upwatch/libdbi/upwatch/spool.c
===================================================================
--- upwatch/libdbi/upwatch/spool.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/spool.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -30,7 +30,7 @@
 static void alarm_handler(int sig); 
 static void set_handler(int sig, void (*h)());
  
-int spool_result(char *basedir, char *target, xmlDocPtr doc, char **targetname)
+int spool_result(const char *basedir, const char *target, xmlDocPtr doc, char **targetname)
 {
   struct stat filestat;
   int count;
@@ -123,7 +123,7 @@
   return 1;
 }
 
-void *spool_open(char *basedir, char *target, char *basename)
+void *spool_open(const char *basedir, const char *target, char *basename)
 {
   struct stat filestat;
   int count;

Modified: upwatch/libdbi/upwatch/spool.h
===================================================================
--- upwatch/libdbi/upwatch/spool.h	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch/spool.h	2006-07-21 20:34:40 UTC (rev 632)
@@ -1,8 +1,8 @@
-void *spool_open(char *basedir, char *target, char *basename);
+void *spool_open(const char *basedir, const char *target, char *basename);
 int spool_printf(void *sp_info, char *fmt, ...);
 int spool_write(void *sp_info, char *buffer, int len);
 int spool_close(void *sp_info, int complete);
 char *spool_tmpfilename(void *sp_info);
 char *spool_targfilename(void *sp_info);
 
-int spool_result(char *basedir, char *target, xmlDocPtr doc, char **targetname);
+int spool_result(const char *basedir, const char *target, xmlDocPtr doc, char **targetname);

Modified: upwatch/libdbi/upwatch-spec.spec
===================================================================
--- upwatch/libdbi/upwatch-spec.spec	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/upwatch-spec.spec	2006-07-21 20:34:40 UTC (rev 632)
@@ -6,7 +6,7 @@
 Release: 1
 Source: http://www.upwatch.com/%{name}-%{version}.tar.gz
 Packager: Ron Arts <raarts at upwatch.com>
-Copyright: Proprietary
+License: GPL 
 Group: Application/Monitoring
 BuildRoot: %{_tmppath}/%{name}-%{version}-root
 BuildRequires: gzip glib2-devel mysql-devel curl-devel autogen 

Modified: upwatch/libdbi/uw_accept/Makefile.am
===================================================================
--- upwatch/libdbi/uw_accept/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_accept/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_accept_SOURCES = run.c uw_accept.h uw_accept.c $(SPECFILES) $(INITFILES)
-uw_accept_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
-uw_accept_LDADD = uw_accept_$(DB_O) uw_accept_$(MAIN_O) $(LIBOPTS) $(LIBST) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_accept_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
+uw_accept_LDADD = uw_accept_$(DB_O) uw_accept_$(MAIN_O) $(LIBOPTS) $(LIBST) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES) 
 INCLUDES = -I../upwatch -I $(INCL_ST)

Modified: upwatch/libdbi/uw_accept/run.c
===================================================================
--- upwatch/libdbi/uw_accept/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_accept/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -20,7 +20,7 @@
   char db[64];
   char user[25];
   char password[25];
-  MYSQL *mysql;
+  dbi_conn conn;
 } *dblist;
 int dblist_cnt;
 
@@ -38,46 +38,45 @@
 
 void init_dblist(void)
 {
-  MYSQL *db;
+  dbi_conn conn;
 
-  db = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                      OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (db) {
-    MYSQL_RES *result;
+  if (conn) {
+    dbi_result result;
 
     if (dblist) free(dblist);
     dblist = calloc(100, sizeof(struct dbspec));
 
-    result = my_query(db, 0, "select pr_realm.name, pr_realm.host, "
+    result = db_query(conn, 0, "select pr_realm.name, pr_realm.host, "
                              "       pr_realm.port, pr_realm.db, pr_realm.user, "
                              "       pr_realm.password "
                              "from   pr_realm "
                              "where  pr_realm.id > 1");
     if (result) {
-      MYSQL_ROW row;
       dblist_cnt = 0;
-      while ((row = mysql_fetch_row(result)) != NULL) {
-        strcpy(dblist[dblist_cnt].realm, row[0]);
-        strcpy(dblist[dblist_cnt].host, row[1]);
-        dblist[dblist_cnt].port = atoi(row[2]);
-        strcpy(dblist[dblist_cnt].db, row[3]);
-        strcpy(dblist[dblist_cnt].user, row[4]);
-        strcpy(dblist[dblist_cnt].password, row[5]);
+      while (dbi_result_next_row(result)) {
+        strcpy(dblist[dblist_cnt].realm, dbi_result_get_string(result, "name"));
+        strcpy(dblist[dblist_cnt].host, dbi_result_get_string(result, "host"));
+        dblist[dblist_cnt].port = dbi_result_get_uint(result, "port");
+        strcpy(dblist[dblist_cnt].db, dbi_result_get_string(result, "db"));
+        strcpy(dblist[dblist_cnt].user, dbi_result_get_string(result, "user"));
+        strcpy(dblist[dblist_cnt].password, dbi_result_get_string(result, "password"));
         dblist_cnt++;
       }
-      mysql_free_result(result);
+      dbi_result_free(result);
     }
-    close_database(db);
+    close_database(conn);
     LOG(LOG_INFO, "read %u realms", dblist_cnt);
   } else {
-    LOG(LOG_NOTICE, "could not open database %s@%s as user %s", OPT_ARG(DBNAME), OPT_ARG(DBHOST), OPT_ARG(DBUSER));
+    LOG(LOG_NOTICE, "could not open %s database %s@%s as user %s", OPT_ARG(DBTYPE), OPT_ARG(DBNAME), OPT_ARG(DBHOST), OPT_ARG(DBUSER));
   } 
 }
 
-MYSQL *open_realm(char *realm)
+dbi_conn open_realm(char *realm)
 {
   int i;
-  MYSQL *mysql;
+  dbi_conn conn;
 static int call_cnt = 0;
 
   if (!dblist || ++call_cnt == 100) {
@@ -89,16 +88,22 @@
     }
   }
   if (realm == NULL || realm[0] == 0) {
-    mysql = open_database(dblist[0].host, dblist[0].port,
+    char buf[10];
+
+    sprintf(buf, "%d", dblist[0].port);
+    conn = open_database(OPT_ARG(DBTYPE), dblist[0].host, buf,
             dblist[0].db, dblist[0].user, dblist[0].password);
-    return(mysql);
+    return(conn);
   }
 
   for (i=0; i < dblist_cnt; i++) {
     if (strcmp(dblist[i].realm, realm) == 0) {
-      mysql = open_database(dblist[i].host, dblist[i].port,
+      char buf[10];
+
+      sprintf(buf, "%d", dblist[0].port);
+      conn = open_database(OPT_ARG(DBTYPE), dblist[i].host, buf,
               dblist[i].db, dblist[i].user, dblist[i].password);
-      return(mysql);
+      return(conn);
     }
   }
   return(NULL);
@@ -106,8 +111,8 @@
 
 static int uw_password_ok(char *user, char *passwd) 
 {
-  MYSQL *mysql;
-  MYSQL_RES *result;
+  dbi_conn conn;
+  dbi_result result;
   char user_realm[256];
   char *realm;
 
@@ -116,33 +121,25 @@
   if (realm) { 
     *realm++ = 0; 
   }
-  mysql = open_realm(realm);
-  if (mysql) {
+  conn = open_realm(realm);
+  if (conn) {
     gchar buffer[256];
-    MYSQL_ROW row;
 
     sprintf(buffer, OPT_ARG(AUTHQUERY), user, passwd);
     LOG(LOG_DEBUG, buffer);
-    if (mysql_query(mysql, buffer)) {
-      close_database(mysql);
+    result = dbi_conn_query(conn, buffer);
+    if (!result) {
+      close_database(conn);
       return(FALSE);
     }
-    result = mysql_store_result(mysql);
-    if (!result || mysql_num_rows(result) < 1) {
-      // LOG(LOG_NOTICE, "user %s, pwd %s not found", user, passwd);
-      close_database(mysql);
-      return(FALSE);
-    }
-    if ((row = mysql_fetch_row(result))) {
-      int id;
-
-      id = atoi(row[0]);
+    if (dbi_result_next_row(result)) {
+      int id = dbi_result_get_uint_idx(result, 0);
       LOG(LOG_DEBUG, "user %s, pwd %s resulted in id %d", user_realm, passwd, id);
     }
-    mysql_free_result(result);
-    close_database(mysql);
+    dbi_result_free(result);
+    close_database(conn);
   } else {
-    close_database(mysql);
+    close_database(conn);
     return(FALSE); // couldn't open database
   }
   return(TRUE);

Modified: upwatch/libdbi/uw_accept/uw_accept.def
===================================================================
--- upwatch/libdbi/uw_accept/uw_accept.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_accept/uw_accept.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -16,7 +16,7 @@
 and copies incoming files to a queue.';
 
 // this section is for the generated specfile 
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_accept`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_acceptbb/Makefile.am
===================================================================
--- upwatch/libdbi/uw_acceptbb/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_acceptbb/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -9,8 +9,8 @@
 
 uw_acceptbb_SOURCES = run.c uw_acceptbb.h uw_acceptbb.c \
  $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_acceptbb_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_acceptbb_LDADD = uw_acceptbb_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_acceptbb_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_acceptbb_LDADD = uw_acceptbb_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch -I $(INCL_ST)

Modified: upwatch/libdbi/uw_acceptbb/uw_acceptbb.def
===================================================================
--- upwatch/libdbi/uw_acceptbb/uw_acceptbb.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_acceptbb/uw_acceptbb.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -14,7 +14,7 @@
 Big Brother package (www.bb4.com)';
 
 // this section is for the generated specfile 
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_acceptbb`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_dns/Makefile.am
===================================================================
--- upwatch/libdbi/uw_dns/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_dns/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_dns_SOURCES = run.c uw_dns.h uw_dns.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_dns_CFLAGS = @LIBXML2_CFLAGS@ @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
-uw_dns_LDADD = uw_dns_$(DB_O) uw_dns_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_dns_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
+uw_dns_LDADD = uw_dns_$(DB_O) uw_dns_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch -I $(INCL_ST)

Modified: upwatch/libdbi/uw_dns/run.c
===================================================================
--- upwatch/libdbi/uw_dns/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_dns/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -113,13 +113,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if ((pktno >> 16) > (getpid() & 0xffff) + 10) {
     pktno = (getpid() & 0xffff) << 16;
@@ -131,11 +131,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -151,10 +151,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_dns_def.id, pr_dns_def.domid, pr_dns_def.tblid, pr_realm.name, "
@@ -165,23 +164,23 @@
                 "       and pr_dns_def.pgroup = '%d' and pr_realm.id = pr_dns_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
       probe->id = id;
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -189,19 +188,22 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
-    probe->yellow = atof(row[5]);
-    probe->red = atof(row[6]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void write_probe(gpointer key, gpointer value, gpointer user_data)

Modified: upwatch/libdbi/uw_dns/uw_dns.def
===================================================================
--- upwatch/libdbi/uw_dns/uw_dns.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_dns/uw_dns.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_dns can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 //spec-files = "%attr(0770,root,upwatch) " 
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_dns`;
 

Modified: upwatch/libdbi/uw_httpget/Makefile.am
===================================================================
--- upwatch/libdbi/uw_httpget/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_httpget/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_httpget_SOURCES = run.c uw_httpget.h uw_httpget.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_httpget_CFLAGS = @LIBXML2_CFLAGS@ @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
-uw_httpget_LDADD = uw_httpget_$(DB_O) uw_httpget_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_httpget_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
+uw_httpget_LDADD = uw_httpget_$(DB_O) uw_httpget_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch -I $(INCL_ST)

Modified: upwatch/libdbi/uw_httpget/run.c
===================================================================
--- upwatch/libdbi/uw_httpget/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_httpget/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -29,7 +29,7 @@
 static void *probe(void *user_data); 
 static void write_results(void);
 void run_actual_probes(void);
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 
 int thread_count = 0;
 
@@ -90,13 +90,13 @@
   return 1;
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 static void write_results(void);
 
 int run()
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -104,11 +104,11 @@
 
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                         OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -124,10 +124,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   //g_hash_table_foreach_remove(cache, delete_probe, NULL);
@@ -140,22 +139,22 @@
                 "       and pr_httpget_def.pgroup = '%u' and pr_realm.id = pr_httpget_def.domid",
                 (unsigned) OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atoi(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
       probe->id = id;
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -164,27 +163,29 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->uri) g_free(probe->uri);
-    probe->uri = strdup(row[5]);
+    probe->uri = dbi_result_get_string_copy(result, "uri");
     if (probe->hostname) g_free(probe->hostname);
-    probe->hostname = strdup(row[6]);
-    probe->port = atoi(row[7]);
-    probe->yellow = atof(row[8]);
-    probe->red = atof(row[9]);
+    probe->hostname = dbi_result_get_string_copy(result, "hostname");
+    probe->port = dbi_result_get_uint(result, "port");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     if (probe->info) g_free(probe->info);
     probe->info = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
-    LOG(LOG_ERR, "%s", mysql_error(mysql));
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void add_probe(gpointer key, gpointer value, gpointer user_data)
@@ -260,7 +261,7 @@
 static void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_httpget/uw_httpget.def
===================================================================
--- upwatch/libdbi/uw_httpget/uw_httpget.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_httpget/uw_httpget.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_httpget can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 //spec-files = "%attr(0770,root,upwatch) " 
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_httpget`;
 

Modified: upwatch/libdbi/uw_imap/Makefile.am
===================================================================
--- upwatch/libdbi/uw_imap/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_imap/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_imap_SOURCES = run.c uw_imap.h uw_imap.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_imap_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_imap_LDADD = uw_imap_$(DB_O) uw_imap_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_imap_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_imap_LDADD = uw_imap_$(DB_O) uw_imap_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch -I $(INCL_ST)

Modified: upwatch/libdbi/uw_imap/run.c
===================================================================
--- upwatch/libdbi/uw_imap/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_imap/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -68,13 +68,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -82,11 +82,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -102,10 +102,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_imap_def.id, pr_imap_def.domid, pr_imap_def.tblid, pr_realm.name, "
@@ -117,22 +116,22 @@
                 "       and pr_imap_def.pgroup = '%d' and pr_realm.id = pr_imap_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -140,24 +139,26 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->username) g_free(probe->username);
-    probe->username = strdup(row[5]);
+    probe->username = dbi_result_get_string_copy(result, "username");
     if (probe->password) g_free(probe->password);
-    probe->password = strdup(row[6]);
-    probe->yellow = atof(row[7]);
-    probe->red = atof(row[8]);
+    probe->password = dbi_result_get_string_copy(result, "password");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
-    LOG(LOG_INFO, "saw an error: not removing any probes");
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void *probe(void *user_data); 
@@ -226,7 +227,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_imap/uw_imap.def
===================================================================
--- upwatch/libdbi/uw_imap/uw_imap.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_imap/uw_imap.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_imap can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_imap`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_investigate/cmd_options.def
===================================================================
--- upwatch/libdbi/uw_investigate/cmd_options.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_investigate/cmd_options.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,7 +13,7 @@
 'uw_investigate does the following: ';
 
 // this section is for the generated specfile
-spec-requires = "libpcap = 0.6.2-13uw /usr/bin/mysql glib2 >= 2.0.4 curl >= 7.9.3 libnet >= 1.0.2";
+spec-requires = "libpcap = 0.6.2-13uw libdbi >= 0.8 glib2 >= 2.0.4 curl >= 7.9.3 libnet >= 1.0.2";
 spec-files    = `echo %dir $spooldir/uw_investigate/new`;
 spec-files    = `echo %dir $spooldir/uw_investigate/tmp`;
 

Modified: upwatch/libdbi/uw_mssql/Makefile.am
===================================================================
--- upwatch/libdbi/uw_mssql/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mssql/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -1,15 +1,17 @@
 include $(top_srcdir)/Makefile.am.path
 
 AM_CFLAGS += -DWITH_THREADS
+if HAVE_LIBTDS
 program = uw_mssql
+endif
 sbin_PROGRAMS = $(program)
 man_MANS = uw_mssql.1
 conf_DATA = $(program:%=%.conf)
 init_DATA = $(INITFILES)
 
 uw_mssql_SOURCES = run.c uw_mssql.h uw_mssql.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_mssql_CFLAGS = @MYSQL_CFLAGS@ @LIBGTHREAD2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_mssql_LDADD = uw_mssql_$(DB_O) uw_mssql_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @MYSQL_LIBS@ @LIBGTHREAD2_LIBS@ @LIBTDS_LIBS@
+uw_mssql_CFLAGS = @LIBGTHREAD2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_mssql_LDADD = uw_mssql_$(DB_O) uw_mssql_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @LIBDBI_LIBS@ @LIBGTHREAD2_LIBS@ @LIBTDS_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_mssql/run.c
===================================================================
--- upwatch/libdbi/uw_mssql/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mssql/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -63,13 +63,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -77,11 +77,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -97,10 +97,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_mssql_def.id, pr_mssql_def.domid, pr_mssql_def.tblid, pr_realm.name, "
@@ -113,22 +112,22 @@
                 "       and pr_mssql_def.pgroup = '%d' and pr_realm.id = pr_mssql_def.domid ",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -136,27 +135,30 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->dbname) g_free(probe->dbname);
-    probe->dbname = strdup(row[5]);
+    probe->dbname = dbi_result_get_string_copy(result, "dbname");
     if (probe->dbuser) g_free(probe->dbuser);
-    probe->dbuser = strdup(row[6]);
+    probe->dbuser = dbi_result_get_string_copy(result, "dbuser");
     if (probe->dbpasswd) g_free(probe->dbpasswd);
-    probe->dbpasswd = strdup(row[7]);
+    probe->dbpasswd = dbi_result_get_string_copy(result, "dbpasswd");
     if (probe->query) g_free(probe->query);
-    probe->query = strdup(row[8]);
-    probe->yellow = atof(row[9]);
-    probe->red = atof(row[10]);
+    probe->query = dbi_result_get_string_copy(result, "query");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void probe(gpointer data, gpointer user_data);

Modified: upwatch/libdbi/uw_mssql/uw_mssql.def
===================================================================
--- upwatch/libdbi/uw_mssql/uw_mssql.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mssql/uw_mssql.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_mssql can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2 freetds";
+spec-requires = "libdbi >= 0.8 glib2 freetds";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_mssql`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_mysql/Makefile.am
===================================================================
--- upwatch/libdbi/uw_mysql/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mysql/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -1,7 +1,9 @@
 include $(top_srcdir)/Makefile.am.path
 
 AM_CFLAGS += -DWITH_THREADS
+if HAVE_LIBMYSQL
 program = uw_mysql
+endif
 sbin_PROGRAMS = $(program)
 man_MANS = uw_mysql.1
 conf_DATA = $(program:%=%.conf)
@@ -9,7 +11,7 @@
 
 uw_mysql_SOURCES = run.c uw_mysql.h uw_mysql.c $(PROBFILES) $(SPECFILES) $(INITFILES)
 uw_mysql_CFLAGS = @MYSQL_CFLAGS@ @LIBGTHREAD2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_mysql_LDADD = uw_mysql_$(DB_O) uw_mysql_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @MYSQL_LIBS@ @LIBGTHREAD2_LIBS@
+uw_mysql_LDADD = uw_mysql_$(DB_O) uw_mysql_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @MYSQL_LIBS@ @LIBDBI_LIBS@ @LIBGTHREAD2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_mysql/run.c
===================================================================
--- upwatch/libdbi/uw_mysql/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mysql/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -2,6 +2,7 @@
 #include <db.h>
 #include <generic.h>
 #include <sys/time.h>
+#include <mysql.h>
 
 #include "uw_mysql.h"
 
@@ -62,13 +63,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -76,11 +77,11 @@
   
   LOG(LOG_INFO, "reading info from database"); 
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -96,10 +97,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_mysql_def.id, pr_mysql_def.domid, pr_mysql_def.tblid, pr_realm.name, "
@@ -112,22 +112,22 @@
                 "       and pr_mysql_def.pgroup = '%d' and pr_realm.id = pr_mysql_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -135,27 +135,30 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->dbname) g_free(probe->dbname);
-    probe->dbname = strdup(row[5]);
+    probe->dbname = dbi_result_get_string_copy(result, "dbname");
     if (probe->dbuser) g_free(probe->dbuser);
-    probe->dbuser = strdup(row[6]);
+    probe->dbuser = dbi_result_get_string_copy(result, "dbuser");
     if (probe->dbpasswd) g_free(probe->dbpasswd);
-    probe->dbpasswd = strdup(row[7]);
+    probe->dbpasswd = dbi_result_get_string_copy(result, "dbpasswd");
     if (probe->query) g_free(probe->query);
-    probe->query = strdup(row[8]);
-    probe->yellow = atof(row[9]);
-    probe->red = atof(row[10]);
+    probe->query = dbi_result_get_string_copy(result, "query");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void probe(gpointer data, gpointer user_data);
@@ -228,7 +231,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 
@@ -256,8 +259,8 @@
   dbuser = probe->dbuser;
   dbpasswd = probe->dbpasswd;
 
-  option = 0 ; mysql_options(mysql, MYSQL_OPT_COMPRESS, &option);
-  option = 50; mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, &option);
+  option = 0 ; mysql_options(mysql, MYSQL_OPT_COMPRESS, (const char *)&option);
+  option = 50; mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&option);
   gettimeofday(&start, NULL);
   if (!mysql_real_connect(mysql, dbhost, dbuser, dbpasswd, dbname, 0, NULL, 0)) {
     probe->msg = strdup(mysql_error(mysql));

Modified: upwatch/libdbi/uw_mysql/uw_mysql.def
===================================================================
--- upwatch/libdbi/uw_mysql/uw_mysql.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mysql/uw_mysql.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_mysql can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 /usr/bin/mysql glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_mysql`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_mysqlstats/Makefile.am
===================================================================
--- upwatch/libdbi/uw_mysqlstats/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mysqlstats/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -1,7 +1,9 @@
 include $(top_srcdir)/Makefile.am.path
 
 AM_CFLAGS += -DWITH_THREADS
+if HAVE_LIBMYSQL
 program = uw_mysqlstats
+endif
 sbin_PROGRAMS = $(program)
 man_MANS = uw_mysqlstats.1
 conf_DATA = $(program:%=%.conf)
@@ -9,7 +11,7 @@
 
 uw_mysqlstats_SOURCES = run.c uw_mysqlstats.h uw_mysqlstats.c $(PROBFILES) $(SPECFILES) $(INITFILES)
 uw_mysqlstats_CFLAGS = @MYSQL_CFLAGS@ @LIBGTHREAD2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_mysqlstats_LDADD = uw_mysqlstats_$(DB_O) uw_mysqlstats_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @MYSQL_LIBS@ @LIBGTHREAD2_LIBS@
+uw_mysqlstats_LDADD = uw_mysqlstats_$(DB_O) uw_mysqlstats_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @LIBDBI_LIBS@ @MYSQL_LIBS@ @LIBGTHREAD2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_mysqlstats/run.c
===================================================================
--- upwatch/libdbi/uw_mysqlstats/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mysqlstats/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -2,6 +2,7 @@
 #include <generic.h>
 #include <db.h>
 #include <sys/time.h>
+#include <mysql.h>
 
 #include "uw_mysqlstats.h"
 
@@ -65,13 +66,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -79,11 +80,11 @@
   
   LOG(LOG_INFO, "reading info from database (group %u)", (unsigned)OPT_VALUE_GROUPID); 
   uw_setproctitle("reading info from database (group %u)", (unsigned)OPT_VALUE_GROUPID);
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -99,10 +100,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_mysqlstats_def.id, pr_mysqlstats_def.domid, pr_mysqlstats_def.tblid, pr_realm.name, "
@@ -114,22 +114,22 @@
                 "       and pr_mysqlstats_def.pgroup = '%d' and pr_realm.id = pr_mysqlstats_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -137,25 +137,28 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->dbname) g_free(probe->dbname);
-    probe->dbname = strdup(row[5]);
+    probe->dbname = dbi_result_get_string_copy(result, "dbname");
     if (probe->dbuser) g_free(probe->dbuser);
-    probe->dbuser = strdup(row[6]);
+    probe->dbuser = dbi_result_get_string_copy(result, "dbuser");
     if (probe->dbpasswd) g_free(probe->dbpasswd);
-    probe->dbpasswd = strdup(row[7]);
-    probe->yellow = atof(row[8]);
-    probe->red = atof(row[9]);
+    probe->dbpasswd = dbi_result_get_string_copy(result, "dbpasswd");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void probe(gpointer data, gpointer user_data);
@@ -224,7 +227,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 
@@ -263,7 +266,7 @@
   dbpasswd = probe->dbpasswd;
 
   mysql_options(mysql, MYSQL_OPT_COMPRESS, 0);
-  mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, &timeout);
+  mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&timeout);
 
   LOG(LOG_DEBUG, "%s %s %s %s", dbhost, dbuser, dbpasswd, dbname);
   if (!mysql_real_connect(mysql, dbhost, dbuser, dbpasswd, dbname, 0, NULL, 0)) {

Modified: upwatch/libdbi/uw_mysqlstats/uw_mysqlstats.def
===================================================================
--- upwatch/libdbi/uw_mysqlstats/uw_mysqlstats.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_mysqlstats/uw_mysqlstats.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -14,7 +14,7 @@
 server like number of select queries etc.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysqlstats glib2";
+spec-requires = "libdbi >= 0.8 /usr/bin/mysql glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_mysqlstats`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_null/Makefile.am
===================================================================
--- upwatch/libdbi/uw_null/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_null/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -11,7 +11,7 @@
 init_DATA = $(INITFILES)
 
 uw_null_SOURCES = run.c uw_null.h uw_null.c $(SPECFILES) $(INITFILES) 
-uw_null_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_null_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
 uw_null_LDADD = uw_null_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBGLIB2_LIBS@ $(SOLARISLIBS)
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES)

Modified: upwatch/libdbi/uw_ping/Makefile.am
===================================================================
--- upwatch/libdbi/uw_ping/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_ping/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -7,8 +7,8 @@
 init_DATA = $(INITFILES)
 
 uw_ping_SOURCES = run.c uw_ping.h uw_ping.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_ping_CFLAGS = @LIBGLIB2_CFLAGS@ @MYSQL_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_ping_LDADD = uw_ping_$(DB_O) uw_ping_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBXML2_LIBS@ @LIBGLIB2_LIBS@
+uw_ping_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_ping_LDADD = uw_ping_$(DB_O) uw_ping_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBXML2_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_ping/run.c
===================================================================
--- upwatch/libdbi/uw_ping/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_ping/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -112,13 +112,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if ((pktno >> 16) > (getpid() & 0xffff) + 10) {
     pktno = (getpid() & 0xffff) << 16;
@@ -130,11 +130,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -150,10 +150,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_ping_def.id, pr_ping_def.domid, pr_ping_def.tblid, pr_realm.name, "
@@ -164,23 +163,23 @@
                 "       and pr_ping_def.pgroup = '%d' and pr_realm.id = pr_ping_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
       probe->id = id;
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -188,21 +187,24 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
-    probe->count = atoi(row[5]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
+    probe->count = dbi_result_get_uint(result, "count");
     if (probe->count > 30) probe->count = 30;
-    probe->yellow = atof(row[6]);
-    probe->red = atof(row[7]);
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void write_probe(gpointer key, gpointer value, gpointer user_data)

Modified: upwatch/libdbi/uw_ping/uw_ping.def
===================================================================
--- upwatch/libdbi/uw_ping/uw_ping.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_ping/uw_ping.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(4770,root,upwatch)" $sbindir/uw_ping`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_pop3/Makefile.am
===================================================================
--- upwatch/libdbi/uw_pop3/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_pop3/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_pop3_SOURCES = run.c uw_pop3.h uw_pop3.c  $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_pop3_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_pop3_LDADD = uw_pop3_$(DB_O) uw_pop3_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_pop3_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_pop3_LDADD = uw_pop3_$(DB_O) uw_pop3_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_pop3/run.c
===================================================================
--- upwatch/libdbi/uw_pop3/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_pop3/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -68,13 +68,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -82,11 +82,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -102,10 +102,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_pop3_def.id, pr_pop3_def.domid, pr_pop3_def.tblid, pr_realm.name, "
@@ -117,22 +116,22 @@
                 "       and pr_pop3_def.pgroup = '%d' and pr_realm.id = pr_pop3_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -140,23 +139,26 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->username) g_free(probe->username);
-    probe->username = strdup(row[5]);
+    probe->username = dbi_result_get_string_copy(result, "username");
     if (probe->password) g_free(probe->password);
-    probe->password = strdup(row[6]);
-    probe->yellow = atof(row[7]);
-    probe->red = atof(row[8]);
+    probe->password = dbi_result_get_string_copy(result, "password");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void *probe(void *user_data); 

Modified: upwatch/libdbi/uw_pop3/uw_pop3.def
===================================================================
--- upwatch/libdbi/uw_pop3/uw_pop3.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_pop3/uw_pop3.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_pop3 can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_pop3`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_postgresql/Makefile.am
===================================================================
--- upwatch/libdbi/uw_postgresql/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_postgresql/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_postgresql_SOURCES = run.c uw_postgresql.h uw_postgresql.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_postgresql_CFLAGS = @MYSQL_CFLAGS@ @LIBGTHREAD2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBPQ_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_postgresql_LDADD = uw_postgresql_$(DB_O) uw_postgresql_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @MYSQL_LIBS@ @LIBGTHREAD2_LIBS@ @LIBPQ_LIBS@
+uw_postgresql_CFLAGS = @LIBGTHREAD2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBPQ_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_postgresql_LDADD = uw_postgresql_$(DB_O) uw_postgresql_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCHT) @LIBDBI_LIBS@ @LIBGTHREAD2_LIBS@ @LIBPQ_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_postgresql/run.c
===================================================================
--- upwatch/libdbi/uw_postgresql/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_postgresql/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -64,13 +64,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -78,11 +78,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -98,10 +98,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_postgresql_def.id, pr_postgresql_def.domid, pr_postgresql_def.tblid, pr_realm.name, "
@@ -114,22 +113,22 @@
                 "       and pr_postgresql_def.pgroup = '%d' and pr_realm.id = pr_postgresql_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -137,27 +136,30 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->dbname) g_free(probe->dbname);
-    probe->dbname = strdup(row[5]);
+    probe->dbname = dbi_result_get_string_copy(result, "dbname");
     if (probe->dbuser) g_free(probe->dbuser);
-    probe->dbuser = strdup(row[6]);
+    probe->dbuser = dbi_result_get_string_copy(result, "dbuser");
     if (probe->dbpasswd) g_free(probe->dbpasswd);
-    probe->dbpasswd = strdup(row[7]);
+    probe->dbpasswd = dbi_result_get_string_copy(result, "dbpasswd");
     if (probe->query) g_free(probe->query);
-    probe->query = strdup(row[8]);
-    probe->yellow = atof(row[9]);
-    probe->red = atof(row[10]);
+    probe->query = dbi_result_get_string_copy(result, "query");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void probe(gpointer data, gpointer user_data);
@@ -230,7 +232,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_postgresql/uw_postgresql.def
===================================================================
--- upwatch/libdbi/uw_postgresql/uw_postgresql.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_postgresql/uw_postgresql.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_postgresql can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql postgresql-libs glib2";
+spec-requires = "libdbi >= 0.8 postgresql-libs glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_postgresql`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_process/Makefile.am
===================================================================
--- upwatch/libdbi/uw_process/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -33,9 +33,9 @@
  ping.c httpget.c iptraf.c sysstat.c mysql.c mysqlstats.c bb_cpu.c bb.c pop3.c smtp.c tcpconnect.c \
 $(USE_LIBPQ) $(USE_LIBSNMP) $(USE_LIBTDS) imap.c errlog.c diskfree.c hwstat.c \
  uw_process.h uw_process_glob.h modules.inc $(SPECFILES) $(INITFILES)
-uw_process_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) \
+uw_process_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) \
   $(DEF_LIBPQ) $(DEF_LIBSNMP) $(DEF_LIBTDS) $(DEF_LIBESMTP) 
-uw_process_LDADD = uw_process_$(DB_O) uw_process_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @MYSQL_LIBS@ \
+uw_process_LDADD = uw_process_$(DB_O) uw_process_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ \
   @LIBESMTP_LIBS@ @LIBGLIB2_LIBS@ @LIBXML2_LIBS@ $(SOLARISLIBS)
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES) ../probes.enum

Modified: upwatch/libdbi/uw_process/bb_cpu.c
===================================================================
--- upwatch/libdbi/uw_process/bb_cpu.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/bb_cpu.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -32,31 +32,34 @@
 //*******************************************************************
 static gint bb_cpu_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct bb_cpu_result *res = (struct bb_cpu_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_bb_cpu_raw "
                     "set    probe = '%u', stattime = '%u', color = '%u', loadavg = '%f', "
                     "       user = '%u',  idle = '%u', free = '%u', used = '%u', message = '%s'",
                     def->probeid, res->stattime, res->color, res->loadavg,
                     res->user, res->idle, res->free, res->used, escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -67,8 +70,7 @@
 //*******************************************************************
 static void bb_cpu_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   float avg_yellow, avg_red;
   gfloat avg_loadavg;
@@ -79,56 +81,57 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(loadavg), avg(user), avg(system), avg(idle), "
-                    "       avg(swapped), avg(free), avg(buffered), avg(cached), "
-                    "       avg(used), max(color), avg(yellow), avg(red) " 
+  result = db_query(t->probe->db, 0,
+                    "select avg(loadavg) as avg_loadavg, avg(user) as avg_user, avg(system) as avg_system, "
+                    "       avg(idle) as avg_idle, avg(swapped) avg_swapped, avg(free) as avg_free, " 
+                    "       avg(buffered) as avg_buffered, avg(cached) as avg_cached, "
+                    "       avg(used) as avg_used, max(color) as max_color, "
+                    "       avg(yellow) as avg_yellow, avg(red) as avg_red " 
                     "from   pr_bb_cpu_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
   
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_loadavg") == NULL) {
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_loadavg = atof(row[0]);
-  avg_user    = atoi(row[1]);
-  avg_system  = atoi(row[2]);
-  avg_idle    = atoi(row[3]);
-  avg_swapped = atoi(row[4]);
-  avg_free    = atoi(row[5]);
-  avg_buffered= atoi(row[6]);
-  avg_cached  = atoi(row[7]);
-  avg_used    = atoi(row[8]);
-  max_color   = atoi(row[9]);
-  avg_yellow  = atof(row[10]);
-  avg_red     = atof(row[11]);
-  mysql_free_result(result);
+  avg_loadavg = dbi_result_get_float(result, "avg_loadavg");
+  avg_user    = dbi_result_get_uint(result, "avg_user");
+  avg_system  = dbi_result_get_uint(result, "avg_system");
+  avg_idle    = dbi_result_get_uint(result, "avg_idle");
+  avg_swapped = dbi_result_get_uint(result, "avg_swapped");
+  avg_free    = dbi_result_get_uint(result, "avg_free");
+  avg_buffered= dbi_result_get_uint(result, "avg_buffered");
+  avg_cached  = dbi_result_get_uint(result, "avg_cached");
+  avg_used    = dbi_result_get_uint(result, "avg_used");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_bb_cpu_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_bb_cpu_%s " 
                     "set    loadavg = '%f', user = '%u', system = '%u', idle = '%u', "
                     "       swapped = '%u', free = '%u', buffered = '%u', cached = '%u', "
@@ -139,7 +142,7 @@
                     avg_swapped, avg_free, avg_buffered, avg_cached, 
                     avg_used, def->probeid, max_color, stattime,
                     avg_yellow, avg_red, slot);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module bb_cpu_module  = {

Modified: upwatch/libdbi/uw_process/generic_ct.c
===================================================================
--- upwatch/libdbi/uw_process/generic_ct.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/generic_ct.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -19,22 +19,24 @@
 //*******************************************************************
 gint ct_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct ct_result *res = (struct ct_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
 
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_%s_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       connect = '%f', total = '%f', "
@@ -42,10 +44,11 @@
                     res->name, def->probeid, def->yellow, def->red, res->stattime, res->color, 
                     res->connect, res->total, escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -56,8 +59,7 @@
 //*******************************************************************
 void ct_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct ct_result *res = (struct ct_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   float avg_yellow, avg_red;
@@ -67,49 +69,48 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(connect), avg(total), "
-                    "       max(color), avg(yellow), avg(red) "
+  result = db_query(t->probe->db, 0,
+                    "select avg(connect) as avg_connect, avg(total) as avg_total, "
+                    "       max(color) as max_color, avg(yellow) as avg_yellow, avg(red) as avg_red "
                     "from   pr_%s_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     res->name, from, def->probeid, slotlow, slothigh);
 
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_connect") == NULL) {
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_connect = atof(row[0]);
-  avg_total = atof(row[1]);
-  max_color   = atoi(row[2]);
-  avg_yellow  = atof(row[3]);
-  avg_red     = atof(row[4]);
-  mysql_free_result(result);
+  avg_connect = dbi_result_get_float(result, "avg_connect");
+  avg_total = dbi_result_get_float(result, "avg_total");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_%s_%s where probe = '%u' and stattime = '%u'",
                     res->name, into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_%s_%s "
                     "set    connect = '%f', total = '%f', "
                     "       probe = %d, color = '%u', stattime = %d, "
@@ -117,6 +118,6 @@
                     res->name, into, avg_connect, avg_total, def->probeid, 
                     max_color, stattime, avg_yellow, avg_red, slot);
 
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 

Modified: upwatch/libdbi/uw_process/httpget.c
===================================================================
--- upwatch/libdbi/uw_process/httpget.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/httpget.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,21 +13,23 @@
 //*******************************************************************
 static gint httpget_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct httpget_result *res = (struct httpget_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_httpget_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       lookup = '%f', connect = '%f', pretransfer = '%f', total = '%f', "
@@ -35,10 +37,11 @@
                     def->probeid, def->yellow, def->red, res->stattime, res->color, 
                     res->lookup, res->connect, res->pretransfer, res->total, escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -49,8 +52,7 @@
 //*******************************************************************
 static void httpget_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   float avg_yellow, avg_red;
   float avg_lookup, avg_connect, avg_pretransfer, avg_total;
@@ -59,51 +61,51 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(lookup), avg(connect), avg(pretransfer), avg(total), "
-                    "       max(color), avg(yellow), avg(red) "
+  result = db_query(t->probe->db, 0,
+                    "select avg(lookup) as avg_lookup, avg(connect) as avg_connect, "
+                    "       avg(pretransfer) as avg_pretransfer, avg(total) as avg_total, "
+                    "       max(color) as max_color, avg(yellow) avg_yellow, avg(red) as avg_red "
                     "from   pr_httpget_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
 
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_lookup") == NULL) {
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_lookup = atof(row[0]);
-  avg_connect = atof(row[1]);
-  avg_pretransfer = atof(row[2]);
-  avg_total = atof(row[3]);
-  max_color   = atoi(row[4]);
-  avg_yellow  = atof(row[5]);
-  avg_red     = atof(row[6]);
-  mysql_free_result(result);
+  avg_lookup = dbi_result_get_float(result, "avg_lookup");
+  avg_connect = dbi_result_get_float(result, "avg_connect");
+  avg_pretransfer = dbi_result_get_float(result, "avg_pretransfer");
+  avg_total = dbi_result_get_float(result, "avg_total");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_httpget_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_httpget_%s "
                     "set    lookup = '%f', connect = '%f', pretransfer = '%f', total = '%f', "
                     "       probe = %d, color = '%u', stattime = %d, "
@@ -111,7 +113,7 @@
                     into, avg_lookup, avg_connect, avg_pretransfer, avg_total, def->probeid, 
                     max_color, stattime, avg_yellow, avg_red, slot);
 
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module httpget_module  = {

Modified: upwatch/libdbi/uw_process/hwstat.c
===================================================================
--- upwatch/libdbi/uw_process/hwstat.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/hwstat.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,21 +13,23 @@
 //*******************************************************************
 static gint hwstat_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct hwstat_result *res = (struct hwstat_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_hwstat_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       temp1 = '%f', temp2 = '%f', temp3 = '%f', "
@@ -42,10 +44,11 @@
                     res->v50p, res->v12p, res->v12n, res->v50n, 
                     escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -56,8 +59,7 @@
 //*******************************************************************
 static void hwstat_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   gfloat avg_yellow, avg_red;
   gfloat avg_temp1, avg_temp2, avg_temp3;
@@ -68,61 +70,61 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(temp1), avg(temp2), avg(temp3), "
-                    "       avg(rot1), avg(rot2), avg(rot3), "
-                    "       avg(vc0), avg(vc1), avg(v33), avg(v50p), "
-                    "       avg(v50n), avg(v50n), max(color), avg(yellow), avg(red) " 
+  result = db_query(t->probe->db, 0,
+                    "select avg(temp1) as avg_temp1, avg(temp2) as avg_temp2, avg(temp3) as avg_temp3, "
+                    "       avg(rot1) as avg_rot1, avg(rot2) as avg_rot2, avg(rot3) as avg_rot3, "
+                    "       avg(vc0) as avg_vc0, avg(vc1) as avg_vc1, avg(v33) as avg_v33, avg(v50p) as avg_v50p, "
+                    "       avg(v12p) as avg_v12p, avg(v12n) as avg_v12n, avg(v50n) as avg_v50n, "
+                    "       max(color) as max_color, avg(yellow) as avg_yellow, avg(red) as avg_red " 
                     "from   pr_hwstat_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
   
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_temp1") == NULL) {
     LOG(LOG_NOTICE, "NULL values found in summarizing from %s for probe %u %u %u", 
                       from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_temp1   = atof(row[0]);
-  avg_temp2   = atof(row[1]);
-  avg_temp3   = atof(row[2]);
-  avg_rot1    = atoi(row[3]);
-  avg_rot2    = atoi(row[4]);
-  avg_rot3    = atoi(row[5]);
-  avg_vc0     = atof(row[6]);
-  avg_vc1     = atof(row[7]);
-  avg_v33     = atof(row[8]);
-  avg_v50p    = atof(row[9]);
-  avg_v12p    = atof(row[10]);
-  avg_v12n    = atof(row[11]);
-  avg_v50n    = atof(row[12]);
-  max_color   = atoi(row[13]);
-  avg_yellow  = atof(row[14]);
-  avg_red     = atof(row[15]);
-  mysql_free_result(result);
+  avg_temp1   = dbi_result_get_float(result, "avg_temp1");
+  avg_temp2   = dbi_result_get_float(result, "avg_temp2");
+  avg_temp3   = dbi_result_get_float(result, "avg_temp3");
+  avg_rot1    = dbi_result_get_uint(result, "avg_rot1");
+  avg_rot2    = dbi_result_get_uint(result, "avg_rot2");
+  avg_rot3    = dbi_result_get_uint(result, "avg_rot3");
+  avg_vc0     = dbi_result_get_float(result, "avg_vc0");
+  avg_vc1     = dbi_result_get_float(result, "avg_vc1");
+  avg_v33     = dbi_result_get_float(result, "avg_v33");
+  avg_v50p    = dbi_result_get_float(result, "avg_v50p");
+  avg_v12p    = dbi_result_get_float(result, "avg_v12p");
+  avg_v12n    = dbi_result_get_float(result, "avg_v12n");
+  avg_v50n    = dbi_result_get_float(result, "avg_yellow");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_hwstat_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_hwstat_%s " 
                     "set    temp1 = '%f', temp2 = '%f', temp3 = '%f', "
                     "       rot1 = '%u', rot2 = '%u', rot3 = '%u', "
@@ -137,7 +139,7 @@
                     avg_v12p, avg_v12n, avg_v50n, 
                     def->probeid, max_color, stattime,
                     avg_yellow, avg_red, slot);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module hwstat_module  = {

Modified: upwatch/libdbi/uw_process/imap.c
===================================================================
--- upwatch/libdbi/uw_process/imap.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/imap.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -25,23 +25,30 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void imap_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void imap_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct imap_def *def = (struct imap_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress   = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->username = strdup(row[9]);
-    if (row[10]) def->password = strdup(row[10]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->username = dbi_result_get_string_copy_idx(result, 9);
+    def->password = dbi_result_get_string_copy_idx(result, 10);
   }
 }
 

Modified: upwatch/libdbi/uw_process/insertcache.c
===================================================================
--- upwatch/libdbi/uw_process/insertcache.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/insertcache.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -19,7 +19,7 @@
 {
   int i, len=0;
   char *sql, *start;
-  MYSQL_RES *result;
+  dbi_result result;
 
   if (probe->insertc->len == 0) return;
   for (i=0; i < probe->insertc->len; i++) {
@@ -35,8 +35,8 @@
   }
   g_ptr_array_free(probe->insertc, TRUE); 
   probe->insertc = g_ptr_array_new();
-  result = my_query(probe->db, 0, sql);
+  result = db_query(probe->db, 0, sql);
   free(sql);
-  if (result) mysql_free_result(result);
+  if (result) dbi_result_free(result);
   // note we ignore dupes/errors for the sake of speed.
 }

Modified: upwatch/libdbi/uw_process/iptraf.c
===================================================================
--- upwatch/libdbi/uw_process/iptraf.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/iptraf.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -59,13 +59,16 @@
   if (HAVE_OPT(MULTI_VALUE_INSERTS)) {
     mod_ic_add(t->probe, "pr_iptraf_raw", strdup(buf));
   } else {
-    MYSQL_RES *result;
+    dbi_result result;
+    const char *errmsg;
+    int lasterr;
 
-    result = my_query(t->probe->db, 0, "insert into pr_iptraf_raw values %s", buf);
-    if (result) mysql_free_result(result);
-    if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+    result = db_query(t->probe->db, 0, "insert into pr_iptraf_raw values %s", buf);
+    if (result) dbi_result_free(result);
+    lasterr = dbi_conn_error(t->probe->db, &errmsg);
+    if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
       t->seen_before = TRUE;
-    } else if (mysql_errno(t->probe->db)) {
+    } else if (lasterr > -1) { // otther error
       return 0; // other failure
     }
   }
@@ -77,8 +80,7 @@
 //*******************************************************************
 static void iptraf_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct iptraf_def *def = (struct iptraf_def *)t->def;
   struct iptraf_result *res = (struct iptraf_result *)t->res;
   float avg_yellow, avg_red;
@@ -100,55 +102,55 @@
     def->slotday_avg_yellow = def->yellow;
     def->slotday_avg_red = def->red;
   } else {
-    result = my_query(t->probe->db, 0,
-                      "select sum(incoming), sum(outgoing), max(color), avg(yellow), avg(red) "
+    result = db_query(t->probe->db, 0,
+                      "select sum(incoming) as incoming, sum(outgoing) as outgoing, "
+                      "       max(color) max_color, avg(yellow) as avg_yellow, avg(red) as avg_red "
                       "from   pr_iptraf_%s use index(probstat) "
                       "where  probe = '%u' and stattime >= '%u' and stattime < '%u'",
                       from, def->probeid, slotlow, slothigh);
 
     if (!result) return;
-    if (mysql_num_rows(result) == 0) { // no records found
+    if (dbi_result_get_numrows(result) == 0) { // no records found
       LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                          from, def->probeid, slotlow, slothigh);
-      mysql_free_result(result);
+      dbi_result_free(result);
       return;
     }
 
-    row = mysql_fetch_row(result);
-    if (!row) {
-      mysql_free_result(result);
+    if (!dbi_result_next_row(result)) {
+      dbi_result_free(result);
       return;
     }
-    if (row[0] == NULL) {
+    if (dbi_result_get_string(result, "incoming") == NULL) {
       LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-      mysql_free_result(result);
+      dbi_result_free(result);
       return;
     }
 
-    incoming    = atof(row[0]);
-    outgoing    = atof(row[1]);
-    max_color   = atoi(row[2]);
-    avg_yellow  = atof(row[3]);
-    avg_red     = atof(row[4]);
-    mysql_free_result(result);
+    incoming    = dbi_result_get_float(result, "incoming");
+    outgoing    = dbi_result_get_float(result, "outgoing");
+    max_color   = dbi_result_get_uint(result, "max_color");
+    avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+    avg_red     = dbi_result_get_float(result, "avg_red");
+    dbi_result_free(result);
   }
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_iptraf_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_iptraf_%s "
                     "set    incoming = '%f', outgoing = '%f', "
                     "       probe = '%u', color = '%u', stattime = '%u', "
                     "       yellow = '%f', red = '%f', slot = '%u'",
                     into, incoming, outgoing, def->probeid, max_color, stattime, 
                     avg_yellow, avg_red, slot);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module iptraf_module  = {

Modified: upwatch/libdbi/uw_process/mssql.c
===================================================================
--- upwatch/libdbi/uw_process/mssql.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/mssql.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -27,25 +27,32 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void mssql_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void mssql_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct mssql_def *def = (struct mssql_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->dbname = strdup(row[9]);
-    if (row[10]) def->dbuser = strdup(row[10]);
-    if (row[9]) def->dbpasswd = strdup(row[9]);
-    if (row[10]) def->query = strdup(row[10]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->dbname = dbi_result_get_string_copy_idx(result, 9);
+    def->dbuser = dbi_result_get_string_copy_idx(result, 10);
+    def->dbpasswd = dbi_result_get_string_copy_idx(result, 11);
+    def->query = dbi_result_get_string_copy_idx(result, 12);
   }
 }
 

Modified: upwatch/libdbi/uw_process/mysql.c
===================================================================
--- upwatch/libdbi/uw_process/mysql.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/mysql.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -27,25 +27,32 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void mysql_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void mysql_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct mysql_def *def = (struct mysql_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->dbname = strdup(row[9]);
-    if (row[10]) def->dbuser = strdup(row[10]);
-    if (row[11]) def->dbpasswd = strdup(row[11]);
-    if (row[12]) def->query = strdup(row[12]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->dbname = dbi_result_get_string_copy_idx(result, 9);
+    def->dbuser = dbi_result_get_string_copy_idx(result, 10);
+    def->dbpasswd = dbi_result_get_string_copy_idx(result, 11);
+    def->query = dbi_result_get_string_copy_idx(result, 12);
   }
 }
 

Modified: upwatch/libdbi/uw_process/mysqlstats.c
===================================================================
--- upwatch/libdbi/uw_process/mysqlstats.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/mysqlstats.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,21 +13,23 @@
 //*******************************************************************
 static gint mysqlstats_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct mysqlstats_result *res = (struct mysqlstats_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_mysqlstats_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       selectq = '%u', insertq = '%u', updateq = '%u', deleteq = '%u',` "
@@ -35,10 +37,11 @@
                     def->probeid, def->yellow, def->red, res->stattime, res->color, 
                     res->selectq, res->insertq, res->updateq, res->deleteq,escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -59,8 +62,7 @@
 //*******************************************************************
 static void mysqlstats_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   float avg_yellow, avg_red;
   int avg_selectq;
@@ -72,51 +74,52 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(selectq), avg(insertq), avg(updateq), avg(deleteq), "
-                    "       max(color), avg(yellow), avg(red) "
+  result = db_query(t->probe->db, 0,
+                    "select avg(selectq) as avg_selectq, avg(insertq) as avg_insertq, "
+                    "       avg(updateq) as avg_updateq, avg(deleteq) as avg_deleteq, "
+                    "       max(color) as max_color, "
+                    "       avg(yellow) as avg_yellow, avg(red) as avg_red "
                     "from   pr_mysqlstats_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
 
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_selectq") == NULL) {
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_selectq = atoi(row[0]);
-  avg_insertq = atoi(row[1]);
-  avg_updateq = atoi(row[2]);
-  avg_deleteq = atoi(row[3]);
-  max_color   = atoi(row[4]);
-  avg_yellow  = atof(row[5]);
-  avg_red     = atof(row[6]);
-  mysql_free_result(result);
+  avg_selectq = dbi_result_get_uint(result, "avg_selectq");
+  avg_insertq = dbi_result_get_uint(result, "avg_insertq");
+  avg_updateq = dbi_result_get_uint(result, "avg_updateq");
+  avg_deleteq = dbi_result_get_uint(result, "avg_deleteq");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_mysqlstats_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_mysqlstats_%s "
                     "set    selectq = '%u', insertq = '%u', updateq = '%u', deleteq = '%u', "
                     "       probe = %d, color = '%u', stattime = %d, "
@@ -124,7 +127,7 @@
                     into,  avg_selectq, avg_insertq, avg_updateq, avg_deleteq, def->probeid, 
                     max_color, stattime, avg_yellow, avg_red, slot);
 
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module mysqlstats_module  = {

Modified: upwatch/libdbi/uw_process/notify.c
===================================================================
--- upwatch/libdbi/uw_process/notify.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/notify.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -18,8 +18,7 @@
 int notify(trx *t)
 {
   int notified = FALSE;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   if (debug > 3) fprintf(stderr, "%s %u %s (was %s). %s\n", t->probe->module_name, t->def->probeid, 
                   color2string(t->res->color), color2string(t->res->prevhistcolor), t->res->hostname);
@@ -32,7 +31,7 @@
 
   // now go back to the last time the user received a warning, and
   // retrieve the color we had at that time
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select   color "
                     "from     pr_hist  "
                     "where    probe = '%u' and class = '%u' and stattime <= '%u' "
@@ -40,13 +39,12 @@
                     "order by stattime desc limit 1",
                     t->def->probeid, t->probe->class, t->res->stattime);
   if (!result) return(notified);
-  row = mysql_fetch_row(result);
-  if (row) {
-    t->res->prevhistcolor = atoi(row[0]);
+  if (dbi_result_next_row(result)) {
+    t->res->prevhistcolor = dbi_result_get_uint(result, "color");
   } else {
     t->res->prevhistcolor = 0;
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
 
   // if it's the same, we don't really need to warn right?
   if (t->res->prevhistcolor == t->res->color) {
@@ -93,7 +91,7 @@
   return *buf;
 }
 
-int mail(char *to, char *subject, char *body, time_t date)
+int mail(const char *to, const char *subject, const char *body, time_t date)
 {
   int notified = FALSE;
 

Modified: upwatch/libdbi/uw_process/ping.c
===================================================================
--- upwatch/libdbi/uw_process/ping.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/ping.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -11,22 +11,29 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void ping_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void ping_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct ping_def *def = (struct ping_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress   = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->count = atoi(row[9]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->count = dbi_result_get_uint_idx(result, 9);
   }
 }
 
@@ -35,31 +42,34 @@
 //*******************************************************************
 static gint ping_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct ping_result *res = (struct ping_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_ping_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       average = '%f', lowest = '%f', highest = '%f', message = '%s'",
                     def->probeid, def->yellow, def->red, res->stattime, res->color, 
                     res->average, res->lowest, res->highest, escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -77,6 +87,7 @@
                "%-20s: %s\n"
                "%-20s: %u\n"
                "%-20s: %f\n"
+               "%-20s: %f\n"
                "%-20s: %f\n",
   "IP Address", def->ipaddress,
   "Description", def->description,
@@ -91,8 +102,7 @@
 //*******************************************************************
 static void ping_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   float avg_yellow, avg_red;
   float avg_average, min_lowest, max_highest; 
@@ -101,56 +111,56 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(lowest), avg(average), avg(highest), "
-                    "       max(color), avg(yellow), avg(red) " 
+  result = db_query(t->probe->db, 0,
+                    "select avg(lowest) as avg_lowest, avg(average) asavg_average, "
+                    "       avg(highest) as avg_highest, max(color) as max_color, "
+                    "       avg(yellow) as avg_yellow, avg(red) as avg_red " 
                     "from   pr_ping_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
   
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_lowest") == NULL) {
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  min_lowest  = atof(row[0]);
-  avg_average = atof(row[1]);
-  max_highest = atof(row[2]);
-  max_color   = atoi(row[3]);
-  avg_yellow  = atof(row[4]);
-  avg_red     = atof(row[5]);
-  mysql_free_result(result);
+  min_lowest  = dbi_result_get_float(result, "min_lowest");
+  avg_average = dbi_result_get_float(result, "avg_average");
+  max_highest = dbi_result_get_float(result, "max_highest");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_ping_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_ping_%s " 
                     "set    average = %f, lowest = %f, highest = %f, probe = %d, color = '%u', " 
                     "       stattime = %d, yellow = '%f', red = '%f', slot = '%u'",
                     into, avg_average, min_lowest, max_highest, def->probeid, 
                     max_color, stattime, avg_yellow, avg_red, slot);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module ping_module  = {

Modified: upwatch/libdbi/uw_process/pop3.c
===================================================================
--- upwatch/libdbi/uw_process/pop3.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/pop3.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -25,23 +25,30 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void pop3_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void pop3_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct pop3_def *def = (struct pop3_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->username = strdup(row[9]);
-    if (row[8]) def->password = strdup(row[8]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->password = dbi_result_get_string_copy_idx(result, 8);
+    def->username = dbi_result_get_string_copy_idx(result, 9);
   }
 }
 

Modified: upwatch/libdbi/uw_process/postgresql.c
===================================================================
--- upwatch/libdbi/uw_process/postgresql.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/postgresql.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -27,25 +27,32 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void postgresql_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void postgresql_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct postgresql_def *def = (struct postgresql_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->dbname = strdup(row[9]);
-    if (row[10]) def->dbuser = strdup(row[10]);
-    if (row[9]) def->dbpasswd = strdup(row[9]);
-    if (row[10]) def->query = strdup(row[10]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->dbname = dbi_result_get_string_copy_idx(result, 9);
+    def->dbuser = dbi_result_get_string_copy_idx(result, 10);
+    def->dbpasswd = dbi_result_get_string_copy_idx(result, 11);
+    def->query = dbi_result_get_string_copy_idx(result, 12);
   }
 }
 

Modified: upwatch/libdbi/uw_process/process.c
===================================================================
--- upwatch/libdbi/uw_process/process.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/process.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -43,8 +43,7 @@
 //*******************************************************************
 static struct probe_result *get_previous_record(trx *t)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_result *prv;
 
   prv = g_malloc0(sizeof(struct probe_result));
@@ -56,19 +55,18 @@
 
   if (!t->probe->store_results) return(prv); // we probably don't have a xxxx_raw table
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select   color, stattime "
                     "from     pr_%s_raw use index(probstat) "
                     "where    probe = '%u' and stattime < '%u' "
                     "order by stattime desc limit 1", 
                     t->res->name, t->def->probeid, t->res->stattime);
   if (!result) return(prv);
-  row = mysql_fetch_row(result);
-  if (row) {
-    prv->color = atoi(row[0]);
-    prv->stattime = atoi(row[1]);
+  if (dbi_result_next_row(result)) {
+    prv->color = dbi_result_get_uint(result, "color");
+    prv->stattime = dbi_result_get_uint(result, "stattime");
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
   t->res->prevcolor = prv->color;
   return(prv);
 }
@@ -90,28 +88,25 @@
 //*******************************************************************
 static struct probe_result *get_following_record(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct probe_result *nxt = NULL;
 
   if (!t->probe->store_results) return(NULL); // we probably don't have a xxxx_raw table
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select   color, stattime "
                     "from     pr_%s_raw use index(probstat) "
                     "where    probe = '%u' and stattime > '%u' "
                     "order by stattime asc limit 1", 
                     t->res->name, t->def->probeid, t->res->stattime);
   if (result) {
-    MYSQL_ROW row;
-
-    row = mysql_fetch_row(result);
-    if (row) {
+    if (dbi_result_next_row(result)) {
       nxt = g_malloc0(sizeof(struct probe_result));
 
-      nxt->color = atoi(row[0]);
-      nxt->stattime = atoi(row[1]);
+      nxt->color = dbi_result_get_uint(result, "color");
+      nxt->stattime = dbi_result_get_uint(result, "stattime");
     }
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
   return(nxt);
 }
@@ -119,9 +114,9 @@
 //*******************************************************************
 // UPDATE PR_STATUS
 //*******************************************************************
-static void update_pr_status(trx *t, struct probe_result *prv)
+static dbi_result update_pr_status(trx *t, struct probe_result *prv)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   char *qry;
 
   qry = g_malloc(512 + (t->res->message ? strlen(t->res->message)*2 : 0));
@@ -145,8 +140,8 @@
   if (t->res->message) {
     char *escmsg;
 
-    escmsg = g_malloc(strlen(t->res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, t->res->message, strlen(t->res->message));
+    escmsg = strdup(t->res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
 
     if (t->res->color != prv->color) {
       sprintf(&qry[strlen(qry)], ", message = '%s'", escmsg);
@@ -157,9 +152,9 @@
   }
 
   sprintf(&qry[strlen(qry)], " where probe = '%u' and class = '%u'", t->def->probeid, t->probe->class);
-  result = my_rawquery(t->probe->db, 0, qry);
-  mysql_free_result(result);
+  result = db_rawquery(t->probe->db, 0, qry);
   g_free(qry);
+  return(result);
 }
 
 //*******************************************************************
@@ -167,24 +162,24 @@
 //*******************************************************************
 static void insert_pr_status(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   char *escmsg;
 
   if (t->res->message) {
-    escmsg = g_malloc(strlen(t->res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, t->res->message, strlen(t->res->message)) ;
+    escmsg = strdup(t->res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_status "
                     "set    class =  '%u', probe = '%u', stattime = '%u', expires = '%u', "
                     "       color = '%u', server = '%u', message = '%s', "
                     "       contact = '%u', hide = '%s'",
                     t->probe->class, t->def->probeid, t->res->stattime, t->res->expires, 
                     t->def->color, t->def->server, escmsg, t->def->contact, t->def->hide);
-  mysql_free_result(result);
+  dbi_result_free(result);
   g_free(escmsg);
 }
 
@@ -193,17 +188,17 @@
 //*******************************************************************
 static void create_pr_hist(trx *t, struct probe_result *prv)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   char *escmsg;
 
   if (t->res->message) {
-    escmsg = g_malloc(strlen(t->res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, t->res->message, strlen(t->res->message)) ;
+    escmsg = strdup(t->res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_hist "
                     "set    server = '%u', class = '%u', probe = '%u', stattime = '%u', "
                     "       prv_color = '%d', color = '%d', message = '%s', contact = '%u', "
@@ -211,7 +206,7 @@
                     t->def->server, t->probe->class, t->def->probeid, t->res->stattime,
                     /* (t->res->received > t->res->expires) ? STAT_PURPLE : */ prv->color, 
                     t->res->color, escmsg, t->def->contact, t->def->hide, t->def->pgroup);
-  mysql_free_result(result);
+  dbi_result_free(result);
   g_free(escmsg);
 }
 
@@ -220,18 +215,18 @@
 //*******************************************************************
 static void delete_history(trx *t, struct probe_result *nxt)
 {
-  MYSQL_RES *result;
+  dbi_result result;
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "delete from pr_hist "
                     "where stattime = '%u' and probe = '%u' and class = '%d'",
                     nxt->stattime, t->def->probeid, t->probe->class);
-  mysql_free_result(result);
-  result = my_query(t->probe->db, 0,
+  dbi_result_free(result);
+  result = db_query(t->probe->db, 0,
                     "delete from pr_status "
                     "where stattime = '%u' and probe = '%u' and class = '%d'",
                     nxt->stattime, t->def->probeid, t->probe->class);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 //*******************************************************************
@@ -239,7 +234,7 @@
 //*******************************************************************
 static void update_server_color(trx *t, struct probe_result *prv)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   int maxcolor, newcolor;
 
   if (t->def->server < 2) return;
@@ -252,24 +247,20 @@
   }
   maxcolor = newcolor; // init
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select max(color) as color from pr_status where server = '%u'", t->def->server);
-  if (result) {
-    MYSQL_ROW row;
-    row = mysql_fetch_row(result);
-    if (row && row[0]) {
-      maxcolor = atoi(row[0]);
-    }
+  if (result && dbi_result_next_row(result)) {
+    maxcolor = dbi_result_get_uint(result, "color");
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
   //if (t->res->color <= maxcolor) return;
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     // update server set color = '200' where id = '345'
                     "update %s set %s = '%u' where %s = '%u'",
                      OPT_ARG(SERVER_TABLE_NAME), OPT_ARG(SERVER_TABLE_COLOR_FIELD), 
                      maxcolor, OPT_ARG(SERVER_TABLE_ID_FIELD), t->def->server);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 //*******************************************************************
@@ -277,26 +268,24 @@
 //*******************************************************************
 void get_previous_pr_hist(trx *t)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   t->res->changed = 0;
   strcpy(t->res->notified, "yes"); // if we cannot find pr_hist record, assume the user has already been warned
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "select   id, stattime, notified, prv_color "
                     "from     pr_hist  "
                     "where    probe = '%u' and class = '%u' and stattime <= '%u' "
                     "order by stattime desc limit 1",
                     t->def->probeid, t->probe->class, t->res->stattime);
   if (!result) return;
-  row = mysql_fetch_row(result);
-  if (row) {
-    t->res->prevhistid = atoll(row[0]);
-    t->res->changed = atoi(row[1]);
-    strcpy(t->res->notified, row[2]);
-    t->res->prevhistcolor = atoi(row[3]);
+  if (dbi_result_next_row(result)) {
+    t->res->prevhistid = dbi_result_get_longlong(t->probe->db, "id");
+    t->res->changed = dbi_result_get_uint(t->probe->db, "stattime");
+    strcpy(t->res->notified, dbi_result_get_string(t->probe->db, "notified"));
+    t->res->prevhistcolor = dbi_result_get_uint(t->probe->db, "prv_color");
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
   return;
 }
 
@@ -305,12 +294,12 @@
 //*******************************************************************
 void set_pr_hist_notified(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "update pr_hist set notified = 'yes' "
                     "where  id = '%ull'", t->res->prevhistid);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 //*******************************************************************
@@ -318,8 +307,7 @@
 //*******************************************************************
 int slot_is_complete(trx *t, int i, guint slotlow, guint slothigh)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   int val = FALSE;
 
   /* 
@@ -327,18 +315,17 @@
    * so we fake it is filled, so it'll always be summarized
    */
   if (i == 0) return 1;
-  result = my_query(t->probe->db, 0,
-                    "select count(*) from pr_%s_%s use index(probstat) "
+  result = db_query(t->probe->db, 0,
+                    "select count(*) as count from pr_%s_%s use index(probstat) "
                     "where  probe = '%u' and stattime >= '%u' and stattime <= '%u'",
                     t->res->name, summ_info[i].from, t->def->probeid, slotlow, slothigh);
   if (!result) return(FALSE);
-  row = mysql_fetch_row(result);
-  if (row && row[0]) {
-    if (atoi(row[0]) >= summ_info[i].perslot) {
+  if (dbi_result_next_row(result)) {
+    if (dbi_result_get_uint(result, "count") >= summ_info[i].perslot) {
       val = TRUE;
     }
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
   return(val);
 }
 
@@ -496,11 +483,14 @@
       create_pr_hist(t, prv); // CREATE PR_HIST
     }
     if (t->res->stattime > t->def->newest) { // IF THIS RAW RECORD IS THE MOST RECENT EVER RECEIVED
+      dbi_result result;
+
       if (debug > 3) fprintf(stderr, "THIS RAW RECORD IS THE MOST RECENT EVER RECEIVED - UPDATE PR_STATUS\n");
-      update_pr_status(t, prv);    // UPDATE PR_STATUS
-      if (mysql_affected_rows(t->probe->db) == 0) { // nothing was actually updated, need to insert new
+      result = update_pr_status(t, prv);    // UPDATE PR_STATUS
+      if (dbi_result_get_numrows_affected(result) == 0) { // nothing was actually updated, need to insert new
         insert_pr_status(t); 
       }
+      dbi_result_free(result);
       if (debug > 3) fprintf(stderr, "UPDATE SERVER COLOR\n");
       update_server_color(t, prv); // UPDATE SERVER COLOR
       must_update_def = TRUE;
@@ -519,11 +509,14 @@
   } else {
     if (debug > 3) fprintf(stderr, "COLOR SAME AS PRECEDING RAW RECORD\n");
     if (t->res->stattime > t->def->newest) { // IF THIS RAW RECORD IS THE MOST RECENT EVER RECEIVED
+      dbi_result result;
+
       if (debug > 3) fprintf(stderr, "THIS RAW RECORD IS THE MOST RECENT EVER RECEIVED - UPDATE PR_STATUS\n");
-      update_pr_status(t, prv);  // UPDATE PR_STATUS (not for the color, but for the expiry time)
-      if (mysql_affected_rows(t->probe->db) == 0) { // nothing was actually updated, need to insert new
+      result = update_pr_status(t, prv);  // UPDATE PR_STATUS (not for the color, but for the expiry time)
+      if (dbi_result_get_numrows_affected(result) == 0) { // nothing was actually updated, need to insert new
         insert_pr_status(t); 
       }
+      dbi_result_free(result);
       must_update_def = TRUE;
     }
   }

Modified: upwatch/libdbi/uw_process/run.c
===================================================================
--- upwatch/libdbi/uw_process/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -30,15 +30,15 @@
 
 void update_last_seen(module *probe)
 {
-  MYSQL_RES *result;
+  dbi_result result;
 
-  result = my_query(probe->db, 0,
+  result = db_query(probe->db, 0,
                     "update probe set lastseen = %u where id = '%u'",
                     probe->lastseen, probe->class);
-  if (result) mysql_free_result(result);
+  if (result) dbi_result_free(result);
 }
 
-int realm_exists(char *realm)
+int realm_exists(const char *realm)
 {
   int i;
 
@@ -57,7 +57,7 @@
   return FALSE;
 }
 
-MYSQL *open_realm(char *realm)
+dbi_conn open_realm(const char *realm)
 {
   int i;
 
@@ -66,29 +66,28 @@
     return NULL;
   }
   if (realm == NULL || realm[0] == 0) {
-    if (dblist[0].mysql) return(dblist[0].mysql);
-    dblist[0].mysql = open_database(dblist[0].host, dblist[0].port, 
+    if (dblist[0].conn) return(dblist[0].conn);
+    dblist[0].conn = open_database(OPT_ARG(DBTYPE), dblist[0].host, dblist[0].port, 
                       dblist[0].db, dblist[0].user, dblist[0].password);
-    return(dblist[0].mysql);
+    return(dblist[0].conn);
   }
 
   for (i=0; i < dblist_cnt; i++) {
     if (strcmp(dblist[i].realm, realm) == 0) {
-      if (dblist[i].mysql) return(dblist[i].mysql);
-      dblist[i].mysql = open_database(dblist[i].host, dblist[i].port, 
+      if (dblist[i].conn) return(dblist[i].conn);
+      dblist[i].conn = open_database(OPT_ARG(DBTYPE), dblist[i].host, dblist[i].port, 
                         dblist[i].db, dblist[i].user, dblist[i].password);
-      return(dblist[i].mysql);
+      return(dblist[i].conn);
     }
   }
   LOG(LOG_ERR, "could not find realm %s", realm);
   return(NULL);
 }
 
-int realm_server_by_name(char *realm, char *name)
+int realm_server_by_name(const char *realm, const char *name)
 {
   int i, id = -1;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   if (!dblist) {
     LOG(LOG_ERR, "realm_server_by_name but no dblist found");
@@ -105,19 +104,19 @@
   }
   if (i == dblist_cnt) return id;
   if (!dblist[i].db) return id;
-  result = my_query(dblist[i].mysql, 0, dblist[i].srvrbyname, name, name, name, name, name);
+  result = db_query(dblist[i].conn, 0, dblist[i].srvrbyname, name, name, name, name, name);
   if (!result) return id;
-  row = mysql_fetch_row(result);
-  if (row) id = atoi(row[0]);
-  mysql_free_result(result);
+  if (dbi_result_next_row(result)) {
+    id = dbi_result_get_uint(result, "id");
+  }
+  dbi_result_free(result);
   return(id);
 }
 
-int realm_server_by_ip(char *realm, char *ip)
+int realm_server_by_ip(const char *realm, char *ip)
 {
   int i, id = -1;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   if (!dblist) {
     LOG(LOG_ERR, "realm_server_by_name but no dblist found");
@@ -134,20 +133,20 @@
   }
   if (i == dblist_cnt) return id;
   if (!dblist[i].db) return id;
-  result = my_query(dblist[i].mysql, 0, dblist[i].srvrbyip, ip, ip, ip, ip, ip);
+  result = db_query(dblist[i].conn, 0, dblist[i].srvrbyip, ip, ip, ip, ip, ip);
   if (!result) return id;
-  row = mysql_fetch_row(result);
-  if (row) id = atoi(row[0]);
-  mysql_free_result(result);
+  if (dbi_result_next_row(result)) {
+    id = dbi_result_get_uint(result, "id");
+  }
+  dbi_result_free(result);
   return(id);
 }
 
-char *realm_server_by_id(char *realm, int id)
+char *realm_server_by_id(const char *realm, int id)
 {
   int i;
   char *name = NULL;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
 
   if (!dblist) {
     LOG(LOG_ERR, "realm_server_by_name but no dblist found");
@@ -164,11 +163,12 @@
   }
   if (i == dblist_cnt) return name;
   if (!dblist[i].db) return name;
-  result = my_query(dblist[i].mysql, 0, dblist[i].srvrbyid, id, id, id, id, id);
+  result = db_query(dblist[i].conn, 0, dblist[i].srvrbyid, id, id, id, id, id);
   if (!result) return name;
-  row = mysql_fetch_row(result);
-  if (row) name = strdup(row[0]);
-  mysql_free_result(result);
+  if (dbi_result_next_row(result)) {
+    id = dbi_result_get_uint(result, "id");
+  }
+  dbi_result_free(result);
   return(name);
 }
 
@@ -182,17 +182,18 @@
   buf[0] = 0;
 
   for (i=0; i < dblist_cnt; i++) {
-    if (dblist[i].realm) free(dblist[i].realm);
-    if (dblist[i].host) free(dblist[i].host);
-    if (dblist[i].db) free(dblist[i].db);
-    if (dblist[i].user) free(dblist[i].user);
-    if (dblist[i].password) free(dblist[i].password);
-    if (dblist[i].srvrbyname) free(dblist[i].srvrbyname);
-    if (dblist[i].srvrbyid) free(dblist[i].srvrbyid);
-    if (dblist[i].srvrbyip) free(dblist[i].srvrbyip);
+    if (dblist[i].realm) free((void *)dblist[i].realm);
+    if (dblist[i].host) free((void *)dblist[i].host);
+    if (dblist[i].port) free((void *)dblist[i].port);
+    if (dblist[i].db) free((void *)dblist[i].db);
+    if (dblist[i].user) free((void *)dblist[i].user);
+    if (dblist[i].password) free((void *)dblist[i].password);
+    if (dblist[i].srvrbyname) free((void *)dblist[i].srvrbyname);
+    if (dblist[i].srvrbyid) free((void *)dblist[i].srvrbyid);
+    if (dblist[i].srvrbyip) free((void *)dblist[i].srvrbyip);
 
-    if (dblist[i].mysql) {
-      close_database(dblist[i].mysql);
+    if (dblist[i].conn) {
+      close_database(dblist[i].conn);
     }
   }
   free(dblist);
@@ -241,61 +242,58 @@
 static void modules_start_run(void)
 {
   int i;
-  MYSQL *db;
+  dbi_conn db;
 
-  db = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+  db = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                      OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
   if (db) {
-    MYSQL_RES *result;
+    dbi_result result;
     dblist = calloc(100, sizeof(struct dbspec));
     dblist_cnt = 0;
     
-    result = my_query(db, 0, "select pr_realm.name, pr_realm.host, "
+    result = db_query(db, 0, "select pr_realm.name, pr_realm.host, "
                              "       pr_realm.port, pr_realm.db, pr_realm.user, "
                              "       pr_realm.password, pr_realm.srvrbyname, "
                              "       pr_realm.srvrbyid, pr_realm.srvrbyip "
                              "from   pr_realm "
                              "where  pr_realm.id > 1");
     if (result) {
-      MYSQL_ROW row;
-      while ((row = mysql_fetch_row(result)) != NULL) {
-        dblist[dblist_cnt].realm = strdup(row[0]);
-        dblist[dblist_cnt].host = strdup(row[1]);
-        dblist[dblist_cnt].port = atoi(row[2]);
-        dblist[dblist_cnt].db = strdup(row[3]);
-        dblist[dblist_cnt].user = strdup(row[4]);
-        dblist[dblist_cnt].password = strdup(row[5]);
-        dblist[dblist_cnt].srvrbyname = strdup(row[6]);
-        dblist[dblist_cnt].srvrbyid = strdup(row[7]);
-        dblist[dblist_cnt].srvrbyip = strdup(row[8]);
+      while (dbi_result_next_row(result)) {
+        dblist[dblist_cnt].realm = dbi_result_get_string_copy(result, "name");
+        dblist[dblist_cnt].host = dbi_result_get_string_copy(result, "host");
+        dblist[dblist_cnt].port = dbi_result_get_string_copy(result, "port");
+        dblist[dblist_cnt].db = dbi_result_get_string_copy(result, "db");
+        dblist[dblist_cnt].user = dbi_result_get_string_copy(result, "user");
+        dblist[dblist_cnt].password = dbi_result_get_string_copy(result, "password");
+        dblist[dblist_cnt].srvrbyname = dbi_result_get_string_copy(result, "srvrbyname");
+        dblist[dblist_cnt].srvrbyid = dbi_result_get_string_copy(result, "srvrbyid");
+        dblist[dblist_cnt].srvrbyip = dbi_result_get_string_copy(result, "srvrbyip");
         dblist_cnt++;
       }
-      mysql_free_result(result);
+      dbi_result_free(result);
     }
     close_database(db);
   }
 
   for (i = 0; modules[i]; i++) {
-    MYSQL_RES *result;
+    dbi_result result;
 
     modules[i]->filecount = 0;
     modules[i]->resultcount = 0;
     modules[i]->errors = 0;
 
-    modules[i]->db = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+    modules[i]->db = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                                    OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
     if (modules[i]->db) {
-      result = my_query(modules[i]->db, 0, "select fuse, lastseen from probe where id = '%d'", modules[i]->class);
+      result = db_query(modules[i]->db, 0, "select fuse, lastseen from probe where id = '%d'", modules[i]->class);
       if (result) {
-        MYSQL_ROW row;
-        row = mysql_fetch_row(result);
-        if (row) {
-          if (row[0]) modules[i]->fuse  = (strcmp(row[0], "yes") == 0) ? 1 : 0;
-          if (row[1]) modules[i]->lastseen = atoi(row[1]);
+        if (dbi_result_next_row(result)) {
+          modules[i]->fuse  = (strcmp(dbi_result_get_string(result, "fuse"), "yes") == 0) ? 1 : 0;
+          modules[i]->lastseen = dbi_result_get_uint(result, "lastseen");
         } else {
           LOG(LOG_NOTICE, "probe record for id %u not found", modules[i]->class);
         }
-        mysql_free_result(result);
+        dbi_result_free(result);
       }
       close_database(modules[i]->db);
       modules[i]->db = NULL;
@@ -395,7 +393,7 @@
   if (HAVE_OPT(TRUST)) {
     int i, found=0;
     int     ct  = STACKCT_OPT( TRUST );
-    char**  pn = STACKLST_OPT( TRUST );
+    const char**  pn = STACKLST_OPT( TRUST );
 
     while (ct--) {
       for (i=0; modules[i]; i++) {
@@ -458,7 +456,7 @@
 {
   int trust;
   int     ct  = STACKCT_OPT( TRUST );
-  char**  pn = STACKLST_OPT( TRUST );
+  const char**  pn = STACKLST_OPT( TRUST );
 
   for (trust=0; trust < ct; trust++) {
     if (strcmp(pn[trust], "all") == 0) {
@@ -526,7 +524,7 @@
     trx t;
     int j;
     int output_ct = STACKCT_OPT(OUTPUT);
-    char **output_pn = STACKLST_OPT(OUTPUT);
+    const char **output_pn = STACKLST_OPT(OUTPUT);
     char *filebase;
 
     filebase = strrchr((char *)g_ptr_array_index(arr,i), '/');
@@ -589,7 +587,7 @@
 {
   int i;
   int     ct  = STACKCT_OPT( INPUT );
-  char**  pn = STACKLST_OPT( INPUT );
+  const char**  pn = STACKLST_OPT( INPUT );
 
   childpidcnt = ct;
   if (debug > 2) fprintf(stderr, "pondering..\n");
@@ -617,22 +615,19 @@
   } 
 
   for (i = 0; modules[i]; i++) {
-    modules[i]->db = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+    modules[i]->db = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                                    OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
     if (modules[i]->db) {
-      MYSQL_RES *result;
+      dbi_result result;
 
-      result = my_query(modules[i]->db, 0, "select lastseen, maxlag, lagwarn from probe where id = '%u'", 
+      result = db_query(modules[i]->db, 0, "select lastseen, maxlag, lagwarn from probe where id = '%u'", 
                                            modules[i]->class);
       if (result) {
-        MYSQL_ROW row;
-
-        row = mysql_fetch_row(result);
-        if (row && row[0]) {
+        if (dbi_result_next_row(result)) {
           unsigned now;
-          int lastseen = atoi(row[0]);
-          int maxlag = atoi(row[1]);
-          int lagwarn = strcmp(row[2], "yes") == 0;
+          int lastseen = dbi_result_get_uint(result, "lastseen");
+          int maxlag = dbi_result_get_uint(result, "maxlag");
+          int lagwarn = strcmp(dbi_result_get_string(result, "lagwarn"), "yes") == 0;
 
           now = (int) time(NULL);
           if ((now - lastseen) > maxlag) {
@@ -641,7 +636,7 @@
 
               sprintf(subject, "UPWATCH: probe %s is lagging in processing", modules[i]->module_name);
               mail(OPT_ARG(NOC_MAIL), subject, subject, (time_t)NULL);
-              my_query(modules[i]->db, 0, "update probe set lagwarn = 'yes' where id = '%u'",
+              db_query(modules[i]->db, 0, "update probe set lagwarn = 'yes' where id = '%u'",
                                            modules[i]->class);
             }
           } else {
@@ -650,14 +645,14 @@
 
               sprintf(subject, "UPWATCH: probe %s is up-to-date again", modules[i]->module_name);
               mail(OPT_ARG(NOC_MAIL), subject, subject, (time_t)NULL);
-              my_query(modules[i]->db, 0, "update probe set lagwarn = 'no' where id = '%u'",
+              db_query(modules[i]->db, 0, "update probe set lagwarn = 'no' where id = '%u'",
                                            modules[i]->class);
             }
           }
         } else {
           LOG(LOG_NOTICE, "probe record for id %u not found", modules[i]->class);
         }
-        mysql_free_result(result);
+        dbi_result_free(result);
       }
       close_database(modules[i]->db);
       modules[i]->db = NULL;
@@ -696,14 +691,13 @@
   trx t;
   struct probe_result res;
   struct probe_def def;
-  MYSQL *mysql;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_conn conn;
+  dbi_result result;
 extern int forever;
   guint lowtime, hightime; 
   char *p;
 
-  res.name = strtok(OPT_ARG(SUMMARIZE), ",");
+  res.name = strtok((char *)OPT_ARG(SUMMARIZE), ",");
   lowtime = 0;
   hightime = time(NULL);
   p = strtok(NULL, ",");
@@ -739,34 +733,33 @@
     return 0;
   }
 
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (!mysql) {
+  if (!conn) {
     return 0;
   }
   modules_start_run();
   found = 0;
-  result = my_query(mysql, 1, "select id, server from pr_%s_def where id > 1", res.name);
+  result = db_query(conn, 1, "select id, server from pr_%s_def where id > 1", res.name);
   if (result == NULL) return(0);
-  while ((row = mysql_fetch_row(result)) && forever) {
-    MYSQL_RES *presult;
-    MYSQL_ROW prow;
+  while (dbi_result_next_row(result) && forever) {
+    dbi_result presult;
 
-    def.probeid = atoi(row[0]);
-    def.server = atoi(row[1]);
+    def.probeid = dbi_result_get_uint(result, "id");
+    def.server = dbi_result_get_uint(result, "server");
     //printf("%u server %u\n", def.probeid, def.server);
 
-    presult = my_query(mysql, 1, "select stattime from pr_%s_raw where probe = '%u' "
+    presult = db_query(conn, 1, "select stattime from pr_%s_raw where probe = '%u' "
                                  "and stattime >= '%u' and stattime <= '%u'", 
                                  res.name, def.probeid, lowtime, hightime);
     if (presult == NULL) continue;
-    while ((prow = mysql_fetch_row(presult)) && forever) {
+    while (dbi_result_next_row(presult) && forever) {
       guint cur_slot, prev_slot;
       gulong dummy_low, dummy_high;
       gulong slotlow, slothigh;
       int i;
 
-      res.stattime = atoi(prow[0]);
+      res.stattime  = dbi_result_get_uint(presult, "stattime");
       if (def.newest == 0) def.newest = res.stattime;
       found++;
 
@@ -788,12 +781,12 @@
         if (debug > 2) { fprintf(stderr, "%8u records processed\r", found); }
       }
     }
-    mysql_free_result(presult);
+    dbi_result_free(presult);
 
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
   modules_end_run();
-  close_database(mysql);
+  close_database(conn);
   return(found);
 }
 

Modified: upwatch/libdbi/uw_process/snmpget.c
===================================================================
--- upwatch/libdbi/uw_process/snmpget.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/snmpget.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -27,27 +27,38 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void snmpget_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void snmpget_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct snmpget_def *def = (struct snmpget_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->community = strdup(row[9]);  /* community string for SNMPv1/v2c transactions */
-    if (row[10]) def->OID = strdup(row[10]);      /* Object ID */
-    if (row[11]) def->dispname = strdup(row[11]); /* Display Name */
-    if (row[12]) def->dispunit = strdup(row[12]); /* Display Unit */
-    if (row[13]) def->multiplier = atof(row[13]); /* Multiplier for result values */
-    if (row[14]) strcpy(def->mode, row[14]);      /* plot absolute or relative values */
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->community = dbi_result_get_string_copy_idx(result, 9); /* community string for SNMPv1/v2c transactions */
+    def->OID = dbi_result_get_string_copy_idx(result, 10);      /* Object ID */
+    def->dispname = dbi_result_get_string_copy_idx(result, 11); /* Display Name */
+    def->dispunit = dbi_result_get_string_copy_idx(result, 12); /* Display Unit */
+    def->multiplier = dbi_result_get_float_idx(result, 13);     /* Multiplier for result values */
+    if (dbi_result_get_string_idx(result, 14)) {
+      strcpy(def->mode, dbi_result_get_string_idx(result, 14)); /* plot absolute or relative values */
+    } else {
+      strcpy(def->mode, "");
+    }
   }
 }
 
@@ -56,21 +67,23 @@
 //*******************************************************************
 static gint snmpget_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct snmpget_result *res = (struct snmpget_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_snmpget_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       value = '%f', "
@@ -78,10 +91,11 @@
                     def->probeid, def->yellow, def->red, res->stattime, res->color, 
                     res->value, escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
+  } else if (lasterr > -1) { // otther error
     return 0; // other failure
   }
   return 1; // success
@@ -129,8 +143,7 @@
 //*******************************************************************
 static void snmpget_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   float avg_yellow, avg_red;
   float avg_value;
@@ -139,48 +152,47 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(value), "
-                    "       max(color), avg(yellow), avg(red) "
+  result = db_query(t->probe->db, 0,
+                    "select avg(value) as avg_value, "
+                    "       max(color) as max_color, avg(yellow) as avg_yellow, avg(red) as avg_red "
                     "from   pr_snmpget_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
 
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u",
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_value") == NULL) {
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_value = atof(row[0]);
-  max_color   = atoi(row[1]);
-  avg_yellow  = atof(row[2]);
-  avg_red     = atof(row[3]);
-  mysql_free_result(result);
+  avg_value   = dbi_result_get_float(result, "avg_value");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_snmpget_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_snmpget_%s "
                     "set    value = '%f', "
                     "       probe = %d, color = '%u', stattime = %d, "
@@ -188,7 +200,7 @@
                     into, avg_value, def->probeid, 
                     max_color, stattime, avg_yellow, avg_red, slot);
 
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module snmpget_module  = {

Modified: upwatch/libdbi/uw_process/sysstat.c
===================================================================
--- upwatch/libdbi/uw_process/sysstat.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/sysstat.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,21 +13,23 @@
 //*******************************************************************
 static gint sysstat_store_raw_result(trx *t)
 {
-  MYSQL_RES *result;
+  dbi_result result;
   struct sysstat_result *res = (struct sysstat_result *)t->res;
   struct probe_def *def = (struct probe_def *)t->def;
   char *escmsg;
+  const char *errmsg;
+  int lasterr;
 
   if (t->res->color == STAT_PURPLE) return 1;
   t->seen_before = FALSE;
   if (res->message) {
-    escmsg = g_malloc(strlen(res->message) * 2 + 1);
-    mysql_real_escape_string(t->probe->db, escmsg, res->message, strlen(res->message)) ;
+    escmsg = strdup(res->message);
+    dbi_conn_quote_string(t->probe->db, &escmsg);
   } else {
     escmsg = strdup("");
   }
     
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_sysstat_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
                     "       loadavg = '%f', user = '%u', system = '%u', idle = '%u', "
@@ -40,11 +42,12 @@
                     res->swapped, res->free, res->buffered, res->cached,
                     res->used, res->systemp, escmsg);
   g_free(escmsg);
-  if (result) mysql_free_result(result);
-  if (mysql_errno(t->probe->db) == ER_DUP_ENTRY) {
+  if (result) dbi_result_free(result);
+  lasterr = dbi_conn_error(t->probe->db, &errmsg);
+  if (errmsg && (lasterr == 1062)) { // MySQL ER_DUP_ENTRY(1062)
     t->seen_before = TRUE;
-  } else if (mysql_errno(t->probe->db)) {
-    LOG(LOG_WARNING, "%s:[%u] %s", "insert into pr_sysstat_raw", mysql_errno(t->probe->db), mysql_error(t->probe->db));
+  } else if (lasterr > -1) { // other error
+    LOG(LOG_WARNING, "%s: %s", "insert into pr_sysstat_raw", errmsg);
     return 0; // other failure
   }
   return 1; // success
@@ -55,8 +58,7 @@
 //*******************************************************************
 static void sysstat_summarize(trx *t, char *from, char *into, guint slot, guint slotlow, guint slothigh, gint resummarize)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct probe_def *def = (struct probe_def *)t->def;
   gfloat avg_yellow, avg_red;
   gfloat avg_loadavg;
@@ -68,62 +70,64 @@
 
   stattime = slotlow + ((slothigh-slotlow)/2);
 
-  result = my_query(t->probe->db, 0,
-                    "select avg(loadavg), avg(user), avg(system), avg(idle), "
-                    "       avg(swapin), avg(swapout), avg(blockin), avg(blockout), "
-                    "       avg(swapped), avg(free), avg(buffered), avg(cached), "
-                    "       avg(used), avg(systemp), max(color), avg(yellow), avg(red) " 
+  result = db_query(t->probe->db, 0,
+                    "select avg(loadavg) as avg_loadavg, avg(user) as avg_user, avg(system) as avg_system, "
+                    "       avg(idle) as avg_idle, avg(swapin) as avg_swapin, avg(swapout) as avg_swapout, "
+                    "       avg(blockin) as avg_blockin, avg(blockout) as avg_blockout, "
+                    "       avg(swapped) as avg_swapped, avg(free) as avg_free, "
+                    "       avg(buffered) as avg_buffered, avg(cached) as avg_cached, "
+                    "       avg(used) as avg_used, avg(systemp) as avg_systemp, max(color) as max_color, "
+                    "       avg(yellow) as avg_yellow, avg(red) as avg_red " 
                     "from   pr_sysstat_%s use index(probstat) "
                     "where  probe = '%d' and stattime >= %d and stattime < %d",
                     from, def->probeid, slotlow, slothigh);
   
   if (!result) return;
-  if (mysql_num_rows(result) == 0) { // no records found
+  if (dbi_result_get_numrows(result) == 0) { // no records found
     LOG(LOG_NOTICE, "nothing to summarize from %s for probe %u %u %u", 
                        from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
-  if (row[0] == NULL) {
+  if (dbi_result_get_string(result, "avg_lowest") == NULL) {
     LOG(LOG_NOTICE, "NULL values found in summarizing from %s for probe %u %u %u", 
                       from, def->probeid, slotlow, slothigh);
-    mysql_free_result(result);
+    dbi_result_free(result);
     return;
   }
 
-  avg_loadavg = atof(row[0]);
-  avg_user    = atoi(row[1]);
-  avg_system  = atoi(row[2]);
-  avg_idle    = atoi(row[3]);
-  avg_swapin  = atoi(row[4]);
-  avg_swapout = atoi(row[5]);
-  avg_blockin = atoi(row[6]);
-  avg_blockout= atoi(row[7]);
-  avg_swapped = atoi(row[8]);
-  avg_free    = atoi(row[9]);
-  avg_buffered= atoi(row[10]);
-  avg_cached  = atoi(row[11]);
-  avg_used    = atoi(row[12]);
-  avg_systemp = atoi(row[13]);
-  max_color   = atoi(row[14]);
-  avg_yellow  = atof(row[15]);
-  avg_red     = atof(row[16]);
-  mysql_free_result(result);
+  avg_loadavg = dbi_result_get_float(result, "avg_loadavg");
+  avg_user    = dbi_result_get_uint(result, "avg_user");
+  avg_system  = dbi_result_get_uint(result, "avg_system");
+  avg_idle    = dbi_result_get_uint(result, "avg_idle");
+  avg_swapin  = dbi_result_get_uint(result, "avg_swapin");
+  avg_swapout = dbi_result_get_uint(result, "avg_swapout");
+  avg_blockin = dbi_result_get_uint(result, "avg_blockin");
+  avg_blockout= dbi_result_get_uint(result, "avg_blockout");
+  avg_swapped = dbi_result_get_uint(result, "avg_swapped");
+  avg_free    = dbi_result_get_uint(result, "avg_free");
+  avg_buffered= dbi_result_get_uint(result, "avg_buffered");
+  avg_cached  = dbi_result_get_uint(result, "avg_cached");
+  avg_used    = dbi_result_get_uint(result, "avg_used");
+  avg_systemp = dbi_result_get_uint(result, "avg_systemp");
+  max_color   = dbi_result_get_uint(result, "max_color");
+  avg_yellow  = dbi_result_get_float(result, "avg_yellow");
+  avg_red     = dbi_result_get_float(result, "avg_red");
+  dbi_result_free(result);
 
   if (resummarize) {
     // delete old values
-    result = my_query(t->probe->db, 0,
+    result = db_query(t->probe->db, 0,
                     "delete from pr_sysstat_%s where probe = '%u' and stattime = '%u'",
                     into, def->probeid, stattime);
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
 
-  result = my_query(t->probe->db, 0,
+  result = db_query(t->probe->db, 0,
                     "insert into pr_sysstat_%s " 
                     "set    loadavg = '%f', user = '%u', system = '%u', idle = '%u', "
                     "       swapin = '%u', swapout = '%u', blockin = '%u', blockout = '%u', "
@@ -136,7 +140,7 @@
                     avg_swapped, avg_free, avg_buffered, avg_cached, 
                     avg_used, avg_systemp, def->probeid, max_color, stattime,
                     avg_yellow, avg_red, slot);
-  mysql_free_result(result);
+  dbi_result_free(result);
 }
 
 module sysstat_module  = {

Modified: upwatch/libdbi/uw_process/tcpconnect.c
===================================================================
--- upwatch/libdbi/uw_process/tcpconnect.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/tcpconnect.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -11,22 +11,29 @@
 //*******************************************************************
 // Get the results of the MySQL query into our probe_def structure
 //*******************************************************************
-static void tcpconnect_set_def_fields(trx *t, struct probe_def *probedef, MYSQL_RES *result)
+static void tcpconnect_set_def_fields(trx *t, struct probe_def *probedef, dbi_result result)
 {
   struct tcpconnect_def *def = (struct tcpconnect_def *) probedef;
-  MYSQL_ROW row = mysql_fetch_row(result);
 
-  if (row) {
-    if (row[0]) def->ipaddress   = strdup(row[0]);
-    if (row[1]) def->description = strdup(row[1]);
-    if (row[2]) def->server   = atoi(row[2]);
-    if (row[3]) def->yellow   = atof(row[3]);
-    if (row[4]) def->red      = atof(row[4]);
-    if (row[5]) def->contact  = atof(row[5]);
-    strcpy(def->hide, row[6] ? row[6] : "no");
-    strcpy(def->email, row[7] ? row[7] : "");
-    if (row[8]) def->delay = atoi(row[8]);
-    if (row[9]) def->port = atoi(row[9]);
+  if (dbi_result_next_row(result)) {
+    def->ipaddress   = dbi_result_get_string_copy_idx(result, 0);
+    def->description = dbi_result_get_string_copy_idx(result, 1);
+    def->server   = dbi_result_get_uint_idx(result, 2);
+    def->yellow   = dbi_result_get_float_idx(result, 3);
+    def->red      = dbi_result_get_float_idx(result, 4);
+    def->contact  = dbi_result_get_float_idx(result, 5);
+    if (dbi_result_get_string_idx(result, 6)) {
+      strcpy(def->hide, dbi_result_get_string_idx(result, 6));
+    } else {
+      strcpy(def->hide, "no");
+    }
+    if (dbi_result_get_string_idx(result, 7)) {
+      strcpy(def->email, dbi_result_get_string_idx(result, 7));
+    } else {
+      strcpy(def->email, "");
+    }
+    def->delay = dbi_result_get_uint_idx(result, 8);
+    def->port = dbi_result_get_uint_idx(result, 9);
   }
 }
 

Modified: upwatch/libdbi/uw_process/uw_process.def
===================================================================
--- upwatch/libdbi/uw_process/uw_process.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/uw_process.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -14,7 +14,7 @@
 
 // this section is for the generated specfile
 spec-buildrequires = "libesmtp-devel";
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_process`;
 spec-files = `echo "%attr(0770,root,upwatch) %dir " $spooldir/q_failed`;
 spec-files = `echo "%attr(0770,root,upwatch) %dir " $spooldir/q_failed/new`;
@@ -56,7 +56,6 @@
 about maildir see http://www.qmail.org/man/man5/maildir.html.';
 };
 
-// describe commandline flags
 flag = {
     name      = input;
     value     = I;
@@ -82,6 +81,15 @@
 };
 
 flag = {
+    name      = realm;
+    value     = R;
+    arg_type  = string;
+    descrip   = "ignored";
+    doc       =
+'uw_process ignores this parameter when it encounters it in fir example upwatch.conf';
+};
+
+flag = {
     name      = failures;
     value     = f;
     arg_type  = string;

Modified: upwatch/libdbi/uw_process/uw_process_glob.h
===================================================================
--- upwatch/libdbi/uw_process/uw_process_glob.h	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/uw_process_glob.h	2006-07-21 20:34:40 UTC (rev 632)
@@ -48,27 +48,27 @@
                          guint slot, guint slotlow, guint slothigh, gint resummarize);
 
 struct dbspec {
-  char *realm;
-  char *host;
-  int port;
-  char *db;
-  char *user;
-  char *password;
-  char *srvrbyname; // query to retrieve the server id given the server name
-  char *srvrbyid;   // query to retrieve the server name given the server id
-  char *srvrbyip;   // query to retrieve the server id given the ipaddress
-  MYSQL *mysql;
+  const char *realm;
+  const char *host;
+  const char *port;
+  const char *db;
+  const char *user;
+  const char *password;
+  const char *srvrbyname; // query to retrieve the server id given the server name
+  const char *srvrbyid;   // query to retrieve the server name given the server id
+  const char *srvrbyip;   // query to retrieve the server id given the ipaddress
+  dbi_conn conn;
 };
 extern struct dbspec *dblist;
 extern int dblist_cnt;
 
-int realm_exists(char *realm);
-MYSQL *open_realm(char *realm);
-int realm_server_by_name(char *realm, char *name);
-char *realm_server_by_id(char *realm, int id);
-int realm_server_by_ip(char *realm, char *ip);
+int realm_exists(const char *realm);
+dbi_conn open_realm(const char *realm);
+int realm_server_by_name(const char *realm, const char *name);
+char *realm_server_by_id(const char *realm, int id);
+int realm_server_by_ip(const char *realm, char *ip);
 
-int mail(char *to, char *subject, char *body, time_t date);
+int mail(const char *to, const char *subject, const char *body, time_t date);
 
 #endif /* __UW_PROCESS_GLOB_H */
 

Modified: upwatch/libdbi/uw_process/uw_tnot.def
===================================================================
--- upwatch/libdbi/uw_process/uw_tnot.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_process/uw_tnot.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,7 +13,7 @@
 'uw_process reads probe resultfiles, and stores them in the database';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_process`;
 spec-files = `echo "%attr(0770,root,upwatch) %dir " $spooldir/uw_process`;
 spec-files = `echo "%attr(0770,root,upwatch) %dir " $spooldir/uw_process/new`;

Modified: upwatch/libdbi/uw_purple/Makefile.am
===================================================================
--- upwatch/libdbi/uw_purple/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_purple/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -7,8 +7,8 @@
 init_DATA = $(INITFILES)
 
 uw_purple_SOURCES = run.c uw_purple.h uw_purple.c  $(SPECFILES) $(INITFILES)
-uw_purple_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_purple_LDADD = uw_purple_$(DB_O) uw_purple_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_purple_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_purple_LDADD = uw_purple_$(DB_O) uw_purple_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_purple/run.c
===================================================================
--- upwatch/libdbi/uw_purple/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_purple/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,12 +8,12 @@
 
 struct dbspec {
   int domid;
-  char *realm;
-  char *host;
+  const char *realm;
+  const char *host;
   int port;
-  char *db;
-  char *user;
-  char *password;
+  const char *db;
+  const char *user;
+  const char *password;
 };
 
 int init(void)
@@ -32,44 +32,47 @@
 {
   xmlDocPtr doc;
   xmlNodePtr probe;
-  MYSQL_RES *result;
-  MYSQL_ROW row;
-  MYSQL *db;
+  dbi_result result;
+  dbi_conn conn;
   int count = 0;
+  char buf[10];
 
-  db = open_database(dbspec->host, dbspec->port, dbspec->db,
+  sprintf(buf, "%d", dbspec->port);
+
+  conn = open_database(OPT_ARG(DBTYPE), dbspec->host, buf, dbspec->db,
                      dbspec->user, dbspec->password);
-  if (!db) return 0;
+  if (!conn) return 0;
 
   doc = UpwatchXmlDoc("result", NULL);
 
   // find all expired probes, but skip those for which processing
   // has been stopped for some reason
-  result = my_query(db, 0, "select probe.name, pr_status.probe, " 
-                           "       pr_status.server, pr_status.color, "
-                           "       pr_status.expires "
-                           "from   pr_status, probe "
-                           "where  probe.id = pr_status.class and color <> 400 "
-                           "       and expires < UNIX_TIMESTAMP()-30 "
-                           "       and expires < probe.lastseen"
-                           "       and probe.expiry = 'yes'");
+  result = db_query(conn, 0, "select probe.name, pr_status.probe, " 
+                             "       pr_status.server, pr_status.color, "
+                             "       pr_status.expires "
+                             "from   pr_status, probe "
+                             "where  probe.id = pr_status.class and color <> 400 "
+                             "       and expires < UNIX_TIMESTAMP()-30 "
+                             "       and expires < probe.lastseen"
+                             "       and probe.expiry = 'yes'");
   if (!result) goto errexit;
 
-  while ((row = mysql_fetch_row(result)) != NULL) {
+  while (dbi_result_next_row(result)) {
     char buffer[256];
     time_t now = time(NULL);
 
-    probe = xmlNewChild(xmlDocGetRootElement(doc), NULL, row[0], NULL);
+    probe = xmlNewChild(xmlDocGetRootElement(doc), NULL, dbi_result_get_string(result, "name"), NULL);
     xmlSetProp(probe, "realm", dbspec->realm);
-    xmlSetProp(probe, "id", row[1]);
-    xmlSetProp(probe, "server", row[2]);
+    xmlSetProp(probe, "id", dbi_result_get_string(result, "probe"));
+    xmlSetProp(probe, "server", dbi_result_get_string(result, "server"));
     sprintf(buffer, "%u", (int) now);	xmlSetProp(probe, "date", buffer);
-    xmlSetProp(probe, "expires", row[4]);
+    xmlSetProp(probe, "expires", dbi_result_get_string(result, "expires"));
 
     xmlNewChild(probe, NULL, "color", "400");  // PURPLE
-    xmlNewChild(probe, NULL, "prevcolor", row[3]);
+    xmlNewChild(probe, NULL, "prevcolor", dbi_result_get_string(result, "color"));
 
-    LOG(LOG_INFO, "%s: purpled %s %s", dbspec->realm, row[0], row[1]);
+    LOG(LOG_INFO, "%s: purpled %s %s", dbspec->realm, dbi_result_get_string(result, "name"), 
+                                                      dbi_result_get_string(result, "probe"));
     count++;
   }
   if (count) {
@@ -79,8 +82,8 @@
   }
 
 errexit:
-  if (result) mysql_free_result(result);
-  if (db) close_database(db);
+  if (result) dbi_result_free(result);
+  if (conn) close_database(conn);
   if (doc) xmlFreeDoc(doc);
   return count;
 }
@@ -91,40 +94,39 @@
 //***********************************************************************
 int run(void)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
-  MYSQL *upwatch;
+  dbi_result result;
+  dbi_conn conn;
   int count = 0;
 
-  upwatch = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                         OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (!upwatch) return 0;
+  if (!conn) return 0;
 
   LOG(LOG_INFO, "processing ..");
   uw_setproctitle("reading info from database");
-  result = my_query(upwatch, 0, "select pr_realm.id, pr_realm.name, pr_realm.host, "
-                                "       pr_realm.port, pr_realm.db, pr_realm.user, "
-                                "       pr_realm.password "
-                                "from   pr_realm "
-                                "where  pr_realm.id > 1");
+  result = db_query(conn, 0, "select pr_realm.id, pr_realm.name, pr_realm.host, "
+                              "       pr_realm.port, pr_realm.db, pr_realm.user, "
+                              "       pr_realm.password "
+                              "from   pr_realm "
+                              "where  pr_realm.id > 1");
   if (result) {
-    while ((row = mysql_fetch_row(result)) != NULL) {
+    while (dbi_result_next_row(result)) {
       struct dbspec db;
 
-      db.domid = atoi(row[0]);
-      db.realm = row[1];
-      db.host = row[2];
-      db.port = atoi(row[3]);
-      db.db = row[4];
-      db.user = row[5];
-      db.password = row[6];
-      uw_setproctitle("checking %s", row[1]);
-      LOG(LOG_DEBUG, "checking %s", row[1]);
+      db.domid = dbi_result_get_uint(result, "id");
+      db.realm = dbi_result_get_string(result, "name");
+      db.host = dbi_result_get_string(result, "host");
+      db.port = dbi_result_get_uint(result, "port");
+      db.db = dbi_result_get_string(result, "db");
+      db.user = dbi_result_get_string(result, "user");
+      db.password = dbi_result_get_string(result, "password");
+      uw_setproctitle("checking %s", dbi_result_get_string(result, "name"));
+      LOG(LOG_DEBUG, "checking %s", dbi_result_get_string(result, "name"));
       count += find_expired_probes(&db);
     }
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
-  close_database(upwatch);
+  close_database(conn);
   LOG(LOG_INFO, "sleeping");
   return count;
 }

Modified: upwatch/libdbi/uw_purple/uw_purple.def
===================================================================
--- upwatch/libdbi/uw_purple/uw_purple.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_purple/uw_purple.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -18,7 +18,7 @@
 be notified';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_purple`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_route/Makefile.am
===================================================================
--- upwatch/libdbi/uw_route/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_route/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -11,8 +11,8 @@
 init_DATA = $(INITFILES)
 
 uw_route_SOURCES = run.c uw_route.h uw_route.c $(SPECFILES) $(INITFILES) 
-uw_route_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_route_LDADD = uw_route_$(DB_O) uw_route_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBGLIB2_LIBS@ @LIBXML2_LIBS@ $(SOLARISLIBS)
+uw_route_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_route_LDADD = uw_route_$(DB_O) uw_route_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@ @LIBXML2_LIBS@ $(SOLARISLIBS)
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_route/uw_route.def
===================================================================
--- upwatch/libdbi/uw_route/uw_route.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_route/uw_route.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -13,7 +13,7 @@
 'uw_route reads probe resultfiles, and stores them in the database';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_route`;
 spec-files = `echo "%attr(0770,root,upwatch) %dir " $spooldir/uw_route`;
 spec-files = `echo "%attr(0770,root,upwatch) %dir " $spooldir/uw_route/new`;

Modified: upwatch/libdbi/uw_send/Makefile.am
===================================================================
--- upwatch/libdbi/uw_send/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_send/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -7,7 +7,7 @@
 init_DATA = $(INITFILES)
 
 uw_send_SOURCES = run.c uw_send.c uw_send.h uw_send.def $(SPECFILES) $(INITFILES)
-uw_send_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @MYSQL_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_send_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
 uw_send_LDADD = uw_send_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES)

Modified: upwatch/libdbi/uw_setip/Makefile.am
===================================================================
--- upwatch/libdbi/uw_setip/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_setip/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_setip_SOURCES = run.c uw_setip.h uw_setip.c $(SPECFILES) $(INITFILES)
-uw_setip_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
-uw_setip_LDADD = uw_setip_$(DB_O) uw_setip_$(MAIN_O) $(LIBOPTS) $(LIBST) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_setip_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
+uw_setip_LDADD = uw_setip_$(DB_O) uw_setip_$(MAIN_O) $(LIBOPTS) $(LIBST) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_setip/run.c
===================================================================
--- upwatch/libdbi/uw_setip/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_setip/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -20,7 +20,7 @@
   char db[64];
   char user[25];
   char password[25];
-  MYSQL *mysql;
+  dbi_conn conn;
 } *dblist;
 int dblist_cnt;
 
@@ -37,46 +37,45 @@
 
 void init_dblist(void)
 {
-  MYSQL *db;
+  dbi_conn conn;
 
-  db = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
-                     OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (db) {
-    MYSQL_RES *result;
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
+                       OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
+  if (conn) {
+    dbi_result result;
 
     if (dblist) free(dblist);
     dblist = calloc(100, sizeof(struct dbspec));
 
-    result = my_query(db, 0, "select pr_realm.name, pr_realm.host, "
-                             "       pr_realm.port, pr_realm.db, pr_realm.user, "
-                             "       pr_realm.password "
-                             "from   pr_realm "
-                             "where  pr_realm.id > 1");
+    result = db_query(conn, 0, "select pr_realm.name, pr_realm.host, "
+                               "       pr_realm.port, pr_realm.db, pr_realm.user, "
+                               "       pr_realm.password "
+                               "from   pr_realm "
+                               "where  pr_realm.id > 1");
     if (result) {
-      MYSQL_ROW row;
       dblist_cnt = 0;
-      while ((row = mysql_fetch_row(result)) != NULL) {
-        strcpy(dblist[dblist_cnt].realm, row[0]);
-        strcpy(dblist[dblist_cnt].host, row[1]);
-        dblist[dblist_cnt].port = atoi(row[2]);
-        strcpy(dblist[dblist_cnt].db, row[3]);
-        strcpy(dblist[dblist_cnt].user, row[4]);
-        strcpy(dblist[dblist_cnt].password, row[5]);
+      while (dbi_result_next_row(result)) {
+        strcpy(dblist[dblist_cnt].realm, dbi_result_get_string(result, "name"));
+        strcpy(dblist[dblist_cnt].host, dbi_result_get_string(result, "host"));
+        dblist[dblist_cnt].port = dbi_result_get_uint(result, "port");
+        strcpy(dblist[dblist_cnt].db, dbi_result_get_string(result, "db"));
+        strcpy(dblist[dblist_cnt].user, dbi_result_get_string(result, "user"));
+        strcpy(dblist[dblist_cnt].password, dbi_result_get_string(result, "password"));
         dblist_cnt++;
       }
-      mysql_free_result(result);
+      dbi_result_free(result);
     }
-    close_database(db);
+    close_database(conn);
     LOG(LOG_INFO, "read %u realms", dblist_cnt);
   } else {
     LOG(LOG_NOTICE, "could not open database %s@%s as user %s", OPT_ARG(DBNAME), OPT_ARG(DBHOST), OPT_ARG(DBUSER));
   } 
 }
 
-MYSQL *open_realm(char *realm)
+dbi_conn open_realm(char *realm)
 {
   int i;
-  MYSQL *mysql;
+  dbi_conn conn;
 static int call_cnt = 0;
 
   if (!dblist || ++call_cnt == 100) {
@@ -88,60 +87,58 @@
     }
   }
   if (realm == NULL || realm[0] == 0) {
-    mysql = open_database(dblist[0].host, dblist[0].port,
+    char buf[10];
+
+    sprintf(buf, "%d", dblist[0].port);
+    conn = open_database(OPT_ARG(DBTYPE), dblist[0].host, buf,
             dblist[0].db, dblist[0].user, dblist[0].password);
-    return(mysql);
+    return(conn);
   }
 
   for (i=0; i < dblist_cnt; i++) {
     if (strcmp(dblist[i].realm, realm) == 0) {
-      mysql = open_database(dblist[i].host, dblist[i].port,
+      char buf[10];
+
+      sprintf(buf, "%d", dblist[0].port);
+      conn = open_database(OPT_ARG(DBTYPE), dblist[i].host, buf,
               dblist[i].db, dblist[i].user, dblist[i].password);
-      return(mysql);
+      return(conn);
     }
   }
   return(NULL);
 }
 
-static int uw_password_ok(char *user, char *passwd) 
+static int uw_password_ok(char *user, char *passwd)
 {
-  MYSQL *mysql;
-  MYSQL_RES *result;
+  dbi_conn conn;
+  dbi_result result;
   char user_realm[256];
   char *realm;
 
   strncpy(user_realm, user, sizeof(user_realm));
   realm = strrchr(user, '@');
-  if (realm) { 
-    *realm++ = 0; 
+  if (realm) {
+    *realm++ = 0;
   }
-  mysql = open_realm(realm);
-  if (mysql) {
+  conn = open_realm(realm);
+  if (conn) {
     gchar buffer[256];
-    MYSQL_ROW row;
 
     sprintf(buffer, OPT_ARG(AUTHQUERY), user, passwd);
     LOG(LOG_DEBUG, buffer);
-    if (mysql_query(mysql, buffer)) {
-      close_database(mysql);
+    result = dbi_conn_query(conn, buffer);
+    if (!result) {
+      close_database(conn);
       return(FALSE);
     }
-    result = mysql_store_result(mysql);
-    if (!result || mysql_num_rows(result) < 1) {
-      // LOG(LOG_NOTICE, "user %s, pwd %s not found", user, passwd);
-      close_database(mysql);
-      return(FALSE);
-    }
-    if ((row = mysql_fetch_row(result))) {
-      int id;
-
-      id = atoi(row[0]);
+    if (dbi_result_next_row(result)) {
+      int id = dbi_result_get_uint_idx(result, 0);
       LOG(LOG_DEBUG, "user %s, pwd %s resulted in id %d", user_realm, passwd, id);
     }
-    mysql_free_result(result);
-    close_database(mysql);
+    dbi_result_free(result);
+    close_database(conn);
   } else {
-    close_database(mysql);
+    close_database(conn);
     return(FALSE); // couldn't open database
   }
   return(TRUE);
@@ -149,22 +146,21 @@
 
 static int uw_set_ip(char *user, char *ip, char *remotehost) 
 {
-  MYSQL *mysql;
-
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  dbi_conn conn;
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
+  if (conn) {
     gchar buffer[256];
 
     sprintf(buffer, OPT_ARG(SETIPQUERY), ip, remotehost, user);
     LOG(LOG_DEBUG, buffer);
-    if (mysql_query(mysql, buffer)) {
-      close_database(mysql);
+    if (!dbi_conn_query(conn, buffer)) {
+      close_database(conn);
       return(FALSE);
     }
-    close_database(mysql);
+    close_database(conn);
   } else {
-    close_database(mysql);
+    close_database(conn);
     return(FALSE); // couldn't open database
   }
   return(TRUE);

Modified: upwatch/libdbi/uw_setip/uw_setip.def
===================================================================
--- upwatch/libdbi/uw_setip/uw_setip.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_setip/uw_setip.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 These are send by clients with variable IP addresses.';
 
 // this section is for the generated specfile 
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_setip`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_smtp/Makefile.am
===================================================================
--- upwatch/libdbi/uw_smtp/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_smtp/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_smtp_SOURCES = run.c uw_smtp.h uw_smtp.c  $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_smtp_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
-uw_smtp_LDADD = uw_smtp_$(DB_O) uw_smtp_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_smtp_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) 
+uw_smtp_LDADD = uw_smtp_$(DB_O) uw_smtp_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_smtp/run.c
===================================================================
--- upwatch/libdbi/uw_smtp/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_smtp/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -70,13 +70,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -84,11 +84,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -104,10 +104,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_smtp_def.id, pr_smtp_def.domid, pr_smtp_def.tblid, pr_realm.name, "
@@ -118,22 +117,22 @@
                 "       and pr_smtp_def.pgroup = '%d' and pr_realm.id = pr_smtp_def.domid",
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -141,19 +140,22 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
-    probe->yellow = atof(row[5]);
-    probe->red = atof(row[6]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void *probe(void *user_data); 
@@ -222,7 +224,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_smtp/uw_smtp.def
===================================================================
--- upwatch/libdbi/uw_smtp/uw_smtp.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_smtp/uw_smtp.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_smtp can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_smtp`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_snmpget/Makefile.am
===================================================================
--- upwatch/libdbi/uw_snmpget/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_snmpget/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -7,8 +7,8 @@
 init_DATA = $(INITFILES)
 
 uw_snmpget_SOURCES = run.c uw_snmpget.h uw_snmpget.c $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_snmpget_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_snmpget_LDADD = uw_snmpget_$(DB_O) uw_snmpget_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBSNMP_LIBS@ @LIBCRYPTO_LIBS@ @LIBGLIB2_LIBS@ 
+uw_snmpget_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_snmpget_LDADD = uw_snmpget_$(DB_O) uw_snmpget_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBSNMP_LIBS@ @LIBCRYPTO_LIBS@ @LIBGLIB2_LIBS@ 
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_snmpget/run.c
===================================================================
--- upwatch/libdbi/uw_snmpget/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_snmpget/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -69,13 +69,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -83,11 +83,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -103,10 +103,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_snmpget_def.id, pr_snmpget_def.domid, pr_snmpget_def.tblid, pr_realm.name, "
@@ -118,22 +117,22 @@
                 "       and pr_snmpget_def.pgroup = '%d' and pr_realm.id = pr_snmpget_def.domid",
                 (unsigned) OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -142,25 +141,28 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
     if (probe->community) g_free(probe->community);
-    probe->community = strdup(row[5]);
+    probe->community = dbi_result_get_string_copy(result, "community");
     if (probe->OID) g_free(probe->OID);
-    probe->OID = strdup(row[6]);
-    strcpy(probe->mode, row[7]);
-    probe->multiplier = atof(row[8]);
-    probe->yellow = atof(row[9]);
-    probe->red = atof(row[10]);
+    probe->OID = dbi_result_get_string_copy(result, "OID");
+    strcpy(probe->mode, dbi_result_get_string(result, "mode"));
+    probe->multiplier = dbi_result_get_float(result, "multiplier");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    const char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 static int active_hosts;
@@ -346,7 +348,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  const char **output = STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_snmpget/uw_snmpget.def
===================================================================
--- upwatch/libdbi/uw_snmpget/uw_snmpget.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_snmpget/uw_snmpget.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_snmpget can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_snmpget`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_syncprobes/Makefile.am
===================================================================
--- upwatch/libdbi/uw_syncprobes/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_syncprobes/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -7,8 +7,8 @@
 init_DATA = $(INITFILES)
 
 uw_syncprobes_SOURCES = run.c uw_syncprobes.h uw_syncprobes.c  $(SPECFILES) $(INITFILES)
-uw_syncprobes_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_syncprobes_LDADD = uw_syncprobes_$(DB_O) uw_syncprobes_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_syncprobes_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_syncprobes_LDADD = uw_syncprobes_$(DB_O) uw_syncprobes_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_syncprobes/run.c
===================================================================
--- upwatch/libdbi/uw_syncprobes/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_syncprobes/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,12 +8,12 @@
 
 struct dbspec {
   int domid;
-  char *realm;
-  char *host;
+  const char *realm;
+  const char *host;
   int port;
-  char *db;
-  char *user;
-  char *password;
+  const char *db;
+  const char *user;
+  const char *password;
 };
 
 int init(void)
@@ -24,41 +24,42 @@
   return(1);
 }
 
-void sync_table(MYSQL *upwatch, struct dbspec *db, char *table);
+void sync_table(dbi_conn conn, struct dbspec *db, const char *table);
 
 int run(void)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
-  MYSQL *upwatch;
+  dbi_result result;
+  dbi_conn upwatch;
 
-  upwatch = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME),
+  upwatch = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME),
                         OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
   if (!upwatch) return 0;
 
   LOG(LOG_INFO, "syncing..");
   uw_setproctitle("reading info from database");
-  result = my_query(upwatch, 0, "select pr_realm.id, pr_realm.name, pr_realm.host, "
+  result = db_query(upwatch, 0, "select pr_realm.id, pr_realm.name, pr_realm.host, "
                                 "       pr_realm.port, pr_realm.db, pr_realm.user, "
                                 "       pr_realm.password, probe.name as tbl "
                                 "from   probe, pr_realm " 
                                 "where  probe.id > 1 and pr_realm.id > 1");
   if (result) {
-    while ((row = mysql_fetch_row(result)) != NULL) {
+    while (dbi_result_next_row(result)) {
       struct dbspec db;
 
-      db.domid = atoi(row[0]);
-      db.realm = row[1];
-      db.host = row[2];
-      db.port = atoi(row[3]);
-      db.db = row[4];
-      db.user = row[5];
-      db.password = row[6];
-      uw_setproctitle("synching %s:pr_%s_def", row[1], row[7]);
-      LOG(LOG_DEBUG, "syncing %s:pr_%s_def", row[1], row[7]);
-      sync_table(upwatch, &db, row[7]);
+      db.domid = dbi_result_get_uint(result, "id");
+      db.realm = dbi_result_get_string(result, "name");
+      db.host = dbi_result_get_string(result, "host");
+      db.port = dbi_result_get_uint(result, "port");
+      db.db = dbi_result_get_string(result, "db");
+      db.user = dbi_result_get_string(result, "user");
+      db.password = dbi_result_get_string(result, "password");
+      uw_setproctitle("synching %s:pr_%s_def", dbi_result_get_string(result, "name"), 
+                       dbi_result_get_string(result, "tbl"));
+      LOG(LOG_DEBUG, "syncing %s:pr_%s_def", dbi_result_get_string(result, "name"), 
+                       dbi_result_get_string(result, "tbl"));
+      sync_table(upwatch, &db, dbi_result_get_string(result, "tbl"));
     }
-    mysql_free_result(result);
+    dbi_result_free(result);
   }
   close_database(upwatch);
   LOG(LOG_INFO, "sleeping");
@@ -73,147 +74,142 @@
 };
  
 #define SIZE_STEP 1000
-struct deftable *read_def(MYSQL *db, char *table, int realmid, int isaggr, int *count)
+struct deftable *read_def(dbi_conn conn, const char *table, int realmid, int isaggr, int *count)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   struct deftable *tbl;
   int tbl_max=1000;
 
   if (isaggr) {
-    result = my_query(db, 0, "select id, domid, tblid, unix_timestamp(changed) " 
-                             "from   pr_%s_def "
-                             "where  id > 1 and tblid > 1 and domid = %u "
-                             "order  by tblid asc", table, realmid);
+    result = db_query(conn, 0, "select id, domid, tblid, unix_timestamp(changed) " 
+                               "from   pr_%s_def "
+                               "where  id > 1 and tblid > 1 and domid = %u "
+                               "order  by tblid asc", table, realmid);
   } else {
-    result = my_query(db, 0, "select id, domid, tblid, unix_timestamp(changed) " 
-                             "from   pr_%s_def "
-                             "where  id > 1 "
-                             "order  by id asc", table);
+    result = db_query(conn, 0, "select id, domid, tblid, unix_timestamp(changed) " 
+                               "from   pr_%s_def "
+                               "where  id > 1 "
+                               "order  by id asc", table);
   }
   if (!result) {
     return(NULL);
   }
   tbl = calloc(SIZE_STEP, sizeof(struct deftable));
   *count = 0; // preset
-  while ((row = mysql_fetch_row(result)) != NULL) {
-    tbl[*count].id = atoi(row[0]);
-    tbl[*count].domid = atoi(row[1]);
-    tbl[*count].tblid = atoi(row[2]);
-    tbl[*count].changed = atoi(row[3]);
+  while (dbi_result_next_row(result)) {
+    tbl[*count].id = dbi_result_get_uint(result, "id");
+    tbl[*count].domid = dbi_result_get_uint(result, "domid");
+    tbl[*count].tblid = dbi_result_get_uint(result, "tblid");
+    tbl[*count].changed = dbi_result_get_uint(result, "changed");
 
     if (++(*count) == tbl_max) {
       tbl_max += 1000;
       tbl = realloc(tbl, tbl_max * sizeof(struct deftable));
     }
   }
-  mysql_free_result(result);
+  dbi_result_free(result);
   return(tbl);
 }
 
-void update_record(MYSQL *db, char *name, unsigned tblid, unsigned upwid, MYSQL *upwatch)
+void update_record(dbi_conn conn, char *name, unsigned tblid, unsigned upwid, dbi_conn upwatch)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
-  MYSQL_FIELD *fields;
+  dbi_result result;
   int i, numfields;
   char buffer[8192], tmp[8192];
 
-  result = my_query(db, 0, "select * from pr_%s_def where id = '%u'", name, tblid);
+  result = db_query(conn, 0, "select * from pr_%s_def where id = '%u'", name, tblid);
   if (!result) return;
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
 
-  numfields = mysql_num_fields(result);
-  fields = mysql_fetch_fields(result);
+  numfields = dbi_result_get_numfields(result);
 
   sprintf(buffer, "update pr_%s_def set ", name);
   for (i=3; i<numfields; i++) {
-    char escaped[16384];
+    char *escaped = strdup(dbi_result_get_string_idx(result, i));
 
-    mysql_real_escape_string(db, escaped, row[i], strlen(row[i]));
-    sprintf(tmp, "%s = '%s', ", fields[i].name, escaped);
+    dbi_conn_quote_string(conn, &escaped);
+    sprintf(tmp, "%s = '%s', ", dbi_result_get_field_name(result, i), escaped);
     strcat(buffer, tmp);
+    if (escaped) free(escaped);
   }
   buffer[strlen(buffer)-2] = 0;
   sprintf(tmp, " where id = '%u'", upwid);
   strcat(buffer, tmp);
-  mysql_free_result(result);
+  dbi_result_free(result);
 
-  result = my_query(upwatch, 0, buffer);
-  if (result) mysql_free_result(result);
+  result = db_query(upwatch, 0, buffer);
+  if (result) dbi_result_free(result);
 }
 
-void delete_record(MYSQL *upwatch, char *name, unsigned id)
+void delete_record(dbi_conn upwatch, const char *name, unsigned id)
 {
-  MYSQL_RES *result;
+  dbi_result result;
 
-  result = my_query(upwatch, 0, "delete from pr_%s_def where id = '%u'", name, id);
-  if (result) mysql_free_result(result);
+  result = db_query(upwatch, 0, "delete from pr_%s_def where id = '%u'", name, id);
+  if (result) dbi_result_free(result);
 
 }
 
-void insert_record(MYSQL *db, char *name, unsigned tblid, unsigned realmid, MYSQL *upwatch)
+void insert_record(dbi_conn conn, const char *name, unsigned tblid, unsigned realmid, dbi_conn upwatch)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
-  MYSQL_FIELD *fields;
+  dbi_result result;
   int i, numfields;
   char buffer[8192], tmp[8192];
 
-  result = my_query(db, 0, "select * from pr_%s_def where id = '%u'", name, tblid);
+  result = db_query(conn, 0, "select * from pr_%s_def where id = '%u'", name, tblid);
   if (!result) return;
 
-  row = mysql_fetch_row(result);
-  if (!row) {
-    mysql_free_result(result);
+  if (!dbi_result_next_row(result)) {
+    dbi_result_free(result);
     return;
   }
 
-  numfields = mysql_num_fields(result);
-  fields = mysql_fetch_fields(result);
+  numfields = dbi_result_get_numfields(result);
 
   sprintf(buffer, "insert into pr_%s_def set domid = '%u', tblid = '%u', ", name, realmid, tblid);
   for (i=3; i<numfields; i++) {
-    char escaped[16384];
+    char *escaped;
 
-    mysql_real_escape_string(db, escaped, row[i], strlen(row[i]));
-    sprintf(tmp, "%s = '%s', ", fields[i].name, escaped);
+    dbi_conn_quote_string_copy(conn, dbi_result_get_char_idx(result, i), &escaped);
+    sprintf(tmp, "%s = '%s', ", dbi_result_get_field_name(result, i), escaped);
     strcat(buffer, tmp);
+    if (escaped) free(escaped);
   }
   buffer[strlen(buffer)-2] = 0;
-  mysql_free_result(result);
+  dbi_result_free(result);
 
-  result = my_query(upwatch, 0, buffer);
-  if (result) mysql_free_result(result);
+  result = db_query(upwatch, 0, buffer);
+  if (result) dbi_result_free(result);
 }
 
-void sync_table(MYSQL *upwatch, struct dbspec *dbspec, char *table)
+void sync_table(dbi_conn upwatch, struct dbspec *dbspec, const char *table)
 {
-  MYSQL *db;
+  dbi_conn conn;
   struct deftable *tbl, *upw;
   int tbl_size=0, upw_size=0;
   int i, j;
   int added=0, updated=0, deleted=0;
+  char buf[10];
 
-  db = open_database(dbspec->host, dbspec->port, dbspec->db,
+  sprintf(buf, "%d", dbspec->port);
+  conn = open_database(OPT_ARG(DBTYPE), dbspec->host, buf, dbspec->db,
                      dbspec->user, dbspec->password);
-  if (!db) return;
+  if (!conn) return;
 
-  tbl = read_def(db, table, dbspec->domid, FALSE, &tbl_size);
+  tbl = read_def(conn, table, dbspec->domid, FALSE, &tbl_size);
   if (!tbl) {
-    close_database(db);
+    close_database(conn);
     return;
   }
 
   upw = read_def(upwatch, table, dbspec->domid, TRUE, &upw_size);
   if (!upw) {
     free(tbl);
-    close_database(db);
+    close_database(conn);
     return;
   }
 
@@ -231,14 +227,14 @@
       continue;
     }
     if (j == upw_size) { // end of dest table
-      insert_record(db, table, tbl[i].id, dbspec->domid, upwatch);
+      insert_record(conn, table, tbl[i].id, dbspec->domid, upwatch);
       added++;
       i++;
       continue;
     }
     if (tbl[i].id == upw[j].tblid) { // ok, found
       if (tbl[i].changed > upw[j].changed) {
-        update_record(db, table, tbl[i].id, upw[j].id, upwatch);
+        update_record(conn, table, tbl[i].id, upw[j].id, upwatch);
         updated++;
       }
       i++;
@@ -246,7 +242,7 @@
       continue;
     }
     if (tbl[i].id < upw[j].tblid) {
-      insert_record(db, table, tbl[i].id, dbspec->domid, upwatch);
+      insert_record(conn, table, tbl[i].id, dbspec->domid, upwatch);
       added++;
       i++;
       continue;
@@ -260,7 +256,7 @@
   }
   free(upw);
   free(tbl);
-  close_database(db);
+  close_database(conn);
   if (added || updated || deleted) {
     LOG(LOG_INFO, "synced %s:pr_%s_def, added %u, updated %u, deleted %u", 
                     dbspec->realm, table, added, updated, deleted);

Modified: upwatch/libdbi/uw_syncprobes/uw_syncprobes.def
===================================================================
--- upwatch/libdbi/uw_syncprobes/uw_syncprobes.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_syncprobes/uw_syncprobes.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -18,7 +18,7 @@
 be notified';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_syncprobes`;
 
 // describe commandline flags

Modified: upwatch/libdbi/uw_sysstat/Makefile.am
===================================================================
--- upwatch/libdbi/uw_sysstat/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_sysstat/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -27,7 +27,7 @@
 init_DATA = $(INITFILES)
 
 uw_sysstat_SOURCES = run.c uw_sysstat.c uw_sysstat.h $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_sysstat_CFLAGS = @MYSQL_CFLAGS@ @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ $(AM_CFLAGS) @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@
+uw_sysstat_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ $(AM_CFLAGS) @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@
 uw_sysstat_LDADD = uw_sysstat_$(MAIN_O) $(XMBMON_LIB) $(LIBOPTS) \
   $(FREEBSDLIBS) $(SOLARISLIBS) $(LIBSTATGRAB) \
   $(LIBUPWATCH) @LIBXML2_LIBS@ @LIBGLIB2_LIBS@ @LIBPCRE_LIBS@

Modified: upwatch/libdbi/uw_tcpconnect/Makefile.am
===================================================================
--- upwatch/libdbi/uw_tcpconnect/Makefile.am	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_tcpconnect/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
@@ -8,8 +8,8 @@
 init_DATA = $(INITFILES)
 
 uw_tcpconnect_SOURCES = run.c uw_tcpconnect.h uw_tcpconnect.c  $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_tcpconnect_CFLAGS = @MYSQL_CFLAGS@ @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
-uw_tcpconnect_LDADD = uw_tcpconnect_$(DB_O) uw_tcpconnect_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @MYSQL_LIBS@ @LIBGLIB2_LIBS@
+uw_tcpconnect_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS)
+uw_tcpconnect_LDADD = uw_tcpconnect_$(DB_O) uw_tcpconnect_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) $(LIBST) @LIBDBI_LIBS@ @LIBGLIB2_LIBS@
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(PROBFILES) $(SPECFILES) $(INITFILES)
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_tcpconnect/run.c
===================================================================
--- upwatch/libdbi/uw_tcpconnect/run.c	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_tcpconnect/run.c	2006-07-21 20:34:40 UTC (rev 632)
@@ -66,13 +66,13 @@
   return(1);
 }
 
-void refresh_database(MYSQL *mysql);
+void refresh_database(dbi_conn conn);
 void run_actual_probes(void);
 void write_results(void);
 
 int run(void)
 {
-  MYSQL *mysql;
+  dbi_conn conn;
 
   if (!cache) {
     cache = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, free_probe);
@@ -80,11 +80,11 @@
   
   LOG(LOG_INFO, "reading info from database");
   uw_setproctitle("reading info from database");
-  mysql = open_database(OPT_ARG(DBHOST), OPT_VALUE_DBPORT, OPT_ARG(DBNAME), 
+  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
 			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
-  if (mysql) {
-    refresh_database(mysql);
-    close_database(mysql);
+  if (conn) {
+    refresh_database(conn);
+    close_database(conn);
   }
 
   if (g_hash_table_size(cache) > 0) {
@@ -100,10 +100,9 @@
   return(g_hash_table_size(cache));
 }
 
-void refresh_database(MYSQL *mysql)
+void refresh_database(dbi_conn conn)
 {
-  MYSQL_RES *result;
-  MYSQL_ROW row;
+  dbi_result result;
   char qry[1024];
 
   sprintf(qry,  "SELECT pr_tcpconnect_def.id, pr_tcpconnect_def.domid, pr_tcpconnect_def.tblid, pr_realm.name, "
@@ -114,23 +113,23 @@
 		"       and pr_tcpconnect_def.pgroup = '%d' and pr_realm.id = pr_tcpconnect_def.domid",	
                 (unsigned)OPT_VALUE_GROUPID);
 
-  result = my_query(mysql, 1, qry);
+  result = db_query(conn, 1, qry);
   if (!result) {
     return;
   }
     
-  while ((row = mysql_fetch_row(result))) {
+  while (dbi_result_next_row(result)) {
     int id;
     struct probedef *probe;
 
-    id = atol(row[0]);
+    id = dbi_result_get_uint(result, "id");
     probe = g_hash_table_lookup(cache, &id);
     if (!probe) {
       probe = g_malloc0(sizeof(struct probedef));
       probe->id = id;
-      if (atoi(row[1]) > 1) {
-        probe->probeid = atoi(row[2]);
-        probe->realm = strdup(row[3]);
+      if (dbi_result_get_uint(result, "domid") > 1) {
+        probe->probeid = dbi_result_get_uint(result, "tblid");
+        strcpy(probe->realm, dbi_result_get_string(result, "name"));
       } else {
         probe->probeid = probe->id;
       }
@@ -138,20 +137,23 @@
     }
 
     if (probe->ipaddress) g_free(probe->ipaddress);
-    probe->ipaddress = strdup(row[4]);
-    probe->port = atoi(row[5]);
-    probe->yellow = atof(row[6]);
-    probe->red = atof(row[7]);
+    probe->ipaddress = dbi_result_get_string_copy(result, "ipaddress");
+    probe->port = dbi_result_get_uint(result, "port");
+    probe->yellow = dbi_result_get_float(result, "yellow");
+    probe->red = dbi_result_get_float(result, "red");
     if (probe->msg) g_free(probe->msg);
     probe->msg = NULL;
     probe->seen = 1;
   }
-  mysql_free_result(result);
-  if (mysql_errno(mysql)) {
+  if (dbi_conn_error_flag(conn)) {
+    char *errmsg;
+    dbi_conn_error(conn, &errmsg);
+    LOG(LOG_ERR, "%s", errmsg);
     g_hash_table_foreach(cache, reset_seen, NULL);
   } else {
     g_hash_table_foreach_remove(cache, return_seen, NULL);
   }
+  dbi_result_free(result);
 }
 
 void *probe(void *user_data); 

Modified: upwatch/libdbi/uw_tcpconnect/uw_tcpconnect.def
===================================================================
--- upwatch/libdbi/uw_tcpconnect/uw_tcpconnect.def	2006-07-21 20:32:44 UTC (rev 631)
+++ upwatch/libdbi/uw_tcpconnect/uw_tcpconnect.def	2006-07-21 20:34:40 UTC (rev 632)
@@ -15,7 +15,7 @@
 so uw_tcpconnect can process thousands of hosts in a very short period.';
 
 // this section is for the generated specfile
-spec-requires = "/usr/bin/mysql glib2";
+spec-requires = "libdbi >= 0.8 glib2";
 spec-files = `echo "%attr(0770,root,upwatch)" $sbindir/uw_tcpconnect`;
 
 // describe commandline flags



From raarts at mail.berlios.de  Sat Jul 22 01:13:48 2006
From: raarts at mail.berlios.de (raarts at BerliOS)
Date: Sat, 22 Jul 2006 01:13:48 +0200
Subject: [Upwatch-commits] r633 - in upwatch/libdbi: . cfg common compat doc
	patches upwatch util uw_accept uw_acceptbb uw_dns uw_httpget
	uw_imap uw_iptraf uw_mssql uw_mysql uw_mysqlstats uw_null
	uw_ping uw_pop3 uw_postgresql uw_process uw_purple uw_route
	uw_send uw_setip uw_smtp uw_snmpget uw_syncprobes uw_sysstat
	uw_sysstat/uw_sysstat.d/maillog uw_sysstat/uw_sysstat.d/mysql
	uw_sysstat/uw_sysstat.d/quagga uw_sysstat/uw_sysstat.d/syslog
	uw_sysstat/uw_sysstat.d/upwatch uw_tcpconnect
Message-ID: <200607212313.k6LNDmAb016723@sheep.berlios.de>

Author: raarts
Date: 2006-07-22 01:12:45 +0200 (Sat, 22 Jul 2006)
New Revision: 633

Added:
   upwatch/libdbi/libstatgrab-0.13/
   upwatch/libdbi/st-1.7/
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/amavisd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/auditd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/automount
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/linux.kernel
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/logrotate
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/newsyslog
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/postgresql
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/quagga
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/rpc
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/selinux
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/spamd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/syslogd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/useradd
Removed:
   upwatch/libdbi/cfg/cvs2cl.pl
   upwatch/libdbi/common/license_proprietary.def
   upwatch/libdbi/patches/libstatgrab-openbsd.patch
   upwatch/libdbi/patches/xmbmon203.patch
   upwatch/libdbi/upwatch-spec.spec
   upwatch/libdbi/uw_investigate/
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/fast
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/netland
Modified:
   upwatch/libdbi/Makefile.am
   upwatch/libdbi/Makefile.am.common
   upwatch/libdbi/Makefile.am.libs
   upwatch/libdbi/cfg/bootstrap
   upwatch/libdbi/common/Makefile.am
   upwatch/libdbi/common/probe.tpl
   upwatch/libdbi/compat/Makefile.am
   upwatch/libdbi/configure.ac
   upwatch/libdbi/doc/about.xml
   upwatch/libdbi/doc/admin-guide.html
   upwatch/libdbi/doc/admin-guide.txt
   upwatch/libdbi/doc/client-configuration.xml
   upwatch/libdbi/doc/client-install.xml
   upwatch/libdbi/doc/howitallworks.xml
   upwatch/libdbi/doc/installation.xml
   upwatch/libdbi/doc/program-guide.html
   upwatch/libdbi/doc/program-guide.txt
   upwatch/libdbi/doc/upwatch.html
   upwatch/libdbi/doc/upwatch.txt
   upwatch/libdbi/patches/README
   upwatch/libdbi/upwatch/generic.h
   upwatch/libdbi/upwatch/log.c
   upwatch/libdbi/util/chklog.c
   upwatch/libdbi/util/chklog_options.def
   upwatch/libdbi/util/uwq_options.def
   upwatch/libdbi/util/uwregexp.c
   upwatch/libdbi/util/uwsaidar.c
   upwatch/libdbi/uw_accept/run.c
   upwatch/libdbi/uw_acceptbb/run.c
   upwatch/libdbi/uw_acceptbb/uw_acceptbb.def
   upwatch/libdbi/uw_dns/run.c
   upwatch/libdbi/uw_dns/uw_dns.def
   upwatch/libdbi/uw_httpget/run.c
   upwatch/libdbi/uw_httpget/uw_httpget.def
   upwatch/libdbi/uw_imap/run.c
   upwatch/libdbi/uw_iptraf/run.c
   upwatch/libdbi/uw_iptraf/uw_iptraf.def
   upwatch/libdbi/uw_mssql/run.c
   upwatch/libdbi/uw_mysql/run.c
   upwatch/libdbi/uw_mysqlstats/run.c
   upwatch/libdbi/uw_null/run.c
   upwatch/libdbi/uw_null/uw_null.def
   upwatch/libdbi/uw_ping/run.c
   upwatch/libdbi/uw_ping/uw_ping.def
   upwatch/libdbi/uw_pop3/run.c
   upwatch/libdbi/uw_postgresql/run.c
   upwatch/libdbi/uw_process/Makefile.am
   upwatch/libdbi/uw_process/iptraf.c
   upwatch/libdbi/uw_process/mysqlstats.c
   upwatch/libdbi/uw_process/run.c
   upwatch/libdbi/uw_process/uw_process.conf
   upwatch/libdbi/uw_purple/uw_purple.def
   upwatch/libdbi/uw_route/run.c
   upwatch/libdbi/uw_route/uw_route.conf
   upwatch/libdbi/uw_route/uw_route.def
   upwatch/libdbi/uw_send/run.c
   upwatch/libdbi/uw_send/uw_send.def
   upwatch/libdbi/uw_setip/run.c
   upwatch/libdbi/uw_smtp/run.c
   upwatch/libdbi/uw_snmpget/run.c
   upwatch/libdbi/uw_syncprobes/uw_syncprobes.def
   upwatch/libdbi/uw_sysstat/Makefile.am
   upwatch/libdbi/uw_sysstat/run.c
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/macros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/postfix
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/rmacros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/sendmail
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/macros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/rmacros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/bgpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/macros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/rmacros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/zebra
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/apmd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/dhcpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gconfd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gdm
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/httpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/identd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/keepalived
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/macros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/named
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/nfs-utils
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/openntpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/pam
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/rmacros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/shorewall
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/smb
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/snmpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sophie
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sshd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/su
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sudo
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/tftpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/upwatch
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/vsftpd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xfs
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xinetd
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/macros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/rmacros.txt
   upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/upwatch
   upwatch/libdbi/uw_sysstat/uw_sysstat.def
   upwatch/libdbi/uw_tcpconnect/run.c
Log:
Sync this branch with the trunk.


Modified: upwatch/libdbi/Makefile.am
===================================================================
--- upwatch/libdbi/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/Makefile.am	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,9 +1,5 @@
 include $(top_srcdir)/Makefile.am.path
 
-#if HAVE_LIBNET
-#USE_LIBNET = uw_investigate
-#endif
-
 if HAVE_LIBPCAP
 UW_IPTRAF = uw_iptraf
 endif
@@ -70,11 +66,11 @@
 export PROGNAMES MONITORPROG CLIENTPROG SERVERPROG EXTRAPROG
 export TOP_SRCDIR = $(top_srcdir)
 
-SUBDIRS = upwatch st-1.4 ${XMBMON} libstatgrab uw_send uw_sysstat uw_null \
-  uw_httpget uw_dns uw_ping uw_pop3 uw_smtp uw_tcpconnect uw_imap \
-  uw_mysql uw_mysqlstats uw_postgresql uw_snmpget uw_mssql uw_iptraf \
-  uw_acceptbb uw_accept uw_purple uw_route uw_syncprobes uw_setip uw_process \
-  ${COMPAT} util scripts config common
+if ENABLE_SERVER
+SUBDIRS = upwatch st-1.7 ${XMBMON} libstatgrab-0.13 ${PROGNAMES} compat util scripts config common
+else
+SUBDIRS = upwatch ${XMBMON} libstatgrab-0.13 ${PROGNAMES} util scripts config common 
+endif
 
 DIST_SUBDIRS = ${SUBDIRS} doc
 
@@ -88,7 +84,7 @@
   upwatch-spec.def upwatch-spec.tpl upwatch.spec templates \
   patches/libpcap-linux-timeout.patch mswindows \
   ${SERVER_DIST} \
-  install-sh config.sub mkinstalldirs depcomp cfg/cvs2cl.pl
+  install-sh config.sub mkinstalldirs depcomp
 
 
 upwatch.spec: force upwatch-spec.def upwatch-spec.tpl common/spec.tpl \
@@ -160,3 +156,4 @@
 
 #	rm -f $(distdir)/doc/program-guide.*
 #	rm -f $(distdir)/doc/admin-guide.*
+

Modified: upwatch/libdbi/Makefile.am.common
===================================================================
--- upwatch/libdbi/Makefile.am.common	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/Makefile.am.common	2006-07-21 23:12:45 UTC (rev 633)
@@ -11,8 +11,7 @@
 SPECTPL = $(top_srcdir)/common/spec.tpl
 PROBTPL = $(top_srcdir)/common/probe.tpl
 INITTPL = $(top_srcdir)/common/init.tpl
-CMDDEF  = $(top_srcdir)/common/generic_options.def $(top_srcdir)/common/dbase_options.def \
- $(top_srcdir)/common/minimal_options.def
+CMDDEF  = $(top_srcdir)/common/generic_options.def $(top_srcdir)/common/minimal_options.def
 PROBDEF = $(top_srcdir)/common/probe_generic.def
 if CYGWIN
 GENINCL = -L /usr/local/share/autogen -L $(top_srcdir)/common

Modified: upwatch/libdbi/Makefile.am.libs
===================================================================
--- upwatch/libdbi/Makefile.am.libs	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/Makefile.am.libs	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,8 +3,8 @@
 LIBUPWATCH = $(top_srcdir)/upwatch/libupwatch.a @LIBXML2_LIBS@
 LIBUPWATCHT = $(top_srcdir)/upwatch/libupwatcht.a @LIBXML2_LIBS@
 
-LIBST = $(top_srcdir)/st-1.4/libst.a
-INCL_ST = $(top_srcdir)/st-1.4
+LIBST = $(top_srcdir)/st-1.7/libst.a
+INCL_ST = $(top_srcdir)/st-1.7
 
-LIBSTATGRAB = $(top_srcdir)/libstatgrab/src/libstatgrab/.libs/libstatgrab.a
-INCL_STATGRAB = $(top_srcdir)/libstatgrab/src/libstatgrab/
+LIBSTATGRAB = $(top_srcdir)/libstatgrab-0.13/src/libstatgrab/.libs/libstatgrab.a
+INCL_STATGRAB = $(top_srcdir)/libstatgrab-0.13/src/libstatgrab/

Modified: upwatch/libdbi/cfg/bootstrap
===================================================================
--- upwatch/libdbi/cfg/bootstrap	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/cfg/bootstrap	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,7 +3,7 @@
 # test if libtoolize is called glibtoolize (MacOSX)
 BOGUS=`glibtoolize -n 2>/dev/null`
 TEST=$?
-if [ x$TEST == "x0" ]
+if [ $TEST -eq 0 ]
 then
 	LIBTOOLIZE=glibtoolize
 else
@@ -14,17 +14,12 @@
 set -x
 
 # libstatgrab
-cd libstatgrab
-#if [ ! -f libstatgrab-openbsd.patch ]
-#then
-#  cp ../patches/libstatgrab-openbsd.patch .
-#  patch -p1 < libstatgrab-openbsd.patch
+cd libstatgrab-0.13
   aclocal
   autoheader
   $LIBTOOLIZE
   autoconf
   automake --gnu --add-missing
-#fi
 cd ..
 
 aclocal \
@@ -36,4 +31,4 @@
 cd xmbmon203
 autoconf
 cd ..
-
+svnversion . > RELEASE

Deleted: upwatch/libdbi/cfg/cvs2cl.pl
===================================================================
--- upwatch/libdbi/cfg/cvs2cl.pl	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/cfg/cvs2cl.pl	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,1995 +0,0 @@
-#!/usr/bin/perl -w
-# -*- mode: perl; perl-indent-level: 2; -*-
-
-eval 'exec perl -w -x $0 ${1+"$@"}'
-  if 0; # not running under some shell
-
-##############################################################
-###                                                        ###
-### cvs2cl.pl: produce ChangeLog(s) from `cvs log` output. ###
-###                                                        ###
-##############################################################
-
-## $Revision: 1.1 $
-## $Date: 2002/12/27 10:12:15 $
-## $Author: raarts $
-##
-##   (C) 2001,2002 Martyn J. Pearce <fluffy at cpan.org>
-##   (C) 1999 Karl Fogel <kfogel at red-bean.com>, under the GNU GPL.
-##
-##   (Extensively hacked on by Melissa O'Neill <oneill at cs.sfu.ca>.)
-##
-## cvs2cl.pl is free software; you can redistribute it and/or modify
-## it under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 2, or (at your option)
-## any later version.
-##
-## cvs2cl.pl is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You may have received a copy of the GNU General Public License
-## along with cvs2cl.pl; see the file COPYING.  If not, write to the
-## Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-## Boston, MA 02111-1307, USA.
-
-
-
-use strict;
-use Text::Wrap;
-use Time::Local;
-use File::Basename;
-
-
-# The Plan:
-#
-# Read in the logs for multiple files, spit out a nice ChangeLog that
-# mirrors the information entered during `cvs commit'.
-#
-# The problem presents some challenges. In an ideal world, we could
-# detect files with the same author, log message, and checkin time --
-# each <filelist, author, time, logmessage> would be a changelog entry.
-# We'd sort them; and spit them out.  Unfortunately, CVS is *not atomic*
-# so checkins can span a range of times.  Also, the directory structure
-# could be hierarchical.
-#
-# Another question is whether we really want to have the ChangeLog
-# exactly reflect commits. An author could issue two related commits,
-# with different log entries, reflecting a single logical change to the
-# source. GNU style ChangeLogs group these under a single author/date.
-# We try to do the same.
-#
-# So, we parse the output of `cvs log', storing log messages in a
-# multilevel hash that stores the mapping:
-#   directory => author => time => message => filelist
-# As we go, we notice "nearby" commit times and store them together
-# (i.e., under the same timestamp), so they appear in the same log
-# entry.
-#
-# When we've read all the logs, we twist this mapping into
-# a time => author => message => filelist mapping for each directory.
-#
-# If we're not using the `--distributed' flag, the directory is always
-# considered to be `./', even as descend into subdirectories.
-
-
-############### Globals ################
-
-
-# What we run to generate it:
-my $Log_Source_Command = "cvs log";
-
-# In case we have to print it out:
-my $VERSION = '$Revision: 1.1 $';
-$VERSION =~ s/\S+\s+(\S+)\s+\S+/$1/;
-
-## Vars set by options:
-
-# Print debugging messages?
-my $Debug = 0;
-
-# Just show version and exit?
-my $Print_Version = 0;
-
-# Just print usage message and exit?
-my $Print_Usage = 0;
-
-# Single top-level ChangeLog, or one per subdirectory?
-my $Distributed = 0;
-
-# What file should we generate (defaults to "ChangeLog")?
-my $Log_File_Name = "ChangeLog";
-
-# Grab most recent entry date from existing ChangeLog file, just add
-# to that ChangeLog.
-my $Cumulative = 0;
-
-# Expand usernames to email addresses based on a map file?
-my $User_Map_File = "";
-
-# Output to a file or to stdout?
-my $Output_To_Stdout = 0;
-
-# Eliminate empty log messages?
-my $Prune_Empty_Msgs = 0;
-
-# Tags of which not to output
-my @ignore_tags;
-
-# Don't call Text::Wrap on the body of the message
-my $No_Wrap = 0;
-
-# Separates header from log message.  Code assumes it is either " " or
-# "\n\n", so if there's ever an option to set it to something else,
-# make sure to go through all conditionals that use this var.
-my $After_Header = " ";
-
-# XML Encoding
-my $XML_Encoding = '';
-
-# Format more for programs than for humans.
-my $XML_Output = 0;
-
-# Do some special tweaks for log data that was written in FSF
-# ChangeLog style.
-my $FSF_Style = 0;
-
-# Show times in UTC instead of local time
-my $UTC_Times = 0;
-
-# Show day of week in output?
-my $Show_Day_Of_Week = 0;
-
-# Show revision numbers in output?
-my $Show_Revisions = 0;
-
-# Show tags (symbolic names) in output?
-my $Show_Tags = 0;
-
-# Show tags separately in output?
-my $Show_Tag_Dates = 0;
-
-# Show branches by symbolic name in output?
-my $Show_Branches = 0;
-
-# Show only revisions on these branches or their ancestors.
-my @Follow_Branches;
-
-# Don't bother with files matching this regexp.
-my @Ignore_Files;
-
-# How exactly we match entries.  We definitely want "o",
-# and user might add "i" by using --case-insensitive option.
-my $Case_Insensitive = 0;
-
-# Maybe only show log messages matching a certain regular expression.
-my $Regexp_Gate = "";
-
-# Pass this global option string along to cvs, to the left of `log':
-my $Global_Opts = "";
-
-# Pass this option string along to the cvs log subcommand:
-my $Command_Opts = "";
-
-# Read log output from stdin instead of invoking cvs log?
-my $Input_From_Stdin = 0;
-
-# Don't show filenames in output.
-my $Hide_Filenames = 0;
-
-# Max checkin duration. CVS checkin is not atomic, so we may have checkin
-# times that span a range of time. We assume that checkins will last no
-# longer than $Max_Checkin_Duration seconds, and that similarly, no
-# checkins will happen from the same users with the same message less
-# than $Max_Checkin_Duration seconds apart.
-my $Max_Checkin_Duration = 180;
-
-# What to put at the front of [each] ChangeLog.
-my $ChangeLog_Header = "";
-
-# Whether to enable 'delta' mode, and for what start/end tags.
-my $Delta_Mode = 0;
-my $Delta_From = "";
-my $Delta_To = "";
-
-## end vars set by options.
-
-# latest observed times for the start/end tags in delta mode
-my $Delta_StartTime = 0;
-my $Delta_EndTime = 0;
-
-# In 'cvs log' output, one long unbroken line of equal signs separates
-# files:
-my $file_separator = "======================================="
-                   . "======================================";
-
-# In 'cvs log' output, a shorter line of dashes separates log messages
-# within a file:
-my $logmsg_separator = "----------------------------";
-
-
-############### End globals ############
-
-
-
-
-&parse_options ();
-&derive_change_log ();
-
-
-
-### Everything below is subroutine definitions. ###
-
-# If accumulating, grab the boundary date from pre-existing ChangeLog.
-sub maybe_grab_accumulation_date ()
-{
-  if (! $Cumulative) {
-    return "";
-  }
-
-  # else
-
-  open (LOG, "$Log_File_Name")
-      or die ("trouble opening $Log_File_Name for reading ($!)");
-
-  my $boundary_date;
-  while (<LOG>)
-  {
-    if (/^(\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d)/)
-    {
-      $boundary_date = "$1";
-      last;
-    }
-  }
-
-  close (LOG);
-  return $boundary_date;
-}
-
-
-# Fills up a ChangeLog structure in the current directory.
-sub derive_change_log ()
-{
-  # See "The Plan" above for a full explanation.
-
-  my %grand_poobah;
-
-  my $file_full_path;
-  my $time;
-  my $revision;
-  my $author;
-  my $msg_txt;
-  my $detected_file_separator;
-
-  my %tag_date_printed;
-
-  # Might be adding to an existing ChangeLog
-  my $accumulation_date = &maybe_grab_accumulation_date ();
-  if ($accumulation_date) {
-    # Insert -d immediately after 'cvs log'
-    my $Log_Date_Command = "-d\'>${accumulation_date}\'";
-    $Log_Source_Command =~ s/(^.*log\S*)/$1 $Log_Date_Command/;
-    &debug ("(adding log msg starting from $accumulation_date)\n");
-  }
-
-  # We might be expanding usernames
-  my %usermap;
-
-  # In general, it's probably not very maintainable to use state
-  # variables like this to tell the loop what it's doing at any given
-  # moment, but this is only the first one, and if we never have more
-  # than a few of these, it's okay.
-  my $collecting_symbolic_names = 0;
-  my %symbolic_names;    # Where tag names get stored.
-  my %branch_names;      # We'll grab branch names while we're at it.
-  my %branch_numbers;    # Save some revisions for @Follow_Branches
-  my @branch_roots;      # For showing which files are branch ancestors.
-
-  # Bleargh.  Compensate for a deficiency of custom wrapping.
-  if (($After_Header ne " ") and $FSF_Style)
-  {
-    $After_Header .= "\t";
-  }
-
-  if (! $Input_From_Stdin) {
-    &debug ("(run \"${Log_Source_Command}\")\n");
-    open (LOG_SOURCE, "$Log_Source_Command |")
-        or die "unable to run \"${Log_Source_Command}\"";
-  }
-  else {
-    open (LOG_SOURCE, "-") or die "unable to open stdin for reading";
-  }
-
-  binmode LOG_SOURCE;
-
-  %usermap = &maybe_read_user_map_file ();
-
-  while (<LOG_SOURCE>)
-  {
-    # If on a new file and don't see filename, skip until we find it, and
-    # when we find it, grab it.
-    if ((! (defined $file_full_path)) and /^Working file: (.*)/)
-    {
-      $file_full_path = $1;
-      if (@Ignore_Files)
-      {
-        my $base;
-        ($base, undef, undef) = fileparse ($file_full_path);
-        # Ouch, I wish trailing operators in regexps could be
-        # evaluated on the fly!
-        if ($Case_Insensitive) {
-          if (grep ($file_full_path =~ m|$_|i, @Ignore_Files)) {
-            undef $file_full_path;
-          }
-        }
-        elsif (grep ($file_full_path =~ m|$_|, @Ignore_Files)) {
-          undef $file_full_path;
-        }
-      }
-      next;
-    }
-
-    # Just spin wheels if no file defined yet.
-    next if (! $file_full_path);
-
-    # Collect tag names in case we're asked to print them in the output.
-    if (/^symbolic names:$/) {
-      $collecting_symbolic_names = 1;
-      next;  # There's no more info on this line, so skip to next
-    }
-    if ($collecting_symbolic_names)
-    {
-      # All tag names are listed with whitespace in front in cvs log
-      # output; so if see non-whitespace, then we're done collecting.
-      if (/^\S/) {
-        $collecting_symbolic_names = 0;
-      }
-      else    # we're looking at a tag name, so parse & store it
-      {
-        # According to the Cederqvist manual, in node "Tags", tag
-        # names must start with an uppercase or lowercase letter and
-        # can contain uppercase and lowercase letters, digits, `-',
-        # and `_'.  However, it's not our place to enforce that, so
-        # we'll allow anything CVS hands us to be a tag:
-        /^\s+([^:]+): ([\d.]+)$/;
-        my $tag_name = $1;
-        my $tag_rev  = $2;
-
-        # A branch number either has an odd number of digit sections
-        # (and hence an even number of dots), or has ".0." as the
-        # second-to-last digit section.  Test for these conditions.
-        my $real_branch_rev = "";
-        if (($tag_rev =~ /^(\d+\.\d+\.)+\d+$/)   # Even number of dots...
-            and (! ($tag_rev =~ /^(1\.)+1$/)))   # ...but not "1.[1.]1"
-        {
-          $real_branch_rev = $tag_rev;
-        }
-        elsif ($tag_rev =~ /(\d+\.(\d+\.)+)0.(\d+)/)  # Has ".0."
-        {
-          $real_branch_rev = $1 . $3;
-        }
-        # If we got a branch, record its number.
-        if ($real_branch_rev)
-        {
-          $branch_names{$real_branch_rev} = $tag_name;
-          if (@Follow_Branches) {
-            if (grep ($_ eq $tag_name, @Follow_Branches)) {
-              $branch_numbers{$tag_name} = $real_branch_rev;
-            }
-          }
-        }
-        else {
-          # Else it's just a regular (non-branch) tag.
-          push (@{$symbolic_names{$tag_rev}}, $tag_name);
-        }
-      }
-    }
-    # End of code for collecting tag names.
-
-    # If have file name, but not revision, and see revision, then grab
-    # it.  (We collect unconditionally, even though we may or may not
-    # ever use it.)
-    if ((! (defined $revision)) and (/^revision (\d+\.[\d.]+)/))
-    {
-      $revision = $1;
-
-      if (@Follow_Branches)
-      {
-        foreach my $branch (@Follow_Branches)
-        {
-          # Special case for following trunk revisions
-          if (($branch =~ /^trunk$/i) and ($revision =~ /^[0-9]+\.[0-9]+$/))
-          {
-            goto dengo;
-          }
-
-          my $branch_number = $branch_numbers{$branch};
-          if ($branch_number)
-          {
-            # Are we on one of the follow branches or an ancestor of
-            # same?
-            #
-            # If this revision is a prefix of the branch number, or
-            # possibly is less in the minormost number, OR if this
-            # branch number is a prefix of the revision, then yes.
-            # Otherwise, no.
-            #
-            # So below, we determine if any of those conditions are
-            # met.
-
-            # Trivial case: is this revision on the branch?
-            # (Compare this way to avoid regexps that screw up Emacs
-            # indentation, argh.)
-            if ((substr ($revision, 0, ((length ($branch_number)) + 1)))
-                eq ($branch_number . "."))
-            {
-              goto dengo;
-            }
-            # Non-trivial case: check if rev is ancestral to branch
-            elsif ((length ($branch_number)) > (length ($revision)))
-            {
-              $revision =~ /^((?:\d+\.)+)(\d+)$/;
-              my $r_left = $1;          # still has the trailing "."
-              my $r_end = $2;
-
-              $branch_number =~ /^((?:\d+\.)+)(\d+)\.\d+$/;
-              my $b_left = $1;  # still has trailing "."
-              my $b_mid  = $2;   # has no trailing "."
-
-              if (($r_left eq $b_left)
-                  && ($r_end <= $b_mid))
-              {
-                goto dengo;
-              }
-            }
-          }
-        }
-      }
-      else    # (! @Follow_Branches)
-      {
-        next;
-      }
-
-      # Else we are following branches, but this revision isn't on the
-      # path.  So skip it.
-      undef $revision;
-    dengo:
-      next;
-    }
-
-    # If we don't have a revision right now, we couldn't possibly
-    # be looking at anything useful.
-    if (! (defined ($revision))) {
-      $detected_file_separator = /^$file_separator$/o;
-      if ($detected_file_separator) {
-        # No revisions for this file; can happen, e.g. "cvs log -d DATE"
-        goto CLEAR;
-      }
-      else {
-        next;
-      }
-    }
-
-    # If have file name but not date and author, and see date or
-    # author, then grab them:
-    unless (defined $time)
-    {
-      if (/^date: .*/)
-      {
-        ($time, $author) = &parse_date_and_author ($_);
-        if (defined ($usermap{$author}) and $usermap{$author}) {
-          $author = $usermap{$author};
-        }
-      }
-      else {
-        $detected_file_separator = /^$file_separator$/o;
-        if ($detected_file_separator) {
-          # No revisions for this file; can happen, e.g. "cvs log -d DATE"
-          goto CLEAR;
-        }
-      }
-      # If the date/time/author hasn't been found yet, we couldn't
-      # possibly care about anything we see.  So skip:
-      next;
-    }
-
-    # A "branches: ..." line here indicates that one or more branches
-    # are rooted at this revision.  If we're showing branches, then we
-    # want to show that fact as well, so we collect all the branches
-    # that this is the latest ancestor of and store them in
-    # @branch_roots.  Just for reference, the format of the line we're
-    # seeing at this point is:
-    #
-    #    branches:  1.5.2;  1.5.4;  ...;
-    #
-    # Okay, here goes:
-
-    if (/^branches:\s+(.*);$/)
-    {
-      if ($Show_Branches)
-      {
-        my $lst = $1;
-        $lst =~ s/(1\.)+1;|(1\.)+1$//;  # ignore the trivial branch 1.1.1
-        if ($lst) {
-          @branch_roots = split (/;\s+/, $lst);
-        }
-        else {
-          undef @branch_roots;
-        }
-        next;
-      }
-      else
-      {
-        # Ugh.  This really bothers me.  Suppose we see a log entry
-        # like this:
-        #
-        #    ----------------------------
-        #    revision 1.1
-        #    date: 1999/10/17 03:07:38;  author: jrandom;  state: Exp;
-        #    branches:  1.1.2;
-        #    Intended first line of log message begins here.
-        #    ----------------------------
-        #
-        # The question is, how we can tell the difference between that
-        # log message and a *two*-line log message whose first line is
-        #
-        #    "branches:  1.1.2;"
-        #
-        # See the problem?  The output of "cvs log" is inherently
-        # ambiguous.
-        #
-        # For now, we punt: we liberally assume that people don't
-        # write log messages like that, and just toss a "branches:"
-        # line if we see it but are not showing branches.  I hope no
-        # one ever loses real log data because of this.
-        next;
-      }
-    }
-
-    # If have file name, time, and author, then we're just grabbing
-    # log message texts:
-    $detected_file_separator = /^$file_separator$/o;
-    if ($detected_file_separator && ! (defined $revision)) {
-      # No revisions for this file; can happen, e.g. "cvs log -d DATE"
-      goto CLEAR;
-    }
-    unless ($detected_file_separator || /^$logmsg_separator$/o)
-    {
-      $msg_txt .= $_;   # Normally, just accumulate the message...
-      next;
-    }
-    # ... until a msg separator is encountered:
-    # Ensure the message contains something:
-    if ((! $msg_txt)
-        || ($msg_txt =~ /^\s*\.\s*$|^\s*$/)
-        || ($msg_txt =~ /\*\*\* empty log message \*\*\*/))
-    {
-      if ($Prune_Empty_Msgs) {
-        goto CLEAR;
-      }
-      # else
-      $msg_txt = "[no log message]\n";
-    }
-
-    ### Store it all in the Grand Poobah:
-    {
-      my $dir_key;        # key into %grand_poobah
-      my %qunk;           # complicated little jobbie, see below
-
-      # Each revision of a file has a little data structure (a `qunk')
-      # associated with it.  That data structure holds not only the
-      # file's name, but any additional information about the file
-      # that might be needed in the output, such as the revision
-      # number, tags, branches, etc.  The reason to have these things
-      # arranged in a data structure, instead of just appending them
-      # textually to the file's name, is that we may want to do a
-      # little rearranging later as we write the output.  For example,
-      # all the files on a given tag/branch will go together, followed
-      # by the tag in parentheses (so trunk or otherwise non-tagged
-      # files would go at the end of the file list for a given log
-      # message).  This rearrangement is a lot easier to do if we
-      # don't have to reparse the text.
-      #
-      # A qunk looks like this:
-      #
-      #   {
-      #     filename    =>    "hello.c",
-      #     revision    =>    "1.4.3.2",
-      #     time        =>    a timegm() return value (moment of commit)
-      #     tags        =>    [ "tag1", "tag2", ... ],
-      #     branch      =>    "branchname" # There should be only one, right?
-      #     branchroots =>    [ "branchtag1", "branchtag2", ... ]
-      #   }
-
-      if ($Distributed) {
-        # Just the basename, don't include the path.
-        ($qunk{'filename'}, $dir_key, undef) = fileparse ($file_full_path);
-      }
-      else {
-        $dir_key = "./";
-        $qunk{'filename'} = $file_full_path;
-      }
-
-      # This may someday be used in a more sophisticated calculation
-      # of what other files are involved in this commit.  For now, we
-      # don't use it much except for delta mode, because the
-      # common-commit-detection algorithm is hypothesized to be
-      # "good enough" as it stands.
-      $qunk{'time'} = $time;
-
-      # We might be including revision numbers and/or tags and/or
-      # branch names in the output.  Most of the code from here to
-      # loop-end deals with organizing these in qunk.
-
-      $qunk{'revision'} = $revision;
-
-      # Grab the branch, even though we may or may not need it:
-      $qunk{'revision'} =~ /((?:\d+\.)+)\d+/;
-      my $branch_prefix = $1;
-      $branch_prefix =~ s/\.$//;  # strip off final dot
-      if ($branch_names{$branch_prefix}) {
-        $qunk{'branch'} = $branch_names{$branch_prefix};
-      }
-
-      # If there's anything in the @branch_roots array, then this
-      # revision is the root of at least one branch.  We'll display
-      # them as branch names instead of revision numbers, the
-      # substitution for which is done directly in the array:
-      if (@branch_roots) {
-        my @roots = map { $branch_names{$_} } @branch_roots;
-        $qunk{'branchroots'} = \@roots;
-      }
-
-      # Save tags too.
-      if (defined ($symbolic_names{$revision})) {
-        $qunk{'tags'} = $symbolic_names{$revision};
-        delete $symbolic_names{$revision};
-
-	# If we're in 'delta' mode, update the latest observed
-	# times for the beginning and ending tags, and
-	# when we get around to printing output, we will simply restrict
-	# ourselves to that timeframe...
-	
-	if ($Delta_Mode) {
-	  if (($time > $Delta_StartTime) &&
-	      (grep { $_ eq $Delta_From } @{$qunk{'tags'}}))
-	  {
-	    $Delta_StartTime = $time;
-	  }
-	  
-	  if (($time > $Delta_EndTime) &&
-	      (grep { $_ eq $Delta_To } @{$qunk{'tags'}}))
-	  {
-	    $Delta_EndTime = $time;
-	  }
-	}
-      }
-
-      # Add this file to the list
-      # (We use many spoonfuls of autovivication magic. Hashes and arrays
-      # will spring into existence if they aren't there already.)
-
-      &debug ("(pushing log msg for ${dir_key}$qunk{'filename'})\n");
-
-      # Store with the files in this commit.  Later we'll loop through
-      # again, making sure that revisions with the same log message
-      # and nearby commit times are grouped together as one commit.
-      push (@{$grand_poobah{$dir_key}{$author}{$time}{$msg_txt}}, \%qunk);
-    }
-
-  CLEAR:
-    # Make way for the next message
-    undef $msg_txt;
-    undef $time;
-    undef $revision;
-    undef $author;
-    undef @branch_roots;
-
-    # Maybe even make way for the next file:
-    if ($detected_file_separator) {
-      undef $file_full_path;
-      undef %branch_names;
-      undef %branch_numbers;
-      undef %symbolic_names;
-    }
-  }
-
-  close (LOG_SOURCE);
-
-  ### Process each ChangeLog
-
-  while (my ($dir,$authorhash) = each %grand_poobah)
-  {
-    &debug ("DOING DIR: $dir\n");
-
-    # Here we twist our hash around, from being
-    #   author => time => message => filelist
-    # in %$authorhash to
-    #   time => author => message => filelist
-    # in %changelog.
-    #
-    # This is also where we merge entries.  The algorithm proceeds
-    # through the timeline of the changelog with a sliding window of
-    # $Max_Checkin_Duration seconds; within that window, entries that
-    # have the same log message are merged.
-    #
-    # (To save space, we zap %$authorhash after we've copied
-    # everything out of it.)
-
-    my %changelog;
-    while (my ($author,$timehash) = each %$authorhash)
-    {
-      my $lasttime;
-      my %stamptime;
-      foreach my $time (sort {$main::a <=> $main::b} (keys %$timehash))
-      {
-        my $msghash = $timehash->{$time};
-        while (my ($msg,$qunklist) = each %$msghash)
-        {
- 	  my $stamptime = $stamptime{$msg};
-          if ((defined $stamptime)
-              and (($time - $stamptime) < $Max_Checkin_Duration)
-              and (defined $changelog{$stamptime}{$author}{$msg}))
-          {
- 	    push(@{$changelog{$stamptime}{$author}{$msg}}, @$qunklist);
-          }
-          else {
-            $changelog{$time}{$author}{$msg} = $qunklist;
-            $stamptime{$msg} = $time;
-          }
-        }
-      }
-    }
-    undef (%$authorhash);
-
-    ### Now we can write out the ChangeLog!
-
-    my ($logfile_here, $logfile_bak, $tmpfile);
-
-    if (! $Output_To_Stdout) {
-      $logfile_here =  $dir . $Log_File_Name;
-      $logfile_here =~ s/^\.\/\//\//;   # fix any leading ".//" problem
-      $tmpfile      = "${logfile_here}.cvs2cl$$.tmp";
-      $logfile_bak  = "${logfile_here}.bak";
-
-      open (LOG_OUT, ">$tmpfile") or die "Unable to open \"$tmpfile\"";
-    }
-    else {
-      open (LOG_OUT, ">-") or die "Unable to open stdout for writing";
-    }
-
-    print LOG_OUT $ChangeLog_Header;
-
-    if ($XML_Output) {
-      my $encoding    = 
-        length $XML_Encoding ? qq'encoding="$XML_Encoding"' : '';
-      my $version     = 'version="1.0"';
-      my $declaration = 
-        sprintf '<?xml %s?>', join ' ', grep length, $version, $encoding;
-      my $root        =
-        '<changelog xmlns="http://www.red-bean.com/xmlns/cvs2cl/">';
-      print LOG_OUT "$declaration\n\n$root\n\n";
-    }
-
-    foreach my $time (sort {$main::b <=> $main::a} (keys %changelog))
-    {
-      next if ($Delta_Mode &&
-	       (($time <= $Delta_StartTime) ||
-		($time > $Delta_EndTime && $Delta_EndTime)));
-
-      # Set up the date/author line.
-      # kff todo: do some more XML munging here, on the header
-      # part of the entry:
-      my ($ignore,$min,$hour,$mday,$mon,$year,$wday)
-          = $UTC_Times ? gmtime($time) : localtime($time);
-
-      # XML output includes everything else, we might as well make
-      # it always include Day Of Week too, for consistency.
-      if ($Show_Day_Of_Week or $XML_Output) {
-        $wday = ("Sunday", "Monday", "Tuesday", "Wednesday",
-                 "Thursday", "Friday", "Saturday")[$wday];
-        $wday = ($XML_Output) ? "<weekday>${wday}</weekday>\n" : " $wday";
-      }
-      else {
-        $wday = "";
-      }
-
-      my $authorhash = $changelog{$time};
-      if ($Show_Tag_Dates) {
-        my %tags;
-        while (my ($author,$mesghash) = each %$authorhash) {
-          while (my ($msg,$qunk) = each %$mesghash) {
-            foreach my $qunkref2 (@$qunk) {
-	      if (defined ($$qunkref2{'tags'})) {
-                foreach my $tag (@{$$qunkref2{'tags'}}) {
-                  $tags{$tag} = 1;
-                }
-              }
-	    }
-          }
-        }
-        foreach my $tag (keys %tags) {
-          if (!defined $tag_date_printed{$tag}) {
-            $tag_date_printed{$tag} = $time;
-            if ($XML_Output) {
-              # NOT YET DONE
-            }
-            else {
-              printf LOG_OUT ("%4u-%02u-%02u${wday} %02u:%02u  tag %s\n\n",
-                              $year+1900, $mon+1, $mday, $hour, $min, $tag);
-            }
-          }
-        }
-      }
-      while (my ($author,$mesghash) = each %$authorhash)
-      {
-        # If XML, escape in outer loop to avoid compound quoting:
-        if ($XML_Output) {
-          $author = &xml_escape ($author);
-        }
-
-      FOOBIE:
-        while (my ($msg,$qunklist) = each %$mesghash)
-        {
-          ## MJP: 19.xii.01 : Exclude @ignore_tags
-          for my $ignore_tag (@ignore_tags) {
-            next FOOBIE
-              if grep $_ eq $ignore_tag, map(@{$_->{tags}},
-                                             grep(defined $_->{tags},
-                                                  @$qunklist));
-          }
-          ## MJP: 19.xii.01 : End exclude @ignore_tags
-
-          my $files               = &pretty_file_list ($qunklist);
-          my $header_line;          # date and author
-          my $body;                 # see below
-          my $wholething;           # $header_line + $body
-
-          if ($XML_Output) {
-            $header_line =
-                sprintf ("<date>%4u-%02u-%02u</date>\n"
-                         . "${wday}"
-                         . "<time>%02u:%02u</time>\n"
-                         . "<author>%s</author>\n",
-                         $year+1900, $mon+1, $mday, $hour, $min, $author);
-          }
-          else {
-            $header_line =
-                sprintf ("%4u-%02u-%02u${wday} %02u:%02u  %s\n\n",
-                         $year+1900, $mon+1, $mday, $hour, $min, $author);
-          }
-
-          $Text::Wrap::huge = 'overflow'
-            if $Text::Wrap::VERSION >= 2001.0130;
-          # Reshape the body according to user preferences.
-          if ($XML_Output)
-          {
-            $msg = &preprocess_msg_text ($msg);
-            $body = $files . $msg;
-          }
-          elsif ($No_Wrap)
-          {
-            $msg = &preprocess_msg_text ($msg);
-            $files = wrap ("\t", "	", "$files");
-            $msg =~ s/\n(.*)/\n\t$1/g;
-            unless ($After_Header eq " ") {
-              $msg =~ s/^(.*)/\t$1/g;
-            }
-            $body = $files . $After_Header . $msg;
-          }
-          else  # do wrapping, either FSF-style or regular
-          {
-            if ($FSF_Style)
-            {
-              $files = wrap ("\t", "        ", "$files");
-
-              my $files_last_line_len = 0;
-              if ($After_Header eq " ")
-              {
-                $files_last_line_len = &last_line_len ($files);
-                $files_last_line_len += 1;  # for $After_Header
-              }
-
-              $msg = &wrap_log_entry
-                  ($msg, "\t", 69 - $files_last_line_len, 69);
-              $body = $files . $After_Header . $msg;
-            }
-            else  # not FSF-style
-            {
-              $msg = &preprocess_msg_text ($msg);
-              $body = $files . $After_Header . $msg;
-              $body = wrap ("\t", "        ", "$body");
-            }
-          }
-
-          $wholething = $header_line . $body;
-
-          if ($XML_Output) {
-            $wholething = "<entry>\n${wholething}</entry>\n";
-          }
-
-          # One last check: make sure it passes the regexp test, if the
-          # user asked for that.  We have to do it here, so that the
-          # test can match against information in the header as well
-          # as in the text of the log message.
-
-          # How annoying to duplicate so much code just because I
-          # can't figure out a way to evaluate scalars on the trailing
-          # operator portion of a regular expression.  Grrr.
-          if ($Case_Insensitive) {
-            unless ($Regexp_Gate && ($wholething !~ /$Regexp_Gate/oi)) {
-              print LOG_OUT "${wholething}\n";
-            }
-          }
-          else {
-            unless ($Regexp_Gate && ($wholething !~ /$Regexp_Gate/o)) {
-              print LOG_OUT "${wholething}\n";
-            }
-          }
-        }
-      }
-    }
-
-    if ($XML_Output) {
-      print LOG_OUT "</changelog>\n";
-    }
-
-    close (LOG_OUT);
-
-    if (! $Output_To_Stdout)
-    {
-      # If accumulating, append old data to new before renaming.  But
-      # don't append the most recent entry, since it's already in the
-      # new log due to CVS's idiosyncratic interpretation of "log -d".
-      if ($Cumulative && -f $logfile_here)
-      {
-        open (NEW_LOG, ">>$tmpfile")
-            or die "trouble appending to $tmpfile ($!)";
-
-        open (OLD_LOG, "<$logfile_here")
-            or die "trouble reading from $logfile_here ($!)";
-
-        my $started_first_entry = 0;
-        my $passed_first_entry = 0;
-        while (<OLD_LOG>)
-        {
-          if (! $passed_first_entry)
-          {
-            if ((! $started_first_entry)
-                && /^(\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d)/) {
-              $started_first_entry = 1;
-            }
-            elsif (/^(\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d)/) {
-              $passed_first_entry = 1;
-              print NEW_LOG $_;
-            }
-          }
-          else {
-            print NEW_LOG $_;
-          }
-        }
-
-        close (NEW_LOG);
-        close (OLD_LOG);
-      }
-
-      if (-f $logfile_here) {
-        rename ($logfile_here, $logfile_bak);
-      }
-      rename ($tmpfile, $logfile_here);
-    }
-  }
-}
-
-
-sub parse_date_and_author ()
-{
-  # Parses the date/time and author out of a line like:
-  #
-  # date: 1999/02/19 23:29:05;  author: apharris;  state: Exp;
-
-  my $line = shift;
-
-  my ($year, $mon, $mday, $hours, $min, $secs, $author) = $line =~
-      m#(\d+)/(\d+)/(\d+)\s+(\d+):(\d+):(\d+);\s+author:\s+([^;]+);#
-          or  die "Couldn't parse date ``$line''";
-  die "Bad date or Y2K issues" unless ($year > 1969 and $year < 2258);
-  # Kinda arbitrary, but useful as a sanity check
-  my $time = timegm($secs,$min,$hours,$mday,$mon-1,$year-1900);
-
-  return ($time, $author);
-}
-
-
-# Here we take a bunch of qunks and convert them into printed
-# summary that will include all the information the user asked for.
-sub pretty_file_list ()
-{
-  if ($Hide_Filenames and (! $XML_Output)) {
-    return "";
-  }
-
-  my $qunksref = shift;
-  my @qunkrefs = @$qunksref;
-  my @filenames;
-  my $beauty = "";          # The accumulating header string for this entry.
-  my %non_unanimous_tags;   # Tags found in a proper subset of qunks
-  my %unanimous_tags;       # Tags found in all qunks
-  my %all_branches;         # Branches found in any qunk
-  my $common_dir = undef;   # Dir prefix common to all files ("" if none)
-  my $fbegun = 0;           # Did we begin printing filenames yet?
-
-  # First, loop over the qunks gathering all the tag/branch names.
-  # We'll put them all in non_unanimous_tags, and take out the
-  # unanimous ones later.
- QUNKREF:
-  foreach my $qunkref (@qunkrefs)
-  {
-    ## MJP: 19.xii.01 : Exclude @ignore_tags
-    for my $ignore_tag (@ignore_tags) {
-      next QUNKREF
-        if grep $_ eq $ignore_tag, @{$$qunkref{'tags'}};
-    }
-    ## MJP: 19.xii.01 : End exclude @ignore_tags
-
-    # Keep track of whether all the files in this commit were in the
-    # same directory, and memorize it if so.  We can make the output a
-    # little more compact by mentioning the directory only once.
-    if ((scalar (@qunkrefs)) > 1)
-    {
-      if (! (defined ($common_dir)))
-      {
-        my ($base, $dir);
-        ($base, $dir, undef) = fileparse ($$qunkref{'filename'});
-
-        if ((! (defined ($dir)))  # this first case is sheer paranoia
-            or ($dir eq "")
-            or ($dir eq "./")
-            or ($dir eq ".\\"))
-        {
-          $common_dir = "";
-        }
-        else
-        {
-          $common_dir = $dir;
-        }
-      }
-      elsif ($common_dir ne "")
-      {
-        # Already have a common dir prefix, so how much of it can we preserve?
-        $common_dir = &common_path_prefix ($$qunkref{'filename'}, $common_dir);
-      }
-    }
-    else  # only one file in this entry anyway, so common dir not an issue
-    {
-      $common_dir = "";
-    }
-
-    if (defined ($$qunkref{'branch'})) {
-      $all_branches{$$qunkref{'branch'}} = 1;
-    }
-    if (defined ($$qunkref{'tags'})) {
-      foreach my $tag (@{$$qunkref{'tags'}}) {
-        $non_unanimous_tags{$tag} = 1;
-      }
-    }
-  }
-
-  # Any tag held by all qunks will be printed specially... but only if
-  # there are multiple qunks in the first place!
-  if ((scalar (@qunkrefs)) > 1) {
-    foreach my $tag (keys (%non_unanimous_tags)) {
-      my $everyone_has_this_tag = 1;
-      foreach my $qunkref (@qunkrefs) {
-        if ((! (defined ($$qunkref{'tags'})))
-            or (! (grep ($_ eq $tag, @{$$qunkref{'tags'}})))) {
-          $everyone_has_this_tag = 0;
-        }
-      }
-      if ($everyone_has_this_tag) {
-        $unanimous_tags{$tag} = 1;
-        delete $non_unanimous_tags{$tag};
-      }
-    }
-  }
-
-  if ($XML_Output)
-  {
-    # If outputting XML, then our task is pretty simple, because we
-    # don't have to detect common dir, common tags, branch prefixing,
-    # etc.  We just output exactly what we have, and don't worry about
-    # redundancy or readability.
-
-    foreach my $qunkref (@qunkrefs)
-    {
-      my $filename    = $$qunkref{'filename'};
-      my $revision    = $$qunkref{'revision'};
-      my $tags        = $$qunkref{'tags'};
-      my $branch      = $$qunkref{'branch'};
-      my $branchroots = $$qunkref{'branchroots'};
-
-      $filename = &xml_escape ($filename);   # probably paranoia
-      $revision = &xml_escape ($revision);   # definitely paranoia
-
-      $beauty .= "<file>\n";
-      $beauty .= "<name>${filename}</name>\n";
-      $beauty .= "<revision>${revision}</revision>\n";
-      if ($branch) {
-        $branch   = &xml_escape ($branch);     # more paranoia
-        $beauty .= "<branch>${branch}</branch>\n";
-      }
-      foreach my $tag (@$tags) {
-        $tag = &xml_escape ($tag);  # by now you're used to the paranoia
-        $beauty .= "<tag>${tag}</tag>\n";
-      }
-      foreach my $root (@$branchroots) {
-        $root = &xml_escape ($root);  # which is good, because it will continue
-        $beauty .= "<branchroot>${root}</branchroot>\n";
-      }
-      $beauty .= "</file>\n";
-    }
-
-    # Theoretically, we could go home now.  But as long as we're here,
-    # let's print out the common_dir and utags, as a convenience to
-    # the receiver (after all, earlier code calculated that stuff
-    # anyway, so we might as well take advantage of it).
-
-    if ((scalar (keys (%unanimous_tags))) > 1) {
-      foreach my $utag ((keys (%unanimous_tags))) {
-        $utag = &xml_escape ($utag);   # the usual paranoia
-        $beauty .= "<utag>${utag}</utag>\n";
-      }
-    }
-    if ($common_dir) {
-      $common_dir = &xml_escape ($common_dir);
-      $beauty .= "<commondir>${common_dir}</commondir>\n";
-    }
-
-    # That's enough for XML, time to go home:
-    return $beauty;
-  }
-
-  # Else not XML output, so complexly compactify for chordate
-  # consumption.  At this point we have enough global information
-  # about all the qunks to organize them non-redundantly for output.
-
-  if ($common_dir) {
-    # Note that $common_dir still has its trailing slash
-    $beauty .= "$common_dir: ";
-  }
-
-  if ($Show_Branches)
-  {
-    # For trailing revision numbers.
-    my @brevisions;
-
-    foreach my $branch (keys (%all_branches))
-    {
-      foreach my $qunkref (@qunkrefs)
-      {
-        if ((defined ($$qunkref{'branch'}))
-            and ($$qunkref{'branch'} eq $branch))
-        {
-          if ($fbegun) {
-            # kff todo: comma-delimited in XML too?  Sure.
-            $beauty .= ", ";
-          }
-          else {
-            $fbegun = 1;
-          }
-          my $fname = substr ($$qunkref{'filename'}, length ($common_dir));
-          $beauty .= $fname;
-          $$qunkref{'printed'} = 1;  # Just setting a mark bit, basically
-
-          if ($Show_Tags && (defined @{$$qunkref{'tags'}})) {
-            my @tags = grep ($non_unanimous_tags{$_}, @{$$qunkref{'tags'}});
-
-            if (@tags) {
-              $beauty .= " (tags: ";
-              $beauty .= join (', ', @tags);
-              $beauty .= ")";
-            }
-          }
-
-          if ($Show_Revisions) {
-            # Collect the revision numbers' last components, but don't
-            # print them -- they'll get printed with the branch name
-            # later.
-            $$qunkref{'revision'} =~ /.+\.([\d]+)$/;
-            push (@brevisions, $1);
-
-            # todo: we're still collecting branch roots, but we're not
-            # showing them anywhere.  If we do show them, it would be
-            # nifty to just call them revision "0" on a the branch.
-            # Yeah, that's the ticket.
-          }
-        }
-      }
-      $beauty .= " ($branch";
-      if (@brevisions) {
-        if ((scalar (@brevisions)) > 1) {
-          $beauty .= ".[";
-          $beauty .= (join (',', @brevisions));
-          $beauty .= "]";
-        }
-        else {
-          $beauty .= ".[$brevisions[0]]";
-        }
-      }
-      $beauty .= ")";
-    }
-  }
-
-  # Okay; any qunks that were done according to branch are taken care
-  # of, and marked as printed.  Now print everyone else.
-
-  foreach my $qunkref (@qunkrefs)
-  {
-    next if (defined ($$qunkref{'printed'}));   # skip if already printed
-
-    if ($fbegun) {
-      $beauty .= ", ";
-    }
-    else {
-      $fbegun = 1;
-    }
-    $beauty .= substr ($$qunkref{'filename'}, length ($common_dir));
-    # todo: Shlomo's change was this:
-    # $beauty .= substr ($$qunkref{'filename'},
-    #              (($common_dir eq "./") ? "" : length ($common_dir)));
-    $$qunkref{'printed'} = 1;  # Set a mark bit.
-
-    if ($Show_Revisions || $Show_Tags)
-    {
-      my $started_addendum = 0;
-
-      if ($Show_Revisions) {
-        $started_addendum = 1;
-        $beauty .= " (";
-        $beauty .= "$$qunkref{'revision'}";
-      }
-      if ($Show_Tags && (defined $$qunkref{'tags'})) {
-        my @tags = grep ($non_unanimous_tags{$_}, @{$$qunkref{'tags'}});
-        if ((scalar (@tags)) > 0) {
-          if ($started_addendum) {
-            $beauty .= ", ";
-          }
-          else {
-            $beauty .= " (tags: ";
-          }
-          $beauty .= join (', ', @tags);
-          $started_addendum = 1;
-        }
-      }
-      if ($started_addendum) {
-        $beauty .= ")";
-      }
-    }
-  }
-
-  # Unanimous tags always come last.
-  if ($Show_Tags && %unanimous_tags)
-  {
-    $beauty .= " (utags: ";
-    $beauty .= join (', ', sort keys (%unanimous_tags));
-    $beauty .= ")";
-  }
-
-  # todo: still have to take care of branch_roots?
-
-  $beauty = "* $beauty:";
-
-  return $beauty;
-}
-
-
-sub common_path_prefix ()
-{
-  my $path1 = shift;
-  my $path2 = shift;
-
-  my ($dir1, $dir2);
-  (undef, $dir1, undef) = fileparse ($path1);
-  (undef, $dir2, undef) = fileparse ($path2);
-
-  # Transmogrify Windows filenames to look like Unix.
-  # (It is far more likely that someone is running cvs2cl.pl under
-  # Windows than that they would genuinely have backslashes in their
-  # filenames.)
-  $dir1 =~ tr#\\#/#;
-  $dir2 =~ tr#\\#/#;
-
-  my $accum1 = "";
-  my $accum2 = "";
-  my $last_common_prefix = "";
-
-  while ($accum1 eq $accum2)
-  {
-    $last_common_prefix = $accum1;
-    last if ($accum1 eq $dir1);
-    my ($tmp1) = split (/\//, (substr ($dir1, length ($accum1))));
-    my ($tmp2) = split (/\//, (substr ($dir2, length ($accum2))));
-    $accum1 .= "$tmp1/" if (defined $tmp1 and $tmp1 ne '');
-    $accum2 .= "$tmp2/" if (defined $tmp2 and $tmp2 ne '');
-  }
-
-  return $last_common_prefix;
-}
-
-
-sub preprocess_msg_text ()
-{
-  my $text = shift;
-
-  # Strip out carriage returns (as they probably result from DOSsy editors).
-  $text =~ s/\r\n/\n/g;
-
-  # If it *looks* like two newlines, make it *be* two newlines:
-  $text =~ s/\n\s*\n/\n\n/g;
-
-  if ($XML_Output)
-  {
-    $text = &xml_escape ($text);
-    $text = "<msg>${text}</msg>\n";
-  }
-  elsif (! $No_Wrap)
-  {
-    # Strip off lone newlines, but only for lines that don't begin with
-    # whitespace or a mail-quoting character, since we want to preserve
-    # that kind of formatting.  Also don't strip newlines that follow a
-    # period; we handle those specially next.  And don't strip
-    # newlines that precede an open paren.
-    1 while ($text =~ s/(^|\n)([^>\s].*[^.\n])\n([^>\n])/$1$2 $3/g);
-
-    # If a newline follows a period, make sure that when we bring up the
-    # bottom sentence, it begins with two spaces.
-    1 while ($text =~ s/(^|\n)([^>\s].*)\n([^>\n])/$1$2  $3/g);
-  }
-
-  return $text;
-}
-
-
-sub last_line_len ()
-{
-  my $files_list = shift;
-  my @lines = split (/\n/, $files_list);
-  my $last_line = pop (@lines);
-  return length ($last_line);
-}
-
-
-# A custom wrap function, sensitive to some common constructs used in
-# log entries.
-sub wrap_log_entry ()
-{
-  my $text = shift;                  # The text to wrap.
-  my $left_pad_str = shift;          # String to pad with on the left.
-
-  # These do NOT take left_pad_str into account:
-  my $length_remaining = shift;      # Amount left on current line.
-  my $max_line_length  = shift;      # Amount left for a blank line.
-
-  my $wrapped_text = "";             # The accumulating wrapped entry.
-  my $user_indent = "";              # Inherited user_indent from prev line.
-
-  my $first_time = 1;                # First iteration of the loop?
-  my $suppress_line_start_match = 0; # Set to disable line start checks.
-
-  my @lines = split (/\n/, $text);
-  while (@lines)   # Don't use `foreach' here, it won't work.
-  {
-    my $this_line = shift (@lines);
-    chomp $this_line;
-
-    if ($this_line =~ /^(\s+)/) {
-      $user_indent = $1;
-    }
-    else {
-      $user_indent = "";
-    }
-
-    # If it matches any of the line-start regexps, print a newline now...
-    if ($suppress_line_start_match)
-    {
-      $suppress_line_start_match = 0;
-    }
-    elsif (($this_line =~ /^(\s*)\*\s+[a-zA-Z0-9]/)
-           || ($this_line =~ /^(\s*)\* [a-zA-Z0-9_\.\/\+-]+/)
-           || ($this_line =~ /^(\s*)\([a-zA-Z0-9_\.\/\+-]+(\)|,\s*)/)
-           || ($this_line =~ /^(\s+)(\S+)/)
-           || ($this_line =~ /^(\s*)- +/)
-           || ($this_line =~ /^()\s*$/)
-           || ($this_line =~ /^(\s*)\*\) +/)
-           || ($this_line =~ /^(\s*)[a-zA-Z0-9](\)|\.|\:) +/))
-    {
-      # Make a line break immediately, unless header separator is set
-      # and this line is the first line in the entry, in which case
-      # we're getting the blank line for free already and shouldn't
-      # add an extra one.
-      unless (($After_Header ne " ") and ($first_time))
-      {
-        if ($this_line =~ /^()\s*$/) {
-          $suppress_line_start_match = 1;
-          $wrapped_text .= "\n${left_pad_str}";
-        }
-
-        $wrapped_text .= "\n${left_pad_str}";
-      }
-
-      $length_remaining = $max_line_length - (length ($user_indent));
-    }
-
-    # Now that any user_indent has been preserved, strip off leading
-    # whitespace, so up-folding has no ugly side-effects.
-    $this_line =~ s/^\s*//;
-
-    # Accumulate the line, and adjust parameters for next line.
-    my $this_len = length ($this_line);
-    if ($this_len == 0)
-    {
-      # Blank lines should cancel any user_indent level.
-      $user_indent = "";
-      $length_remaining = $max_line_length;
-    }
-    elsif ($this_len >= $length_remaining) # Line too long, try breaking it.
-    {
-      # Walk backwards from the end.  At first acceptable spot, break
-      # a new line.
-      my $idx = $length_remaining - 1;
-      if ($idx < 0) { $idx = 0 };
-      while ($idx > 0)
-      {
-        if (substr ($this_line, $idx, 1) =~ /\s/)
-        {
-          my $line_now = substr ($this_line, 0, $idx);
-          my $next_line = substr ($this_line, $idx);
-          $this_line = $line_now;
-
-          # Clean whitespace off the end.
-          chomp $this_line;
-
-          # The current line is ready to be printed.
-          $this_line .= "\n${left_pad_str}";
-
-          # Make sure the next line is allowed full room.
-          $length_remaining = $max_line_length - (length ($user_indent));
-
-          # Strip next_line, but then preserve any user_indent.
-          $next_line =~ s/^\s*//;
-
-          # Sneak a peek at the user_indent of the upcoming line, so
-          # $next_line (which will now precede it) can inherit that
-          # indent level.  Otherwise, use whatever user_indent level
-          # we currently have, which might be none.
-          my $next_next_line = shift (@lines);
-          if ((defined ($next_next_line)) && ($next_next_line =~ /^(\s+)/)) {
-            $next_line = $1 . $next_line if (defined ($1));
-            # $length_remaining = $max_line_length - (length ($1));
-            $next_next_line =~ s/^\s*//;
-          }
-          else {
-            $next_line = $user_indent . $next_line;
-          }
-          if (defined ($next_next_line)) {
-            unshift (@lines, $next_next_line);
-          }
-          unshift (@lines, $next_line);
-
-          # Our new next line might, coincidentally, begin with one of
-          # the line-start regexps, so we temporarily turn off
-          # sensitivity to that until we're past the line.
-          $suppress_line_start_match = 1;
-
-          last;
-        }
-        else
-        {
-          $idx--;
-        }
-      }
-
-      if ($idx == 0)
-      {
-        # We bottomed out because the line is longer than the
-        # available space.  But that could be because the space is
-        # small, or because the line is longer than even the maximum
-        # possible space.  Handle both cases below.
-
-        if ($length_remaining == ($max_line_length - (length ($user_indent))))
-        {
-          # The line is simply too long -- there is no hope of ever
-          # breaking it nicely, so just insert it verbatim, with
-          # appropriate padding.
-          $this_line = "\n${left_pad_str}${this_line}";
-        }
-        else
-        {
-          # Can't break it here, but may be able to on the next round...
-          unshift (@lines, $this_line);
-          $length_remaining = $max_line_length - (length ($user_indent));
-          $this_line = "\n${left_pad_str}";
-        }
-      }
-    }
-    else  # $this_len < $length_remaining, so tack on what we can.
-    {
-      # Leave a note for the next iteration.
-      $length_remaining = $length_remaining - $this_len;
-
-      if ($this_line =~ /\.$/)
-      {
-        $this_line .= "  ";
-        $length_remaining -= 2;
-      }
-      else  # not a sentence end
-      {
-        $this_line .= " ";
-        $length_remaining -= 1;
-      }
-    }
-
-    # Unconditionally indicate that loop has run at least once.
-    $first_time = 0;
-
-    $wrapped_text .= "${user_indent}${this_line}";
-  }
-
-  # One last bit of padding.
-  $wrapped_text .= "\n";
-
-  return $wrapped_text;
-}
-
-
-sub xml_escape ()
-{
-  my $txt = shift;
-  $txt =~ s/&/&amp;/g;
-  $txt =~ s/</&lt;/g;
-  $txt =~ s/>/&gt;/g;
-  return $txt;
-}
-
-
-sub maybe_read_user_map_file ()
-{
-  my %expansions;
-
-  if ($User_Map_File)
-  {
-    open (MAPFILE, "<$User_Map_File")
-        or die ("Unable to open $User_Map_File ($!)");
-
-    while (<MAPFILE>)
-    {
-      next if /^\s*#/;  # Skip comment lines.
-      next if not /:/;  # Skip lines without colons.
-
-      # It is now safe to split on ':'.
-      my ($username, $expansion) = split ':';
-      chomp $expansion;
-      $expansion =~ s/^'(.*)'$/$1/;
-      $expansion =~ s/^"(.*)"$/$1/;
-
-      # If it looks like the expansion has a real name already, then
-      # we toss the username we got from CVS log.  Otherwise, keep
-      # it to use in combination with the email address.
-
-      if ($expansion =~ /^\s*<{0,1}\S+ at .*/) {
-        # Also, add angle brackets if none present
-        if (! ($expansion =~ /<\S+@\S+>/)) {
-          $expansions{$username} = "$username <$expansion>";
-        }
-        else {
-          $expansions{$username} = "$username $expansion";
-        }
-      }
-      else {
-        $expansions{$username} = $expansion;
-      }
-    }
-
-    close (MAPFILE);
-  }
-
-  return %expansions;
-}
-
-
-sub parse_options ()
-{
-  # Check this internally before setting the global variable.
-  my $output_file;
-
-  # If this gets set, we encountered unknown options and will exit at
-  # the end of this subroutine.
-  my $exit_with_admonishment = 0;
-
-  while (my $arg = shift (@ARGV))
-  {
-    if ($arg =~ /^-h$|^-help$|^--help$|^--usage$|^-?$/) {
-      $Print_Usage = 1;
-    }
-    elsif ($arg =~ /^--delta$/) {
-      my $narg = shift(@ARGV) || die "$arg needs argument.\n";
-      if ($narg =~ /^([A-Za-z][A-Za-z0-9_\-]*):([A-Za-z][A-Za-z0-9_\-]*)$/) {
-	$Delta_From = $1;
-	$Delta_To = $2;
-	$Delta_Mode = 1;
-      } else {
-	die "--delta FROM_TAG:TO_TAG is what you meant to say.\n";
-      }
-    }
-    elsif ($arg =~ /^--debug$/) {        # unadvertised option, heh
-      $Debug = 1;
-    }
-    elsif ($arg =~ /^--version$/) {
-      $Print_Version = 1;
-    }
-    elsif ($arg =~ /^-g$|^--global-opts$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      # Don't assume CVS is called "cvs" on the user's system:
-      $Log_Source_Command =~ s/(^\S*)/$1 $narg/;
-    }
-    elsif ($arg =~ /^-l$|^--log-opts$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      $Log_Source_Command .= " $narg";
-    }
-    elsif ($arg =~ /^-f$|^--file$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      $output_file = $narg;
-    }
-    elsif ($arg =~ /^--accum$/) {
-      $Cumulative = 1;
-    }
-    elsif ($arg =~ /^--fsf$/) {
-      $FSF_Style = 1;
-    }
-    elsif ($arg =~ /^-U$|^--usermap$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      $User_Map_File = $narg;
-    }
-    elsif ($arg =~ /^-W$|^--window$/) {
-      defined(my $narg = shift (@ARGV)) || die "$arg needs argument.\n";
-      $Max_Checkin_Duration = $narg;
-    }
-    elsif ($arg =~ /^-I$|^--ignore$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      push (@Ignore_Files, $narg);
-    }
-    elsif ($arg =~ /^-C$|^--case-insensitive$/) {
-      $Case_Insensitive = 1;
-    }
-    elsif ($arg =~ /^-R$|^--regexp$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      $Regexp_Gate = $narg;
-    }
-    elsif ($arg =~ /^--stdout$/) {
-      $Output_To_Stdout = 1;
-    }
-    elsif ($arg =~ /^--version$/) {
-      $Print_Version = 1;
-    }
-    elsif ($arg =~ /^-d$|^--distributed$/) {
-      $Distributed = 1;
-    }
-    elsif ($arg =~ /^-P$|^--prune$/) {
-      $Prune_Empty_Msgs = 1;
-    }
-    elsif ($arg =~ /^-S$|^--separate-header$/) {
-      $After_Header = "\n\n";
-    }
-    elsif ($arg =~ /^--no-wrap$/) {
-      $No_Wrap = 1;
-    }
-    elsif ($arg =~ /^--gmt$|^--utc$/) {
-      $UTC_Times = 1;
-    }
-    elsif ($arg =~ /^-w$|^--day-of-week$/) {
-      $Show_Day_Of_Week = 1;
-    }
-    elsif ($arg =~ /^-r$|^--revisions$/) {
-      $Show_Revisions = 1;
-    }
-    elsif ($arg =~ /^-t$|^--tags$/) {
-      $Show_Tags = 1;
-    }
-    elsif ($arg =~ /^-T$|^--tagdates$/) {
-      $Show_Tag_Dates = 1;
-    }
-    elsif ($arg =~ /^-b$|^--branches$/) {
-      $Show_Branches = 1;
-    }
-    elsif ($arg =~ /^-F$|^--follow$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      push (@Follow_Branches, $narg);
-    }
-    elsif ($arg =~ /^--stdin$/) {
-      $Input_From_Stdin = 1;
-    }
-    elsif ($arg =~ /^--header$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      $ChangeLog_Header = &slurp_file ($narg);
-      if (! defined ($ChangeLog_Header)) {
-        $ChangeLog_Header = "";
-      }
-    }
-    elsif ($arg =~ /^--xml-encoding$/) {
-      my $narg = shift (@ARGV) || die "$arg needs argument.\n";
-      $XML_Encoding = $narg ;
-    }
-    elsif ($arg =~ /^--xml$/) {
-      $XML_Output = 1;
-    }
-    elsif ($arg =~ /^--hide-filenames$/) {
-      $Hide_Filenames = 1;
-      $After_Header = "";
-    }
-    elsif ($arg =~ /^--ignore-tag$/ ) {
-      die "$arg needs argument.\n"
-        unless @ARGV;
-      push @ignore_tags, shift @ARGV;
-    }
-    else {
-      # Just add a filename as argument to the log command
-      $Log_Source_Command .= " '$arg'";
-    }
-  }
-
-  ## Check for contradictions...
-
-  if ($Output_To_Stdout && $Distributed) {
-    print STDERR "cannot pass both --stdout and --distributed\n";
-    $exit_with_admonishment = 1;
-  }
-
-  if ($Output_To_Stdout && $output_file) {
-    print STDERR "cannot pass both --stdout and --file\n";
-    $exit_with_admonishment = 1;
-  }
-
-  if ($XML_Output && $Cumulative) {
-    print STDERR "cannot pass both --xml and --accum\n";
-    $exit_with_admonishment = 1;
-  }
-
-  # Or if any other error message has already been printed out, we
-  # just leave now:
-  if ($exit_with_admonishment) {
-    &usage ();
-    exit (1);
-  }
-  elsif ($Print_Usage) {
-    &usage ();
-    exit (0);
-  }
-  elsif ($Print_Version) {
-    &version ();
-    exit (0);
-  }
-
-  ## Else no problems, so proceed.
-
-  if ($output_file) {
-    $Log_File_Name = $output_file;
-  }
-}
-
-
-sub slurp_file ()
-{
-  my $filename = shift || die ("no filename passed to slurp_file()");
-  my $retstr;
-
-  open (SLURPEE, "<${filename}") or die ("unable to open $filename ($!)");
-  my $saved_sep = $/;
-  undef $/;
-  $retstr = <SLURPEE>;
-  $/ = $saved_sep;
-  close (SLURPEE);
-  return $retstr;
-}
-
-
-sub debug ()
-{
-  if ($Debug) {
-    my $msg = shift;
-    print STDERR $msg;
-  }
-}
-
-
-sub version ()
-{
-  print "cvs2cl.pl version ${VERSION}; distributed under the GNU GPL.\n";
-}
-
-
-sub usage ()
-{
-  &version ();
-  print <<'END_OF_INFO';
-Generate GNU-style ChangeLogs in CVS working copies.
-
-Notes about the output format(s):
-
-   The default output of cvs2cl.pl is designed to be compact, formally
-   unambiguous, but still easy for humans to read.  It is largely
-   self-explanatory, I hope; the one abbreviation that might not be
-   obvious is "utags".  That stands for "universal tags" -- a
-   universal tag is one held by all the files in a given change entry.
-
-   If you need output that's easy for a program to parse, use the
-   --xml option.  Note that with XML output, just about all available
-   information is included with each change entry, whether you asked
-   for it or not, on the theory that your parser can ignore anything
-   it's not looking for.
-
-Notes about the options and arguments (the actual options are listed
-last in this usage message):
-
-  * The -I and -F options may appear multiple times.
-
-  * To follow trunk revisions, use "-F trunk" ("-F TRUNK" also works).
-    This is okay because no would ever, ever be crazy enough to name a
-    branch "trunk", right?  Right.
-
-  * For the -U option, the UFILE should be formatted like
-    CVSROOT/users. That is, each line of UFILE looks like this
-       jrandom:jrandom at red-bean.com
-    or maybe even like this
-       jrandom:'Jesse Q. Random <jrandom at red-bean.com>'
-    Don't forget to quote the portion after the colon if necessary.
-
-  * Many people want to filter by date.  To do so, invoke cvs2cl.pl
-    like this:
-       cvs2cl.pl -l "-d'DATESPEC'"
-    where DATESPEC is any date specification valid for "cvs log -d".
-    (Note that CVS 1.10.7 and below requires there be no space between
-    -d and its argument).
-
-Options/Arguments:
-
-  -h, -help, --help, or -?     Show this usage and exit
-  --version                    Show version and exit
-  -r, --revisions              Show revision numbers in output
-  -b, --branches               Show branch names in revisions when possible
-  -t, --tags                   Show tags (symbolic names) in output
-  -T, --tagdates               Show tags in output on their first occurance
-  --stdin                      Read from stdin, don't run cvs log
-  --stdout                     Output to stdout not to ChangeLog
-  -d, --distributed            Put ChangeLogs in subdirs
-  -f FILE, --file FILE         Write to FILE instead of "ChangeLog"
-  --fsf                        Use this if log data is in FSF ChangeLog style
-  -W SECS, --window SECS       Window of time within which log entries unify
-  -U UFILE, --usermap UFILE    Expand usernames to email addresses from UFILE
-  -R REGEXP, --regexp REGEXP   Include only entries that match REGEXP
-  -I REGEXP, --ignore REGEXP   Ignore files whose names match REGEXP
-  -C, --case-insensitive       Any regexp matching is done case-insensitively
-  -F BRANCH, --follow BRANCH   Show only revisions on or ancestral to BRANCH
-  -S, --separate-header        Blank line between each header and log message
-  --no-wrap                    Don't auto-wrap log message (recommend -S also)
-  --gmt, --utc                 Show times in GMT/UTC instead of local time
-  --accum                      Add to an existing ChangeLog (incompat w/ --xml)
-  -w, --day-of-week            Show day of week
-  --header FILE                Get ChangeLog header from FILE ("-" means stdin)
-  --xml                        Output XML instead of ChangeLog format
-  --xml-encoding ENCODING      Insert encoding clause in XML header
-  --hide-filenames             Don't show filenames (ignored for XML output)
-  -P, --prune                  Don't show empty log messages
-  -g OPTS, --global-opts OPTS  Invoke like this "cvs OPTS log ..."
-  -l OPTS, --log-opts OPTS     Invoke like this "cvs ... log OPTS"
-  FILE1 [FILE2 ...]            Show only log information for the named FILE(s)
-
-See http://www.red-bean.com/cvs2cl for maintenance and bug info.
-END_OF_INFO
-}
-
-__END__
-
-=head1 NAME
-
-cvs2cl.pl - produces GNU-style ChangeLogs in CVS working copies, by
-    running "cvs log" and parsing the output.  Shared log entries are
-    unified in an intuitive way.
-
-=head1 DESCRIPTION
-
-This script generates GNU-style ChangeLog files from CVS log
-information.  Basic usage: just run it inside a working copy and a
-ChangeLog will appear.  It requires repository access (i.e., 'cvs log'
-must work).  Run "cvs2cl.pl --help" to see more advanced options.
-
-See http://www.red-bean.com/cvs2cl for updates, and for instructions
-on getting anonymous CVS access to this script.
-
-Maintainer: Karl Fogel <kfogel at red-bean.com>
-Please report bugs to <bug-cvs2cl at red-bean.com>.
-
-=head1 README
-
-This script generates GNU-style ChangeLog files from CVS log
-information.  Basic usage: just run it inside a working copy and a
-ChangeLog will appear.  It requires repository access (i.e., 'cvs log'
-must work).  Run "cvs2cl.pl --help" to see more advanced options.
-
-See http://www.red-bean.com/cvs2cl for updates, and for instructions
-on getting anonymous CVS access to this script.
-
-Maintainer: Karl Fogel <kfogel at red-bean.com>
-Please report bugs to <bug-cvs2cl at red-bean.com>.
-
-=head1 PREREQUISITES
-
-This script requires C<Text::Wrap>, C<Time::Local>, and
-C<File::Basename>.
-It also seems to require C<Perl 5.004_04> or higher.
-
-=pod OSNAMES
-
-any
-
-=pod SCRIPT CATEGORIES
-
-Version_Control/CVS
-
-=cut
-
-
--*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*-
-
-Note about a bug-slash-opportunity:
------------------------------------
-
-There's a bug in Text::Wrap, which affects cvs2cl.  This script
-reveals it:
-
-  #!/usr/bin/perl -w
-
-  use Text::Wrap;
-
-  my $test_text =
-  "This script demonstrates a bug in Text::Wrap.  The very long line
-  following this paragraph will be relocated relative to the surrounding
-  text:
-
-  ====================================================================
-
-  See?  When the bug happens, we'll get the line of equal signs below
-  this paragraph, even though it should be above.";
-
-
-  # Print out the test text with no wrapping:
-  print "$test_text";
-  print "\n";
-  print "\n";
-
-  # Now print it out wrapped, and see the bug:
-  print wrap ("\t", "        ", "$test_text");
-  print "\n";
-  print "\n";
-
-If the line of equal signs were one shorter, then the bug doesn't
-happen.  Interesting.
-
-Anyway, rather than fix this in Text::Wrap, we might as well write a
-new wrap() which has the following much-needed features:
-
-* initial indentation, like current Text::Wrap()
-* subsequent line indentation, like current Text::Wrap()
-* user chooses among: force-break long words, leave them alone, or die()?
-* preserve existing indentation: chopped chunks from an indented line
-  are indented by same (like this line, not counting the asterisk!)
-* optional list of things to preserve on line starts, default ">"
-
-Note that the last two are essentially the same concept, so unify in
-implementation and give a good interface to controlling them.
-
-And how about:
-
-Optionally, when encounter a line pre-indented by same as previous
-line, then strip the newline and refill, but indent by the same.
-Yeah...

Modified: upwatch/libdbi/common/Makefile.am
===================================================================
--- upwatch/libdbi/common/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/common/Makefile.am	2006-07-21 23:12:45 UTC (rev 633)
@@ -2,6 +2,5 @@
 
 EXTRA_DIST = db.c generic_options.def dbase_options.def \
   main.c man1.tpl spec.tpl init.tpl minimal_options.def \
-  probe.tpl probe_generic.def common.h license_proprietary.def \
-  license_gpl.def
+  probe.tpl probe_generic.def common.h license_gpl.def
 

Deleted: upwatch/libdbi/common/license_proprietary.def
===================================================================
--- upwatch/libdbi/common/license_proprietary.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/common/license_proprietary.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,9 +0,0 @@
-copyright = {
-  date = "2002-2004";
-  author=  "Ron Arts";
-  owner = "Upwatch BV";
-  eaddr = "info at upwatch.com";
-  type = "NOTE";
-  text = 
-'Redistribution Prohibited. Violation will be prosecuted to the maximum extent possible by applicable law.';
-};

Modified: upwatch/libdbi/common/probe.tpl
===================================================================
--- upwatch/libdbi/common/probe.tpl	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/common/probe.tpl	2006-07-21 23:12:45 UTC (rev 633)
@@ -24,7 +24,7 @@
   delay int unsigned NOT NULL default '1',	-- after this many minutes of red light
   disable enum('yes', 'no') not null default 'no', -- disable this probe
   hide enum('yes', 'no') not null default 'no', -- hide probe results from viewing
-  ipaddress varchar(15) NOT NULL default '127.0.0.1',	-- target ipaddress 
+  ipaddress varchar(128) NOT NULL default '127.0.0.1',	-- target ipaddress or hostname
   description text NOT NULL default '',		-- description
   freq smallint unsigned NOT NULL default '1',	-- frequency in minutes
   yellow float NOT NULL default '[+yellow+]',	-- value for yellow alert

Modified: upwatch/libdbi/compat/Makefile.am
===================================================================
--- upwatch/libdbi/compat/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/compat/Makefile.am	2006-07-21 23:12:45 UTC (rev 633)
@@ -2,4 +2,4 @@
 SERVERONLY = bb
 endif
 
-SUBDIRS = ${SERVERONLY} sometests
+SUBDIRS = ${SERVERONLY}

Modified: upwatch/libdbi/configure.ac
===================================================================
--- upwatch/libdbi/configure.ac	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/configure.ac	2006-07-21 23:12:45 UTC (rev 633)
@@ -7,6 +7,7 @@
 AM_INIT_AUTOMAKE($PACKAGE,$VERSION)
 AM_CONFIG_HEADER(config.h:config-h.in)
 AC_SUBST(VERSION)
+AM_PROG_AS
 
 AC_DEFINE_UNQUOTED([RELEASE], ["${RELEASE}"], [Package release string])
 
@@ -58,88 +59,89 @@
     if test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/include' ; fi
     if test "$infodir" = '${prefix}/info' ; 		then infodir='/usr/share/info' ; fi
     if test "$mandir" = '${prefix}/man' ;		then mandir='/usr/share/man' ; fi
+    LDFLAGS="${LDFLAGS} -L/usr/lib64"
     ;;
   *-*-freebsd*) 
     freebsd=true
-    if test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/bin' ; fi
-    if test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/sbin' ; fi
-    if test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/libexec' ; fi
-    if test "$datadir" = '${prefix}/share' ;		then datadir='/usr/local/share' ; fi
-    if test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/etc' ; fi
-    if test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
-    if test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
-    if test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/lib' ; fi
-    if test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/include' ; fi
-    if test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/include' ; fi
-    if test "$infodir" = '${prefix}/info' ; 		then infodir='/usr/share/info' ; fi
-    if test "$mandir" = '${prefix}/man' ;		then mandir='/usr/share/man' ; fi
+    if ! test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr//local/bin' ; fi
+    if ! test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/local/sbin' ; fi
+    if ! test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/local/libexec' ; fi
+    if ! test "$datadir" = '${prefix}/share' ;		then datadir='/usr/local/share' ; fi
+    if ! test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/usr/local/etc' ; fi
+    if ! test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
+    if ! test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
+    if ! test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/local/lib' ; fi
+    if ! test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/local/include' ; fi
+    if ! test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/local/include' ; fi
+    if ! test "$infodir" = '${prefix}/info' ; 		then infodir='/usr/local/share/info' ; fi
+    if ! test "$mandir" = '${prefix}/man' ;		then mandir='/usr/local/share/man' ; fi
     CFLAGS="${CFLAGS} -I/usr/local/include"
     LDFLAGS="-L/usr/local/lib"
     ;;
   *-*-netbsd*) 
     netbsd=true
-    if test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/bin' ; fi
-    if test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/sbin' ; fi
-    if test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/libexec' ; fi
-    if test "$datadir" = '${prefix}/share' ;		then datadir='/usr/local/share' ; fi
-    if test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/etc' ; fi
-    if test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
-    if test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
-    if test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/lib' ; fi
-    if test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/include' ; fi
-    if test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/include' ; fi
-    if test "$infodir" = '${prefix}/info' ; 		then infodir='/usr/share/info' ; fi
-    if test "$mandir" = '${prefix}/man' ;		then mandir='/usr/share/man' ; fi
+    if ! test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/local/bin' ; fi
+    if ! test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/local/sbin' ; fi
+    if ! test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/local/libexec' ; fi
+    if ! test "$datadir" = '${prefix}/share' ;		then datadir='/usr/local/share' ; fi
+    if ! test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/usr/local/etc' ; fi
+    if ! test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
+    if ! test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
+    if ! test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/local/lib' ; fi
+    if ! test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/local/include' ; fi
+    if ! test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/local/include' ; fi
+    if ! test "$infodir" = '${prefix}/info' ; 		then infodir='/usr/local/share/info' ; fi
+    if ! test "$mandir" = '${prefix}/man' ;		then mandir='/usr/local/share/man' ; fi
     CFLAGS="${CFLAGS} -I/usr/local/include -I/usr/pkg/include"
     LDFLAGS="-L/usr/local/lib -L/usr/pkg/lib"
     ;;
   *-*-openbsd*)
     openbsd=true
-    if test "$bindir" = '${exec_prefix}/bin' ;          then bindir='/usr/bin' ; fi
-    if test "$sbindir" = '${exec_prefix}/sbin' ;        then sbindir='/usr/sbin' ; fi
-    if test "$libexecdir" = '${exec_prefix}/libexec';   then libexecdir='/usr/libexec' ; fi
-    if test "$datadir" = '${prefix}/share' ;            then datadir='/usr/local/share' ; fi
-    if test "$sysconfdir" = '${prefix}/etc' ;           then sysconfdir='/etc' ; fi
-    if test "$sharedstatedir" = '${prefix}/com' ;       then sharedstatedir='/usr/local/com' ; fi
-    if test "$localstatedir" = '${prefix}/var' ;        then localstatedir='/var' ; fi
-    if test "$libdir" = '${exec_prefix}/lib' ;          then libdir='/usr/lib' ; fi
-    if test "$includedir" = '${prefix}/include' ;       then includedir='/usr/include' ; fi
-    if test "$oldincludedir" = '/usr/include' ;         then oldincludedir='/usr/include' ; fi
-    if test "$infodir" = '${prefix}/info' ;             then infodir='/usr/share/info' ; fi
-    if test "$mandir" = '${prefix}/man' ;               then mandir='/usr/share/man' ; fi
+    if ! test "$bindir" = '${exec_prefix}/bin' ;          then bindir='/usr/local/bin' ; fi
+    if ! test "$sbindir" = '${exec_prefix}/sbin' ;        then sbindir='/usr/local/sbin' ; fi
+    if ! test "$libexecdir" = '${exec_prefix}/libexec';   then libexecdir='/usr/local/libexec' ; fi
+    if ! test "$datadir" = '${prefix}/share' ;            then datadir='/usr/local/share' ; fi
+    if ! test "$sysconfdir" = '${prefix}/etc' ;           then sysconfdir='/etc' ; fi
+    if ! test "$sharedstatedir" = '${prefix}/com' ;       then sharedstatedir='/usr/local/com' ; fi
+    if ! test "$localstatedir" = '${prefix}/var' ;        then localstatedir='/var' ; fi
+    if ! test "$libdir" = '${exec_prefix}/lib' ;          then libdir='/usr/local/lib' ; fi
+    if ! test "$includedir" = '${prefix}/include' ;       then includedir='/usr/local/include' ; fi
+    if ! test "$oldincludedir" = '/usr/include' ;         then oldincludedir='/usr/local/include' ; fi
+    if ! test "$infodir" = '${prefix}/info' ;             then infodir='/usr/local/share/info' ; fi
+    if ! test "$mandir" = '${prefix}/man' ;               then mandir='/usr/local/share/man' ; fi
     CFLAGS="${CFLAGS} -I/usr/local/include"
     LDFLAGS="-L/usr/local/lib"
     ;;
   *-*-solaris*)
     solaris=true
-    if test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/bin' ; fi
-    if test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/sbin' ; fi
-    if test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/libexec' ; fi
-    if test "$datadir" = '${prefix}/share' ;		then datadir='/usr/share' ; fi
-    if test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/etc' ; fi
-    if test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
-    if test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
-    if test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/local/lib' ; fi
-    if test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/include' ; fi
-    if test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/include' ; fi
-    if test "$infodir" = '${prefix}/info';  		then infodir='/usr/share/info' ; fi
-    if test "$mandir" = '${prefix}/man' ;		then mandir='/usr/share/man' ; fi
+    if ! test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/local/bin' ; fi
+    if ! test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/local/sbin' ; fi
+    if ! test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/local/libexec' ; fi
+    if ! test "$datadir" = '${prefix}/share' ;		then datadir='/usr/local/share' ; fi
+    if ! test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/etc' ; fi
+    if ! test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
+    if ! test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
+    if ! test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/local/lib' ; fi
+    if ! test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/local/include' ; fi
+    if ! test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/local/include' ; fi
+    if ! test "$infodir" = '${prefix}/info';  		then infodir='/usr/local/share/info' ; fi
+    if ! test "$mandir" = '${prefix}/man' ;		then mandir='/usr/local/share/man' ; fi
     LIBS="-lgen ${LIBS}"
     ;;
   *-*-cygwin*)
     cygwin=true
-    if test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/bin' ; fi
-    if test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/sbin' ; fi
-    if test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/libexec' ; fi
-    if test "$datadir" = '${prefix}/share' ;		then datadir='/usr/share' ; fi
-    if test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/etc' ; fi
-    if test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
-    if test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
-    if test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/local/lib' ; fi
-    if test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/include' ; fi
-    if test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/include' ; fi
-    if test "$infodir" = '${prefix}/info';  		then infodir='/usr/share/info' ; fi
-    if test "$mandir" = '${prefix}/man' ;		then mandir='/usr/share/man' ; fi
+    if ! test "$bindir" = '${exec_prefix}/bin' ; 		then bindir='/usr/bin' ; fi
+    if ! test "$sbindir" = '${exec_prefix}/sbin' ; 	then sbindir='/usr/sbin' ; fi
+    if ! test "$libexecdir" = '${exec_prefix}/libexec';	then libexecdir='/usr/libexec' ; fi
+    if ! test "$datadir" = '${prefix}/share' ;		then datadir='/usr/share' ; fi
+    if ! test "$sysconfdir" = '${prefix}/etc' ;		then sysconfdir='/etc' ; fi
+    if ! test "$sharedstatedir" = '${prefix}/com' ;	then sharedstatedir='/usr/local/com' ; fi
+    if ! test "$localstatedir" = '${prefix}/var' ; 	then localstatedir='/var' ; fi
+    if ! test "$libdir" = '${exec_prefix}/lib' ; 		then libdir='/usr/local/lib' ; fi
+    if ! test "$includedir" = '${prefix}/include' ; 	then includedir='/usr/include' ; fi
+    if ! test "$oldincludedir" = '/usr/include' ; 	then oldincludedir='/usr/include' ; fi
+    if ! test "$infodir" = '${prefix}/info';  		then infodir='/usr/share/info' ; fi
+    if ! test "$mandir" = '${prefix}/man' ;		then mandir='/usr/share/man' ; fi
     ;;
   *)
     generic=true
@@ -219,7 +221,11 @@
 then
   enable_server=yes
   enable_monitors=yes
-  enable_iptraf=yes
+  case $host in
+    *-*-linux*)
+    enable_iptraf=yes
+    ;;
+  esac
 fi
 
 AM_CONDITIONAL(ENABLE_SERVER, test x$enable_all = xyes)
@@ -302,6 +308,19 @@
     [MYSQL_LIB_PREFIX=/usr/lib/mysql]
 )
 AC_SUBST(MYSQL_LIB_PREFIX)
+
+for libpath in /usr/lib/mysql $MYSQL_LIB_PREFIX /usr/local/lib/mysql /usr/lib /cygdrive/c/mysql/lib/opt /usr/pkg/lib/mysql /usr/lib64/mysql
+do
+  for file in $libpath/libmysqlclient.so* $libpath/mysqlclient.lib
+  do
+    if test -f $file
+    then
+      MYSQL_LIBS="-L${libpath} -lmysqlclient"
+      break
+    fi
+  done
+done
+
 # path to mysql includes
 AC_ARG_WITH(mysql-include,
     [  --with-mysql-include=<path>        prefix of MySQL headers. Default /usr/include/mysql],
@@ -558,7 +577,7 @@
 if test "$enable_server" = "yes"
 then
 	# libesmtp
-	AC_CHECK_LIB([esmtp], [smtp_create_session], [HAVE_LIBESMTP=1], [HAVE_LIBESMTP=0])
+	AC_CHECK_LIB([esmtp], [smtp_create_session], [HAVE_LIBESMTP=1], [HAVE_LIBESMTP=0], $LIBPTHREAD_LIBS)
 	if test $HAVE_LIBESMTP -eq 1
 	then
 	        LIBESMTP_LIBS=-lesmtp
@@ -707,26 +726,9 @@
 
 if test "$enable_server" = "yes" -o "$enable_monitors" = "yes"
 then
-  AC_CONFIG_FILES([st-1.4/Makefile])
+  AC_CONFIG_FILES([st-1.7/Makefile])
 fi
 
-# server 
-if test "$enable_server" = "yes"
-then
-  AC_CONFIG_FILES([uw_setip/Makefile])
-  AC_CONFIG_FILES([uw_accept/Makefile])
-  AC_CONFIG_FILES([uw_acceptbb/Makefile])
-  AC_CONFIG_FILES([uw_purple/Makefile])
-  AC_CONFIG_FILES([uw_route/Makefile])
-  AC_CONFIG_FILES([uw_process/Makefile])
-  AC_CONFIG_FILES([uw_syncprobes/Makefile])
-  AC_CONFIG_FILES([compat/Makefile])
-  AC_CONFIG_FILES([compat/sometests/Makefile])
-  AC_CONFIG_FILES([compat/sometests/setproctitle/Makefile])
-  AC_CONFIG_FILES([compat/bb/Makefile])
-  AC_CONFIG_FILES([compat/bb/bbhimport/Makefile])
-fi
-
 # monitors
 if test "$enable_monitors" = "yes"
 then
@@ -744,15 +746,29 @@
   AC_CONFIG_FILES([uw_postgresql/Makefile])
 fi
 
-# extra
-if test "$enable_iptraf" = "yes"
+if test "$enable_server" = "yes" -o "$enable_iptraf" = "yes"
 then
 if test $HAVE_LIBPCAP -eq 1; then
   AC_CONFIG_FILES([uw_iptraf/Makefile])
 fi
 fi
 
-( cd libstatgrab ; ./configure --disable-manpages --disable-examples \
+# server 
+if test "$enable_server" = "yes"
+then
+AC_CONFIG_FILES([uw_setip/Makefile])
+AC_CONFIG_FILES([uw_accept/Makefile])
+AC_CONFIG_FILES([uw_acceptbb/Makefile])
+AC_CONFIG_FILES([uw_purple/Makefile])
+AC_CONFIG_FILES([uw_route/Makefile])
+AC_CONFIG_FILES([uw_process/Makefile])
+AC_CONFIG_FILES([uw_syncprobes/Makefile])
+AC_CONFIG_FILES([compat/Makefile])
+AC_CONFIG_FILES([compat/bb/Makefile])
+AC_CONFIG_FILES([compat/bb/bbhimport/Makefile])
+fi
+
+( cd libstatgrab-0.13 ; ./configure --disable-manpages --disable-examples \
   --disable-statgrab --disable-saidar --disable-shared ; cd .. )
 
 if test "$enable_xmbmon" = "yes"

Modified: upwatch/libdbi/doc/about.xml
===================================================================
--- upwatch/libdbi/doc/about.xml	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/doc/about.xml	2006-07-21 23:12:45 UTC (rev 633)
@@ -30,13 +30,15 @@
     <listitem><para>Extensive and complete documentation, partly generated from source</para></listitem>
     <listitem><para>Multi-tenanting: multiple companies can run monitoring services for network
     of multiple client-companies using the same backend+probe serverpark</para></listitem>
-    <listitem><para>OS support: clients available for Linux, Windows, FreeBSD, Solaris, server runs on
-    linux or freeBSD, remote monitoring is linux only.</para></listitem>
+    <listitem><para>OS support: clients available for Linux, OpenBSD, NetBSD, Windows, FreeBSD, Solaris, server runs on
+    Linux, OpenBSD or NetBSD, remote monitoring is linux only.</para></listitem>
     <listitem><para>Monitoring results are in XML, and can be pre- and postprocessed</para></listitem>
-    <listitem><para>Secure: run as ordinary user, developed with security in mind</para></listitem>
+    <listitem><para>Secure: runs mostly as ordinary user, developed with security in mind</para></listitem>
     <listitem><para>Compatible with all Big Brother clients, imports bb-hosts file</para></listitem>
+<!-- We have no GUI
     <listitem><para>GUI is multi-language enabled (uses gettext)</para></listitem>
-    <listitem><para>GUI has mobile client support</para></listitem>
+    <listitem><para>GUI has mobile client support</para></listitem> 
+-->
     <listitem><para>Generates realtime graphs from the database</para></listitem>
     <listitem><para>Notifications by email or SMS.</para></listitem>
     <listitem><para>Clients for: HTTP GET, IMAP, MSSQL, MySQL, PING, POP3, PostgreSQL, SMTP, 
@@ -44,7 +46,8 @@
     <listitem><para>Local client detects: CPU load, loadavg, swap use, I/O use, memory use, and
     where supported hardware info like CPU temperature, fan speed and Power voltages. Also you can
     set it up to scan any logfile using regular expressions you supply.</para></listitem>
-    <listitem><para>Fully opensource: GUI built on Apache/PHP, Backend on C/Perl, 
+    <listitem><para>Fully opensource: Backend on C/Perl, 
+    <!-- <listitem><para>Fully opensource: GUI built on Apache/PHP, Backend on C/Perl,  -->
     Database is MySQL. Uses GNU configure.</para></listitem>
     </itemizedlist>
     </sect1>

Modified: upwatch/libdbi/doc/admin-guide.html
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/doc/admin-guide.txt
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/doc/client-configuration.xml
===================================================================
--- upwatch/libdbi/doc/client-configuration.xml	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/doc/client-configuration.xml	2006-07-21 23:12:45 UTC (rev 633)
@@ -163,42 +163,6 @@
       </itemizedlist>
 
        </sect3>
-       <sect3 id="OpenBSD_problems">
-       <title>OpenBSD problems</title>
-<para>
-<literallayout>
->From: "andreas guetl" 
->To: 
->Subject: fix for mbmon on openbsd
->Date: Fri, 5 Sep 2003 10:35:37 +0200
-
-hello!
-
-i tried various progs for monitoring cpu-temp on openbsd boxes
-but none of them worked. then i found the solution on
-http://archives.neohapsis.com/archives/openbsd/2001-02/2550.html
-and id simply did the trick, not only for healthd (which gave me
-wrong values) but also for mbmon which works very fine.
-
-1.) enable the option APERTURE in the kernel
-enabled by default but disabled in any selfmade kernel, who needs
-x on openbsd ;)
-
-2.) uncomment machdep.allowaperture in /etc/sysctl.conf and change
-the value from 2 to 1
-
-after rebooting with the new kernel the monitoring works really
-fine.
-
-thanks for your fine program!!
-
-(but what has the agp-aperture to do with monitoring hw?)
-
-so long,
-andy 
-</literallayout>
-</para>
-       </sect3>
        </sect2>
     </sect1>
     <sect1 id="Monitoring_specific_logfiles">
@@ -214,10 +178,13 @@
        <filename>/etc/upwatch.d/uw_sysstat.d/errlog</filename> (except <filename>rmacros.txt</filename>
        and <filename>macros.txt</filename>). 
        These files should contain regular expressions prefixed by one of the keywords 
-       <command>green</command>, <command>yellow</command>, or <command>red</command>. Next 
+       <command>green</command>, <command>yellow</command>, <command>red</command> or <command>ignore</command>. Next 
        uw_sysstat starts scanning <filename>/var/log/messages</filename>. It reads a line
        from the logfile and the following happens:</para>
        <itemizedlist>
+       <listitem><para>Check against the ignore list. If a match is found, flag green
+       condition, and continue with the next line. This is mostly used to skip lines that
+       would otherwise be flagged as red, for example because they contain the word ERROR.</para></listitem>
        <listitem><para>Check against the red list. If match found, flag red
        condition, and send the offending line to the upwatch server</para></listitem>
        <listitem><para>Check line against the yellow list. If matches, flag yellow

Modified: upwatch/libdbi/doc/client-install.xml
===================================================================
--- upwatch/libdbi/doc/client-install.xml	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/doc/client-install.xml	2006-07-21 23:12:45 UTC (rev 633)
@@ -45,6 +45,8 @@
                 you'll need the following on your system to build upwatch:</para>
             <itemizedlist>
                 <listitem><para>lynx</para></listitem>
+                <listitem><para>autoconf 2.59</para></listitem>
+                <listitem><para>automake 1.9</para></listitem>
                 <listitem><para>autogen 5.3.6 (autogen.sourceforge.net)</para></listitem>
                 <listitem><para>autogen needs libguile and umb-scheme</para></listitem>
                 <listitem><para>RPM tools, if you want to build RPM's</para></listitem>
@@ -63,6 +65,8 @@
               $ cd upwatch-x.x
               $ ./configure
               $ make 
+              $ groupadd upwatch
+              $ useradd -d /etc/upwatch.d -s /sbin/nologin -g upwatch upwatch
               $ make install
            </literallayout>
         <para> Nothing to it... In case of problems, you're probably missing some library or

Modified: upwatch/libdbi/doc/howitallworks.xml
===================================================================
--- upwatch/libdbi/doc/howitallworks.xml	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/doc/howitallworks.xml	2006-07-21 23:12:45 UTC (rev 633)
@@ -105,10 +105,6 @@
            <varname>uw_send</varname> queue, which is emptied by the uw_send process which sends
            all files to a remote queue on another host (received and queued by uw_accept).
         </para>
-        <para> <varname>uw_examine</varname> can do some additional tests like traceroute to the target host.
-           It attaches this report
-           to the probe result, and in its turn puts everything in an <varname>uw_process</varname> or
-           <varname>uw_send</varname> queue.</para>
        </sect2>
        <sect2 id="uw_process_storing_results_in_the_database">
         <title>uw_process: storing results in the database</title>

Modified: upwatch/libdbi/doc/installation.xml
===================================================================
--- upwatch/libdbi/doc/installation.xml	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/doc/installation.xml	2006-07-21 23:12:45 UTC (rev 633)
@@ -120,7 +120,7 @@
         <para>You actually need to create two databases, one for the probes to read from, and one 
         for the results to be written to. The first database should be called upwatch, the other
         one can be any name (in this example we use netland). If you have a new database installation
-        create a password for the root account, and remove the anonymous accounts as follows:<para>
+        create a password for the root account, and remove the anonymous accounts as follows:
         <literallayout>
            $ mysql -u root 
            mysql> DELETE FROM mysql.user WHERE User = '';

Modified: upwatch/libdbi/doc/program-guide.html
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/doc/program-guide.txt
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/doc/upwatch.html
===================================================================
(Binary files differ)

Modified: upwatch/libdbi/doc/upwatch.txt
===================================================================
(Binary files differ)

Copied: upwatch/libdbi/libstatgrab-0.13 (from rev 632, upwatch/trunk/libstatgrab-0.13)

Modified: upwatch/libdbi/patches/README
===================================================================
--- upwatch/libdbi/patches/README	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/patches/README	2006-07-21 23:12:45 UTC (rev 633)
@@ -11,9 +11,3 @@
 Adds timeout support to the linux libpcap library.
 Don't know if that's still needed for the newest versions.
 
-
-libstatgrab-openbsd.patch
-
-Old patch to add openbsd support to libpcap
-
-

Deleted: upwatch/libdbi/patches/libstatgrab-openbsd.patch
===================================================================
--- upwatch/libdbi/patches/libstatgrab-openbsd.patch	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/patches/libstatgrab-openbsd.patch	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,32 +0,0 @@
-diff -uNr libstatgrab-orig/configure.in libstatgrab/configure.in
---- libstatgrab-orig/configure.in	2004-05-30 21:56:28.000000000 +0200
-+++ libstatgrab/configure.in	2004-06-09 19:00:00.000000000 +0200
-@@ -40,6 +40,12 @@
-                 [],
-                 [#include <sys/disk.h>])
- 
-+# ds_bytes has been removed in OpenBSD
-+AC_CHECK_MEMBER(struct disk_sysctl.ds_bytes,
-+                [AC_DEFINE(HAVE_DS_BYTES, , [Removed in OpenBSD])],
-+                [],
-+                [#include <sys/disk.h>])
-+
- # Check for sys/loadavg.h
- AC_CHECK_HEADERS([sys/loadavg.h])
- 
-diff -uNr libstatgrab-orig/src/libstatgrab/disk_stats.c libstatgrab/src/libstatgrab/disk_stats.c
---- libstatgrab-orig/src/libstatgrab/disk_stats.c	2004-05-30 21:56:28.000000000 +0200
-+++ libstatgrab/src/libstatgrab/disk_stats.c	2004-06-09 19:01:26.000000000 +0200
-@@ -415,6 +415,12 @@
- #endif
- #else
-
-+#ifdef HAVE_DS_BYTES
-+                rbytes = wbytes = stats[i].ds_bytes;
-+#else
-+                rbytes = stats[i].ds_rbytes;
-+                wbytes = stats[i].ds_wbytes;
-+#endif
- #endif
- 
- 		/* Don't keep stats for disks that have never been used. */

Deleted: upwatch/libdbi/patches/xmbmon203.patch
===================================================================
--- upwatch/libdbi/patches/xmbmon203.patch	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/patches/xmbmon203.patch	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,54 +0,0 @@
---- xmbmon203-orig/Makefile.in	2003-07-04 05:13:45.000000000 +0200
-+++ xmbmon203/Makefile.in	2004-05-25 16:40:11.660167592 +0200
-@@ -37,14 +37,16 @@
- RM=rm -f
- INSTALL=install
- 
--INST_DIR=/usr/local/bin
-+INST_DIR=$(DESTDIR)/usr/local/bin
- INST_XDIR=/usr/X11R6/bin
- INST_XRDIR=/usr/X11R6/lib/X11/app-defaults
-  
- .c.o:
- 	$(CC) -c $(CFLAGS) $*.c
- 
--PROGRAM = mbmon xmbmon
-+PROGRAM = mbmon xmbmon.a
-+PACKAGE = upwatch
-+VERSION = `cat ../VERSION`
- 
- TESTPROG = testpci testsmb testhwm testfan
- 
-@@ -55,6 +57,17 @@
- 
- all: $(PROGRAM)
- 
-+distdir: 
-+	mkdir -p ../$(PACKAGE)-$(VERSION)/xmbmon203/AC-TOOLS
-+	cp *.c *.h Makefile.* *.txt configure *.in *.resources ../$(PACKAGE)-$(VERSION)/xmbmon203
-+	cp AC-TOOLS/config.* AC-TOOLS/install-sh ../$(PACKAGE)-$(VERSION)/xmbmon203/AC-TOOLS
-+
-+check:
-+	echo check OK
-+
-+xmbmon.a: $(OBJS)
-+	$(AR) -r xmbmon.a *.o
-+
- mbmon: mbmon.c mbmon.h methods.h pci_pm.h smbuses.h sensors.h $(OBJS)
- 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ mbmon.c $(OBJS) $(SPLIBS)
- 
-@@ -130,8 +143,12 @@
- 	$(RM) Makefile config.cache config.log config.h config.status
- 
- install: $(PROGRAM)
--	$(INSTALL) -o root -g wheel -m 4555 -c -p mbmon $(INST_DIR)
--	$(INSTALL) -o root -g wheel -m 4555 -c -p xmbmon $(INST_XDIR)
-+	mkdir -p $(INST_DIR)
-+	if test `${ID} -u` -eq 0; then \
-+	  $(INSTALL) -o root -g wheel -m 4555 -c -p mbmon $(INST_DIR); \
-+	else \
-+	  cp mbmon $(INST_DIR); \
-+	fi
- 
- lint:
- 	$(LINT) $(INCLUDES) $(DEFS) $(FONTDEFINES) $(SRCS) -lm

Copied: upwatch/libdbi/st-1.7 (from rev 632, upwatch/trunk/st-1.7)

Modified: upwatch/libdbi/upwatch/generic.h
===================================================================
--- upwatch/libdbi/upwatch/generic.h	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/upwatch/generic.h	2006-07-21 23:12:45 UTC (rev 633)
@@ -43,7 +43,7 @@
 extern int _logline;
 extern int _log2stderr;
 extern int _log2syslog;
-extern char *_logfilename;
+extern const char *_logfilename;
 
 extern int run(void);
 extern int init(void);

Modified: upwatch/libdbi/upwatch/log.c
===================================================================
--- upwatch/libdbi/upwatch/log.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/upwatch/log.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -19,7 +19,7 @@
 char *progname;
 int _log2stderr;
 int _log2syslog;
-char *_logfilename;
+const char *_logfilename;
 
 /****************************
  logging utility function

Deleted: upwatch/libdbi/upwatch-spec.spec
===================================================================
--- upwatch/libdbi/upwatch-spec.spec	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/upwatch-spec.spec	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,176 +0,0 @@
-
-Summary: UpWatch - The Best monitoring framework
-Vendor: http://www.upwatch.com
-Name: upwatch
-Version: 0.1
-Release: 1
-Source: http://www.upwatch.com/%{name}-%{version}.tar.gz
-Packager: Ron Arts <raarts at upwatch.com>
-License: GPL 
-Group: Application/Monitoring
-BuildRoot: %{_tmppath}/%{name}-%{version}-root
-BuildRequires: gzip glib2-devel mysql-devel curl-devel autogen 
-
-%define strip_binaries 1
-%define gzip_man 1
-%define  __prefix /usr
-
-Prefix: %{__prefix} 
-
-%description
-Upwatch is a full-fledged monitoring and report engine for
-internet hosts. It boasts support for various services, long-time
-history, graphs, and notification
-
-This package contains all upwatch documentation, plus supporting files
-like the database schema.
-
-
-
-%package uw_accept
-Summary: UpWatch - Upwatch daemon for accepting reports
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl >= 7.9.3 autogen >= 5.3.6 libnet >= 1.0.2
-
-%description uw_accept
-uw_accept listen on port 1985 for incoming upwatch reports.
-Using a POP3-like protocol it asks for a username and password
-and copies incoming files to a queue
-
-%files uw_accept
-%defattr(-,root,root)
-/usr/bin/uw_accept
-%config(noreplace) /etc/uw_accept.conf
-%config(noreplace) /etc/upwatch.d/uw_accept.conf
-/usr/share/man/man1/uw_accept.1.gz
-
-
-%package uw_httpget
-Summary: UpWatch - Upwatch parallel probe daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl >= 7.9.3 autogen >= 5.3.6 libnet >= 1.0.2
-
-%description uw_httpget
-uw_httpget reads a list of hosts from the database, and 
-sends http GET requests to each host. This happens in parallel, 
-so uw_httpget can process thousands of hosts in a very short period.
-
-%files uw_httpget
-%defattr(-,root,root)
-/usr/bin/uw_httpget
-%config(noreplace) /etc/uw_httpget.conf
-%config(noreplace) /etc/upwatch.d/uw_httpget.conf
-/usr/share/man/man1/uw_httpget.1.gz
-
-
-%package uw_ping
-Summary: UpWatch - Upwatch parallel ping daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl >= 7.9.3 autogen >= 5.3.6 libnet >= 1.0.2
-
-%description uw_ping
-uw_ping reads a list of hosts from the database, and sends ping 
-packets to each host.  This happens in parallel, so uw_ping can 
-process thousands of hosts in a very short period.
-
-%files uw_ping
-%defattr(-,root,root)
-/usr/bin/uw_ping
-%config(noreplace) /etc/uw_ping.conf
-%config(noreplace) /etc/upwatch.d/uw_ping.conf
-/usr/share/man/man1/uw_ping.1.gz
-
-
-%package uw_process
-Summary: UpWatch - Upwatch parallel probe daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl >= 7.9.3 autogen >= 5.3.6 libnet >= 1.0.2
-
-%description uw_process
-uw_process sends all files in the queue to a central server using 
-the uw_process protocol. This is a very simple protocol and looks
-something like POP3.
-
-%files uw_process
-%defattr(-,root,root)
-/usr/bin/uw_process
-%config(noreplace) /etc/uw_process.conf
-%config(noreplace) /etc/upwatch.d/uw_process.conf
-/usr/share/man/man1/uw_process.1.gz
-
-
-%package uw_send
-Summary: UpWatch - Upwatch parallel probe daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl >= 7.9.3 autogen >= 5.3.6 libnet >= 1.0.2
-
-%description uw_send
-uw_send sends all files in the queue to a central server using 
-the uw_send protocol. This is a very simple protocol and looks
-something like POP3.
-
-%files uw_send
-%defattr(-,root,root)
-/usr/bin/uw_send
-%config(noreplace) /etc/uw_send.conf
-%config(noreplace) /etc/upwatch.d/uw_send.conf
-/usr/share/man/man1/uw_send.1.gz
-
-
-%package uw_traceroute
-Summary: UpWatch - Upwatch problem investigator daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl >= 7.9.3 autogen >= 5.3.6 libnet >= 1.0.2
-
-%description uw_traceroute
-When some probe cannot get to its destination, it hands the
-problem over to uw_traceroute, which does a traceroute (either icmp, 
-tcp or udp) to the destination, and reports on its findings.
-
-%files uw_traceroute
-%defattr(-,root,root)
-/usr/bin/uw_traceroute
-%config(noreplace) /etc/uw_traceroute.conf
-%config(noreplace) /etc/upwatch.d/uw_traceroute.conf
-/usr/share/man/man1/uw_traceroute.1.gz
-
-
-%prep
-%setup  
-
-%build 
-%configure
-make 
-make check
-
-%install
-[ "$RPM_BUILD_ROOT" != "/" ] && rm -rf $RPM_BUILD_ROOT
-mkdir -p $RPM_BUILD_ROOT
-make DESTDIR=$RPM_BUILD_ROOT install
-
-mkdir -p $RPM_BUILD_ROOT/etc/upwatch.d
-install -m 644 config/upwatch.conf $RPM_BUILD_ROOT/etc/
-install -m 644 uw_accept/uw_accept.conf $RPM_BUILD_ROOT/etc/upwatch.d
-install -m 644 uw_process/uw_process.conf $RPM_BUILD_ROOT/etc/upwatch.d
-
-%if %{strip_binaries}
-{ cd $RPM_BUILD_ROOT
-  strip .%{__prefix}/bin/* || /bin/true
-}
-%endif
-%if %{gzip_man}
-{ cd $RPM_BUILD_ROOT
-  gzip .%{_mandir}/man1/*.1 
-}
-%endif
-
-%clean
-#[ "$RPM_BUILD_ROOT" != "/" ] && rm -rf $RPM_BUILD_ROOT
-
-%files
-%doc AUTHORS COPYING ChangeLog NEWS README 
-
-%changelog
-* Mon Sep 2 2002 Ron Arts <raarts at upwatch.com>
-- Rel. 1: First package version
-

Modified: upwatch/libdbi/util/chklog.c
===================================================================
--- upwatch/libdbi/util/chklog.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/util/chklog.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -33,7 +33,7 @@
 
   setvbuf(stdout, (char *)NULL, _IOLBF, 0); // make stdout linebuffered
 
-  logregex_refresh_type("/etc/upwatch.d/uw_sysstat.d", OPT_ARG(TYPE));
+  logregex_refresh_type("/etc/upwatch.d/uw_sysstat.d", (char *) &OPT_ARG(TYPE));
 
   if (strcmp(*argv, "-") == 0) {
     in = stdin;
@@ -57,7 +57,7 @@
     }
     buffer[strlen(buffer)-1] = 0;
     if (HAVE_OPT(MATCH)) {
-      if (logregex_matchline(OPT_ARG(TYPE), buffer, &color)) {
+      if (logregex_matchline((char *) &OPT_ARG(TYPE), buffer, &color)) {
         if (HAVE_OPT(LINE_INFO)) {
           printf("line %u: %d: ", line, color);
         }
@@ -65,13 +65,13 @@
       }
     }
     if (HAVE_OPT(REVERSE)) {
-      logregex_rmatchline(OPT_ARG(TYPE), buffer);
+      logregex_rmatchline((char *) &OPT_ARG(TYPE), buffer);
       printf("green %s\n", buffer);
     }
   }
   fclose(in);
   if (HAVE_OPT(STATS)) {
-    logregex_print_stats(OPT_ARG(TYPE));
+    logregex_print_stats((char *) &OPT_ARG(TYPE));
   }
   return 0;
 }

Modified: upwatch/libdbi/util/chklog_options.def
===================================================================
--- upwatch/libdbi/util/chklog_options.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/util/chklog_options.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -27,7 +27,7 @@
     arg_type  = string;
     descrip   = "print lines and error info in output lines";
     doc       =
-"Print line numbers and erros statuses.";
+"Print line numbers and error statuses.";
 };
 
 flag = {

Modified: upwatch/libdbi/util/uwq_options.def
===================================================================
--- upwatch/libdbi/util/uwq_options.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/util/uwq_options.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -36,6 +36,6 @@
 #include license_gpl.def
 #include minimal_options.def
 
-#include dbase_options_ign.def
 #include generic_options_ign.def
 #include option_realm_ign.def
+#include dbase_options_ign.def

Modified: upwatch/libdbi/util/uwregexp.c
===================================================================
--- upwatch/libdbi/util/uwregexp.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/util/uwregexp.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -38,7 +38,7 @@
       break;
     }
 
-    logregex_refresh_type("/etc/upwatch.d/uw_sysstat.d", style);
+    logregex_refresh_type("/etc/upwatch.d/uw_sysstat.d", (char *) &style);
     logregex_expand_macros(style, regexp, buf);
 
     printf("Resulting regex: %s\n", buf);
@@ -58,5 +58,6 @@
     free(regexp);
   }
   printf("\n");
+  exit(0);
 }
 

Modified: upwatch/libdbi/util/uwsaidar.c
===================================================================
--- upwatch/libdbi/util/uwsaidar.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/util/uwsaidar.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -17,7 +17,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  *
- * $Id: uwsaidar.c,v 1.2 2004/05/30 20:14:58 raarts Exp $
+ * $Id: saidar.c,v 1.34 2005/09/07 14:15:40 tdb Exp $
  */
 
 #ifdef HAVE_CONFIG_H
@@ -69,8 +69,14 @@
 char *size_conv(long long number){
 	char type[] = {'B', 'K', 'M', 'G', 'T'};
 	int x=0;
+	int sign=1;
 	static char string[10];
 
+	if(number < 0){
+		sign=-1;
+		number=-number;
+	}
+
 	for(;x<5;x++){
 		if( (number/1024) < (100)) {
 			break;
@@ -78,7 +84,9 @@
 		number = (number/1024);
 	}
 
-	snprintf(string, 10, "%lld%c", number, type[x]);	
+	number = number*sign;
+
+	snprintf(string, 10, "%lld%c", number, type[x]);
 	return string;
 	
 }
@@ -327,8 +335,11 @@
 		r=0;
 		w=0;
 		for(counter=0;counter<stats.disk_io_entries;counter++){
+			char name[12];
+			strncpy(name, disk_io_stat_ptr->disk_name, sizeof(name));
+			name[sizeof(name)-1] = '\0'; /* strncpy doesn't terminate longer strings */
 			move(line, 0);
-			printw("%s", disk_io_stat_ptr->disk_name);
+			printw("%s", name);
 			move(line, 12);
 			rt = (disk_io_stat_ptr->systime)? (disk_io_stat_ptr->read_bytes/disk_io_stat_ptr->systime): disk_io_stat_ptr->read_bytes;
 			printw("%7s", size_conv(rt));
@@ -354,8 +365,11 @@
 		/* Network */
 		network_stat_ptr = stats.network_io_stats;
 		for(counter=0;counter<stats.network_io_entries;counter++){
+			char name[20];
+			strncpy(name, network_stat_ptr->interface_name, sizeof(name));
+			name[sizeof(name)-1] = '\0'; /* strncpy doesn't terminate longer strings */
 			move(line, 42);
-			printw("%s", network_stat_ptr->interface_name);
+			printw("%s", name);
 			move(line, 62);
 			rt = (network_stat_ptr->systime)? (network_stat_ptr->rx / network_stat_ptr->systime): network_stat_ptr->rx;
 			printw("%7s", size_conv(rt));
@@ -372,12 +386,15 @@
 		/* Disk */
 		disk_stat_ptr = stats.fs_stats;
 		for(counter=0;counter<stats.fs_entries;counter++){
+			char name[20];
+			strncpy(name, disk_stat_ptr->mnt_point, sizeof(name));
+			name[sizeof(name)-1] = '\0'; /* strncpy doesn't terminate longer strings */
 			move(line, 42);
-			printw("%s", disk_stat_ptr->mnt_point);
+			printw("%s", name);
 			move(line, 62);
 			printw("%7s", size_conv(disk_stat_ptr->avail));
 			move(line, 73);
-			printw("%5.2f%%", 100.00 * ((float) disk_stat_ptr->used / (float) (disk_stat_ptr->used + disk_stat_ptr->avail)));
+			printw("%6.2f%%", 100.00 * ((float) disk_stat_ptr->used / (float) (disk_stat_ptr->used + disk_stat_ptr->avail)));
 			disk_stat_ptr++;
 			line++;
 		}
@@ -386,7 +403,7 @@
 	refresh();
 }
 
-void sig_winch_handler(int sig){
+void sig_winch_handler(int dummy){
 	clear();
 	display_headings();
 	display_data();

Modified: upwatch/libdbi/uw_accept/run.c
===================================================================
--- upwatch/libdbi/uw_accept/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_accept/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -7,7 +7,7 @@
 #include <netdb.h>
 #include <signal.h>
 #include <string.h>
-#include <malloc.h>
+#include <stdlib.h>
 #include <ctype.h>
 
 #include <generic.h>

Modified: upwatch/libdbi/uw_acceptbb/run.c
===================================================================
--- upwatch/libdbi/uw_acceptbb/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_acceptbb/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -10,7 +10,7 @@
 
 #include <signal.h>
 #include <string.h>
-#include <malloc.h>
+#include <stdlib.h>
 #include <ctype.h>
 
 #include <st.h>
@@ -183,7 +183,7 @@
     LOG(LOG_DEBUG, "timeout function");
     if (doc) {
       int ct  = STACKCT_OPT(OUTPUT);
-      char **output = STACKLST_OPT(OUTPUT);
+      char **output = (char **) &STACKLST_OPT(OUTPUT);
 
       xmlSetDocCompressMode(doc, OPT_VALUE_COMPRESS);
       for (i=0; i < ct; i++) {

Modified: upwatch/libdbi/uw_acceptbb/uw_acceptbb.def
===================================================================
--- upwatch/libdbi/uw_acceptbb/uw_acceptbb.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_acceptbb/uw_acceptbb.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -77,4 +77,5 @@
 
 #include license_gpl.def
 #include generic_options.def
+#include dbase_options.def
 

Modified: upwatch/libdbi/uw_dns/run.c
===================================================================
--- upwatch/libdbi/uw_dns/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_dns/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -271,7 +271,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_dns/uw_dns.def
===================================================================
--- upwatch/libdbi/uw_dns/uw_dns.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_dns/uw_dns.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -92,25 +92,6 @@
 This flag may be given multiple times.';
 };
 
-flag = {
-    must-set;
-    name      = uwuser;
-    value     = U;        /* flag style option character */
-    arg_type  = string;   /* option argument indication  */
-    max       = NOLIMIT;  /* occurrence limit (none)     */
-    descrip   = "Upwatch username";
-};
-
-flag = {
-    must-set;
-    name      = uwpasswd;
-    value     = P;        /* flag style option character */
-    arg_type  = string;   /* option argument indication  */
-    max       = NOLIMIT;  /* occurrence limit (none)     */
-    descrip   = "UpWatch password";
-};
-
 #include license_gpl.def
 #include dbase_options.def
 #include generic_options.def
-

Modified: upwatch/libdbi/uw_httpget/run.c
===================================================================
--- upwatch/libdbi/uw_httpget/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_httpget/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -261,7 +261,7 @@
 static void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_httpget/uw_httpget.def
===================================================================
--- upwatch/libdbi/uw_httpget/uw_httpget.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_httpget/uw_httpget.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -92,24 +92,7 @@
 This flag may be given multiple times.';
 };
 
-flag = {
-    must-set;
-    name      = uwuser;
-    value     = U;        /* flag style option character */
-    arg_type  = string;   /* option argument indication  */
-    max       = NOLIMIT;  /* occurrence limit (none)     */
-    descrip   = "Upwatch username";
-};
-
-flag = {
-    must-set;
-    name      = uwpasswd;
-    value     = P;        /* flag style option character */
-    arg_type  = string;   /* option argument indication  */
-    max       = NOLIMIT;  /* occurrence limit (none)     */
-    descrip   = "UpWatch password";
-};
-
 #include license_gpl.def
 #include dbase_options.def
 #include generic_options.def
+#include option_realm_ign.def

Modified: upwatch/libdbi/uw_imap/run.c
===================================================================
--- upwatch/libdbi/uw_imap/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_imap/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -227,7 +227,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_iptraf/run.c
===================================================================
--- upwatch/libdbi/uw_iptraf/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_iptraf/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,6 +3,7 @@
 
 #include <unistd.h>
 #include <sys/socket.h>
+#include <sys/types.h>
 #include <arpa/inet.h>
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
@@ -41,7 +42,7 @@
   time_t now;
   struct ipnetw *net;
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
 
   doc = UpwatchXmlDoc("result", NULL);
@@ -94,7 +95,7 @@
     int i, oldcount_ipnets;
     struct ipnetw *newnet, *oldnet, *net;
     int     ct  = STACKCT_OPT( NETWORK );
-    char**  pn = STACKLST_OPT( NETWORK );
+    char**  pn = (char **) &STACKLST_OPT( NETWORK );
 
     for (i=0; i < OPT_VALUE_INTERVAL; i++) { // wait some seconds
       sleep(1);
@@ -150,7 +151,7 @@
   }
   if (HAVE_OPT(EXTIGNORE)) {
     int     ct  = STACKCT_OPT(EXTIGNORE);
-    char**  pn = STACKLST_OPT(EXTIGNORE);
+    char**  pn = (char **) &STACKLST_OPT(EXTIGNORE);
     int i;
 
     if (ct >= 255) { LOG(LOG_ERR, "Too many extignore statements, only 255 are supported"); }
@@ -224,7 +225,7 @@
   mypid = getpid() & 0xffff;
   if (HAVE_OPT(INTERFACE)) {
     int     ct  = STACKCT_OPT( INTERFACE );
-    char**  pn = STACKLST_OPT( INTERFACE );
+    char**  pn = (char **) &STACKLST_OPT( INTERFACE );
 
     while (ct--) {
       dev = *pn++;

Modified: upwatch/libdbi/uw_iptraf/uw_iptraf.def
===================================================================
--- upwatch/libdbi/uw_iptraf/uw_iptraf.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_iptraf/uw_iptraf.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -136,3 +136,5 @@
 
 #include license_gpl.def
 #include generic_options.def
+#include dbase_options_ign.def
+

Modified: upwatch/libdbi/uw_mssql/run.c
===================================================================
--- upwatch/libdbi/uw_mssql/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_mssql/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -233,7 +233,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_mysql/run.c
===================================================================
--- upwatch/libdbi/uw_mysql/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_mysql/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -231,7 +231,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 
@@ -259,8 +259,7 @@
   dbuser = probe->dbuser;
   dbpasswd = probe->dbpasswd;
 
-  option = 0 ; mysql_options(mysql, MYSQL_OPT_COMPRESS, (const char *)&option);
-  option = 50; mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&option);
+  option = 50; mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (const char *) &option);
   gettimeofday(&start, NULL);
   if (!mysql_real_connect(mysql, dbhost, dbuser, dbpasswd, dbname, 0, NULL, 0)) {
     probe->msg = strdup(mysql_error(mysql));

Modified: upwatch/libdbi/uw_mysqlstats/run.c
===================================================================
--- upwatch/libdbi/uw_mysqlstats/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_mysqlstats/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -190,7 +190,7 @@
   xmlDocPtr doc = (xmlDocPtr) user_data;
   struct probedef *probe = (struct probedef *)value;
 
-  xmlNodePtr subtree, mysql;
+  xmlNodePtr subtree, mysqlstats;
   int color;
   char info[1024];
   char buffer[1024];
@@ -203,22 +203,22 @@
     color = STAT_GREEN;
   }
 
-  mysql = xmlNewChild(xmlDocGetRootElement(doc), NULL, "mysql", NULL);
+  mysqlstats = xmlNewChild(xmlDocGetRootElement(doc), NULL, "mysqlstats", NULL);
   if (probe->realm) {
-    xmlSetProp(mysql, "realm", probe->realm);
+    xmlSetProp(mysqlstats, "realm", probe->realm);
   }
-  sprintf(buffer, "%d", probe->probeid);      xmlSetProp(mysql, "id", buffer);
-  sprintf(buffer, "%s", probe->ipaddress);    xmlSetProp(mysql, "ipaddress", buffer);
-  sprintf(buffer, "%d", (int) now);           xmlSetProp(mysql, "date", buffer);
+  sprintf(buffer, "%d", probe->probeid);      xmlSetProp(mysqlstats, "id", buffer);
+  sprintf(buffer, "%s", probe->ipaddress);    xmlSetProp(mysqlstats, "ipaddress", buffer);
+  sprintf(buffer, "%d", (int) now);           xmlSetProp(mysqlstats, "date", buffer);
   sprintf(buffer, "%d", ((int)now)+((unsigned)OPT_VALUE_EXPIRES*60)); 
-    xmlSetProp(mysql, "expires", buffer);
-  sprintf(buffer, "%d", color);               xmlSetProp(mysql, "color", buffer);
-  sprintf(buffer, "%llu", probe->selectq);      subtree = xmlNewChild(mysql, NULL, "select", buffer);
-  sprintf(buffer, "%llu", probe->insertq);      subtree = xmlNewChild(mysql, NULL, "insert", buffer);
-  sprintf(buffer, "%llu", probe->updateq);      subtree = xmlNewChild(mysql, NULL, "update", buffer);
-  sprintf(buffer, "%llu", probe->deleteq);      subtree = xmlNewChild(mysql, NULL, "delete", buffer);
+    xmlSetProp(mysqlstats, "expires", buffer);
+  sprintf(buffer, "%d", color);               xmlSetProp(mysqlstats, "color", buffer);
+  sprintf(buffer, "%llu", probe->selectq);      subtree = xmlNewChild(mysqlstats, NULL, "selectq", buffer);
+  sprintf(buffer, "%llu", probe->insertq);      subtree = xmlNewChild(mysqlstats, NULL, "insertq", buffer);
+  sprintf(buffer, "%llu", probe->updateq);      subtree = xmlNewChild(mysqlstats, NULL, "updateq", buffer);
+  sprintf(buffer, "%llu", probe->deleteq);      subtree = xmlNewChild(mysqlstats, NULL, "deleteq", buffer);
   if (probe->msg) {
-    subtree = xmlNewTextChild(mysql, NULL, "info", probe->msg);
+    subtree = xmlNewTextChild(mysqlstats, NULL, "info", probe->msg);
     free(probe->msg);
     probe->msg = NULL;
   }
@@ -227,7 +227,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 
@@ -265,8 +265,7 @@
   dbuser = probe->dbuser;
   dbpasswd = probe->dbpasswd;
 
-  mysql_options(mysql, MYSQL_OPT_COMPRESS, 0);
-  mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (const char *)&timeout);
+  mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, (char * ) &timeout);
 
   LOG(LOG_DEBUG, "%s %s %s %s", dbhost, dbuser, dbpasswd, dbname);
   if (!mysql_real_connect(mysql, dbhost, dbuser, dbpasswd, dbname, 0, NULL, 0)) {

Modified: upwatch/libdbi/uw_null/run.c
===================================================================
--- upwatch/libdbi/uw_null/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_null/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -71,7 +71,7 @@
     g_ptr_array_free(arr, TRUE);
     return 0;
   }
-  g_ptr_array_sort(arr, mystrcmp);
+  g_ptr_array_sort(arr, (GCompareFunc) mystrcmp);
   if (debug > 3) { fprintf(stderr, "%u files in directory\n", files); sleep(3); }
 
   // now we have a sorted list of files 

Modified: upwatch/libdbi/uw_null/uw_null.def
===================================================================
--- upwatch/libdbi/uw_null/uw_null.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_null/uw_null.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -79,7 +79,6 @@
 };
 
 #include license_gpl.def
-#include dbase_options.def
 #include generic_options.def
 #include option_realm_ign.def
-
+#include minimal_options.def

Modified: upwatch/libdbi/uw_ping/run.c
===================================================================
--- upwatch/libdbi/uw_ping/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_ping/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -272,7 +272,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_ping/uw_ping.def
===================================================================
--- upwatch/libdbi/uw_ping/uw_ping.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_ping/uw_ping.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -92,36 +92,7 @@
 it knows which probe to retrieve from the definition table';
 };
 
-flag = {
-    must-set;
-    name      = statfile;
-    value     = K;
-    arg_type  = string;
-    descrip   = "file to keep current state of probes";
-    doc       =
-'To determine if probe status changed, we keep the previous status
-in a file. This is the name of that file';
-};
-
-flag = {
-    must-set;
-    name      = uwuser;
-    value     = U;        /* flag style option character */
-    arg_type  = string;   /* option argument indication  */
-    max       = NOLIMIT;  /* occurrence limit (none)     */
-    descrip   = "Upwatch username";
-};
-
-flag = {
-    must-set;
-    name      = uwpasswd;
-    value     = P;        /* flag style option character */
-    arg_type  = string;   /* option argument indication  */
-    max       = NOLIMIT;  /* occurrence limit (none)     */
-    descrip   = "UpWatch password";
-};
-
 #include license_gpl.def
 #include dbase_options.def
 #include generic_options.def
-
+#include option_realm_ign.def

Modified: upwatch/libdbi/uw_pop3/run.c
===================================================================
--- upwatch/libdbi/uw_pop3/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_pop3/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -227,7 +227,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_postgresql/run.c
===================================================================
--- upwatch/libdbi/uw_postgresql/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_postgresql/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -232,7 +232,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_process/Makefile.am
===================================================================
--- upwatch/libdbi/uw_process/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_process/Makefile.am	2006-07-21 23:12:45 UTC (rev 633)
@@ -36,7 +36,7 @@
 uw_process_CFLAGS = @LIBGLIB2_CFLAGS@ @LIBXML2_CFLAGS@ @LIBOPTS_CFLAGS@ $(AM_CFLAGS) \
   $(DEF_LIBPQ) $(DEF_LIBSNMP) $(DEF_LIBTDS) $(DEF_LIBESMTP) 
 uw_process_LDADD = uw_process_$(DB_O) uw_process_$(MAIN_O) $(LIBOPTS) $(LIBUPWATCH) @LIBDBI_LIBS@ \
-  @LIBESMTP_LIBS@ @LIBGLIB2_LIBS@ @LIBXML2_LIBS@ $(SOLARISLIBS)
+  @LIBESMTP_LIBS@ @LIBGLIB2_LIBS@ @LIBXML2_LIBS@ $(SOLARISLIBS) $(LIBGTHREAD2_LIBS)
 
 BUILT_SOURCES = $(program:%=%.1) $(program:%=%.h) $(program:%=%.c) $(SPECFILES) $(INITFILES) ../probes.enum
 INCLUDES = -I../upwatch

Modified: upwatch/libdbi/uw_process/iptraf.c
===================================================================
--- upwatch/libdbi/uw_process/iptraf.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_process/iptraf.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,5 +1,6 @@
 #include "config.h"
 #include <string.h>
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: upwatch/libdbi/uw_process/mysqlstats.c
===================================================================
--- upwatch/libdbi/uw_process/mysqlstats.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_process/mysqlstats.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -32,7 +32,7 @@
   result = db_query(t->probe->db, 0,
                     "insert into pr_mysqlstats_raw "
                     "set    probe = '%u', yellow = '%f', red = '%f', stattime = '%u', color = '%u', "
-                    "       selectq = '%u', insertq = '%u', updateq = '%u', deleteq = '%u',` "
+                    "       selectq = '%u', insertq = '%u', updateq = '%u', deleteq = '%u', "
                     "       message = '%s' ",
                     def->probeid, def->yellow, def->red, res->stattime, res->color, 
                     res->selectq, res->insertq, res->updateq, res->deleteq,escmsg);

Modified: upwatch/libdbi/uw_process/run.c
===================================================================
--- upwatch/libdbi/uw_process/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_process/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -393,7 +393,7 @@
   if (HAVE_OPT(TRUST)) {
     int i, found=0;
     int     ct  = STACKCT_OPT( TRUST );
-    const char**  pn = STACKLST_OPT( TRUST );
+    char**  pn = (char **) &STACKLST_OPT( TRUST );
 
     while (ct--) {
       for (i=0; modules[i]; i++) {
@@ -456,7 +456,7 @@
 {
   int trust;
   int     ct  = STACKCT_OPT( TRUST );
-  const char**  pn = STACKLST_OPT( TRUST );
+  char**  pn = (char **) &STACKLST_OPT( TRUST );
 
   for (trust=0; trust < ct; trust++) {
     if (strcmp(pn[trust], "all") == 0) {
@@ -515,7 +515,7 @@
     g_ptr_array_free(arr, TRUE);
     return 0;
   }
-  g_ptr_array_sort(arr, mystrcmp);
+  g_ptr_array_sort(arr, (GCompareFunc) mystrcmp);
   if (debug > 3) { fprintf(stderr, "%u files in directory\n", files); sleep(3); }
 
   // now we have a sorted list of files 
@@ -524,7 +524,7 @@
     trx t;
     int j;
     int output_ct = STACKCT_OPT(OUTPUT);
-    const char **output_pn = STACKLST_OPT(OUTPUT);
+    char **output_pn = (char **) &STACKLST_OPT(OUTPUT);
     char *filebase;
 
     filebase = strrchr((char *)g_ptr_array_index(arr,i), '/');
@@ -587,7 +587,7 @@
 {
   int i;
   int     ct  = STACKCT_OPT( INPUT );
-  const char**  pn = STACKLST_OPT( INPUT );
+  char**  pn = (char **) &STACKLST_OPT( INPUT );
 
   childpidcnt = ct;
   if (debug > 2) fprintf(stderr, "pondering..\n");
@@ -635,7 +635,7 @@
               char subject[256];
 
               sprintf(subject, "UPWATCH: probe %s is lagging in processing", modules[i]->module_name);
-              mail(OPT_ARG(NOC_MAIL), subject, subject, (time_t)NULL);
+              mail((char *) &OPT_ARG(NOC_MAIL), subject, subject, (time_t)NULL);
               db_query(modules[i]->db, 0, "update probe set lagwarn = 'yes' where id = '%u'",
                                            modules[i]->class);
             }
@@ -644,7 +644,7 @@
               char subject[256];
 
               sprintf(subject, "UPWATCH: probe %s is up-to-date again", modules[i]->module_name);
-              mail(OPT_ARG(NOC_MAIL), subject, subject, (time_t)NULL);
+              mail((char *) &OPT_ARG(NOC_MAIL), subject, subject, (time_t)NULL);
               db_query(modules[i]->db, 0, "update probe set lagwarn = 'no' where id = '%u'",
                                            modules[i]->class);
             }
@@ -697,7 +697,7 @@
   guint lowtime, hightime; 
   char *p;
 
-  res.name = strtok((char *)OPT_ARG(SUMMARIZE), ",");
+  res.name = strtok((char *) &OPT_ARG(SUMMARIZE), ",");
   lowtime = 0;
   hightime = time(NULL);
   p = strtok(NULL, ",");

Modified: upwatch/libdbi/uw_process/uw_process.conf
===================================================================
--- upwatch/libdbi/uw_process/uw_process.conf	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_process/uw_process.conf	2006-07-21 23:12:45 UTC (rev 633)
@@ -2,6 +2,7 @@
 #logfile /var/log/upwatch/uw_process.log
 input q_pop3
 input q_httpget
+input q_tcpconnect
 input q_imap
 input q_iptraf
 input q_mssql
@@ -12,7 +13,7 @@
 input q_errlog
 input q_diskfree
 input q_ping
-input q_spare
+#input q_spare
 input q_bb
 input q_bb_cpu
 input q_mysqlstats

Modified: upwatch/libdbi/uw_purple/uw_purple.def
===================================================================
--- upwatch/libdbi/uw_purple/uw_purple.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_purple/uw_purple.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,4 +1,5 @@
 AutoGen Definitions options;
+
 export        = "#define progOptions uw_purpleOptions";
 prog-name     = uw_purple;
 prog-title    = "Upwatch purple daemon";
@@ -53,8 +54,7 @@
     descrip   = "name of queue to drop results";
     doc       =
 'The argument is taken to be a maildir under the directory `spooldir`.
-All results are placed in this queue.
-This flag may be given multiple times.';
+All results are placed in this queue.';
 };
 
 #include license_gpl.def

Modified: upwatch/libdbi/uw_route/run.c
===================================================================
--- upwatch/libdbi/uw_route/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_route/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -36,7 +36,7 @@
   if (HAVE_OPT(ROUTE)) {
     int i=0;
     int     ct  = STACKCT_OPT( ROUTE );
-    char**  pn = STACKLST_OPT( ROUTE );
+    char**  pn = (char **) &STACKLST_OPT( ROUTE );
 
     while (ct--) {
       char probe[256], queue[256];
@@ -98,7 +98,7 @@
     g_ptr_array_free(arr, TRUE);
     return 0;
   }
-  g_ptr_array_sort(arr, mystrcmp);
+  g_ptr_array_sort(arr, (GCompareFunc) mystrcmp);
   if (debug > 3) { fprintf(stderr, "%u files in directory\n", files); sleep(3); }
 
   // now we have a sorted list of files 

Modified: upwatch/libdbi/uw_route/uw_route.conf
===================================================================
--- upwatch/libdbi/uw_route/uw_route.conf	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_route/uw_route.conf	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,5 +1,6 @@
 input uw_route
 route httpget q_httpget
+route tcpconnect q_tcpconnect
 route imap q_imap
 route iptraf q_iptraf
 route httpget q_httpget

Modified: upwatch/libdbi/uw_route/uw_route.def
===================================================================
--- upwatch/libdbi/uw_route/uw_route.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_route/uw_route.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -10,7 +10,7 @@
 homerc        = "$$/upwatch.conf";
 homerc        = "$$/uw_route.conf";
 detail        = 
-'uw_route reads probe resultfiles, and stores them in the database';
+'uw_route reads probe resultfiles, and stores them in the right processing queue';
 
 // this section is for the generated specfile
 spec-requires = "libdbi >= 0.8 glib2";

Modified: upwatch/libdbi/uw_send/run.c
===================================================================
--- upwatch/libdbi/uw_send/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_send/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,5 +1,7 @@
 #include "config.h"
+#include <signal.h>
 #include <sys/types.h>
+#include <sys/signal.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
@@ -103,12 +105,12 @@
   }
 
   ct    = STACKCT_OPT( INPUT );
-  input = STACKLST_OPT(INPUT);
-  host  = STACKLST_OPT(HOST);
-  port  = STACKLST_OPT(PORT);
-  user  = STACKLST_OPT(UWUSER);
-  pwd   = STACKLST_OPT(UWPASSWD);
-  thr   = STACKLST_OPT(THREADS);
+  input = (char **) &STACKLST_OPT(INPUT);
+  host  = (char **) &STACKLST_OPT(HOST);
+  port  = (char **) &STACKLST_OPT(PORT);
+  user  = (char **) &STACKLST_OPT(UWUSER);
+  pwd   = (char **) &STACKLST_OPT(UWPASSWD);
+  thr   = (char **) &STACKLST_OPT(THREADS);
 
   // read in options for queuing
   for (i=0; input[i] && i < ct && i < 4; i++) {

Modified: upwatch/libdbi/uw_send/uw_send.def
===================================================================
--- upwatch/libdbi/uw_send/uw_send.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_send/uw_send.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -147,4 +147,3 @@
 
 #include license_gpl.def
 #include generic_options.def
-#include dbase_options_ign.def

Modified: upwatch/libdbi/uw_setip/run.c
===================================================================
--- upwatch/libdbi/uw_setip/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_setip/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -7,7 +7,7 @@
 #include <netdb.h>
 #include <signal.h>
 #include <string.h>
-#include <malloc.h>
+#include <stdlib.h>
 #include <ctype.h>
 
 #include <generic.h>
@@ -147,8 +147,8 @@
 static int uw_set_ip(char *user, char *ip, char *remotehost) 
 {
   dbi_conn conn;
-  conn = open_database(OPT_ARG(DBTYPE), OPT_ARG(DBHOST), OPT_ARG(DBPORT), OPT_ARG(DBNAME), 
-			OPT_ARG(DBUSER), OPT_ARG(DBPASSWD));
+  conn = open_database((char *) &OPT_ARG(DBTYPE), (char *) &OPT_ARG(DBHOST), (char *) &OPT_ARG(DBPORT), 
+                        (char *) &OPT_ARG(DBNAME), (char *) &OPT_ARG(DBUSER), (char *) &OPT_ARG(DBPASSWD));
   if (conn) {
     gchar buffer[256];
 

Modified: upwatch/libdbi/uw_smtp/run.c
===================================================================
--- upwatch/libdbi/uw_smtp/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_smtp/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -224,7 +224,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_snmpget/run.c
===================================================================
--- upwatch/libdbi/uw_snmpget/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_snmpget/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -348,7 +348,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  const char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 

Modified: upwatch/libdbi/uw_syncprobes/uw_syncprobes.def
===================================================================
--- upwatch/libdbi/uw_syncprobes/uw_syncprobes.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_syncprobes/uw_syncprobes.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -60,4 +60,4 @@
 #include license_gpl.def
 #include dbase_options.def
 #include generic_options.def
-
+#include option_realm_ign.def

Modified: upwatch/libdbi/uw_sysstat/Makefile.am
===================================================================
--- upwatch/libdbi/uw_sysstat/Makefile.am	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/Makefile.am	2006-07-21 23:12:45 UTC (rev 633)
@@ -27,7 +27,7 @@
 init_DATA = $(INITFILES)
 
 uw_sysstat_SOURCES = run.c uw_sysstat.c uw_sysstat.h $(PROBFILES) $(SPECFILES) $(INITFILES)
-uw_sysstat_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ $(AM_CFLAGS) @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@
+uw_sysstat_CFLAGS = @LIBXML2_CFLAGS@ @LIBGLIB2_CFLAGS@ $(AM_CFLAGS) @LIBPCRE_CFLAGS@ @LIBOPTS_CFLAGS@ @LIBGTHREAD2_CFLAGS@
 uw_sysstat_LDADD = uw_sysstat_$(MAIN_O) $(XMBMON_LIB) $(LIBOPTS) \
   $(FREEBSDLIBS) $(SOLARISLIBS) $(LIBSTATGRAB) \
   $(LIBUPWATCH) @LIBXML2_LIBS@ @LIBGLIB2_LIBS@ @LIBPCRE_LIBS@

Modified: upwatch/libdbi/uw_sysstat/run.c
===================================================================
--- upwatch/libdbi/uw_sysstat/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -22,6 +22,11 @@
 #if USE_XMBMON
 #include "mbmon.h"
 #endif
+#ifdef __OpenBSD__
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/sensors.h>
+#endif
 
 char ipaddress[24];
 
@@ -54,7 +59,7 @@
 } stats_t;
 stats_t st;
 
-#if USE_XMBMON
+#if USE_XMBMON|| defined (__OpenBSD__)
 typedef struct {
   float temp1;
   float temp2;
@@ -113,7 +118,62 @@
   //       hw.vc0, hw.vc1, hw.v33, hw.v50p, hw.v12p, hw.v12n, hw.v50n);
 }
 #endif
+#ifdef __OpenBSD__
+void get_hwstats(void)
+{
+  int i;
+  struct sensor s; 
+  size_t slen = sizeof(s); 
+  float value;
+  for (i=0;i<256;i++)
+  {
+    int mib[] = { CTL_HW, HW_SENSORS, i }; 
+    if ( sysctl(mib, sizeof(mib)/sizeof(mib[0]), &s, &slen, NULL, 0) == -1 ) continue;
+    if (s.flags & SENSOR_FINVALID) continue;
 
+    /* Ok, we have a valid sensor now, now check the type */
+    switch (s.type) {
+      case SENSOR_TEMP:
+              if ( debug > 5 ) printf("Sensor %d is a temparature sensor\n", s.num);
+              value = (s.value - 273150000) / 1000000.0;
+              if(strcmp(s.desc,"Temp1")==0)  hw.temp1 = value; 
+              if(strcmp(s.desc,"Temp2")==0)  hw.temp2 = value;
+              if(strcmp(s.desc,"Temp3")==0)  hw.temp3 = value;
+
+	      // The admtmp driver only tells us about Internal and External temperatures
+              if(strcmp(s.desc,"External Temp")==0 && strncmp(s.device,"admtemp", 7) == 0)  hw.temp1 = value; 
+              if(strcmp(s.desc,"Internal Temp")==0 && strncmp(s.device,"admtemp", 7) == 0)  hw.temp2 = value; 
+
+              break;
+      case SENSOR_FANRPM:
+              if ( debug > 4 ) printf("Sensor %d is a fan speed sensor\n", s.num);
+              if(strcmp(s.desc,"Fan1")==0)  hw.rot1 = (int) s.value;
+              if(strcmp(s.desc,"Fan2")==0)  hw.rot2 = (int) s.value;
+              if(strcmp(s.desc,"Fan3")==0)  hw.rot3 = (int) s.value;
+              break;
+      case SENSOR_VOLTS_DC:
+              if ( debug > 5 ) printf("Sensor %d is a voltage sensor\n", s.num);
+              value = s.value / 1000000.0;
+              if(strcmp(s.desc,"VCore A")==0)  hw.vc0 = value;
+              if(strcmp(s.desc,"VCore B")==0)  hw.vc1 = value;
+              if(strcmp(s.desc,"+3.3V")==0)  hw.v33 = value;
+              if(strcmp(s.desc,"+5V")==0)  hw.v50p = value;
+              if(strcmp(s.desc,"+12V")==0)  hw.v12p = value;
+              if(strcmp(s.desc,"-12V")==0)  hw.v12n = value;
+              if(strcmp(s.desc,"-5V")==0)  hw.v50n = value;
+              break;
+      default:
+              if ( debug > 5 ) printf("Sensor hw.sensors.%d is of a unknown type! It describes itselve as: %s\n", s.num, s.desc);
+              break;
+    }
+  }
+  if ( debug > 4 ) printf("Temp = %4.1f, %4.1f, %4.1f;",hw.temp1, hw.temp2, hw.temp3);
+  if ( debug > 4 ) printf("Rot = %4d, %4d, %4d\n", hw.rot1, hw.rot2, hw.rot3);
+  if ( debug > 4 ) printf("Vcore = %4.2f, %4.2f\nVolt = %4.2f, %4.2f, %5.2f, %6.2f, %5.2f\n", 
+         hw.vc0, hw.vc1, hw.v33, hw.v50p, hw.v12p, hw.v12n, hw.v50n);
+}
+#endif
+
 #if HAVE_LIBPCRE
 #define STATFILE "/var/run/upwatch/uw_sysstat.stat"
 int check_log(GString *string, int idx)
@@ -225,7 +285,7 @@
 
   if (HAVE_OPT(ERRLOG)) {
     int ct  = STACKCT_OPT(ERRLOG);
-    char **errlog = STACKLST_OPT(ERRLOG);
+    char **errlog = (char **) &STACKLST_OPT(ERRLOG);
     for (idx=0, i=0; i < ct && idx < 255; i++) {
       char *start, *end;
   
@@ -317,9 +377,6 @@
   time_t now = time(NULL);
 
   node = xmlNewChild(xmlDocGetRootElement(doc), NULL, name, NULL);
-  if (HAVE_OPT(DOMAIN)) {
-    xmlSetProp(node, "domain", OPT_ARG(DOMAIN));
-  }
   if (HAVE_OPT(REALM)) {
     xmlSetProp(node, "realm", OPT_ARG(REALM));
   }
@@ -333,7 +390,7 @@
   return node;
 }
 
-#if USE_XMBMON
+#if USE_XMBMON || defined (__OpenBSD__)
 void add_hwstat(xmlNodePtr node)
 {
   char buffer[24];
@@ -511,20 +568,36 @@
 {
   float fullest = 0.0;
   char info[32768];
+  int i, ignore;
 
   if (st.disk) {
     sg_fs_stats *disk_stat_ptr = st.disk;
     int counter;
 
-    for (counter=0; counter < st.disk_entries; counter++){
+    for (counter=0, ignore=0; counter < st.disk_entries; counter++){
       float use;
-      use = 100.00 * ((float) disk_stat_ptr->used / (float) (disk_stat_ptr->used + disk_stat_ptr->avail));
-      if (use > fullest) fullest = use;
-      disk_stat_ptr++;
+
+    if (HAVE_OPT( IGNOREDISKFREE )) {
+        int     ct = STACKCT_OPT(  IGNOREDISKFREE );
+        char**  pp = (char **) &STACKLST_OPT( IGNOREDISKFREE );
+
+        do  {
+            char* p = *pp++;
+            if (strcmp(disk_stat_ptr->device_name, p) ==0 ) ignore=1;
+        } while (--ct > 0);
     }
+
+     if (ignore == 0 ) {
+        use = 100.00 * ((float) disk_stat_ptr->used / (float) (disk_stat_ptr->used + disk_stat_ptr->avail));
+        if (use > fullest) fullest = use;
+      }
+      ignore=0; /* Reset the ignore flag */
+      disk_stat_ptr++; /* next partition please */
+    }
   }
 
-  if (fullest > OPT_VALUE_DISKFREE_YELLOW) { // if some disk is more then 80% full give `df` listing
+  if (fullest > OPT_VALUE_DISKFREE_YELLOW) { // if some disk is more then the yellow treshold full give `df` listing
+
     char cmd[1024];
     char buffer[24];
     FILE *in;
@@ -567,7 +640,7 @@
   xmlDocPtr doc;
   xmlNodePtr node;
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   GString *log;
   int i;
   int color;
@@ -600,8 +673,8 @@
   add_sysstat_info(node);
   color = xmlGetPropInt(node, "color");
   if (color > highest_color) highest_color = color;
-#if USE_XMBMON
-  if (OPT_VALUE_HWSTATS) {
+#if USE_XMBMON|| defined (__OpenBSD__)
+  if (OPT_VALUE_HWSTATS ) { 
     // do the hwstat
     get_hwstats();
     node = newnode(doc, "hwstat");
@@ -631,6 +704,7 @@
   node = newnode(doc, "diskfree");
   add_diskfree_info(node);
   color = xmlGetPropInt(node, "color");
+
   if (color > highest_color) highest_color = color;
 
   if (HAVE_OPT(HPQUEUE) && (highest_color != prv_highest_color)) {

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/amavisd (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/maillog/amavisd)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/macros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/macros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/macros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,10 +3,10 @@
 # match a macroname!!
 # entries are matched in the order specified
 WLOGDATE (Mon|Tue|Wed|Thu|Fri|Sat|Sun) [-A-Za-z]* [\d ]\d \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
-LOGDATE [A-Za-z]* [\d ]\d \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
+LOGDATE [A-Za-z]{3}\s{1,2}[\d]{1,2} \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
 EMAIL   [-\.\$\w]+@[a-z\d][-a-z\d]*(\.[a-z\d][-a-z\d]+)*\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z])
 HOSTNAME ([a-z\d][-a-z\d]*)(\.[a-z\d][-a-z\d]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))?
-IPADDR (25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 HOSTNAM [-\da-z]+
 PATH	/?[-_\.[:alnum:]]?(/[-_\.[:alnum:]]+)*/?
 SMONTH  (Mon|Tue|Wed|Thu|Fri|Sat|Sun)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/postfix
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/postfix	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/postfix	2006-07-21 23:12:45 UTC (rev 633)
@@ -41,9 +41,21 @@
 green [LOGDATE] postfix/smtp[PID]: [MSGID]: enabling PIX <CRLF>\.<CRLF> workaround for [HOSTNAME]\[[IPADDR]\]
 green [LOGDATE] postfix/smtp[PID]: warning: host [HOSTNAME]\[[IPADDR]\] greeted me with my own hostname [HOSTNAME]
 green [LOGDATE] postfix/smtp[PID]: warning: host [HOSTNAME]\[[IPADDR]\] replied to HELO/EHLO with my own hostname [HOSTNAME]
+green [LOGDATE] postfix/smtp[PID]: connect to [HOSTNAME]\[[IPADDR]\]: Network is unreachable \(port [NUM]\)
+green [LOGDATE] postfix/smtp[PID]: connect to [HOSTNAME] \[[IPADDR]\]: read timeout \(port [NUM]\)
+green [LOGDATE] postfix/anvil[PID]: statistics: 
+green [LOGDATE] postfix/scache[PID]: statistics: 
+green [LOGDATE] postfix/smtp[PID]: connect to [HOSTNAME]\[[IPADDR]\]: Connection refused \(port [NUM]\) 
+green [LOGDATE] postfix/sendmail[PID]: fatal: No recipient addresses found in message header
+yellow [LOGDATE] postfix/[WORD][PID]: warning: My hostname [WORD] is not a fully qualified name - set myhostname or mydomain in [PATH]
+ignore [LOGDATE] postfix/smtpd[PID]: too many errors after NOOP from [HOSTNAME]\[[IPADDR]\]
+ignore [LOGDATE] postfix/smtpd[PID]: too many errors after RCPT from [HOSTNAME]\[[IPADDR]\]
+ignore [LOGDATE] postfix/smtp[PID]: .*?: host [HOSTNAME]\[[IPADDR]\] said: 451
 red [LOGDATE] postfix/local[PID]: table has changed -- exiting
 red [LOGDATE] postfix/postfix-script: fatal: the Postfix mail system is already running
 red [LOGDATE] postfix/postfix-script: fatal: the Postfix mail system is not running
 red [LOGDATE] postfix/smtpd[PID]: lookup table has changed -- exiting
 red [LOGDATE] postfix/trivial-rewrite[PID]: table has changed -- exiting
 red [LOGDATE] postfix/smtp[PID]: fatal:
+red [LOGDATE] postfix/sendmail[PID]: fatal: [WORD]\([NUM]\): Message file too big [PATH]:
+red [LOGDATE] postfix/postdrop[PID]: warning: uid=[NUM]: File too large

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/rmacros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/rmacros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/rmacros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,11 +1,11 @@
 # macros for log2regex 
 # they are very much like the ones in the 'macros' file, but
 # specifically designed to extract rules from existing logfiles
-LOGDATE [A-Za-z]* [0-9 ][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [-\.\/0-9A-Za-z]+
+LOGDATE [A-Za-z]{3}\s{1,2}[\d]{1,2} \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
 SMONTH  (Mon|Tue|Wed|Thu|Fri|Sat|Sun)
 EMAIL   [-\.\$_0-9a-z]+@([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))?
 HOSTNAME ([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PATH	(/[-\._[:alnum:]]+){2,}([/]?)
 USER    root
 USER=   user=[-\.\$_0-9a-z]+

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/sendmail
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/sendmail	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/maillog/sendmail	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,8 +1,13 @@
-green [LOGDATE] (sm-msp-queue|sendmail)[PID]: [MSGID]: ((from=.*|to=.*|ctladdr=.*|size=.*|class=.*|pri=.*|nrcpts=.*|msgid=.*|proto=.*|dsn=.*|delay=.*|xdelay=.*|mailer=.*|relay=.*)[,\s]*)*
+green [LOGDATE] (sm-msp-queue|sendmail|sm-mta)[PID]: [MSGID]: ((from=.*|to=.*|ctladdr=.*|size=.*|class=.*|pri=.*|nrcpts=.*|msgid=.*|proto=.*|dsn=.*|delay=.*|xdelay=.*|mailer=.*|relay=.*)[,\s]*)*
 green [LOGDATE] sendmail[PID]: alias database [PATH] (auto)?rebuilt by root
 green [LOGDATE] sendmail[PID]: [PATH]: [NUM] aliases, longest [NUM] bytes, [NUM] bytes total
-green [LOGDATE] sendmail[PID]: restarting on signal /usr/sbin/sendmail
+green [LOGDATE] sendmail[PID]: restarting on signal [PATH]
 green [LOGDATE] sendmail[PID]: STARTTLS=.*, relay=.*, version=.*, verify=.*, cipher=.*, bits=.*
 green [LOGDATE] sendmail[PID]: [MSGID]: forward .*: Group writable directory
 green [LOGDATE] sendmail[PID]: gethostbyaddr\([IPADDR]\) failed: 
-
+green [LOGDATE] sendmail[PID]: gethostbyaddr\(IPv(4|6):[IPADDR]\) failed:
+green [LOGDATE] sendmail[PID]: accepting new messages \(again\)
+green [LOGDATE] sendmail[PID]: accepting connections again for daemon MTA
+green [LOGDATE] sendmail[PID]: [MSGID]: [HOSTNAME] \[[IPADDR]\] did not issue MAIL/EXPN/VRFY/ETRN during connection to MTA
+red [LOGDATE] sendmail[PID]: rejecting new messages: min free: [NUM]
+red [LOGDATE] sendmail[PID]: grew WorkList for /var/spool/mqueue to 8000

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/macros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/macros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/macros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -6,6 +6,6 @@
 PATH    (/[-\._[:alnum:]]+){2,}([/]?)
 TABLE   \w+/\w+
 HOSTNAME ([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PATH	(/[-\._[:alnum:]]+){2,}([/]?)
 NUM	[-+]?(0x)?\d+

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/rmacros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/rmacros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/mysql/rmacros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -4,6 +4,6 @@
 LOGDATE \d\d\d\d\d\d \d\d:\d\d:\d\d
 TABLE   \w+/\w+
 HOSTNAME ([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PATH	(/[-\._[:alnum:]]+){2,}([/]?)
 NUM	[-+]?(0x)?\d+

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/bgpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/bgpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/bgpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1,17 @@
+green [LOGDATE] BGP: %ADJCHANGE: neighbor [IPADDR] Down User reset
+green [LOGDATE] BGP: %ADJCHANGE: neighbor [IPADDR] Up
+green [LOGDATE] BGP: %ADJCHANGE: neighbor [IPADDR] Down BGP Notification received
+green [LOGDATE] BGP: %ADJCHANGE: neighbor [IPADDR] Down BGP Notification send
+green [LOGDATE] BGP: %ADJCHANGE: neighbor [IPADDR] Down Peer closed the session
+green [LOGDATE] BGP: %MAXPFX: No. of prefix received from [IPADDR] \(afi [NUM]\) reaches [NUM], max [NUM]
+green [LOGDATE] BGP: %MAXPFXEXCEED: No. of prefix received from [IPADDR] \(afi [NUM]\): [NUM] exceed limit [NUM]
 green [LOGDATE] BGP: %NOTIFICATION: received from neighbor [IPADDR] [NUM]/[NUM] \(Cease\) [NUM] bytes
+green [LOGDATE] BGP: %NOTIFICATION: sent to neighbor [IPADDR] [NUM]/[NUM] \(Cease/Administratively Reset\) [NUM] bytes
+green [LOGDATE] BGP: %NOTIFICATION: received from neighbor [IPADDR] [NUM]/[NUM] \(Hold Timer Expired\) [NUM] bytes
+green [LOGDATE] BGP: %NOTIFICATION: sent to neighbor [IPADDR] [NUM]/[NUM] \(Hold Timer Expired\) [NUM] bytes
+green [LOGDATE] BGP: %NOTIFICATION: sent to neighbor [IPADDR] [NUM]/[NUM] \(Cease/Maximum Number of Prefixes Reached\) [NUM] bytes
+green [LOGDATE] BGP: %NOTIFICATION: received from neighbor [IPADDR] [NUM]/[NUM] \(Cease/Connection Rejected\) [NUM] bytes
+green [LOGDATE] BGP: %NOTIFICATION: sent to neighbor [IPADDR] [NUM]/[NUM] \(Cease/Connection collision resolution\) [NUM] bytes
+green [LOGDATE] BGP: SMUX_CLOSE with reason: [NUM]
+
+yellow [LOGDATE] BGP: %NOTIFICATION: received from neighbor [IPADDR] [NUM]/[NUM] \(OPEN Message Error/Authentication Failure\) [NUM] bytes

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/macros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/macros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/macros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,6 +3,6 @@
 # match a macroname!!
 # entries are matched in the order specified
 LOGDATE \d\d\d\d/\d\d/\d\d \d\d:\d\d:\d\d
-IPADDR (25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PID 	\[\d+\]
 NUM     [-+]?\d+

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/rmacros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/rmacros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/rmacros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -2,6 +2,6 @@
 # they are very much like the ones in the 'macros' file, but
 # specifically designed to extract rules from existing logfiles
 LOGDATE [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PID 	\[[0-9]+\]
 NUM	[-+]?(0x)?\d+

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/zebra
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/zebra	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/quagga/zebra	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,3 +3,4 @@
 green [LOGDATE] ZEBRA: Zebra [NUM]\.[NUM]\.[NUM] starting: vty@[NUM]
 green [LOGDATE] ZEBRA: Terminating on signal
 green [LOGDATE] ZEBRA: Zebra [NUM]\.[NUM]\.[NUM] starting: vty@[NUM]
+green [LOGDATE] ZEBRA: SMUX_CLOSE with reason: [NUM]

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/apmd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/apmd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/apmd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,3 +1,4 @@
 green [LOGDATE] apmd[PID]: Charge: \* \* \* \(-[NUM]% unknown\)
 green [LOGDATE] apmd[PID]: Exiting
 green [LOGDATE] apmd[PID]: Version [NUM]\.[NUM]final \(APM BIOS [NUM]\.[NUM], Linux driver [NUM]\.[NUM]\)
+green [LOGDATE] apmd[PID]: apmd .* interfacing with apm driver .* and APM BIOS 

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/auditd (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/auditd)

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/automount (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/automount)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/dhcpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/dhcpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/dhcpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,3 +3,15 @@
 green [LOGDATE] dhcpd: DHCPDISCOVER from [MACADDR]
 green [LOGDATE] dhcpd: Wrote [NUM] leases to leases file\.
 green [LOGDATE] dhcpd: No hostname for [IPADDR]
+green [LOGDATE] dhcpd: Remove host declaration [WORD] or remove [IPADDR]
+green [LOGDATE] dhcpd: from the dynamic address pool for 
+green [LOGDATE] dhcpd: Dynamic and static leases present for [IPADDR].
+green [LOGDATE] dhcpd: Internet Software Consortium DHCP Server
+green [LOGDATE] dhcpd: Copyright [NUM]-[NUM] Internet Software Consortium.
+green [LOGDATE] dhcpd: All rights reserved.
+green [LOGDATE] dhcpd: For info, please visit http://www.isc.org/products/DHCP
+green [LOGDATE] dhcpd: (Listening|Sending) on LPF/.*?/.*?/[IPADDR]/[NUM]
+green [LOGDATE] dhcpd: Sending on\s+Socket/fallback/fallback-net
+green [LOGDATE] dhcpd: Wrote [NUM] deleted host decls to leases file.
+green [LOGDATE] dhcpd: Wrote [NUM] new dynamic host decls to leases file.
+green [LOGDATE] dhcpd:\s*$

Deleted: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/fast
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/fast	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/fast	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +0,0 @@
-green [LOGDATE] fast[PID]: ssh connection for [USER] to \(\) finished
-green [LOGDATE] fast[PID]: ssh connection for [USER] to [IPADDR] \(.*\) finished

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gconfd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gconfd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gconfd	2006-07-21 23:12:45 UTC (rev 633)
@@ -7,4 +7,4 @@
 green [LOGDATE] gconfd \([USER]-[NUM]\): adres gevonden "xml:readonly:[PATH]" naar een alleen-lezen configuratiebron op positie [NUM]
 green [LOGDATE] gconfd \([USER]-[NUM]\): Resolved address "xml:readwrite:[PATH]" to a writable config source at position [NUM]
 green [LOGDATE] gconfd \([USER]-[NUM]\): Adres gevonden "xml:readwrite:[PATH]" naar een schrijfbare configuratiebron op positie [NUM]
-
+green [LOGDATE] gconfd

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gdm
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gdm	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/gdm	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +1,6 @@
 green [LOGDATE] gdm-binary[PID]: Couldn't authenticate user
-
+green [LOGDATE] gdm[PID]: Couldn't authenticate user
+ignore [LOGDATE] gdm[PID]: gdm_slave_xioerror_handler: Fatal X error - Restarting [HOSTNAME]:[NUM]
+ignore [LOGDATE] gdm[PID]: gdm_slave_xioerror_handler: Fatal X error - Restarting [IPADDR]:[NUM]
+green [LOGDATE] gdm[PID]: QUERY_VT request denied: Not authenticated
+green [LOGDATE] gdm[PID]: QUERY_LOGOUT_ACTION request denied: Not authenticated

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/httpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/httpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/httpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -7,3 +7,4 @@
 green [LOGDATE] httpd: \[[SMONTH] [LOGDATE]\] \[warn\] module status_module is already loaded, skipping
 green [LOGDATE] httpd: \[[SMONTH] [LOGDATE]\] \[warn\] NameVirtualHost [IPADDR]:[NUM] has no VirtualHosts
 green [LOGDATE] httpd: [USER]
+green [LOGDATE] logger: HTTP down: return value was 0

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/identd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/identd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/identd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1,2 @@
 green [LOGDATE] identd[PID]: request_thread: read\([NUM], \.\.\., [NUM]\) failed: Connection reset by peer
+green [LOGDATE] identd[PID]: Connection from [HOSTNAME]

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/keepalived
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/keepalived	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/keepalived	2006-07-21 23:12:45 UTC (rev 633)
@@ -5,25 +5,13 @@
 green [LOGDATE] Keepalived_vrrp: VRRP_Instance(VI_eth[NUM]) Received higher prio advert
 green [LOGDATE] Keepalived_vrrp: VRRP_Instance(VI_eth[NUM]) removing protocol Virtual Routes
 green [LOGDATE] Keepalived_vrrp: VRRP_Instance(VI_eth[NUM]) Transition to MASTER STATE
-ignore [LOGDATE] Keepalived: Watchdog: Error while sending data to Healthcheck Child\. error=\(Broken pipe\)\.
-green [LOGDATE] Keepalived: Watchdog: success connecting /tmp/\.healthcheckers wdog socket
-green [LOGDATE] Keepalived: Watchdog: Healthcheck Child no longer exist, restarting\.\.\.
-green [LOGDATE] Keepalived: Remove a zombie pid file /var/run/keepalived_checkers.pid
-green [LOGDATE] Keepalived_healthcheckers: Timeout connect, timeout server \[[IPADDR]:[NUM]\]\.
-green [LOGDATE] Keepalived_healthcheckers: Removing service \[[IPADDR]:[NUM]\] from VS \[[IPADDR]:[NUM]\]
-green [LOGDATE] Keepalived_healthcheckers: Remote SMTP server \[[IPADDR]:[NUM]\] connected\.
-green [LOGDATE] Keepalived_healthcheckers: SMTP alert successfully sent\.
-green [LOGDATE] Keepalived_healthcheckers: HTTP status code success to \[[IPADDR]:[NUM]\] url\([NUM]\)\.
-green [LOGDATE] Keepalived_healthcheckers: Remote Web server \[[IPADDR]:[NUM]\] succeed on service\.
-green [LOGDATE] Keepalived_healthcheckers: Adding service \[[IPADDR]:[NUM]\] to VS \[[IPADDR]:[NUM]\]
-green [LOGDATE] Keepalived_healthcheckers: Connection trouble to: \[[IPADDR]:[NUM]\]\.
-green [LOGDATE] Keepalived_healthcheckers: Read error with server \[[IPADDR]:[NUM]\]: Connection reset by peer
-ignore [LOGDATE] Keepalived_healthcheckers: Error connecting server \[[IPADDR]:[NUM]\]\.
-green [LOGDATE] Keepalived_healthcheckers: Timeout WEB read server \[[IPADDR]:[NUM]\]\.
-green [LOGDATE] Keepalived_healthcheckers: Netlink reflector reports IP [IPADDR] added
-green [LOGDATE] Keepalived_healthcheckers: Registering Kernel netlink reflector
-green [LOGDATE] Keepalived_healthcheckers: Registering Kernel netlink comand channel
-green [LOGDATE] Keepalived_healthcheckers: Configuration is using : [NUM] Bytes
-green [LOGDATE] Keepalived_healthcheckers: IPVS : Service already exists
-green [LOGDATE] Keepalived_healthcheckers: IPVS : Destination already exists
-green [LOGDATE] Keepalived_healthcheckers: Activating healtchecker for service \[[IPADDR]:[NUM]\]
+green [LOGDATE] Keepalived: Terminating on signal
+green [LOGDATE] Keepalived_vrrp: Terminating VRRP child process on signal
+green [LOGDATE] Keepalived_vrrp: VRRP_Instance\([WORD]\) removing protocol VIPs.
+green [LOGDATE] kernel: IPVS: stopping sync thread [NUM] ..
+green [LOGDATE] Keepalived: Stopping Keepalived 
+green [LOGDATE] kernel: IPVS: sync thread stopped!
+green [LOGDATE] Keepalived_healthcheckers: Terminating Healthchecker child process on signal
+green [LOGDATE] Keepalived_healthcheckers: IPVS: No such destination
+red [LOGDATE] Keepalived_healthcheckers: Error connecting server \[[IPADDR]:[NUM]\]\.
+red [LOGDATE] Keepalived_healthcheckers: Cannot send get request to \[[IPADDR]:[NUM]\]\.

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/linux.kernel (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/linux.kernel)

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/logrotate (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/logrotate)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/macros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/macros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/macros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,10 +3,10 @@
 # match a macroname!!
 # entries are matched in the order specified
 WLOGDATE (Mon|Tue|Wed|Thu|Fri|Sat|Sun) [A-Za-z]* [\d ]\d \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
-LOGDATE [A-Za-z]* [\d ]\d \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
+LOGDATE [A-Za-z]{3}\s{1,2}[\d]{1,2} \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
 EMAIL   [-\.\$\w]+@[a-z\d][-a-z\d]*(\.[a-z\d][-a-z\d]+)*\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z])
 HOSTNAME ([a-z\d][-a-z\d]*)(\.[a-z\d][-a-z\d]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))?
-IPADDR (25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 HOSTNAM [-\da-z]+
 MACADDR ([a-f\d][a-f\d])(:[a-f\d][a-f\d]){5,}
 PATH	/?[-_\.[:alnum:]]?(/[-_\.[:alnum:]]+)*/?

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/named
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/named	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/named	2006-07-21 23:12:45 UTC (rev 633)
@@ -3,8 +3,8 @@
 green [LOGDATE] named[PID]: check_hints: A records for J\.ROOT-SERVERS\.NET class [NUM] do not match hint records
 green [LOGDATE] named[PID]: Cleaned cache of [NUM] RRset
 green [LOGDATE] named[PID]: client [IPADDR]#[NUM]: bad zone transfer request: '[HOSTNAME]/IN': non-authoritative zone \(NOTAUTH\)
-ignore [LOGDATE] named[PID]: client [IPADDR]#[NUM]: error sending response: host unreachable
 ignore [LOGDATE] named[PID]: client [IPADDR]#[NUM]: error sending response: invalid file
+ignore [LOGDATE] named[PID]: client [IPADDR]#[NUM]: error sending response: host unreachable
 green [LOGDATE] named[PID]: client [IPADDR]#[NUM]: no more recursive clients: quota reached
 green [LOGDATE] named[PID]: client [IPADDR]#[NUM]: update forwarding denied
 green [LOGDATE] named[PID]: client [IPADDR]#[NUM]: update '[HOSTNAME]/IN' denied
@@ -16,7 +16,6 @@
 green [LOGDATE] named[PID]: dns_master_load: [PATH]:[NUM]: ignoring out-of-zone data \(.*\)
 green [LOGDATE] named[PID]: drained [NUM] queries \(delay [NUM] sec\)
 green [LOGDATE] named[PID]: exiting
-
 green [LOGDATE] named[PID]: Forwarding source address is \[[IPADDR]\]\.[NUM]
 green [LOGDATE] named[PID]: group = [NUM]
 green [LOGDATE] named[PID]: hint zone "" \(IN\) loaded \(serial [NUM]\)

Deleted: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/netland
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/netland	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/netland	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +0,0 @@
-green [LOGDATE] make-backup.sh[PID]: backup done
-

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/newsyslog (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/newsyslog)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/nfs-utils
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/nfs-utils	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/nfs-utils	2006-07-21 23:12:45 UTC (rev 633)
@@ -6,5 +6,5 @@
 green [LOGDATE] rpc.mountd: authenticated (un)?mount request from [HOSTNAME]:[NUM] for [PATH] \([PATH]\)
 green [LOGDATE] rpc.mountd: refused mount request from [HOSTNAME] for [PATH] \([PATH]\)
 green [LOGDATE] rpc.statd[PID]: Caught signal [NUM], un-registering and exiting\.
+green [LOGDATE] rpc.mountd: Caught signal [NUM], un-registering and exiting.
 
-

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/openntpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/openntpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/openntpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -2,12 +2,18 @@
 green [LOGDATE] ntpd[PID]: ntp engine ready
 green [LOGDATE] ntpd[PID]: peer [IPADDR] now invalid
 green [LOGDATE] ntpd[PID]: peer [IPADDR] now valid
-green [LOGDATE] services[NUM] ntpd[PID]: listening on [IPADDR]
-green [LOGDATE] services[NUM] ntpd[PID]: ntp engine ready
-green [LOGDATE] services[NUM] ntpd[PID]: peer [IPADDR] now valid
+green [LOGDATE] ntpd[PID]: listening on [IPADDR]
+green [LOGDATE] ntpd[PID]: ntp engine ready
+green [LOGDATE] ntpd[PID]: peer [IPADDR] now valid
 green [LOGDATE] ntpd[PID]: adjusting local clock by
 green [LOGDATE] ntpd[PID]: Terminating
 green [LOGDATE] ntpd[PID]: ntp engine exiting
 green [LOGDATE] ntpd[PID]: dispatch_imsg in main: pipe closed
 green [LOGDATE] ntpd[PID]: Lost child: child exited
+green [LOGDATE] ntpd[PID]: recvfrom [IPADDR]: Connection refused
+green [LOGDATE] ntpd[PID]: reply from [IPADDR]: not synced, next query [NUM]s
+green [LOGDATE] ntpd[PID]: sendto: Operation not permitted
+green [LOGDATE] ntpd[PID]: sendto: Connection refused
+green [LOGDATE] ntpd[PID]: IMSG_HOST_DNS with invalid peerID
+yellow [LOGDATE] ntpd[PID]: could not parse "[HOSTNAME]": Temporary failure in name resolution
 red [LOGDATE] ntpd[PID]: adjtime failed: Invalid argument

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/pam
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/pam	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/pam	2006-07-21 23:12:45 UTC (rev 633)
@@ -17,5 +17,7 @@
 green [LOGDATE] [WORD]\(pam_unix\)[PID]: session closed for [USER_]
 green [LOGDATE] [WORD]\(pam_unix\)[PID]: session (opened|closed) for [USER_]
 green [LOGDATE] [WORD]\(pam_unix\)[PID]: session opened for [USER_]
-green [LOGDATE] [WORD]\(pam_unix\)[PID]: password changed for raarts
-
+green [LOGDATE] [WORD]\(pam_unix\)[PID]: password changed for [USER]
+green [LOGDATE] [WORD]\(pam_unix\)[PID]: auth could not identify password for \[[USER]\]
+green [LOGDATE] unix_chkpwd[PID]: password check failed for user \([USER]\)
+green [LOGDATE] passwd(pam_unix)[PID]: password changed for [USER]

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/postgresql (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/postgresql)

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/quagga (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/quagga)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/rmacros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/rmacros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/rmacros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,11 +1,11 @@
 # macros for log2regex 
 # they are very much like the ones in the 'macros' file, but
 # specifically designed to extract rules from existing logfiles
-LOGDATE [A-Za-z]* [0-9 ][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [-\.\/0-9A-Za-z]+
+LOGDATE [A-Za-z]{3}\s{1,2}[\d]{1,2} \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
 SMONTH  (Mon|Tue|Wed|Thu|Fri|Sat|Sun)
 EMAIL   [-\.\$_0-9a-z]+@([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))?
 HOSTNAME ([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PATH	(/[-\._[:alnum:]]+){2,}([/]?)
 MACADDR ([a-f0-9][a-f0-9])(:[a-f0-9][a-f0-9]){5,}
 TCPFLAG (SYN|ACK|PSH|FIN|RST)(\ (SYN|ACK|PSH|FIN|RST))*

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/rpc (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/rpc)

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/selinux (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/selinux)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/shorewall
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/shorewall	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/shorewall	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1,2 @@
 green [LOGDATE] kernel: Shorewall:
+green [LOGDATE] root: Shorewall Restarted

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/smb
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/smb	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/smb	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +1,22 @@
 green [LOGDATE] smb: nmbd shutdown failed
 green [LOGDATE] smb: smbd shutdown failed
+green [LOGDATE] mount.smbfs[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] client/smbmount.c:send_fs_socket\([NUM]\)
+green [LOGDATE] smbd[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] lib/access.c:check_access\([NUM]\)
+green [LOGDATE] smbd[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] lib/util_sock.c:get_peer_addr\([NUM]\)
+ignore [LOGDATE] smbd[PID]:\s*getpeername failed. Error was Transport endpoint is not connected
+green [LOGDATE] smbd[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] lib/util_sock.c:read_socket_data\([NUM]\)
+ignore [LOGDATE] smb_lookup: find .* failed, error=-512
+green [LOGDATE] smb_add_request: request \[.*, .*\] timed out!
+green [LOGDATE] mount.smbfs[PID]: tdb\([PATH]\): tdb_lock failed on list [NUM] ltype=[NUM] \(Bad file descriptor\)
+green [LOGDATE] mount.smbfs[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] tdb/tdbutil.c:tdb_log\([NUM]\) 
+green [LOGDATE] kernel: smb_proc_readX_data:
+ignore [LOGDATE] smbd[PID]:\s*Error writing [NUM] bytes to client. [NUM]. \(Connection reset by peer\)
+green [LOGDATE] smbd[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] lib/util_sock.c:send_smb\([NUM]\)
+ignore [LOGDATE] smbd[PID]: write_socket_data: write failure. Error = Connection reset by peer
+green [LOGDATE] smbd[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] lib/util_sock.c:write_socket_data\([NUM]\) 
+green [LOGDATE] smb_add_request: request \[.*\] timed out!
+green [LOGDATE] mount.smbfs[PID]: tdb\([PATH]\): tdb_lock failed on list [NUM] ltype=[NUM] \(Bad file descriptor\)
+green [LOGDATE] nmbd[PID]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] nmbd/nmbd_responserecordsdb.c:find_response_record\([NUM]\) 
+green [LOGDATE] nmbd[PID]: find_response_record: response packet id [NUM] received with no matching record.
+green [LOGDATE] smbd[13734]: \[[NUM]/[NUM]/[NUM] [NUM]:[NUM]:[NUM], [NUM]\] lib/util_sock.c:write_data\([NUM]\)
+ignore [LOGDATE] smbd[13734]:\s*write_data: write failure in writing to client [IPADDR]. Error Connection reset by peer

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/snmpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/snmpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/snmpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1,7 @@
 green [LOGDATE] snmpd: snmpd shutdown failed
+green [LOGDATE] snmpd[PID]: Received SNMP packet\(s\) from UDP: \[[IPADDR]\]:[NUM]
+green [LOGDATE] snmpd[PID]: Connection from UDP: \[[IPADDR]\]:[NUM]
+green [LOGDATE] snmpd[PID]: [smux_accept] accepted fd [NUM] from  \[[IPADDR]\]:[NUM]
+green [LOGDATE] snmpd[PID]: [smux_accept] accepted fd [NUM] from [IPADDR]:[NUM]
+green [LOGDATE] snmpd[PID]: accepted smux peer: oid SNMPv2-SMI::enterprises\.[NUM]\.[NUM]\.[NUM]\.[NUM], descr 
+green [LOGDATE] snmpd[PID]: Got trap from peer on fd [NUM]

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sophie
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sophie	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sophie	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,6 +1,6 @@
 green [LOGDATE] sophie: [PATH] placed in the background
-green [LOGDATE] sophie[PID]: Callbacks\?       : yes 
-green [LOGDATE] sophie[PID]: Error strings\?   : yes 
+green [LOGDATE] sophie[PID]: Callbacks\?       : [WORD] 
+green [LOGDATE] sophie[PID]: Error strings\?   : [WORD] 
 green [LOGDATE] sophie[PID]: File '[PATH]' infected with virus '.*' 
 green [LOGDATE] sophie[PID]: limit_classif    : [NUM] 
 green [LOGDATE] sophie[PID]: limit_decompr    : [NUM] 
@@ -16,19 +16,19 @@
 green [LOGDATE] sophie[PID]: notice           : SIGNAL '[NUM]' caught - cleaning up and exiting\. 
 green [LOGDATE] sophie[PID]: [PATH] Placed in the background \[PID: [NUM]\] 
 green [LOGDATE] sophie[PID]: PID file         : [PATH] 
-green [LOGDATE] sophie[PID]: Running as user  : mail 
+green [LOGDATE] sophie[PID]: Running as user  : [WORD]
 green [LOGDATE] sophie[PID]: SAVI config      : [PATH] 
-green [LOGDATE] sophie[PID]: Show virus name\? : yes 
+green [LOGDATE] sophie[PID]: Show virus name\? : [WORD]
 ignore [LOGDATE] sophie[PID]: Error strings
-green [LOGDATE] sophie[PID]: socket_check     : yes 
-green [LOGDATE] sophie[PID]: Socket group     : mail 
+green [LOGDATE] sophie[PID]: socket_check     : [WORD]
+green [LOGDATE] sophie[PID]: Socket group     : [WORD]
 green [LOGDATE] sophie[PID]: Socket path      : [PATH] 
 green [LOGDATE] sophie[PID]: Sophie child has timed-out \(no data received in [NUM] seconds\) - process killed 
 green [LOGDATE] sophie[PID]: Sophie IDE       : Sophos IDE version [NUM]\.[NUM] \(detects [NUM] viruses\) 
 green [LOGDATE] sophie[PID]: Sophie version   : [NUM]\.[NUM]rc[NUM] 
 green [LOGDATE] sophie[PID]: Sophos engine    : Sophos engine version [NUM]\.[NUM] 
 green [LOGDATE] sophie[PID]: Timeout          : [NUM] seconds 
-green [LOGDATE] sophie[PID]: Timestamps\?      : no 
+green [LOGDATE] sophie[PID]: Timestamps\?      : [WORD]
 green [LOGDATE] sophie[PID]: Umask            : [NUM] 
 green [LOGDATE] sophie[PID]: warning          : Scan result => '[PATH]' infected with virus '.*' 
 green [LOGDATE] sophie[PID]: warning          : Socket '[PATH]' already exists! 

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/spamd (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/spamd)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sshd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sshd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sshd	2006-07-21 23:12:45 UTC (rev 633)
@@ -32,6 +32,7 @@
 green [LOGDATE] sshd[PID]: fatal: Did not receive ident string\.
 ignore [LOGDATE] sshd[PID]: fatal: Read error from remote host: Connection reset by peer
 green [LOGDATE] sshd[PID]: fatal: Read from socket failed: Connection reset by peer
+ignore [LOGDATE] sshd[PID]: Read error from remote host [IPADDR]: Connection reset by peer
 green [LOGDATE] sshd[PID]: fatal: Timeout before authentication for [IPADDR]
 green [LOGDATE] sshd[PID]: Found matching DSA key: [MACADDR]
 green [LOGDATE] sshd[PID]: Generating new [NUM] bit RSA key\.
@@ -66,3 +67,10 @@
 ignore [LOGDATE] sshd[PID]: syslogin_perform_logout: logout\(\) returned an error
 green [LOGDATE] sshd[PID]: WARNING: [PATH] does not exist, using old modulus
 green [LOGDATE] sshd[PID]: WARNING: [PATH] does not exist, using old prime
+ignore [LOGDATE] sshd[PID]: Read error from remote host [IPADDR]: No route to host
+green [LOGDATE] sshd[PID]: input_userauth_request: invalid user [USER]
+green [LOGDATE] sshd[PID]: Authentication refused: bad ownership or modes for file [PATH]
+green [LOGDATE] sshd: sshd shutdown failed
+ignore [LOGDATE] sshd[PID]: Read error from remote host [IPADDR]: Connection timed out
+ignore [LOGDATE] sshd[PID]: error: Bind to port [NUM] on [IPADDR] failed: Address already in use.
+green [LOGDATE] sshd\(pam_unix\)[PID]: service\(sshd\) ignoring max retries; [NUM] > [NUM]

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/su
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/su	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/su	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +1,4 @@
 green [LOGDATE] su: \(to [USER]\) [USER] on none
+green [LOGDATE] su: [USER] to [USER] on /dev/[WORD][NUM]
 green [LOGDATE] su: pam_unix2: session finished for user [USER], service su
+green [LOGDATE] su[PID]: Warning! Could not relabel with user_u:object_r:devpts_t, not relabeling. 

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sudo
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sudo	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/sudo	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1 @@
-green [LOGDATE] sudo:   nobody : TTY=unknown ; PWD=[PATH] ; USER=[USER] ; COMMAND=[PATH] 
+green [LOGDATE] sudo:\s+[USER] : TTY=[WORD][NUM] ; PWD=[PATH] ; USER=[USER] ; COMMAND=[PATH]

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/syslogd (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/syslogd)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/tftpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/tftpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/tftpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1,3 @@
 green [LOGDATE] in.tftpd[PID]: nak: Operation not permitted
+green [LOGDATE] in.tftpd[PID]: sending NAK \([NUM], File not found\) to [IPADDR]
+green [LOGDATE] in.tftpd[PID]: RRQ from [IPADDR] filename .*

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/upwatch
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/upwatch	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/upwatch	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +1,4 @@
 green [LOGDATE] uw_[WORD]: uw_[WORD] shutdown failed
 green [LOGDATE] uw_maint.pl[PID]: [NUM] finished
+green [LOGDATE] upwatch:\s*$
+green [LOGDATE] upwatch: \^\[\[[NUM]

Copied: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/useradd (from rev 632, upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog/useradd)

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/vsftpd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/vsftpd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/vsftpd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1 +1,2 @@
 green [LOGDATE] vsftpd(pam_unix)[PID]: check pass; user unknown
+green [LOGDATE] vsftpd: warning: can't get client address: Bad file descriptor

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xfs
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xfs	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xfs	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,4 +1,5 @@
 green [LOGDATE] xfs: ignoring font path element [PATH] \(unreadable\) 
+green [LOGDATE] xfs: ignoring font path element [PATH]:[WORD] \(unreachable\)
 green [LOGDATE] xfs[PID]: attempting clone\.\.\. 
 green [LOGDATE] xfs[PID]: clone: child becoming drone 
 green [LOGDATE] xfs[PID]: clone: parent revitalizing as xfs 

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xinetd
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xinetd	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/syslog/xinetd	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,2 +1 @@
 green [LOGDATE] xinetd[PID]: Exiting\.\.\.
-green [LOGDATE] xinetd[PID]: [NUM] .* no services. Exiting...

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/macros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/macros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/macros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -2,10 +2,10 @@
 # choose your macronames carefully. regular expressions should never
 # match a macroname!!
 # entries are matched in the order specified
-LOGDATE [A-Za-z]* [\d ]\d \d\d:\d\d:\d\d [-\/\dA-Za-z]+
+LOGDATE [A-Za-z]{3}\s{1,2}[\d]{1,2} \d\d:\d\d:\d\d [-\.\/\dA-Za-z]+
 TABLE   \w+/\w+
 HOSTNAME ([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})
 PATH	(/[-\._[:alnum:]]+){2,}([/]?)
 WORD	[-\.\dA-Za-z_]+
 NUM	[-+]?(0x)?\d+

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/rmacros.txt
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/rmacros.txt	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/rmacros.txt	2006-07-21 23:12:45 UTC (rev 633)
@@ -5,7 +5,7 @@
 SMONTH  (Mon|Tue|Wed|Thu|Fri|Sat|Sun)
 EMAIL   [-\.\$_0-9a-z]+@([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))?
 HOSTNAME ([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)*(\.(arpa|com|edu|biz|org|gov|int|info|mil|net|name|museum|coop|aero|[a-z][a-z]))
-IPADDR	(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])){3}
+IPADDR ((([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?)|((25[0-5]|2[0-4][\d]|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3})	
 PATH	(/[-\._[:alnum:]]+){2,}([/]?)
 MACADDR ([a-f0-9][a-f0-9])(:[a-f0-9][a-f0-9]){5,}
 TCPFLAG (SYN|ACK|PSH|FIN|RST)(\ (SYN|ACK|PSH|FIN|RST))*

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/upwatch
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/upwatch	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.d/upwatch/upwatch	2006-07-21 23:12:45 UTC (rev 633)
@@ -1,45 +1,59 @@
 green [LOGDATE] rpm[PID]: installe
-green [LOGDATE] uw_ping[PID]: run\.c\([NUM]\): ICMP Echo from [IPADDR]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [WORD]: purpled [NUM] probes
-green [LOGDATE] uw_[WORD][PID]: last message repeated [NUM] times
-green [LOGDATE] uw_[WORD][PID]: logregex\.c\([NUM]\): loading [PATH]
-green [LOGDATE] uw_[WORD][PID]: logregex\.c\([NUM]\): reloading [PATH]
-green [LOGDATE] uw_[WORD][PID]: main\.c\([NUM]\): exit
-green [LOGDATE] uw_[WORD][PID]: main\.c\([NUM]\): run [NUM]: processed [NUM] items in [NUM]\.[NUM] seconds
-green [LOGDATE] uw_[WORD][PID]: main\.c\([NUM]\): signal [NUM] received - finishing up
-green [LOGDATE] uw_[WORD][PID]: main\.c\([NUM]\): sleeping for [NUM] seconds
-green [LOGDATE] uw_[WORD][PID]: main\.c\([NUM]\): start
-green [LOGDATE] uw_[WORD][PID]: notify\.c\([NUM]\): MAILTO: [EMAIL] [NUM] [NUM] Message accepted for delivery
-green [LOGDATE] uw_[WORD][PID]: notify\.c\([NUM]\): MAILTO: [EMAIL] [NUM] Ok: queued as
-green [LOGDATE] uw_[WORD][PID]: notify\.c\([NUM]\): [HOSTNAME]: [WORD] [COLOR] \(was [COLOR]\)
-green [LOGDATE] uw_[WORD][PID]: pr_process\.c\([NUM]\): Processing [PATH]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): can't resolve [HOSTNAME]: No such file or directory
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): child [NUM] exited with status [NUM]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]:
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: Broken pipe
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: Connection reset by peer
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: Login error:
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: new connection
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: [PATH] close error
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: spooled to [PATH]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: timeout on greeting string
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: timeout reading DATA statement
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: timeout reading fileblock
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: timeout reading PASS response
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [IPADDR]: timeout reading USER string
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [PATH]: empty file
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): reading info from database
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): running [NUM] probes
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): signal [NUM] received - finishing up
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): started [PID]: on [PATH]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): st_read: Connection reset by peer
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): unknown message:
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): uploaded [PATH]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): user [WORD], pwd [WORD] not found
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): [WORD]: purpled [WORD] [NUM]
-green [LOGDATE] uw_[WORD][PID]: run\.c\([NUM]\): writing results
-green [LOGDATE] uw_[WORD][PID]: spool\.c\([NUM]\): spooled to [PATH]
-red [LOGDATE] uw_[WORD][PID]: db\.c\([NUM]\): Too many connections
-red [LOGDATE] uw_[WORD][PID]: notify\.c\([NUM]\): UPWATCH: probe mysqlstats is lagging in processing
-
+green [LOGDATE] uw_ping[PID] run\.c\([NUM]\): ICMP Echo from [IPADDR]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [WORD]: purpled [NUM] probes
+green [LOGDATE] uw_[WORD][PID] last message repeated [NUM] times
+green [LOGDATE] uw_[WORD][PID] logregex\.c\([NUM]\): loading [PATH]
+green [LOGDATE] uw_[WORD][PID] logregex\.c\([NUM]\): reloading [PATH]
+green [LOGDATE] uw_[WORD][PID] main\.c\([NUM]\): exit
+green [LOGDATE] uw_[WORD][PID] main\.c\([NUM]\): run [NUM]: processed [NUM] items in [NUM]\.[NUM] seconds
+green [LOGDATE] uw_[WORD][PID] main\.c\([NUM]\): signal [NUM] received - finishing up
+green [LOGDATE] uw_[WORD][PID] main\.c\([NUM]\): sleeping for [NUM] seconds
+green [LOGDATE] uw_[WORD][PID] main\.c\([NUM]\): start
+green [LOGDATE] uw_[WORD][PID] notify\.c\([NUM]\): MAILTO: [EMAIL] [NUM] [NUM] Message accepted for delivery
+green [LOGDATE] uw_[WORD][PID] notify\.c\([NUM]\): MAILTO: [EMAIL] [NUM] Ok: queued as
+green [LOGDATE] uw_[WORD][PID] notify\.c\([NUM]\): [HOSTNAME]: [WORD] [COLOR] \(was [COLOR]\)
+green [LOGDATE] uw_[WORD][PID] pr_process\.c\([NUM]\): Processing [PATH]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): can't resolve [HOSTNAME]: No such file or directory
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): child [NUM] exited with status [NUM]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]:
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: Broken pipe
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: Connection reset by peer
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: Login error:
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: new connection
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: [PATH] close error
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: spooled to [PATH]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: timeout on greeting string
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: timeout reading DATA statement
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: timeout reading fileblock
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: timeout reading PASS response
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [IPADDR]: timeout reading USER string
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [PATH]: empty file
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): reading info from database
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): running [NUM] probes
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): signal [NUM] received - finishing up
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): started [PID]: on [PATH]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): st_read: Connection reset by peer
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): read: Connection reset by peer
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): unknown message:
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): uploaded [PATH]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): user [WORD], pwd [WORD] not found
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [WORD]: purpled [WORD] [NUM]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): writing results
+green [LOGDATE] uw_[WORD][PID] spool\.c\([NUM]\): spooled to [PATH]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): [HOSTNAME]:[NUM]: Timer expired
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): timeout reading [WORD] response
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): timeout reading [WORD] command
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): timeout reading login request string
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): st_read: Connection reset by peer
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): timeout reading OK enter password
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): SIGALRM received
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): read: Interrupted system call
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\):\s*$ 
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): Processing [PATH]
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): processing ..
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): sleeping
+green [LOGDATE] uw_[WORD][PID] run\.c\([NUM]\): syncing..
+red [LOGDATE] uw_[WORD][PID] db\.c\([NUM]\): Too many connections
+red [LOGDATE] uw_[WORD][PID] notify\.c\([NUM]\): UPWATCH: probe [WORD] is lagging in processing
+red [LOGDATE] uw_[WORD][PID] db\.c\([NUM]\): Can't connect to MySQL server on '[HOSTNAME]' \([NUM]\) dbhost=[HOSTNAME],dbport=[NUM],dbname=[WORD],db

Modified: upwatch/libdbi/uw_sysstat/uw_sysstat.def
===================================================================
--- upwatch/libdbi/uw_sysstat/uw_sysstat.def	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_sysstat/uw_sysstat.def	2006-07-21 23:12:45 UTC (rev 633)
@@ -34,19 +34,6 @@
 
 // describe commandline flags
 flag = {
-    name      = domain;
-    value     = D;
-    arg_type  = string;
-    descrip   = "upwatch domain where this probe belongs to";
-    doc       =
-'The upwatch backend can work with several domains. Each domain is maintained in
-a separate database, defines its own probes, and receives its own results. 
-With this option you can specify the domain where the result for this probe
-will be stored';
-};
-
-// describe commandline flags
-flag = {
     name      = realm;
     value     = R;
     arg_type  = string;
@@ -121,7 +108,6 @@
 
 flag = {
     name      = hwstats;
-    value     = h;
     arg_type  = bool;
     descrip   = "Generate hardware statistics";
     doc       =
@@ -160,6 +146,14 @@
 };
 
 flag = {
+    name      = ignorediskfree;
+    arg_type  = string;   /* option argument indication  */
+    stack_arg;
+    descrip   = "Ignore the diskfree status of this disk";
+};
+
+
+flag = {
     name      = ipaddress;
     arg_type  = string;   /* option argument indication  */
     arg_default = "127.0.0.1";
@@ -240,5 +234,3 @@
 
 #include license_gpl.def
 #include generic_options.def
-#include dbase_options_ign.def
-

Modified: upwatch/libdbi/uw_tcpconnect/run.c
===================================================================
--- upwatch/libdbi/uw_tcpconnect/run.c	2006-07-21 20:34:40 UTC (rev 632)
+++ upwatch/libdbi/uw_tcpconnect/run.c	2006-07-21 23:12:45 UTC (rev 633)
@@ -222,7 +222,7 @@
 void write_results(void)
 {
   int ct  = STACKCT_OPT(OUTPUT);
-  char **output = STACKLST_OPT(OUTPUT);
+  char **output = (char **) &STACKLST_OPT(OUTPUT);
   int i;
   xmlDocPtr doc;
 



From wijnand at mail.berlios.de  Thu Jul 27 15:46:36 2006
From: wijnand at mail.berlios.de (wijnand at BerliOS)
Date: Thu, 27 Jul 2006 15:46:36 +0200
Subject: [Upwatch-commits] r635 - upwatch/trunk/uw_ping
Message-ID: <200607271346.k6RDkafm032602@sheep.berlios.de>

Author: wijnand
Date: 2006-07-27 15:46:34 +0200 (Thu, 27 Jul 2006)
New Revision: 635

Modified:
   upwatch/trunk/uw_ping/uw_ping.conf
Log:
Fix default uw_ping.conf


Modified: upwatch/trunk/uw_ping/uw_ping.conf
===================================================================
--- upwatch/trunk/uw_ping/uw_ping.conf	2006-07-26 16:12:53 UTC (rev 634)
+++ upwatch/trunk/uw_ping/uw_ping.conf	2006-07-27 13:46:34 UTC (rev 635)
@@ -2,4 +2,4 @@
 #logfile /var/log/upwatch/uw_ping.log
 
 # maildir name where to drop results
-output uw_test
+output uw_send



