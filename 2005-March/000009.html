<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Upwatch-commits] r479 - in upwatch/trunk: . mswindows mswindows/Monitor mswindows/MonitorClient mswindows/MonitorService mswindows/MonitorService/glib-dev-2.4.5 mswindows/MonitorService/glib-dev-2.4.5/include mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0 mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/upwatch-commits/2005-March/index.html" >
   <LINK REL="made" HREF="mailto:upwatch-commits%40lists.berlios.de?Subject=Re%3A%20%5BUpwatch-commits%5D%20r479%20-%20in%20upwatch/trunk%3A%20.%20mswindows%20mswindows/Monitor%20mswindows/MonitorClient%20mswindows/MonitorService%20mswindows/MonitorService/glib-dev-2.4.5%20mswindows/MonitorService/glib-dev-2.4.5/include%20mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0%20mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib%20mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject&In-Reply-To=%3C200503252056.j2PKuunI020595%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000008.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Upwatch-commits] r479 - in upwatch/trunk: . mswindows mswindows/Monitor mswindows/MonitorClient mswindows/MonitorService mswindows/MonitorService/glib-dev-2.4.5 mswindows/MonitorService/glib-dev-2.4.5/include mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0 mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject</H1>
    <B>Ron Arts at BerliOS</B> 
    <A HREF="mailto:upwatch-commits%40lists.berlios.de?Subject=Re%3A%20%5BUpwatch-commits%5D%20r479%20-%20in%20upwatch/trunk%3A%20.%20mswindows%20mswindows/Monitor%20mswindows/MonitorClient%20mswindows/MonitorService%20mswindows/MonitorService/glib-dev-2.4.5%20mswindows/MonitorService/glib-dev-2.4.5/include%20mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0%20mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib%20mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject&In-Reply-To=%3C200503252056.j2PKuunI020595%40sheep.berlios.de%3E"
       TITLE="[Upwatch-commits] r479 - in upwatch/trunk: . mswindows mswindows/Monitor mswindows/MonitorClient mswindows/MonitorService mswindows/MonitorService/glib-dev-2.4.5 mswindows/MonitorService/glib-dev-2.4.5/include mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0 mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject">raarts at sheep.berlios.de
       </A><BR>
    <I>Fri Mar 25 21:56:56 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000008.html">[Upwatch-commits] r478 - upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: raarts
Date: 2005-03-25 21:56:55 +0100 (Fri, 25 Mar 2005)
New Revision: 479

Added:
   upwatch/trunk/mswindows/
   upwatch/trunk/mswindows/Monitor/
   upwatch/trunk/mswindows/Monitor/Monitor.sln
   upwatch/trunk/mswindows/MonitorClient/
   upwatch/trunk/mswindows/MonitorClient/LogUploader.cpp
   upwatch/trunk/mswindows/MonitorClient/LogUploader.h
   upwatch/trunk/mswindows/MonitorClient/MonitorClient.aps
   upwatch/trunk/mswindows/MonitorClient/MonitorClient.cpp
   upwatch/trunk/mswindows/MonitorClient/MonitorClient.h
   upwatch/trunk/mswindows/MonitorClient/MonitorClient.rc
   upwatch/trunk/mswindows/MonitorClient/MonitorClient.vcproj
   upwatch/trunk/mswindows/MonitorClient/ReadMe.txt
   upwatch/trunk/mswindows/MonitorClient/SetupDialog.cpp
   upwatch/trunk/mswindows/MonitorClient/SetupDialog.h
   upwatch/trunk/mswindows/MonitorClient/icon1.ico
   upwatch/trunk/mswindows/MonitorClient/resource.h
   upwatch/trunk/mswindows/MonitorClient/stdafx.cpp
   upwatch/trunk/mswindows/MonitorClient/stdafx.h
   upwatch/trunk/mswindows/MonitorService/
   upwatch/trunk/mswindows/MonitorService/ErrorLog.h
   upwatch/trunk/mswindows/MonitorService/LogUploader.cpp
   upwatch/trunk/mswindows/MonitorService/LogUploader.h
   upwatch/trunk/mswindows/MonitorService/Main.cpp
   upwatch/trunk/mswindows/MonitorService/Main.h
   upwatch/trunk/mswindows/MonitorService/MonitorOutput.cpp
   upwatch/trunk/mswindows/MonitorService/MonitorOutput.h
   upwatch/trunk/mswindows/MonitorService/MonitorService.vcproj
   upwatch/trunk/mswindows/MonitorService/SystemInformation.cpp
   upwatch/trunk/mswindows/MonitorService/SystemInformation.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib-object.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/galloca.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/garray.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gasyncqueue.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gatomic.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gbacktrace.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcache.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcompletion.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gconvert.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdataset.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdate.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdir.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gerror.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gfileutils.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghash.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghook.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n-lib.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/giochannel.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/glist.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmacros.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmain.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmarkup.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmem.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmessages.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gnode.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gpattern.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprimes.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprintf.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqsort.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gquark.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqueue.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grand.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grel.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gscanner.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gshell.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gslist.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gspawn.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstrfuncs.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstring.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthread.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthreadpool.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtimer.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtree.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtypes.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gunicode.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gutils.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gwin32.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glibconfig.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gmodule.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gboxed.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gclosure.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/genums.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gmarshal.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobject.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobjectnotifyqueue.c
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparam.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparamspecs.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsignal.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsourceclosure.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtype.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypemodule.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypeplugin.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvalue.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluearray.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluecollector.h
   upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluetypes.h
   upwatch/trunk/mswindows/MonitorService/glib.lib
   upwatch/trunk/mswindows/MonitorService/libpcre.lib
   upwatch/trunk/mswindows/MonitorService/log.cpp
   upwatch/trunk/mswindows/MonitorService/log.h
   upwatch/trunk/mswindows/MonitorService/logregex.cpp
   upwatch/trunk/mswindows/MonitorService/logregex.h
   upwatch/trunk/mswindows/MonitorService/pcre.h
   upwatch/trunk/mswindows/MonitorService/pcreposix.h
   upwatch/trunk/mswindows/MonitorService/snprintf.c
   upwatch/trunk/mswindows/MonitorService/snprintf.h
Modified:
   upwatch/trunk/Makefile.am
Log:
Added the client for Microsoft Windows.


Modified: upwatch/trunk/Makefile.am
===================================================================
--- upwatch/trunk/Makefile.am	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/Makefile.am	2005-03-25 20:56:55 UTC (rev 479)
@@ -81,7 +81,7 @@
 
 EXTRA_DIST = Makefile.am.common Makefile.am.libs Makefile.am.path VERSION RELEASE libtool ChangeLog \
   upwatch-spec.def upwatch-spec.tpl upwatch.spec templates \
-  patches/libpcap-linux-timeout.patch \
+  patches/libpcap-linux-timeout.patch mswindows \
   ${SERVER_DIST} \
   install-sh config.sub mkinstalldirs depcomp cfg/cvs2cl.pl
 

Added: upwatch/trunk/mswindows/Monitor/Monitor.sln
===================================================================
--- upwatch/trunk/mswindows/Monitor/Monitor.sln	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/Monitor/Monitor.sln	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,29 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;MonitorClient&quot;, &quot;..\MonitorClient\MonitorClient.vcproj&quot;, &quot;{A5267F5A-022D-40D4-9D87-3A7F18C80622}&quot;
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;MonitorService&quot;, &quot;..\MonitorService\MonitorService.vcproj&quot;, &quot;{DDF220C1-EAEC-484E-8355-9BBCF41E2A22}&quot;
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{A5267F5A-022D-40D4-9D87-3A7F18C80622}.Debug.ActiveCfg = Release|Win32
+		{A5267F5A-022D-40D4-9D87-3A7F18C80622}.Debug.Build.0 = Release|Win32
+		{A5267F5A-022D-40D4-9D87-3A7F18C80622}.Release.ActiveCfg = Release|Win32
+		{A5267F5A-022D-40D4-9D87-3A7F18C80622}.Release.Build.0 = Release|Win32
+		{DDF220C1-EAEC-484E-8355-9BBCF41E2A22}.Debug.ActiveCfg = Release|Win32
+		{DDF220C1-EAEC-484E-8355-9BBCF41E2A22}.Debug.Build.0 = Release|Win32
+		{DDF220C1-EAEC-484E-8355-9BBCF41E2A22}.Release.ActiveCfg = Release|Win32
+		{DDF220C1-EAEC-484E-8355-9BBCF41E2A22}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal

Added: upwatch/trunk/mswindows/MonitorClient/LogUploader.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/LogUploader.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/LogUploader.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,88 @@
+#include &quot;.\stdafx.h&quot;
+#include &quot;.\loguploader.h&quot;
+
+using namespace std;
+
+CLogUploader* CLogUploader::m_pLogUploader = NULL;
+
+CLogUploader* CLogUploader::GetUploader()
+{
+	if (CLogUploader::m_pLogUploader == NULL)
+		CLogUploader::m_pLogUploader = new CLogUploader();
+	return CLogUploader::m_pLogUploader;
+}
+
+void CLogUploader::ShutdownUploader()
+{
+	delete CLogUploader::m_pLogUploader;
+	CLogUploader::m_pLogUploader = NULL;
+}
+
+CLogUploader::CLogUploader()
+:m_socket_is_busy(false)
+{
+	WSAStartup(MAKEWORD(2, 2), &amp;m_wsaData);
+}
+
+CLogUploader::~CLogUploader()
+{
+	WSACleanup();
+}
+
+void CLogUploader::SetupUploaderInfo(std::string&amp; username, 
+									 std::string&amp; password, 
+									 std::string&amp; ip_address, 
+									 u_short port)
+{
+	m_username = &quot;user &quot; + username + &quot;\n&quot;;
+	m_password = &quot;pass &quot; + password + &quot;\n&quot;;
+	m_ok = &quot;+OK&quot;;
+	m_quit = &quot;quit\n&quot;;
+
+	m_client.sin_family = AF_INET;
+	m_client.sin_addr.s_addr = inet_addr(ip_address.c_str());
+	m_client.sin_port = htons(port);
+}
+
+int CLogUploader::Login()
+{
+	m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	int result = connect(m_socket, reinterpret_cast&lt;sockaddr*&gt;(&amp;m_client), sizeof(m_client));
+	if (result == SOCKET_ERROR)
+		result = WSAGetLastError();
+	else
+	{
+		m_socket_is_busy = true;
+		char buffer[0x32];
+		string::size_type size = m_ok.size();
+		recv(m_socket, buffer, sizeof(buffer), 0);
+		if (string(buffer).substr(0, size) == m_ok)
+			send(m_socket, m_username.c_str(), static_cast&lt;int&gt;(m_username.size()), 0);
+		recv(m_socket, buffer, sizeof(buffer), 0);
+		if (string(buffer).substr(0, size) == m_ok)
+			send(m_socket, m_password.c_str(), static_cast&lt;int&gt;(m_password.size()), 0);
+		recv(m_socket, buffer, sizeof(buffer), 0);
+		if (string(buffer).substr(0, size) != m_ok)
+			result = -1;
+	}
+	return result;
+}
+
+int CLogUploader::Command(std::string&amp; command)
+{
+	if (send(m_socket, command.c_str(), static_cast&lt;int&gt;(command.size()), 0) == SOCKET_ERROR)
+		return WSAGetLastError();
+	char buffer[0x32];
+	recv(m_socket, buffer, sizeof(buffer), 0);
+	if (string(buffer).substr(0, m_ok.size()) == m_ok)
+		return 0;
+	else
+		return -1;
+}
+
+int CLogUploader::Quit()
+{
+	send(m_socket, m_quit.c_str(), static_cast&lt;int&gt;(m_quit.size()), 0);
+	m_socket_is_busy = false;
+	return closesocket(m_socket);
+}
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorClient/LogUploader.h
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/LogUploader.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/LogUploader.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,33 @@
+#pragma once
+
+#pragma comment(lib, &quot;WS2_32.lib&quot;)
+
+#include &lt;string&gt;
+
+class CLogUploader
+{
+public:
+	static CLogUploader* GetUploader();
+	static void ShutdownUploader();
+	void SetupUploaderInfo(std::string&amp; username, std::string&amp; password, std::string&amp; ip_address, u_short port);
+
+	int Login();
+	int Command(std::string&amp; command);
+	int Quit();
+	bool IsSocketBusy() { return m_socket_is_busy; }
+private:
+	CLogUploader();
+	~CLogUploader();
+
+	static CLogUploader*	m_pLogUploader;
+	bool		m_socket_is_busy;
+
+	WSAData		m_wsaData;
+	SOCKET		m_socket;
+	sockaddr_in	m_client;
+
+	std::string	m_username;
+	std::string	m_password;
+	std::string	m_ok;
+	std::string m_quit;
+};

Added: upwatch/trunk/mswindows/MonitorClient/MonitorClient.aps
===================================================================
(Binary files differ)


Property changes on: upwatch/trunk/mswindows/MonitorClient/MonitorClient.aps
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: upwatch/trunk/mswindows/MonitorClient/MonitorClient.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/MonitorClient.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/MonitorClient.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,19 @@
+// MonitorClient.cpp : Implementation of WinMain
+
+#include &quot;stdafx.h&quot;
+#include &quot;resource.h&quot;
+#include &quot;MonitorClient.h&quot;
+#include &quot;SetupDialog.h&quot;
+
+class CMonitorClientModule : public CAtlExeModuleT&lt; CMonitorClientModule &gt; {};
+
+CMonitorClientModule _AtlModule;
+
+//
+extern &quot;C&quot; int WINAPI _tWinMain(HINSTANCE /*hInstance*/, HINSTANCE /*hPrevInstance*/, 
+                                LPTSTR /*lpCmdLine*/, int nShowCmd)
+{
+	CSetupDialog dialog;
+	dialog.DoModal();
+	return _AtlModule.WinMain(nShowCmd);
+}

Added: upwatch/trunk/mswindows/MonitorClient/MonitorClient.h
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/MonitorClient.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/MonitorClient.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,76 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 6.00.0361 */
+/* at Thu Jul 22 04:18:51 2004
+ */
+/* Compiler settings for .\MonitorClient.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the &lt;rpcndr.h&gt; version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include &quot;rpc.h&quot;
+#include &quot;rpcndr.h&quot;
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of &lt;rpcndr.h&gt;
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __MonitorClient_h__
+#define __MonitorClient_h__
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+/* header files for imported files */
+#include &quot;oaidl.h&quot;
+#include &quot;ocidl.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot;{
+#endif 
+
+void * __RPC_USER MIDL_user_allocate(size_t);
+void __RPC_USER MIDL_user_free( void * ); 
+
+
+#ifndef __MonitorClientLib_LIBRARY_DEFINED__
+#define __MonitorClientLib_LIBRARY_DEFINED__
+
+/* library MonitorClientLib */
+/* [helpstring][version][uuid] */ 
+
+
+EXTERN_C const IID LIBID_MonitorClientLib;
+#endif /* __MonitorClientLib_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+

Added: upwatch/trunk/mswindows/MonitorClient/MonitorClient.rc
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/MonitorClient.rc	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/MonitorClient.rc	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,154 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include &quot;resource.h&quot;
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include &quot;winres.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    &quot;resource.h\0&quot;
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    &quot;#include &quot;&quot;winres.h&quot;&quot;\r\n&quot;
+    &quot;\0&quot;
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    &quot;\r\n&quot;
+    &quot;\0&quot;
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+IDD_SETUPDIALOG DIALOGEX 0, 0, 368, 270
+STYLE DS_SETFONT | DS_MODALFRAME | DS_3DLOOK | DS_CENTER | WS_POPUP | 
+    WS_CAPTION
+CAPTION &quot;Setup Dialog&quot;
+FONT 9, &quot;MS Sans Serif&quot;, 0, 0, 0x0
+BEGIN
+    EDITTEXT        IDC_UPLOADSITE,48,24,72,14,ES_AUTOHSCROLL
+    EDITTEXT        IDC_LOGIN,48,48,72,14,ES_AUTOHSCROLL
+    EDITTEXT        IDC_PASSWORD,48,72,72,14,ES_AUTOHSCROLL
+    COMBOBOX        IDC_DOMAIN,12,150,108,30,CBS_DROPDOWN | CBS_SORT | 
+                    WS_VSCROLL | WS_TABSTOP
+    COMBOBOX        IDC_DNS,12,180,108,30,CBS_DROPDOWN | CBS_SORT | 
+                    WS_VSCROLL | WS_TABSTOP
+    COMBOBOX        IDC_IPADDRESS,12,210,108,30,CBS_DROPDOWN | CBS_SORT | 
+                    WS_VSCROLL | WS_TABSTOP
+    EDITTEXT        IDC_SERVER_IDENTIFICATION,12,240,108,14,ES_AUTOHSCROLL | 
+                    ES_NUMBER
+    EDITTEXT        IDC_EXPIRE_DATE,240,18,112,14,ES_AUTOHSCROLL | ES_NUMBER
+    EDITTEXT        IDC_INTERVAL,240,42,112,14,ES_AUTOHSCROLL | ES_NUMBER
+    EDITTEXT        IDC_LOAD,150,102,60,14,ES_AUTOHSCROLL | ES_NUMBER
+    EDITTEXT        IDC_DISKFREE_YELLOW,222,102,60,14,ES_AUTOHSCROLL | 
+                    ES_NUMBER
+    EDITTEXT        IDC_DISKFREE_RED,294,102,60,14,ES_AUTOHSCROLL
+    EDITTEXT        IDC_LOG_FILTER,150,168,204,12,ES_MULTILINE | 
+                    ES_AUTOHSCROLL
+    DEFPUSHBUTTON   &quot;Save And Exit&quot;,IDOK,300,246,60,16,BS_CENTER
+    PUSHBUTTON      &quot;Exit&quot;,IDCANCEL,240,246,50,16
+    GROUPBOX        &quot;Upload Site&quot;,IDC_STATIC,7,6,125,114
+    PUSHBUTTON      &quot;Test Connection&quot;,IDC_TESTCONNECTION,18,96,102,14
+    GROUPBOX        &quot;Server Information&quot;,IDC_STATIC,6,126,126,138
+    GROUPBOX        &quot;Log Settings&quot;,IDC_STATIC,144,6,216,204
+    LTEXT           &quot;Numeric ID&quot;,IDC_STATIC,12,228,108,12,SS_CENTERIMAGE
+    LTEXT           &quot;Expiry Time (minutes)&quot;,IDC_STATIC,150,18,84,12,
+                    SS_CENTERIMAGE
+    LTEXT           &quot;Probing Interval (seconds)&quot;,IDC_STATIC,150,42,84,12,
+                    SS_CENTERIMAGE
+    LTEXT           &quot;Realm&quot;,IDC_STATIC,12,138,108,12,SS_CENTERIMAGE
+    LTEXT           &quot;IP Address&quot;,IDC_STATIC,12,198,108,12,SS_CENTERIMAGE
+    LTEXT           &quot;Load Threshold&quot;,IDC_STATIC,150,90,60,8
+    LTEXT           &quot;Disk Free Yellow&quot;,IDC_STATIC,221,90,60,8
+    LTEXT           &quot;Disk Free Red&quot;,IDC_STATIC,294,90,60,8
+    LTEXT           &quot;Error Log filter directory&quot;,IDC_STATIC,150,150,204,12,
+                    SS_CENTERIMAGE
+    EDITTEXT        IDC_STATUS,192,222,169,14,ES_AUTOHSCROLL | ES_READONLY
+    LTEXT           &quot;Status:&quot;,IDC_STATIC,150,222,36,12,SS_CENTERIMAGE,
+                    WS_EX_RIGHT
+    LTEXT           &quot;Name in DNS&quot;,IDC_STATIC,12,168,108,12,SS_CENTERIMAGE
+    PUSHBUTTON      &quot;Filter File&quot;,IDC_BUTTON1,306,186,50,14
+    LTEXT           &quot;Spool Interval&quot;,IDC_STATIC,150,66,84,12,SS_CENTERIMAGE | 
+                    NOT WS_VISIBLE
+    EDITTEXT        IDC_SPOOL,240,66,112,14,ES_AUTOHSCROLL | ES_NUMBER | NOT 
+                    WS_VISIBLE
+    LTEXT           &quot;Location&quot;,IDC_STATIC,12,24,36,12,SS_CENTERIMAGE
+    LTEXT           &quot;UserName&quot;,IDC_STATIC,12,48,36,12,SS_CENTERIMAGE
+    LTEXT           &quot;Password&quot;,IDC_STATIC,12,72,36,12,SS_CENTERIMAGE
+END
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_SETUPDIALOG, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 361
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 263
+    END
+END
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Icon
+//
+
+// Icon with lowest ID value placed first to ensure application icon
+// remains consistent on all systems.
+IDI_MONITOR             ICON                    &quot;icon1.ico&quot;
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+

Added: upwatch/trunk/mswindows/MonitorClient/MonitorClient.vcproj
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/MonitorClient.vcproj	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/MonitorClient.vcproj	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,222 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;big5&quot;?&gt;
+&lt;VisualStudioProject
+	ProjectType=&quot;Visual C++&quot;
+	Version=&quot;7.10&quot;
+	Name=&quot;MonitorClient&quot;
+	ProjectGUID=&quot;{A5267F5A-022D-40D4-9D87-3A7F18C80622}&quot;
+	Keyword=&quot;AtlProj&quot;&gt;
+	&lt;Platforms&gt;
+		&lt;Platform
+			Name=&quot;Win32&quot;/&gt;
+	&lt;/Platforms&gt;
+	&lt;Configurations&gt;
+		&lt;Configuration
+			Name=&quot;Debug|Win32&quot;
+			OutputDirectory=&quot;Debug&quot;
+			IntermediateDirectory=&quot;Debug&quot;
+			ConfigurationType=&quot;1&quot;
+			UseOfATL=&quot;1&quot;
+			ATLMinimizesCRunTimeLibraryUsage=&quot;FALSE&quot;
+			CharacterSet=&quot;2&quot;&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				Optimization=&quot;0&quot;
+				PreprocessorDefinitions=&quot;WIN32;_WINDOWS;_DEBUG&quot;
+				MinimalRebuild=&quot;TRUE&quot;
+				BasicRuntimeChecks=&quot;3&quot;
+				RuntimeLibrary=&quot;3&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;TRUE&quot;
+				DebugInformationFormat=&quot;4&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				IgnoreImportLibrary=&quot;TRUE&quot;
+				OutputFile=&quot;$(OutDir)/MonitorClient.exe&quot;
+				LinkIncremental=&quot;2&quot;
+				IgnoreEmbeddedIDL=&quot;FALSE&quot;
+				GenerateDebugInformation=&quot;TRUE&quot;
+				SubSystem=&quot;2&quot;
+				ImportLibrary=&quot;&quot;
+				TargetMachine=&quot;1&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+				PreprocessorDefinitions=&quot;_DEBUG&quot;
+				MkTypLibCompatible=&quot;FALSE&quot;
+				TargetEnvironment=&quot;1&quot;
+				GenerateStublessProxies=&quot;TRUE&quot;
+				TypeLibraryName=&quot;$(IntDir)/MonitorClient.tlb&quot;
+				HeaderFileName=&quot;MonitorClient.h&quot;
+				DLLDataFileName=&quot;&quot;
+				InterfaceIdentifierFileName=&quot;MonitorClient_i.c&quot;
+				ProxyFileName=&quot;MonitorClient_p.c&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;
+				Description=&quot;Performing registration&quot;
+				CommandLine=&quot;&quot;$(TargetPath)&quot; /RegServer&quot;
+				ExcludedFromBuild=&quot;TRUE&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+				PreprocessorDefinitions=&quot;_DEBUG&quot;
+				Culture=&quot;0&quot;
+				AdditionalIncludeDirectories=&quot;$(IntDir)&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedWrapperGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCAuxiliaryManagedWrapperGeneratorTool&quot;/&gt;
+		&lt;/Configuration&gt;
+		&lt;Configuration
+			Name=&quot;Release|Win32&quot;
+			OutputDirectory=&quot;Release&quot;
+			IntermediateDirectory=&quot;Release&quot;
+			ConfigurationType=&quot;1&quot;
+			UseOfATL=&quot;1&quot;
+			ATLMinimizesCRunTimeLibraryUsage=&quot;FALSE&quot;
+			CharacterSet=&quot;2&quot;&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				GlobalOptimizations=&quot;TRUE&quot;
+				FavorSizeOrSpeed=&quot;1&quot;
+				OmitFramePointers=&quot;TRUE&quot;
+				PreprocessorDefinitions=&quot;WIN32;_WINDOWS;NDEBUG&quot;
+				RuntimeLibrary=&quot;0&quot;
+				BufferSecurityCheck=&quot;FALSE&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;TRUE&quot;
+				DebugInformationFormat=&quot;0&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				IgnoreImportLibrary=&quot;TRUE&quot;
+				OutputFile=&quot;$(OutDir)/MonitorClient.exe&quot;
+				LinkIncremental=&quot;1&quot;
+				IgnoreEmbeddedIDL=&quot;TRUE&quot;
+				GenerateDebugInformation=&quot;FALSE&quot;
+				SubSystem=&quot;2&quot;
+				OptimizeReferences=&quot;2&quot;
+				EnableCOMDATFolding=&quot;2&quot;
+				ImportLibrary=&quot;$(OutDir)/MonitorClient.lib&quot;
+				TargetMachine=&quot;1&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+				PreprocessorDefinitions=&quot;NDEBUG&quot;
+				MkTypLibCompatible=&quot;FALSE&quot;
+				TargetEnvironment=&quot;1&quot;
+				GenerateStublessProxies=&quot;TRUE&quot;
+				TypeLibraryName=&quot;$(IntDir)/MonitorClient.tlb&quot;
+				HeaderFileName=&quot;MonitorClient.h&quot;
+				DLLDataFileName=&quot;&quot;
+				InterfaceIdentifierFileName=&quot;MonitorClient_i.c&quot;
+				ProxyFileName=&quot;MonitorClient_p.c&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;
+				ExcludedFromBuild=&quot;FALSE&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+				PreprocessorDefinitions=&quot;NDEBUG&quot;
+				Culture=&quot;0&quot;
+				AdditionalIncludeDirectories=&quot;$(IntDir)&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedWrapperGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCAuxiliaryManagedWrapperGeneratorTool&quot;/&gt;
+		&lt;/Configuration&gt;
+	&lt;/Configurations&gt;
+	&lt;References&gt;
+	&lt;/References&gt;
+	&lt;Files&gt;
+		&lt;Filter
+			Name=&quot;Source Files&quot;
+			Filter=&quot;cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx&quot;
+			UniqueIdentifier=&quot;{4FC737F1-C7A5-4376-A066-2A32D752A2FF}&quot;&gt;
+			&lt;File
+				RelativePath=&quot;.\LogUploader.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\MonitorClient.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\SetupDialog.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\stdafx.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;1&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						UsePrecompiledHeader=&quot;1&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Header Files&quot;
+			Filter=&quot;h;hpp;hxx;hm;inl;inc;xsd&quot;
+			UniqueIdentifier=&quot;{93995380-89BD-4b04-88EB-625FBE52EBFB}&quot;&gt;
+			&lt;File
+				RelativePath=&quot;.\LogUploader.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\Resource.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\SetupDialog.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\stdafx.h&quot;&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Resource Files&quot;
+			Filter=&quot;rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx&quot;
+			UniqueIdentifier=&quot;{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}&quot;&gt;
+			&lt;File
+				RelativePath=&quot;.\icon1.ico&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\MonitorClient.rc&quot;&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Generated Files&quot;
+			SourceControlFiles=&quot;FALSE&quot;&gt;
+		&lt;/Filter&gt;
+		&lt;File
+			RelativePath=&quot;.\ReadMe.txt&quot;&gt;
+		&lt;/File&gt;
+	&lt;/Files&gt;
+	&lt;Globals&gt;
+		&lt;Global
+			Name=&quot;RESOURCE_FILE&quot;
+			Value=&quot;MonitorClient.rc&quot;/&gt;
+	&lt;/Globals&gt;
+&lt;/VisualStudioProject&gt;

Added: upwatch/trunk/mswindows/MonitorClient/ReadMe.txt
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/ReadMe.txt	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/ReadMe.txt	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,59 @@
+========================================================================
+    ACTIVE TEMPLATE LIBRARY : MonitorClient Project Overview
+========================================================================
+
+AppWizard has created this MonitorClient project for you to use as the starting point for
+writing your Executable (EXE).
+
+This file contains a summary of what you will find in each of the files that
+make up your project.
+
+MonitorClient.vcproj
+    This is the main project file for VC++ projects generated using an Application Wizard. 
+    It contains information about the version of Visual C++ that generated the file, and 
+    information about the platforms, configurations, and project features selected with the
+    Application Wizard.
+
+MonitorClient.idl
+    This file contains the IDL definitions of the type library, the interfaces
+    and co-classes defined in your project.
+    This file will be processed by the MIDL compiler to generate:
+        C++ interface definitions and GUID declarations (MonitorClient.h)
+        GUID definitions                                (MonitorClient_i.c)
+        A type library                                  (MonitorClient.tlb)
+        Marshaling code                                 (MonitorClient_p.c and dlldata.c)
+
+MonitorClient.h
+    This file contains the C++ interface definitions and GUID declarations of the
+    items defined in MonitorClient.idl. It will be regenerated by MIDL during compilation.
+MonitorClient.cpp
+    This file contains the object map and the implementation of WinMain.
+MonitorClient.rc
+    This is a listing of all of the Microsoft Windows resources that the
+    program uses.
+
+
+/////////////////////////////////////////////////////////////////////////////
+Other standard files:
+
+StdAfx.h, StdAfx.cpp
+    These files are used to build a precompiled header (PCH) file
+    named MonitorClient.pch and a precompiled types file named StdAfx.obj.
+
+Resource.h
+    This is the standard header file that defines resource IDs.
+
+/////////////////////////////////////////////////////////////////////////////
+Proxy/stub DLL project and module definition file:
+
+MonitorClientps.vcproj
+    This file is the project file for building a proxy/stub DLL if necessary.
+	The IDL file in the main project must contain at least one interface and you must 
+	first compile the IDL file before building the proxy/stub DLL.	This process generates
+	dlldata.c, MonitorClient_i.c and MonitorClient_p.c which are required
+	to build the proxy/stub DLL.
+
+MonitorClientps.def
+    This module definition file provides the linker with information about the exports
+    required by the proxy/stub.
+/////////////////////////////////////////////////////////////////////////////

Added: upwatch/trunk/mswindows/MonitorClient/SetupDialog.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/SetupDialog.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/SetupDialog.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,211 @@
+// SetupDialog.cpp : Implementation of CSetupDialog
+
+#define CONFIG_FILE &quot;c:\\Program Files\\upwatch\\etc\\uw_sysstat.conf&quot;
+
+#include &quot;stdafx.h&quot;
+#include &quot;.\setupdialog.h&quot;
+#include &quot;.\loguploader.h&quot;
+
+#include &lt;string&gt;
+#include &lt;sstream&gt;
+using namespace std;
+
+// CSetupDialog
+
+
+char* CSetupDialog::m_tags[] =
+{
+	&quot;login&quot;, &quot;password&quot;, &quot;domain&quot;, &quot;ip&quot;, &quot;serverid&quot;, &quot;expire&quot;, &quot;interval&quot;,
+	&quot;threshold&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;filter&quot;, &quot;uploadsite&quot;, &quot;dns&quot;, &quot;upwatch&quot;
+};
+
+template &lt;class T&gt;
+__inline bool from_string(T &amp;t, 
+                 const std::string &amp;s, 
+                 std::ios_base &amp; (*f)(std::ios_base&amp;))
+{
+   std::istringstream iss(s);
+   return !(iss&gt;&gt;f&gt;&gt;t).fail();
+}
+
+CSetupDialog::CSetupDialog()
+{
+}
+
+CSetupDialog::~CSetupDialog()
+{
+}
+
+LRESULT CSetupDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled)
+{
+	string szData = LoadData();
+	for (int i = 0;i &lt; 14;i++)
+		SetDlgItemText(IDC_LOGIN + i, GetTagData(szData, string(m_tags[i])).c_str());
+	/*NOTIFYICONDATA nd;
+	ZeroMemory(&amp;nd, sizeof(NOTIFYICONDATA));
+	nd.cbSize = sizeof(NOTIFYICONDATA);
+	nd.hWnd = m_hWnd;
+	nd.uID = 0;
+	nd.uCallbackMessage = WM_ICONNOTIFY;
+	nd.uFlags = NIF_MESSAGE | NIF_ICON;
+	nd.hIcon =reinterpret_cast&lt;HICON&gt;(LoadImage(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_MONITOR), 
+		IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR));
+	Shell_NotifyIcon(NIM_ADD, &amp;nd);
+	//m_hThread = CreateThread(NULL, NULL, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(&amp;StartMoniter), this, 0, NULL);*/
+	return 1;  // Let the system set the focus
+}
+
+LRESULT CSetupDialog::OnClickedOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled)
+{
+	SaveData();
+	EndDialog(IDOK);
+	return 0;
+}
+
+LRESULT CSetupDialog::OnClickedCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled)
+{
+	EndDialog(IDCANCEL);
+	return 0;
+}
+
+LRESULT CSetupDialog::OnIconNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled)
+{
+	/*switch (lParam)
+	{
+	case WM_RBUTTONDOWN:
+		HMENU hMenu = CreatePopupMenu();
+		MENUITEMINFO item;
+		ZeroMemory(&amp;item, sizeof(MENUITEMINFO));
+		item.cbSize = sizeof(MENUITEMINFO);
+		item.fMask = MIIM_STRING | MIIM_ID;
+
+		for (int i = 0;i &lt; 3;i++)
+		{
+			string str;
+            switch (i)
+			{
+			case 0:
+				if (CMonitorOutput::m_control == FALSE)
+                    str = &quot;Pause Monitor&quot;;
+				else
+					str = &quot;Resume Monitor&quot;;
+				break;
+			case 1:
+				str = &quot;Setting&quot;;
+				break;
+			case 2:
+				str = &quot;Shutdown&quot;;
+				break;
+			}
+			item.wID++;
+			item.dwTypeData = const_cast&lt;LPTSTR&gt;(str.c_str());
+			item.cch = static_cast&lt;DWORD&gt;(str.size());
+			InsertMenuItem(hMenu, i, TRUE, &amp;item);
+		}
+
+		SetForegroundWindow(m_hWnd);
+		POINT pt;
+		GetCursorPos(&amp;pt);
+		int id = TrackPopupMenu(hMenu, TPM_RIGHTALIGN | TPM_BOTTOMALIGN | TPM_RETURNCMD | TPM_LEFTBUTTON, 
+			pt.x, pt.y, 0, m_hWnd, NULL);
+		DestroyMenu(hMenu);
+
+		switch (id)
+		{
+		case 1:
+			CMonitorOutput::m_control = 1 - CMonitorOutput::m_control;
+			if (CMonitorOutput::m_control == FALSE)
+				ResumeThread(m_hThread);
+			break;
+		case 2:
+			{
+                ShowWindow(SW_SHOW);
+				string szData = LoadData();
+				for (int i = 0;i &lt; 13;i++)
+					SetDlgItemText(IDC_LOGIN + i, GetTagData(szData, string(m_tags[i])).c_str());
+			}
+			break;
+		case 3:
+			CMonitorOutput::m_control = 2;
+			WaitForSingleObject(m_hThread, 5000);
+			CloseHandle(m_hThread);
+			EndDialog(0);
+            break;
+		}
+	}*/
+	return 0;
+}
+
+LRESULT CSetupDialog::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled)
+{
+	return 0;
+}
+
+string CSetupDialog::LoadData()
+{
+	HANDLE hFile = CreateFile(CONFIG_FILE, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL);
+	DWORD size = GetFileSize(hFile, NULL);
+	LPTSTR data = new TCHAR[size];
+	ReadFile(hFile, data, size, &amp;size, NULL);
+	CloseHandle(hFile);
+
+	return data;
+}
+
+void CSetupDialog::SaveData()
+{
+	string szData = &quot;&lt;config&gt;\n&quot;;
+	for (DWORD i = 0;i &lt; 14;i++)
+	{
+		TCHAR str[512];
+        GetDlgItemText(IDC_LOGIN + i, str, 512);
+		szData += &quot;\t&quot; + SetTagData(string(m_tags[i]), string(str)) + &quot;\n&quot;;
+	}
+	szData += &quot;&lt;/config&gt;&quot;;
+	HANDLE hFile = CreateFile(CONFIG_FILE, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
+	WriteFile(hFile, szData.c_str(), static_cast&lt;DWORD&gt;(szData.size()), &amp;i, NULL);
+	SetEndOfFile(hFile);
+	CloseHandle(hFile);
+}
+
+string CSetupDialog::SetTagData(const string&amp; strTag, const string&amp; szTagData)
+{
+	return &quot;&lt;&quot; + strTag + &quot;&gt;&quot; + szTagData + &quot;&lt;/&quot; + strTag + &quot;&gt;&quot;;
+}
+
+string CSetupDialog::GetTagData(const string&amp; szData, const string&amp; strTag)
+{
+	string::size_type pos = szData.find(&quot;&lt;&quot; + strTag);
+	if (pos == -1)
+		return string(&quot;&quot;);
+	pos = szData.find(&quot;&gt;&quot;, pos) + 1;
+	string data = szData.substr(pos, szData.find(&quot;&lt;/&quot; + strTag + &quot;&gt;&quot;) - pos);
+	return data;
+}
+LRESULT CSetupDialog::OnBnClickedTestconnection(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL&amp; /*bHandled*/)
+{
+	char text[0x512];
+	string username, password, uploadsite;
+	GetDlgItemText(IDC_UPLOADSITE, text, 0x512);
+	uploadsite = text;
+	GetDlgItemText(IDC_LOGIN, text, 0x512);
+	username = text;
+	GetDlgItemText(IDC_PASSWORD, text, 0x512);
+	password = text;
+	string::size_type pos = uploadsite.find(&quot;:&quot;);
+	WORD port;
+	if (pos != -1)
+		from_string(port, uploadsite.substr(pos + 1), dec);
+	else
+		return 0;
+	CLogUploader* pUploader = CLogUploader::GetUploader();
+	pUploader-&gt;SetupUploaderInfo(username, password, uploadsite.substr(0, pos), port);
+	if (pUploader-&gt;Login() == 0)
+		SetDlgItemText(IDC_STATUS, _T(&quot;Connect Success&quot;));
+	else
+		SetDlgItemText(IDC_STATUS, _T(&quot;Connect Failed&quot;));
+	pUploader-&gt;Quit();
+	pUploader-&gt;ShutdownUploader();
+
+	return 0;
+}

Added: upwatch/trunk/mswindows/MonitorClient/SetupDialog.h
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/SetupDialog.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/SetupDialog.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,57 @@
+// SetupDialog.h : Declaration of the CSetupDialog
+
+#pragma once
+
+#include &quot;resource.h&quot;       // main symbols
+#include &lt;atlhost.h&gt;
+
+#include &lt;string&gt;
+// CSetupDialog
+
+#define WM_ICONNOTIFY WM_APP
+
+class CSetupDialog : 
+	public CDialogImpl&lt;CSetupDialog&gt;
+{
+public:
+	CSetupDialog();
+	~CSetupDialog();
+
+	enum { IDD = IDD_SETUPDIALOG };
+
+BEGIN_MSG_MAP(CSetupDialog)
+	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+	MESSAGE_HANDLER(WM_ICONNOTIFY, OnIconNotify)
+	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+	COMMAND_HANDLER(IDOK, BN_CLICKED, OnClickedOK)
+	COMMAND_HANDLER(IDCANCEL, BN_CLICKED, OnClickedCancel)
+	COMMAND_HANDLER(IDC_TESTCONNECTION, BN_CLICKED, OnBnClickedTestconnection)
+END_MSG_MAP()
+
+// Handler prototypes:
+//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled);
+//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled);
+//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL&amp; bHandled);
+
+	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled);
+	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled);
+	LRESULT OnClickedOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled);
+	LRESULT OnClickedCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled);
+	LRESULT OnIconNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled);
+
+	static void StartMoniter(CSetupDialog* p);
+	static std::string LoadData();
+	static std::string GetTagData(const std::string&amp; szData, const std::string&amp; strTag);
+	static std::string SetTagData(const std::string&amp; strTag, const std::string&amp; szTagData);
+
+	static char *m_tags[];
+private:
+	void SaveData();
+
+private:
+	HANDLE	m_hThread;
+public:
+	LRESULT OnBnClickedTestconnection(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL&amp; /*bHandled*/);
+};
+
+

Added: upwatch/trunk/mswindows/MonitorClient/icon1.ico
===================================================================
(Binary files differ)


Property changes on: upwatch/trunk/mswindows/MonitorClient/icon1.ico
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: upwatch/trunk/mswindows/MonitorClient/resource.h
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/resource.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/resource.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,36 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by MonitorClient.rc
+//
+#define IDS_PROJNAME                    100
+#define IDD_SETUPDIALOG                 102
+#define IDI_ICON1                       201
+#define IDI_MONITOR                     201
+#define IDC_LOGIN                       202
+#define IDC_PASSWORD                    203
+#define IDC_DOMAIN                      204
+#define IDC_IPADDRESS                   205
+#define IDC_SERVER_IDENTIFICATION       206
+#define IDC_EXPIRE_DATE                 207
+#define IDC_INTERVAL                    208
+#define IDC_LOAD                        209
+#define IDC_DISKFREE_YELLOW             210
+#define IDC_DISKFREE_RED                211
+#define IDC_LOG_FILTER                  212
+#define IDC_UPLOADSITE                  213
+#define IDC_DNS                         214
+#define IDC_SPOOL                       215
+#define IDC_TESTCONNECTION              220
+#define IDC_STATUS                      221
+#define IDC_BUTTON1                     1000
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1002
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif

Added: upwatch/trunk/mswindows/MonitorClient/stdafx.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/stdafx.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/stdafx.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,5 @@
+// stdafx.cpp : source file that includes just the standard includes
+// MonitorClient.pch will be the pre-compiled header
+// stdafx.obj will contain the pre-compiled type information
+
+#include &quot;stdafx.h&quot;

Added: upwatch/trunk/mswindows/MonitorClient/stdafx.h
===================================================================
--- upwatch/trunk/mswindows/MonitorClient/stdafx.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorClient/stdafx.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,42 @@
+// stdafx.h : include file for standard system include files,
+// or project specific include files that are used frequently,
+// but are changed infrequently
+
+#pragma once
+
+#ifndef STRICT
+#define STRICT
+#endif
+
+// Modify the following defines if you have to target a platform prior to the ones specified below.
+// Refer to MSDN for the latest info on corresponding values for different platforms.
+#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
+#define WINVER 0x0510		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
+#endif
+
+#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
+#define _WIN32_WINNT 0x0510	// Change this to the appropriate value to target Windows 2000 or later.
+#endif						
+
+#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
+#define _WIN32_WINDOWS 0x0510 // Change this to the appropriate value to target Windows Me or later.
+#endif
+
+#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
+#define _WIN32_IE 0x0510	// Change this to the appropriate value to target IE 5.0 or later.
+#endif
+
+#define _ATL_APARTMENT_THREADED
+#define _ATL_NO_AUTOMATIC_NAMESPACE
+
+#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit
+
+// turns off ATL's hiding of some common and often safely ignored warning messages
+#define _ATL_ALL_WARNINGS
+
+
+#include &quot;resource.h&quot;
+#include &lt;atlbase.h&gt;
+#include &lt;atlcom.h&gt;
+
+using namespace ATL;
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorService/ErrorLog.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/ErrorLog.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/ErrorLog.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,103 @@
+#pragma once
+
+#define CONFIG_FILE &quot;c:\\Program Files\\upwatch\\etc\\uw_sysstat.conf&quot;
+#define SPEC_FILE &quot;c:\\Program Files\\upwatch\\etc\\uw_sysstat.spec&quot;
+#define STATFILE &quot;c:/Program Files/upwatch/log/uw_sysstat.stat&quot;
+#define RECORD_FILE &quot;c:\\Program Files\\upwatch\\log\\uw_sysstat.record&quot;
+#define SPOOL_DIRECTORY &quot;c:\\Program Files\\upwatch\\spool&quot;
+#define LOG_DIRECTORY &quot;c:\\Program Files\\upwatch\\log&quot;
+
+#define STAT_GREEN 200
+#define STAT_YELLOW 300
+#define STAT_PURPLE 400
+#define STAT_RED 500
+#define LOG_INFO 0
+#define LOG_WARNING 1
+#define LOG_ERR 2
+#define PATH_MAX 260
+
+#include &lt;sys/stat.h&gt;
+#include &quot;.\log.h&quot;
+#include &quot;.\logregex.h&quot;
+#include &quot;.\glib.h&quot;
+
+#pragma comment(lib, &quot;glib.lib&quot;)
+#pragma comment(lib, &quot;libpcre.lib&quot;)
+
+static struct _errlogspec {
+  char *style;
+  char *path;
+  long long offset;
+} *errlogspec = NULL;
+
+static int check_log(GString *string, int idx, int *color)
+{
+  FILE *in;
+  struct stat st;
+  char buffer[8192];
+  int firstmatch = TRUE;
+  int logcolor = STAT_GREEN;
+
+  in = fopen(errlogspec[idx].path, &quot;r&quot;);
+  if (!in) {
+    errlogspec[idx].offset = 0;
+    return STAT_GREEN;
+  }
+  if (fstat(fileno(in), &amp;st)) {
+    char buf2[PATH_MAX+4];
+
+    sprintf(buf2, &quot;%s: %m\n&quot;, errlogspec[idx].path);
+    g_string_append(string, buf2);
+    LOG(LOG_WARNING, buf2);
+    fclose(in);
+    errlogspec[idx].offset = 0;
+    return STAT_YELLOW;
+  }
+  if (st.st_size &lt; errlogspec[idx].offset) {
+    errlogspec[idx].offset = 0;
+  }
+  fseek(in, (long)errlogspec[idx].offset, SEEK_SET);
+  while (fgets(buffer, sizeof(buffer), in)) {
+    int color;
+
+    if (logregex_matchline(errlogspec[idx].style, buffer, &amp;color)) {
+      if (firstmatch) {
+        char buf2[PATH_MAX+4];
+
+        sprintf(buf2, &quot;%s:\n&quot;, errlogspec[idx].path);
+        g_string_append(string, buf2);
+        firstmatch = FALSE;
+      }
+      g_string_append(string, buffer);
+    }
+    if (color &gt; logcolor) logcolor = color;
+  }
+  errlogspec[idx].offset = st.st_size;
+  fclose(in);
+  return logcolor;
+}
+
+//
+// check the system log for funny things. Set appropriate color
+static GString *check_logs(int *color)
+{
+  GString* string;
+  FILE *out;
+  int i;
+
+  string = g_string_new(&quot;&quot;);
+  logregex_refresh(LOG_DIRECTORY);
+
+  for (i=0; errlogspec[i].path; i++) {
+    int logcolor = check_log(string, i, color);
+    if (logcolor &gt; *color) *color = logcolor;
+  }
+  out = fopen(STATFILE, &quot;w&quot;);
+  if (out) {
+    for (i=0; errlogspec[i].path; i++) {
+      fprintf(out, &quot;%s %Ld\n&quot;, errlogspec[i].path, errlogspec[i].offset);
+    }
+    fclose(out);
+  }
+  return(string);
+}
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorService/LogUploader.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorService/LogUploader.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/LogUploader.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,93 @@
+#include &quot;main.h&quot;
+#include &quot;.\loguploader.h&quot;
+
+using namespace std;
+
+CLogUploader* CLogUploader::m_pLogUploader = NULL;
+
+CLogUploader* CLogUploader::GetUploader()
+{
+	if (CLogUploader::m_pLogUploader == NULL)
+		CLogUploader::m_pLogUploader = new CLogUploader();
+	return CLogUploader::m_pLogUploader;
+}
+
+void CLogUploader::ShutdownUploader()
+{
+	delete CLogUploader::m_pLogUploader;
+	CLogUploader::m_pLogUploader = NULL;
+}
+
+CLogUploader::CLogUploader()
+:m_socket_is_busy(false)
+{
+	WSAStartup(MAKEWORD(2, 2), &amp;m_wsaData);
+}
+
+CLogUploader::~CLogUploader()
+{
+	WSACleanup();
+}
+
+void CLogUploader::SetupUploaderInfo(std::string&amp; username, 
+									 std::string&amp; password, 
+									 std::string&amp; ip_address, 
+									 u_short port)
+{
+	m_username = &quot;user &quot; + username + &quot;\n&quot;;
+	m_password = &quot;pass &quot; + password + &quot;\n&quot;;
+	m_ok = &quot;+OK&quot;;
+	m_quit = &quot;quit\n&quot;;
+
+	m_client.sin_family = AF_INET;
+	m_client.sin_addr.s_addr = inet_addr(ip_address.c_str());
+	m_client.sin_port = htons(port);
+}
+
+int CLogUploader::Login()
+{
+	m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	int result = connect(m_socket, reinterpret_cast&lt;sockaddr*&gt;(&amp;m_client), sizeof(m_client));
+	if (result == SOCKET_ERROR)
+		result = WSAGetLastError();
+	else
+	{
+		m_socket_is_busy = true;
+		char buffer[0x32];
+		string::size_type size = m_ok.size();
+		recv(m_socket, buffer, sizeof(buffer), 0);
+		if (string(buffer).substr(0, size) == m_ok)
+			send(m_socket, m_username.c_str(), static_cast&lt;int&gt;(m_username.size()), 0);
+		recv(m_socket, buffer, sizeof(buffer), 0);
+		if (string(buffer).substr(0, size) == m_ok)
+			send(m_socket, m_password.c_str(), static_cast&lt;int&gt;(m_password.size()), 0);
+		recv(m_socket, buffer, sizeof(buffer), 0);
+		if (string(buffer).substr(0, size) != m_ok)
+			result = -1;
+	}
+	return result;
+}
+
+int CLogUploader::Command(std::string&amp; command)
+{
+	return Command(command.c_str(), static_cast&lt;DWORD&gt;(command.size()));
+}
+
+int CLogUploader::Command(const char* pData, DWORD dwSize)
+{
+	if (send(m_socket, pData, dwSize, 0) == SOCKET_ERROR)
+		return WSAGetLastError();
+	char buffer[0x32];
+	recv(m_socket, buffer, sizeof(buffer), 0);
+	if (string(buffer).substr(0, m_ok.size()) == m_ok)
+		return 0;
+	else
+		return -1;
+}
+
+int CLogUploader::Quit()
+{
+	send(m_socket, m_quit.c_str(), static_cast&lt;int&gt;(m_quit.size()), 0);
+	m_socket_is_busy = false;
+	return closesocket(m_socket);
+}
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorService/LogUploader.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/LogUploader.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/LogUploader.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,40 @@
+#pragma once
+
+#pragma comment(lib, &quot;WS2_32.lib&quot;)
+
+#include &lt;string&gt;
+
+class CLogUploader
+{
+public:
+	// Initializing the uploader
+	static CLogUploader* GetUploader();
+	// Shut down the uploader
+	static void ShutdownUploader();
+	// Setup the uploader info (e.g username/password ipaddress)
+	void SetupUploaderInfo(std::string&amp; username, std::string&amp; password, std::string&amp; ip_address, u_short port);
+
+	// The loging procedure
+	int Login();
+	// Execute upwatch command
+	int Command(std::string&amp;);
+	int Command(const char*, DWORD);
+	// Quit upwatch connection
+	int Quit();
+	bool IsSocketBusy() { return m_socket_is_busy; }
+private:
+	CLogUploader();
+	~CLogUploader();
+
+	static CLogUploader*	m_pLogUploader;
+	bool		m_socket_is_busy;
+
+	WSAData		m_wsaData;
+	SOCKET		m_socket;
+	sockaddr_in	m_client;
+
+	std::string	m_username;
+	std::string	m_password;
+	std::string	m_ok;
+	std::string m_quit;
+};

Added: upwatch/trunk/mswindows/MonitorService/Main.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorService/Main.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/Main.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,203 @@
+#include &quot;main.h&quot;
+#include &quot;monitoroutput.h&quot;
+
+#include &lt;algorithm&gt;
+
+#define MONITOR_SERVICE_NAME TEXT(&quot;WindowsMonitorService&quot;)
+#define UPWATCH_SERVICE_NAME TEXT(&quot;UpwatchService&quot;)
+
+// Spawn thread listening the monitor status
+static HANDLE hThread[2] = {0};
+
+// Service handler
+static SERVICE_STATUS_HANDLE hService = NULL;
+
+// Main Service Routine
+void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
+
+// Upwatch service routine
+void WINAPI UpwatchMain(DWORD dwArgc, LPTSTR* lpszArgv);
+
+// Service Handler
+DWORD WINAPI ServiceHandler(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
+
+// Upwatch Service Handler
+DWORD WINAPI UpWatchServiceHandler(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
+
+int WINAPI WinMain(HINSTANCE, HINSTANCE, LPTSTR lpCmdLine, int nShowCmd)
+{
+	if (__argc == 2)
+	{
+		SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
+		// Check if install is required
+		if (std::string(__argv[1]).compare(&quot;/install&quot;) == 0)
+		{
+			TCHAR strFileName[0x512] = {0};
+			strFileName[0] = '\&quot;';
+			strFileName[GetModuleFileName(NULL, &amp;strFileName[1], 0x512) + 1] = '\&quot;';
+			SC_HANDLE hService = CreateService(hSCM, MONITOR_SERVICE_NAME, NULL, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
+				SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, strFileName, NULL, NULL, NULL, NULL, NULL);
+			CloseServiceHandle(hService);
+			hService = CreateService(hSCM, UPWATCH_SERVICE_NAME, NULL, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
+				SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, strFileName, NULL, NULL, NULL, NULL, NULL);
+			CloseServiceHandle(hService);
+		}
+		// Check if uninstall is required
+		else if (std::string(__argv[1]).compare(&quot;/uninstall&quot;) == 0)
+		{
+			SC_HANDLE hService = OpenService(hSCM, MONITOR_SERVICE_NAME, SERVICE_ALL_ACCESS);
+			DeleteService(hService);
+			hService = OpenService(hSCM, UPWATCH_SERVICE_NAME, SERVICE_ALL_ACCESS);
+			DeleteService(hService);
+		}
+		CloseServiceHandle(hSCM);
+		return 0;
+	}
+	// Load the default service routine
+	SERVICE_TABLE_ENTRY service_table[] =
+	{
+		{
+            MONITOR_SERVICE_NAME,
+			&amp;ServiceMain
+		},
+		{
+			UPWATCH_SERVICE_NAME,
+			&amp;UpwatchMain,
+		},
+		{ NULL, NULL }
+	};
+	StartServiceCtrlDispatcher(service_table);
+	return 0;
+}
+
+void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
+{
+	// Load the default service routine
+	std::string strDemandService(lpszArgv[0]);
+	std::string strService(MONITOR_SERVICE_NAME);
+	transform(strDemandService.begin(), strDemandService.end(), strDemandService.begin(), tolower);
+	transform(strService.begin(), strService.end(), strService.begin(), tolower);
+	// Check the right service request
+	if (strDemandService != strService)
+		return UpwatchMain(dwArgc, lpszArgv);
+	hService = RegisterServiceCtrlHandlerEx(MONITOR_SERVICE_NAME, &amp;ServiceHandler, NULL);
+	SERVICE_STATUS ServiceStatus = {0};
+	ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+	ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
+	ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
+
+	// Start the service
+	SetServiceStatus(hService, &amp;ServiceStatus);
+	HANDLE hEvent[2];
+	hThread[0] = CreateThread(NULL, 0, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(&amp;CMonitorOutput::StartMonitor),
+		NULL, 0, NULL);
+	CMonitorOutput::m_hEvent[0] = CreateEvent(NULL, FALSE, FALSE, NULL);
+	hEvent[0] = hThread[0];
+	hEvent[1] = CMonitorOutput::m_hEvent[0];
+	if (WaitForMultipleObjects(2, hEvent, FALSE, INFINITE) == WAIT_OBJECT_0 + 1)
+		ServiceStatus.dwCurrentState = SERVICE_RUNNING;
+	else
+		ServiceStatus.dwCurrentState = SERVICE_STOPPED;
+	SetServiceStatus(hService, &amp;ServiceStatus);
+	return;
+}
+
+void WINAPI UpwatchMain(DWORD dwArgc, LPTSTR* lpszArgv)
+{
+	std::string strDemandService(lpszArgv[0]);
+	std::string strService(UPWATCH_SERVICE_NAME);
+	transform(strDemandService.begin(), strDemandService.end(), strDemandService.begin(), tolower);
+	transform(strService.begin(), strService.end(), strService.begin(), tolower);
+	// Sanity Check to see if service request is right
+	if (strDemandService != strService)
+		return;
+	hService = RegisterServiceCtrlHandlerEx(UPWATCH_SERVICE_NAME, &amp;UpWatchServiceHandler, NULL);
+	SERVICE_STATUS ServiceStatus = {0};
+	ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+	ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
+	ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+
+	SetServiceStatus(hService, &amp;ServiceStatus);
+	HANDLE hEvent[2];
+	hThread[1] = CreateThread(NULL, 0, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(&amp;CMonitorOutput::StartUpwatch),
+		NULL, 0, NULL);
+	CMonitorOutput::m_hEvent[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
+	hEvent[0] = hThread[1];
+	hEvent[1] = CMonitorOutput::m_hEvent[1];
+	if (WaitForMultipleObjects(2, hEvent, FALSE, INFINITE) == WAIT_OBJECT_0 + 1)
+		ServiceStatus.dwCurrentState = SERVICE_RUNNING;
+	else
+		ServiceStatus.dwCurrentState = SERVICE_STOPPED;
+	SetServiceStatus(hService, &amp;ServiceStatus);
+	return;
+}
+
+// This is to see if the service require stopping and pausing and to service status to
+// the service manager
+DWORD WINAPI ServiceHandler(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
+{
+	SERVICE_STATUS ServiceStatus = {0};
+	ServiceStatus.dwServiceType = SERVICE_WIN32;
+	ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
+	switch (dwControl)
+	{
+	case SERVICE_CONTROL_CONTINUE:
+		if (CMonitorOutput::m_control == FALSE)
+			break;
+		CMonitorOutput::m_control = FALSE;
+		ResumeThread(hThread[0]);
+		ServiceStatus.dwCurrentState = SERVICE_RUNNING;
+		break;
+	case SERVICE_CONTROL_PAUSE:
+		if (CMonitorOutput::m_control == TRUE)
+		{
+			ServiceStatus.dwCurrentState = SERVICE_PAUSED;
+			break;
+		}	
+		ServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
+		SetServiceStatus(hService, &amp;ServiceStatus);
+		CMonitorOutput::m_control = TRUE;
+		SetEvent(CMonitorOutput::m_hEvent[0]);
+		Sleep(100);
+		WaitForSingleObject(CMonitorOutput::m_hEvent[0], INFINITE);
+		ServiceStatus.dwCurrentState = SERVICE_PAUSED;
+		break;
+	case SERVICE_CONTROL_STOP:
+		ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
+		SetServiceStatus(hService, &amp;ServiceStatus);
+		CMonitorOutput::m_control = 2;
+		if (CMonitorOutput::m_control == TRUE)
+		{
+			ResumeThread(hThread[0]);
+            SetEvent(CMonitorOutput::m_hEvent[0]);
+		}
+		WaitForSingleObject(hThread[0], INFINITE);
+		ServiceStatus.dwCurrentState = SERVICE_STOPPED;
+		break;
+	default:
+		return ERROR_CALL_NOT_IMPLEMENTED;
+	}
+	SetServiceStatus(hService, &amp;ServiceStatus);
+	return NO_ERROR;
+}
+
+DWORD WINAPI UpWatchServiceHandler(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
+{
+	SERVICE_STATUS ServiceStatus = {0};
+	ServiceStatus.dwServiceType = SERVICE_WIN32;
+	ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+	switch (dwControl)
+	{
+	case SERVICE_CONTROL_STOP:
+		ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
+		SetServiceStatus(hService, &amp;ServiceStatus);
+		SetEvent(CMonitorOutput::m_hEvent[1]);
+		WaitForSingleObject(hThread[1], INFINITE);
+		ServiceStatus.dwCurrentState = SERVICE_STOPPED;
+		break;
+	default:
+		return ERROR_CALL_NOT_IMPLEMENTED;
+	}
+	SetServiceStatus(hService, &amp;ServiceStatus);
+	return NO_ERROR;
+}

Added: upwatch/trunk/mswindows/MonitorService/Main.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/Main.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/Main.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,2 @@
+#define WIN32_MEAN_AND_LEAN
+#include &lt;windows.h&gt;
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorService/MonitorOutput.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorService/MonitorOutput.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/MonitorOutput.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,844 @@
+#pragma comment(lib, &quot;comsupp.lib&quot;)
+
+#include &quot;main.h&quot;
+#include &quot;atlsafe.h&quot;
+#include &quot;comutil.h&quot;
+#include &quot;Tlhelp32.h&quot;
+
+#include &quot;.\loguploader.h&quot;
+#include &quot;.\systeminformation.h&quot;
+#include &quot;.\monitoroutput.h&quot;
+#include &quot;.\errorlog.h&quot;
+
+#include &lt;fstream&gt;
+#include &lt;strstream&gt;
+#include &lt;iomanip&gt;
+#include &lt;algorithm&gt;
+#include &lt;functional&gt;
+#include &lt;map&gt;
+#include &lt;ctime&gt;
+using namespace std;
+
+// The tags are in order to retrieve data from the configuration file
+char* CMonitorOutput::m_tags[] =
+{
+	&quot;login&quot;, &quot;password&quot;, &quot;domain&quot;, &quot;ip&quot;, &quot;serverid&quot;, &quot;expire&quot;, &quot;interval&quot;,
+	&quot;threshold&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;filter&quot;, &quot;uploadsite&quot;, &quot;dns&quot;, &quot;upwatch&quot;
+};
+
+HANDLE CMonitorOutput::m_hEvent[2] = {0};
+CSystemInformation*	CMonitorOutput::m_pSysInfo = NULL;
+BOOL CMonitorOutput::m_control = FALSE;
+ULONG CMonitorOutput::m_memory,	CMonitorOutput::m_cpu_counter, CMonitorOutput::m_disk, 
+	CMonitorOutput::m_cpu, CMonitorOutput::m_fan, CMonitorOutput::m_temp,
+	CMonitorOutput::m_process;
+
+std::string			CMonitorOutput::m_domain;
+std::string			CMonitorOutput::m_server;
+std::string			CMonitorOutput::m_fromhost;
+std::string			CMonitorOutput::m_ipaddress;
+std::string			CMonitorOutput::m_date;
+std::string			CMonitorOutput::m_expires;
+std::string			CMonitorOutput::m_interval;
+std::string			CMonitorOutput::m_threshold;
+std::string			CMonitorOutput::m_yellow;
+std::string			CMonitorOutput::m_red;
+std::string			CMonitorOutput::m_spoolInterval;
+
+template &lt;class T&gt;
+__inline bool from_string(T &amp;t, 
+                 const std::string &amp;s, 
+                 std::ios_base &amp; (*f)(std::ios_base&amp;))
+{
+   std::istringstream iss(s);
+   return !(iss&gt;&gt;f&gt;&gt;t).fail();
+}
+
+template &lt;class T&gt;
+__inline const T from_string_1(CComVariant&amp; s)
+{
+	char* str = _com_util::ConvertBSTRToString(s.bstrVal);
+	std::istringstream iss(str);
+	delete[] str;
+	T t;
+	iss&gt;&gt;dec&gt;&gt;t;
+	return t;
+}
+
+template &lt;class T&gt;
+__inline std::string to_string(T t, std::ios_base &amp; (*f)(std::ios_base&amp;))
+{
+   std::ostringstream oss;
+   oss &lt;&lt; f &lt;&lt; t;
+   return oss.str();
+}
+
+// Upwatch main thread
+void CALLBACK CMonitorOutput::StartUpwatch()
+{
+	// Load user data
+	string user, pass, uploadsite, upwatch_interval, szData;
+	szData = LoadData();
+	if (szData.compare(&quot;&quot;) == 0)
+		return;
+	// Send event to notify the manager the thread start running
+	SetEvent(m_hEvent[1]);
+
+	// Decode the data into variables
+	for (int i = 0;i &lt; 14;i++)
+	{
+        string strTagData = GetTagData(szData, string(m_tags[i]));
+		switch (i)
+		{
+		case 0:
+			user = strTagData;
+			break;
+		case 1:
+			pass = strTagData;
+			break;
+		case 13:
+			upwatch_interval = strTagData;
+			break;
+		case 11:
+			uploadsite = strTagData;
+			break;
+		}
+	}
+	DWORD interval;
+	from_string(interval, upwatch_interval, dec);
+	interval *= 1000;
+
+	string::size_type pos = uploadsite.find(&quot;:&quot;);
+	WORD port;
+	if (pos != -1)
+		from_string(port, uploadsite.substr(pos + 1), dec);
+
+	// Start the counter and uploader
+	CLogUploader* pUploader = CLogUploader::GetUploader();
+	while (WaitForSingleObject(m_hEvent[1], interval) == WAIT_TIMEOUT)
+	{
+		// Spool files in SPOOL_DIRECTORY
+		WIN32_FIND_DATA data;
+		HANDLE hFindFile = FindFirstFile(string(SPOOL_DIRECTORY + string(&quot;\\*.*&quot;)).c_str(), &amp;data);
+		if (hFindFile == INVALID_HANDLE_VALUE)
+			continue;
+		vector&lt;string&gt; files;
+		do
+		{
+			files.push_back(data.cFileName);
+		} while (FindNextFile(hFindFile, &amp;data));
+		FindClose(hFindFile);
+		if (files.size() &lt;= 2)
+			continue;
+		sort(files.begin(), files.end());
+		pUploader-&gt;SetupUploaderInfo(user, pass, uploadsite.substr(0, pos), port);
+		// Startup upwatch session
+		if (files.size() &amp;&amp; pUploader-&gt;Login() == 0)
+		{
+			vector&lt;string&gt;::const_iterator iter = files.begin();
+			for (;iter != files.end();iter++)
+			{
+				// Retrieve the file data from each file and execute upwatch command to upload them
+				string strFileName = SPOOL_DIRECTORY + string(&quot;\\&quot;) + *iter;
+                HANDLE hFile = CreateFile(strFileName.c_str(), FILE_READ_ACCESS, 0, NULL,
+					OPEN_EXISTING, 0, NULL);
+				if (hFile == INVALID_HANDLE_VALUE)
+					continue;
+				DWORD dwSize = GetFileSize(hFile, NULL);
+				auto_ptr&lt;char&gt; buffer(new char[dwSize]);
+				ReadFile(hFile, buffer.get(), dwSize, &amp;dwSize, NULL);
+				CloseHandle(hFile);
+				string szHead = &quot;data &quot; + to_string(dwSize, dec) + &quot; &quot; + *iter + &quot;\n&quot;;
+				if (pUploader-&gt;Command(szHead) == 0 &amp;&amp; pUploader-&gt;Command(buffer.get(), dwSize) == 0)
+                    DeleteFile(strFileName.c_str());
+				else
+					break;
+			}
+			if (iter == files.end())
+				files.clear();
+			// End a session
+			pUploader-&gt;Quit();
+		}
+	}
+	CLogUploader::ShutdownUploader();
+}
+
+void CALLBACK CMonitorOutput::StartMonitor()
+{
+	SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
+	string szData;
+	CSystemInformation* sysInfo = NULL;
+	// Get the WMI connection pointer
+	HRESULT hr = CSystemInformation::GetSystemInformation(&amp;sysInfo);
+	if (sysInfo == NULL)
+	{
+		string str = &quot;Failed To Initialize WMI: &quot; + to_string(hr, hex);
+		//MessageBox(NULL, str.c_str(), &quot;Error&quot;, MB_ICONERROR);
+		goto Exit;
+	}
+	hr = SetupMonitor(sysInfo);
+	if (FAILED(hr))
+	{
+		string str = &quot;Failed To Query WMI: &quot; + to_string(hr, hex);
+		//MessageBox(NULL, str.c_str(), &quot;Error&quot;, MB_ICONERROR);
+		sysInfo-&gt;Shutdown();
+		goto Exit;
+	}
+	// Tell the service manager the service is running
+	SetEvent(m_hEvent[0]);
+
+	// Get the data from the configuration file
+	szData = LoadData();
+	if (szData.compare(&quot;&quot;) == 0)
+		goto Exit;
+	for (int i = 0, j, k;i &lt; 13;i++)
+	{
+        string strTagData = GetTagData(szData, string(m_tags[i]));
+		switch (i)
+		{
+		/*case 0:
+			user = strTagData;
+			break;
+		case 1:
+			pass = strTagData;
+			break;*/
+		case 2:
+			m_domain = strTagData;
+			break;
+		case 3:
+			m_ipaddress = strTagData;
+			break;
+		case 4:
+			m_server = strTagData;
+			break;
+		case 5:
+			from_string(j, strTagData, dec);		// expires
+			break;
+		case 6:
+			from_string(k, strTagData, dec);		// interval
+			break;
+		case 7:
+			m_threshold = strTagData;
+			break;
+		case 8:
+			m_yellow = strTagData;
+			break;
+		case 9:
+			m_red = strTagData;
+			break;
+		/*case 11:
+			uploadsite = strTagData;*/
+		case 12:
+			m_fromhost = strTagData;
+			break;
+		//case 13:
+		//	m_spoolInterval = strTagData;
+		//	break;
+		}
+	}
+	/*FILETIME ft;
+	ULARGE_INTEGER ui;
+	GetSystemTimeAsFileTime(&amp;ft);
+	CopyMemory(&amp;ui, &amp;ft, sizeof(FILETIME));
+	m_date = to_string(ui.QuadPart, dec);
+	m_expires = to_string(ui.QuadPart + (j * 60), dec);
+	m_interval = to_string(k * 60, dec);*/
+	time_t t;
+	time(&amp;t);
+	m_date = to_string(static_cast&lt;long&gt;(t), dec);
+	m_expires = to_string(static_cast&lt;long&gt;(t) + (j * 60), dec);
+	m_interval = to_string(k * 60, dec);
+	//from_string(k, m_spoolInterval, dec);
+
+	// Start the loop of monitoring
+	while (1)
+	{
+		/*FILETIME ft;
+		ULARGE_INTEGER ui;
+		GetSystemTimeAsFileTime(&amp;ft);
+		CopyMemory(&amp;ui, &amp;ft, sizeof(FILETIME));
+		m_date = to_string(ui.QuadPart, dec);*/
+		time_t t;
+		time(&amp;t);
+		m_date = to_string(static_cast&lt;long&gt;(t), dec);
+		m_expires = to_string(static_cast&lt;long&gt;(t) + (j * 60), dec);
+		// Determine if pausing or stopping is requested
+		if (m_control == TRUE)
+		{
+			SetEvent(m_hEvent[0]);
+			SuspendThread(GetCurrentThread());
+		}
+		else if (m_control == 2)
+			break;
+		// Monitor and output the result
+		CMonitorOutput output;
+		output.InitLogFile();
+		output.SystemStat();
+		output.ErrorLog();
+		output.DiskFree();
+		output.EndLogFile();
+		WriteSpool(output.GetData());
+
+		// Profile interval
+		WaitForSingleObject(m_hEvent[0], k*1000);
+
+		// Refresh current performance data
+		sysInfo-&gt;RefreshInstances();
+	}
+Exit:
+	sysInfo-&gt;Shutdown();
+}
+
+// This routine is to setup WMI queries
+HRESULT	CMonitorOutput::SetupMonitor(CSystemInformation* pSysInfo)
+{
+	m_pSysInfo = pSysInfo;
+	m_process = m_pSysInfo-&gt;AddPerfMon(CComBSTR(L&quot;Win32_PerfRawData_PerfProc_Process&quot;));
+	m_memory = m_pSysInfo-&gt;AddPerfMon(CComBSTR(L&quot;Win32_PerfRawData_PerfOS_Memory&quot;));
+	m_cpu_counter = m_pSysInfo-&gt;AddPerfMon(CComBSTR(L&quot;Win32_PerfRawData_PerfOS_Processor&quot;));
+	m_disk = m_pSysInfo-&gt;AddQuery(CComBSTR(L&quot;SELECT Name, FreeSpace, Size, FileSystem FROM Win32_LogicalDisk WHERE MediaType = 12&quot;));
+	m_cpu = m_pSysInfo-&gt;AddQuery(CComBSTR(L&quot;SELECT LoadPercentage FROM Win32_Processor&quot;));
+	//m_fan = m_pSysInfo-&gt;AddQuery(CComBSTR(L&quot;SELECT DesiredSpeed FROM Win32_Fan&quot;));
+	m_temp = m_pSysInfo-&gt;AddQuery(CComBSTR(L&quot;SELECT NominalReading FROM Win32_TemperatureProbe&quot;));
+	return m_pSysInfo-&gt;RefreshInstances();
+}
+
+void CMonitorOutput::WriteSpool(string&amp; strData)
+{
+	string strFile = SPOOL_DIRECTORY + string(&quot;\\&quot;) + m_date + &quot;.&quot; + m_server + &quot;.&quot; + m_fromhost + &quot;.log&quot;;
+	HANDLE hFile = CreateFile(strFile.c_str(), GENERIC_ALL, 0, NULL, CREATE_ALWAYS, 0, NULL);
+	DWORD dwSize;
+	WriteFile(hFile, strData.c_str(), static_cast&lt;DWORD&gt;(strData.size()), &amp;dwSize, NULL);
+	CloseHandle(hFile);
+}
+
+// Spool writing routine
+void CMonitorOutput::InitLogFile()
+{
+	m_data &lt;&lt; 
+		&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; &lt;&lt;
+		&quot;&lt;!DOCTYPE result SYSTEM \&quot;/usr/share/upwatch/dtd/result.dtd\&quot;&gt;\n&quot; &lt;&lt;
+		&quot;&lt;result xmlns=\&quot;<A HREF="http://www.upwatch.com/schemas/1.0/\">http://www.upwatch.com/schemas/1.0/\</A>&quot; fromhost=\&quot;&quot; &lt;&lt; 
+		m_fromhost &lt;&lt; &quot;\&quot; date=\&quot;&quot; &lt;&lt; m_date &lt;&lt; &quot;\&quot;&gt;\n&quot; &lt;&lt; endl;
+}
+
+// The end of the log file
+void CMonitorOutput::EndLogFile()
+{
+	m_data &lt;&lt; &quot;&lt;/result&gt;&quot; &lt;&lt; endl;
+}
+
+// Get system stat data
+void CMonitorOutput:: SystemStat()
+{
+	static ULONGLONG it[2], pt[2], ut[2], ts[2], pr[2], wr[2], ab[2], cb[2], mb[2], sb[2], mt[2];
+	char* strTemp;
+	int c[2] = { 0, 1 };
+	vector&lt;CComVariant&gt; result;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_cpu_counter, L&quot;PercentProcessorTime&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(it[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_cpu_counter, L&quot;PercentPrivilegedTime&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(pt[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_cpu_counter, L&quot;PercentUserTime&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(ut[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_cpu_counter, L&quot;Timestamp_Sys100NS&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(ts[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;PageReadsPerSec&quot;, result)))
+		return;
+	pr[c[0]] = result[0].intVal;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;PageWritesPerSec&quot;, result)))
+		return;
+	wr[c[0]] = result[0].intVal;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;AvailableBytes&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(ab[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;CommittedBytes&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(cb[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;CacheBytes&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(mb[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;SystemDriverResidentBytes&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(sb[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, m_memory, L&quot;Timestamp_Sys100NS&quot;, result)))
+		return;
+	strTemp = _com_util::ConvertBSTRToString(result[0].bstrVal);
+	from_string(mt[c[0]], strTemp, dec);
+	delete[] strTemp;
+	if (FAILED(m_pSysInfo-&gt;GetResult(0, m_cpu, L&quot;LoadPercentage&quot;, result)))
+		return;
+
+	m_data &lt;&lt; 
+		&quot;\t&lt;sysstat realm=\&quot;&quot; &lt;&lt; m_domain &lt;&lt; &quot;\&quot; server=\&quot;&quot; &lt;&lt; m_server &lt;&lt; &quot;\&quot; ipaddress=\&quot;&quot; &lt;&lt;
+		m_ipaddress &lt;&lt; &quot;\&quot; date=\&quot;&quot; &lt;&lt; m_date &lt;&lt; &quot;\&quot; expires=\&quot;&quot; &lt;&lt; m_expires &lt;&lt; &quot;\&quot; color=\&quot;&quot; &lt;&lt;
+		STAT_GREEN &lt;&lt; &quot;\&quot; interval=\&quot;&quot; &lt;&lt; m_interval &lt;&lt; &quot;\&quot;&gt;\n&quot;;
+	vector&lt;CComVariant&gt;::const_iterator iter;
+	for (iter = result.begin();iter != result.end();iter++)
+		m_data &lt;&lt; &quot;\t\t&lt;loadavg&gt;&quot; &lt;&lt; iter-&gt;intVal &lt;&lt; &quot;&lt;/loadavg&gt;\n&quot;;
+	m_data &lt;&lt;
+		&quot;\t\t&lt;user&gt;&quot; &lt;&lt; (int)((double)(ut[c[0]] - ut[c[1]])*100/(ts[c[0]] - ts[c[1]])) &lt;&lt; &quot;&lt;/user&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;system&gt;&quot; &lt;&lt; (int)((double)(pt[c[0]] - pt[c[1]])*100/(ts[c[0]] - ts[c[1]])) &lt;&lt; &quot;&lt;/system&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;idle&gt;&quot; &lt;&lt; (int)((double)(it[c[0]] - it[c[1]])*100/(ts[c[0]] - ts[c[1]])) &lt;&lt; &quot;&lt;/idle&gt;\n&quot; &lt;&lt;
+        &quot;\t\t&lt;swapin&gt;&quot; &lt;&lt; pr[c[0]] &lt;&lt; &quot;&lt;/swapin&gt;\n&quot; &lt;&lt;
+        &quot;\t\t&lt;swapout&gt;&quot; &lt;&lt; wr[c[0]] &lt;&lt; &quot;&lt;/swapout&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;blockin&gt;0&lt;/blockin&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;blockout&gt;0&lt;/blockout&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;swapped&gt;&quot; &lt;&lt; sb[c[0]] &lt;&lt; &quot;&lt;/swapped&gt;\n&quot; &lt;&lt;
+        &quot;\t\t&lt;free&gt;&quot; &lt;&lt; ab[c[0]] &lt;&lt; &quot;&lt;/free&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;buffered&gt;0&lt;/buffered&gt;\n&quot; &lt;&lt;
+		&quot;\t\t&lt;cached&gt;&quot; &lt;&lt; mb[c[0]] &lt;&lt; &quot;&lt;/cached&gt;\n&quot; &lt;&lt;
+        &quot;\t\t&lt;used&gt;&quot; &lt;&lt; cb[c[0]] &lt;&lt; &quot;&lt;/used&gt;\n&quot;;
+	HardwareInfo();
+	ProcessList(result.begin()-&gt;intVal);
+	m_data &lt;&lt;
+		&quot;\t&lt;/sysstat&gt;\n&quot;;
+	swap(c[0], c[1]);
+}
+
+// Get Hardware stat
+void CMonitorOutput::HardwareInfo()
+{
+	vector&lt;CComVariant&gt; result;
+	if (FAILED(m_pSysInfo-&gt;GetResult(0, m_temp, L&quot;NominalReading&quot;, result)) || !result.size())
+	{
+		m_data &lt;&lt; &quot;\t\t&lt;systemp&gt;0&lt;/systemp&gt;\n&quot;;
+		return;
+	}
+    m_data &lt;&lt; &quot;\t\t&lt;systemp&gt;&quot; &lt;&lt; result[0].intVal &lt;&lt; &quot;&lt;/systemp&gt;\n&quot;;
+}
+
+// Get Processlist, iLoad is the threshold passed to determine if result should be spooled or not
+void CMonitorOutput::ProcessList(int iLoad)
+{
+	wchar_t* strName[] = { L&quot;PercentPrivilegedTime&quot;, L&quot;PercentUserTime&quot;, L&quot;PercentProcessorTime&quot;, L&quot;Timestamp_Sys100NS&quot; };
+	vector&lt;CComVariant&gt; pid, names, result;
+
+	static map&lt;int, vector&lt;ULONGLONG&gt; &gt; process_time[2];
+	static map&lt;int, string&gt; process_name[2];
+	static vector&lt;int&gt; process_id[2];
+
+	vector&lt;CComVariant&gt;::const_iterator iter[2];
+	vector&lt;int&gt;::const_iterator pid_iter;
+
+	if (FAILED(m_pSysInfo-&gt;GetResult(1, CMonitorOutput::m_process, L&quot;IDProcess&quot;, pid)) ||
+		FAILED(m_pSysInfo-&gt;GetResult(1, CMonitorOutput::m_process, L&quot;Name&quot;, names)))
+		return;
+	static int i;
+	process_time[i].clear();
+	process_name[i].clear();
+	process_id[i].clear();
+	for (iter[0] = pid.begin(), iter[1] = names.begin();iter[0] != pid.end();iter[0]++, iter[1]++)
+	{
+		char* temp = _com_util::ConvertBSTRToString(iter[1]-&gt;bstrVal);
+		process_id[i].push_back(iter[0]-&gt;intVal);
+		process_name[i][iter[0]-&gt;intVal] = temp;
+		delete[] temp;
+	}
+	for (int j = 0;j &lt; 4;j++)
+	{
+		if (FAILED(m_pSysInfo-&gt;GetResult(1, CMonitorOutput::m_process, strName[j], result)))
+			return;
+		for (pid_iter = process_id[i].begin(), iter[0] = result.begin();pid_iter != process_id[i].end();iter[0]++, pid_iter++)
+		{
+			char* temp = _com_util::ConvertBSTRToString(iter[0]-&gt;bstrVal);
+			ULONGLONG value;
+			from_string(value, string(temp), dec);
+			delete[] temp;
+			process_time[i][*pid_iter].push_back(value);
+		}
+	}
+
+	if (!i)
+	{
+		++i;
+		return;
+	}
+
+	static int threshold;
+	if (!threshold)
+		from_string(threshold, m_threshold, dec);
+	if (threshold &lt; iLoad)
+	{
+        map&lt;int, vector&lt;double&gt; &gt; percentages;
+		for (pid_iter = process_id[1].begin();pid_iter != process_id[1].end();pid_iter++)
+		{
+			if (find(process_id[0].begin(), process_id[0].end(), *pid_iter) == process_id[0].end())
+				continue;
+			percentages[*pid_iter].resize(8);
+			transform(process_time[1][*pid_iter].begin(), process_time[1][*pid_iter].end(),
+				process_time[0][*pid_iter].begin(), process_time[0][*pid_iter].begin(), minus&lt;ULONGLONG&gt;());
+			transform(process_time[0][*pid_iter].begin(), process_time[0][*pid_iter].end(),
+				percentages[*pid_iter].begin(), bind2nd(divides&lt;double&gt;(), process_time[0][*pid_iter][3]));
+		}
+
+		m_data &lt;&lt; &quot;\t\t&lt;info&gt;\n&quot;;
+		m_data &lt;&lt; &quot;\t\t\t&quot; &lt;&lt; right &lt;&lt; setw(6) &lt;&lt; &quot;PID&quot; &lt;&lt; &quot; &quot; &lt;&lt; setw(20) &lt;&lt; &quot;Process&quot; &lt;&lt; &quot; &quot; &lt;&lt;
+			left &lt;&lt; setw(10) &lt;&lt; &quot;Priv CPU%&quot; &lt;&lt; &quot; &quot; &lt;&lt; setw(10) &lt;&lt; &quot;User CPU%&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Processor CPU%\n&quot;;
+		for (pid_iter = process_id[1].begin();pid_iter != process_id[1].end();pid_iter++)
+		{
+			if (find(process_id[0].begin(), process_id[0].end(), *pid_iter) == process_id[0].end() || *pid_iter == 0)
+				continue;
+			m_data &lt;&lt; &quot;\t\t\t&quot; &lt;&lt; right &lt;&lt; setw(6) &lt;&lt; *pid_iter &lt;&lt; &quot; &quot; &lt;&lt; setw(20) &lt;&lt; process_name[0][*pid_iter] &lt;&lt; &quot; &quot;;
+			vector&lt;double&gt;::const_iterator percentage_iter = percentages[*pid_iter].begin();
+			for (;percentage_iter != percentages[*pid_iter].begin() + 3;percentage_iter++)
+			{
+				int value = static_cast&lt;int&gt;(*percentage_iter * 100);
+				m_data &lt;&lt; setw(10) &lt;&lt; value &lt;&lt; &quot; &quot;;
+			}
+			m_data &lt;&lt; &quot;\n&quot;;
+		}
+		m_data &lt;&lt; &quot;\t\t&lt;/info&gt;\n&quot;;
+	}
+
+	process_time[0] = process_time[1];
+	process_name[0] = process_name[1];
+	process_id[0] = process_id[1];
+}
+
+// Get the event log result and spool it into the event log directory
+void CMonitorOutput::ErrorLog()
+{
+	HANDLE hFile = CreateFile(SPEC_FILE, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
+	vector&lt;_errlogspec&gt; specs;
+	if (hFile != INVALID_HANDLE_VALUE)
+	{
+		DWORD dwSize = GetFileSize(hFile, NULL);
+		char* buffer = new char[dwSize + 1];
+		ReadFile(hFile, buffer, dwSize, &amp;dwSize, NULL);
+		string strBuffer(buffer);
+		delete[] buffer;
+
+		string::size_type offset = 0, pos = strBuffer.find('\n');
+		while (pos != string::npos)
+		{
+			_errlogspec s = {0};
+			string path = strBuffer.substr(offset, pos);
+			string::size_type trim = path.find('\r');
+			if (trim != string::npos)
+				path.replace(trim, 1, &quot;&quot;);
+			
+			s.path = new char[path.size() + 1];
+			copy(path.begin(), path.end(), s.path);
+			s.path[path.size()] = 0;
+
+			string style = &quot;abc&quot;;
+			s.style = new char[style.size() + 1];
+			copy(style.begin(), style.end(), s.style);
+			s.style[style.size()] = 0;
+			specs.push_back(s);
+
+			offset = pos + 1;
+			pos = strBuffer.find('\n', offset);
+		}
+		CloseHandle(hFile);
+	}
+	_errlogspec s = {0};
+	specs.push_back(s);
+	errlogspec = &amp;specs[0];
+
+	HANDLE h;
+    EVENTLOGRECORD *pevlr; 
+    static BYTE bBuffer[0x5000];
+    DWORD dwRead, dwNeeded, dwThisRecord, dwNumRecords;
+
+	FILETIME FileTime, LocalFileTime;
+	SYSTEMTIME SysTime;
+	LONGLONG lgTemp;
+	static LONGLONG SecsTo1970 = 116444736000000000;
+
+	string eventlog[] = { &quot;Application&quot;, &quot;Security&quot;, &quot;System&quot; };
+	static DWORD dwLatestRecord[3] = {0};
+	if (dwLatestRecord[0] == 0)
+	{
+		hFile = CreateFile(RECORD_FILE, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
+		if (hFile != INVALID_HANDLE_VALUE)
+		{
+			ReadFile(hFile, dwLatestRecord, 3*sizeof(DWORD), &amp;dwRead, NULL);
+			CloseHandle(hFile);
+		}
+	}
+ 
+	// Enumerate the event log with records and output them into text file
+	for (int i = 0;i &lt; 3;i++)
+	{
+        h = OpenEventLog(NULL, eventlog[i].c_str());
+		if (h == NULL) 
+			continue;
+        pevlr = reinterpret_cast&lt;PEVENTLOGRECORD&gt;(&amp;bBuffer);
+	
+		static DWORD dwOldRecord[3], dwNumberOfRecords[3];
+		GetOldestEventLogRecord(h, &amp;dwThisRecord);
+		GetNumberOfEventLogRecords(h, &amp;dwNumRecords);
+		if (dwOldRecord[i] == dwThisRecord &amp;&amp; dwNumberOfRecords[i] == dwNumRecords)
+		{
+			CloseEventLog(h);
+			continue;
+		}
+		dwOldRecord[i] = dwThisRecord;
+		dwNumberOfRecords[i] = dwNumRecords;
+
+        vector&lt;string&gt; logs;
+		while (ReadEventLog(h, EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ, 0,
+			pevlr, 0x5000,  &amp;dwRead, &amp;dwNeeded))
+		{
+			while (dwRead &gt; 0) 
+			{ 
+				if (pevlr-&gt;TimeGenerated &lt;= dwLatestRecord[i])
+				{
+					dwRead -= pevlr-&gt;Length; 
+					pevlr = reinterpret_cast&lt;EVENTLOGRECORD*&gt;(reinterpret_cast&lt;PBYTE&gt;(pevlr) + pevlr-&gt;Length);
+					continue;
+				}
+				else
+					dwLatestRecord[i] = pevlr-&gt;TimeGenerated;
+                strstream strLog;
+				lgTemp = Int32x32To64(pevlr-&gt;TimeGenerated,10000000) + SecsTo1970;
+		
+				FileTime.dwLowDateTime = static_cast&lt;DWORD&gt;(lgTemp);
+				FileTime.dwHighDateTime = static_cast&lt;DWORD&gt;(lgTemp &gt;&gt; 32);
+
+                FileTimeToLocalFileTime(&amp;FileTime, &amp;LocalFileTime);
+                FileTimeToSystemTime(&amp;LocalFileTime, &amp;SysTime);
+
+				strLog &lt;&lt; setw(2) &lt;&lt; SysTime.wMonth &lt;&lt; &quot;/&quot; &lt;&lt; SysTime.wDay &lt;&lt; &quot;/&quot; &lt;&lt;  SysTime.wYear &lt;&lt; &quot; &quot;
+					&lt;&lt; SysTime.wHour &lt;&lt; &quot;:&quot; &lt;&lt; SysTime.wMinute &lt;&lt; &quot;:&quot; &lt;&lt; SysTime.wSecond &lt;&lt; &quot;\t&quot;;
+				
+				strLog &lt;&lt; setw(4) &lt;&lt; dwThisRecord++ &lt;&lt; &quot; ID: &quot; &lt;&lt; hex &lt;&lt;
+					setw(8) &lt;&lt; pevlr-&gt;EventID &lt;&lt; &quot; &quot;;
+				
+				switch(pevlr-&gt;EventType)
+				{
+                case EVENTLOG_ERROR_TYPE:
+                    strLog &lt;&lt; &quot;EVENTLOG_ERROR_TYPE\t\t&quot;;
+                    break;
+                case EVENTLOG_WARNING_TYPE:
+                    strLog &lt;&lt; &quot;EVENTLOG_WARNING_TYPE\t\t&quot;;
+                    break;
+                case EVENTLOG_INFORMATION_TYPE:
+                    strLog &lt;&lt; &quot;EVENTLOG_INFORMATION_TYPE\t&quot;;
+                    break;
+                case EVENTLOG_AUDIT_SUCCESS:
+                    strLog &lt;&lt; &quot;EVENTLOG_AUDIT_SUCCESS\t&quot;;
+                    break;
+                case EVENTLOG_AUDIT_FAILURE:
+                    strLog &lt;&lt; &quot;EVENTLOG_AUDIT_FAILURE\t&quot;;
+                    break;
+                default:
+                    strLog &lt;&lt; &quot;Unknown Event Type\t&quot;;
+                    break;
+				}
+				
+				char* source = reinterpret_cast&lt;char*&gt;(&amp;pevlr[1]);
+				strLog &lt;&lt; &quot;Source: &quot; &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; source;
+				
+				string key = &quot;SYSTEM\\CurrentControlSet\\Services\\Eventlog\\&quot; + eventlog[i] + &quot;\\&quot; + string(source);
+				HKEY hKey;
+				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, key.c_str(), 0, KEY_READ, &amp;hKey) != ERROR_SUCCESS)
+					goto Next;
+				
+				char sz[0xff*0xff];
+				DWORD dw = sizeof(sz);
+				dw = RegQueryValueEx(hKey, &quot;EventMessageFile&quot;, NULL, NULL, reinterpret_cast&lt;PBYTE&gt;(sz), &amp;dw);
+				RegCloseKey(hKey);
+				if (dw != ERROR_SUCCESS)
+					goto Next;
+			
+				ExpandEnvironmentStrings(string(sz).c_str(), sz, sizeof(sz));
+				string::size_type pos = string(sz).find(&quot;;&quot;);
+				if (pos == string::npos)
+					pos = string(sz).size();
+				HMODULE hModule = LoadLibrary(string(sz).substr(0, pos).c_str());
+				if (!hModule)
+					goto Next;
+
+				PVOID* Args = new PVOID[pevlr-&gt;NumStrings + 1];
+				size_t offset = pevlr-&gt;StringOffset;
+				for (int j = 0;j &lt; pevlr-&gt;NumStrings;j++)
+				{
+					Args[j] = reinterpret_cast&lt;PBYTE&gt;(pevlr) + offset;
+					offset += string(static_cast&lt;char*&gt;(Args[j])).size() + 1;
+				}
+				Args[j] = 0;
+				FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
+					hModule, pevlr-&gt;EventID, 0, sz, sizeof(sz), reinterpret_cast&lt;va_list*&gt;(Args));
+				delete[] Args;
+				FreeLibrary(hModule);
+				strLog &lt;&lt; &quot;Message: &quot; &lt;&lt; sz &lt;&lt; &quot;\n&quot;;
+Next:
+				strLog &lt;&lt; '\0';
+				dwRead -= pevlr-&gt;Length; 
+				pevlr = reinterpret_cast&lt;EVENTLOGRECORD*&gt;(reinterpret_cast&lt;PBYTE&gt;(pevlr) + pevlr-&gt;Length);
+
+				logs.push_back(strLog.str());
+			}
+			pevlr = reinterpret_cast&lt;PEVENTLOGRECORD&gt;(&amp;bBuffer);
+		}
+		CloseEventLog(h);
+
+		string filename = LOG_DIRECTORY + string(&quot;\\&quot;) + eventlog[i] + &quot;\\logfile&quot;;
+		ofstream output(filename.c_str());
+		vector&lt;string&gt;::const_iterator iter = logs.begin();
+		for (;iter != logs.end();iter++)
+			output &lt;&lt; *iter &lt;&lt; &quot;\n&quot;;
+		output.close();
+	}
+	hFile = CreateFile(RECORD_FILE, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
+	if (hFile != INVALID_HANDLE_VALUE)
+	{
+		WriteFile(hFile, dwLatestRecord, 3*sizeof(DWORD), &amp;dwRead, NULL);
+		CloseHandle(hFile);
+	}
+	
+	// Here analyse the event log and output the required color
+	static int highest_color = STAT_GREEN;
+	int color = highest_color;
+	GString *log = check_logs(&amp;color);
+	if (color &gt; highest_color)
+		highest_color = color;
+
+	m_data &lt;&lt; 
+		&quot;\t&lt;errlog realm=\&quot;&quot; &lt;&lt; m_domain &lt;&lt; &quot;\&quot; server=\&quot;&quot; &lt;&lt; m_server &lt;&lt; &quot;\&quot; ipaddress=\&quot;&quot; &lt;&lt;
+		m_ipaddress &lt;&lt; &quot;\&quot; date=\&quot;&quot; &lt;&lt; m_date &lt;&lt; &quot;\&quot; expires=\&quot;&quot; &lt;&lt; m_expires &lt;&lt; &quot;\&quot; color=\&quot;&quot; &lt;&lt; 
+		color &lt;&lt; &quot;\&quot; interval=\&quot;&quot; &lt;&lt; m_interval &lt;&lt; &quot;\&quot;&gt;\n&quot;;
+	if (log)
+	{
+		if (log-&gt;str &amp;&amp; strlen(log-&gt;str) &gt; 0)
+			m_data &lt;&lt; &quot;\t\t&lt;info&gt;&quot; &lt;&lt; log-&gt;str &lt;&lt; &quot;\n\t\t&lt;/info&gt;\n&quot;;
+		g_string_free(log, TRUE);
+	}
+	m_data &lt;&lt; &quot;\t&lt;/errlog&gt;\n&quot;;
+
+	vector&lt;_errlogspec&gt;::const_iterator spec_iter = specs.begin();
+	for (;spec_iter != specs.end();spec_iter++)
+	{
+		delete[] spec_iter-&gt;style;
+		delete[] spec_iter-&gt;path;
+	}
+	errlogspec = NULL;
+}
+
+// Get the disk information
+void CMonitorOutput::DiskFree()
+{
+	vector&lt;vector&lt;CComVariant&gt; &gt;diskinfo;
+	vector&lt;CComVariant&gt; result;
+	vector&lt;ULONGLONG&gt; freespace, percentage;
+	if (FAILED(m_pSysInfo-&gt;GetResult(0, m_disk, L&quot;Name&quot;, result)))
+		return;
+	
+	diskinfo.push_back(result);
+	if (FAILED(m_pSysInfo-&gt;GetResult(0, m_disk, L&quot;FreeSpace&quot;, result)))
+		return;
+	diskinfo.push_back(result);
+	
+	freespace.resize(result.size());
+	transform(result.begin(), result.end(), freespace.begin(), &amp;from_string_1&lt;ULONGLONG&gt;);
+	transform(freespace.begin(), freespace.end(), freespace.begin(), bind2nd(multiplies&lt;ULONGLONG&gt;(), 100));
+	
+	if (FAILED(m_pSysInfo-&gt;GetResult(0, m_disk, L&quot;Size&quot;, result)))
+		return;
+	diskinfo.push_back(result);
+	
+	percentage.resize(result.size());
+	transform(result.begin(), result.end(), percentage.begin(), &amp;from_string_1&lt;ULONGLONG&gt;);
+	transform(freespace.begin(), freespace.end(), percentage.begin(), percentage.begin(), divides&lt;ULONGLONG&gt;());
+	
+	if (FAILED(m_pSysInfo-&gt;GetResult(0, m_disk, L&quot;FileSystem&quot;, result)))
+		return;
+	diskinfo.push_back(result);
+
+	SHORT color = STAT_GREEN, yellow, red, max_percentage = 100 - static_cast&lt;SHORT&gt;(*min_element(percentage.begin(), percentage.end()));
+	from_string(yellow, m_yellow, dec);
+	from_string(red, m_red, dec);
+	if (max_percentage &gt; yellow &amp;&amp; max_percentage &lt; red)
+		color = STAT_YELLOW;
+	else if (max_percentage &gt; red)
+		color = STAT_RED;
+
+	m_data &lt;&lt; 
+		&quot;\t&lt;diskfree realm=\&quot;&quot; &lt;&lt; m_domain &lt;&lt; &quot;\&quot; server=\&quot;&quot; &lt;&lt; m_server &lt;&lt; &quot;\&quot; ipaddress=\&quot;&quot; &lt;&lt;
+		m_ipaddress &lt;&lt; &quot;\&quot; date=\&quot;&quot; &lt;&lt; m_date &lt;&lt; &quot;\&quot; expires=\&quot;&quot; &lt;&lt; m_expires &lt;&lt; &quot;\&quot; color=\&quot;&quot; &lt;&lt; 
+		color &lt;&lt; &quot;\&quot; interval=\&quot;&quot; &lt;&lt; m_interval &lt;&lt; &quot;\&quot;&gt;\n&quot;;
+	m_data &lt;&lt; &quot;\t\t&lt;info&gt;\n\t\t&quot; &lt;&lt; 
+		setw(22) &lt;&lt; &quot;Filesystem&quot; &lt;&lt;
+		setw(22) &lt;&lt; &quot;K-blocks&quot; &lt;&lt;
+		setw(22) &lt;&lt; &quot;Used&quot; &lt;&lt;
+		setw(22) &lt;&lt; &quot;Avail&quot; &lt;&lt; &quot; &quot; &lt;&lt;
+		setw(10) &lt;&lt; &quot;Capacity&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Mounted\n&quot;;
+	for (unsigned i = 0;i &lt; result.size();i++)
+	{
+		ULONGLONG freespace, size, capacity;
+		char* strTemp = _com_util::ConvertBSTRToString(diskinfo[1][i].bstrVal);
+		from_string(freespace, strTemp, dec);
+		delete[] strTemp;
+
+		strTemp = _com_util::ConvertBSTRToString(diskinfo[2][i].bstrVal);
+		from_string(size, strTemp, dec);
+		delete[] strTemp;
+
+		strTemp = _com_util::ConvertBSTRToString(diskinfo[0][i].bstrVal);
+
+		char* strFileSystem = _com_util::ConvertBSTRToString(diskinfo[3][i].bstrVal);
+		capacity = size - freespace;
+		m_data &lt;&lt; &quot;\t\t&quot; &lt;&lt;
+			setw(22) &lt;&lt; strFileSystem &lt;&lt;
+			setw(22) &lt;&lt; size &lt;&lt;
+			setw(22) &lt;&lt; capacity &lt;&lt;
+			setw(22) &lt;&lt; freespace &lt;&lt; &quot; &quot; &lt;&lt;
+			setw(10) &lt;&lt; 100*((double)capacity)/size &lt;&lt; &quot; &quot;
+			&lt;&lt; strTemp &lt;&lt; &quot;\n&quot;;
+		delete[] strFileSystem;
+		delete[] strTemp;
+	}
+	m_data &lt;&lt; &quot;\t\t&lt;/info&gt;\n\t&lt;/diskfree&gt;\n&quot;;
+}
+
+// Load the data from configuration file
+string CMonitorOutput::LoadData()
+{
+	HANDLE hFile = CreateFile(CONFIG_FILE, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL);
+	if (hFile == INVALID_HANDLE_VALUE)
+		return string(&quot;&quot;);
+	DWORD size = GetFileSize(hFile, NULL);
+	LPTSTR data = new TCHAR[size];
+	ReadFile(hFile, data, size, &amp;size, NULL);
+	CloseHandle(hFile);
+
+	return data;
+}
+
+string CMonitorOutput::SetTagData(const string&amp; strTag, const string&amp; szTagData)
+{
+	return &quot;&lt;&quot; + strTag + &quot;&gt;&quot; + szTagData + &quot;&lt;/&quot; + strTag + &quot;&gt;&quot;;
+}
+
+string CMonitorOutput::GetTagData(const string&amp; szData, const string&amp; strTag)
+{
+	string::size_type pos = szData.find(&quot;&lt;&quot; + strTag);
+	if (pos == -1)
+		return string(&quot;&quot;);
+	pos = szData.find(&quot;&gt;&quot;, pos) + 1;
+	string data = szData.substr(pos, szData.find(&quot;&lt;/&quot; + strTag + &quot;&gt;&quot;) - pos);
+	return data;
+}
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorService/MonitorOutput.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/MonitorOutput.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/MonitorOutput.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,68 @@
+#pragma once
+
+#include &lt;sstream&gt;
+#include &lt;string&gt;
+
+class CSystemInformation;
+
+class CMonitorOutput
+{
+public:
+	// Main setup of monitor service
+	static HRESULT	SetupMonitor(CSystemInformation* pSysInfo);
+
+	// The monitor main thread
+	static void CALLBACK StartMonitor();
+
+	// The upwatch main thread
+	static void CALLBACK StartUpwatch();
+
+	// Spool writing routine
+	static void WriteSpool(std::string&amp; strData);
+
+	// Get the configuration data
+	std::string GetData() { return m_data.str(); }
+
+	// Initialize the log file
+	void InitLogFile();
+	// End using the log file
+	void EndLogFile();
+
+	// Retrieve system status
+	void SystemStat();
+	// Retrieve hardware status
+	void HardwareInfo();
+	// Retrieve process list status
+	void ProcessList(int);
+	// Retrieve log status
+	void ErrorLog();
+	// Retrieve disk free information
+	void DiskFree();
+
+	static HANDLE				m_hEvent[2];
+	static BOOL					m_control;
+private:
+	std::stringstream	m_data;
+
+	static CSystemInformation*	m_pSysInfo;
+	// The WMI command to retrieve certain device info
+	static ULONG m_memory,	m_cpu_counter, m_disk, m_cpu, m_fan, m_temp, m_process;
+
+	static std::string			m_domain;
+	static std::string			m_server;
+	static std::string			m_fromhost;
+	static std::string			m_ipaddress;
+	static std::string			m_date;
+	static std::string			m_expires;
+	static std::string			m_interval;
+	static std::string			m_threshold;
+	static std::string			m_yellow;
+	static std::string			m_red;
+	static std::string			m_spoolInterval;
+
+	static std::string LoadData();
+	static std::string GetTagData(const std::string&amp; szData, const std::string&amp; strTag);
+	static std::string SetTagData(const std::string&amp; strTag, const std::string&amp; szTagData);
+
+	static char *m_tags[];
+};

Added: upwatch/trunk/mswindows/MonitorService/MonitorService.vcproj
===================================================================
--- upwatch/trunk/mswindows/MonitorService/MonitorService.vcproj	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/MonitorService.vcproj	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,187 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;big5&quot;?&gt;
+&lt;VisualStudioProject
+	ProjectType=&quot;Visual C++&quot;
+	Version=&quot;7.10&quot;
+	Name=&quot;MonitorService&quot;
+	ProjectGUID=&quot;{DDF220C1-EAEC-484E-8355-9BBCF41E2A22}&quot;
+	Keyword=&quot;Win32Proj&quot;&gt;
+	&lt;Platforms&gt;
+		&lt;Platform
+			Name=&quot;Win32&quot;/&gt;
+	&lt;/Platforms&gt;
+	&lt;Configurations&gt;
+		&lt;Configuration
+			Name=&quot;Debug|Win32&quot;
+			OutputDirectory=&quot;Debug&quot;
+			IntermediateDirectory=&quot;Debug&quot;
+			ConfigurationType=&quot;1&quot;
+			CharacterSet=&quot;2&quot;&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				Optimization=&quot;0&quot;
+				AdditionalIncludeDirectories=&quot;&quot;glib-dev-2.4.5\include\glib-2.0&quot;&quot;
+				PreprocessorDefinitions=&quot;WIN32;_DEBUG;_WINDOWS&quot;
+				MinimalRebuild=&quot;TRUE&quot;
+				BasicRuntimeChecks=&quot;3&quot;
+				RuntimeLibrary=&quot;5&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;TRUE&quot;
+				DebugInformationFormat=&quot;4&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				OutputFile=&quot;$(OutDir)/MonitorService.exe&quot;
+				LinkIncremental=&quot;2&quot;
+				GenerateDebugInformation=&quot;TRUE&quot;
+				ProgramDatabaseFile=&quot;$(OutDir)/MonitorService.pdb&quot;
+				SubSystem=&quot;2&quot;
+				TargetMachine=&quot;1&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedWrapperGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCAuxiliaryManagedWrapperGeneratorTool&quot;/&gt;
+		&lt;/Configuration&gt;
+		&lt;Configuration
+			Name=&quot;Release|Win32&quot;
+			OutputDirectory=&quot;Release&quot;
+			IntermediateDirectory=&quot;Release&quot;
+			ConfigurationType=&quot;1&quot;
+			CharacterSet=&quot;2&quot;&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				GlobalOptimizations=&quot;TRUE&quot;
+				FavorSizeOrSpeed=&quot;1&quot;
+				OmitFramePointers=&quot;TRUE&quot;
+				AdditionalIncludeDirectories=&quot;&quot;glib-dev-2.4.5\include\glib-2.0&quot;&quot;
+				PreprocessorDefinitions=&quot;WIN32;NDEBUG;_WINDOWS&quot;
+				StringPooling=&quot;TRUE&quot;
+				RuntimeLibrary=&quot;0&quot;
+				BufferSecurityCheck=&quot;FALSE&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;TRUE&quot;
+				DebugInformationFormat=&quot;0&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				OutputFile=&quot;$(OutDir)/MonitorService.exe&quot;
+				LinkIncremental=&quot;1&quot;
+				GenerateDebugInformation=&quot;FALSE&quot;
+				SubSystem=&quot;2&quot;
+				OptimizeReferences=&quot;2&quot;
+				EnableCOMDATFolding=&quot;2&quot;
+				TargetMachine=&quot;1&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedWrapperGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCAuxiliaryManagedWrapperGeneratorTool&quot;/&gt;
+		&lt;/Configuration&gt;
+	&lt;/Configurations&gt;
+	&lt;References&gt;
+	&lt;/References&gt;
+	&lt;Files&gt;
+		&lt;Filter
+			Name=&quot;Source Files&quot;
+			Filter=&quot;cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx&quot;
+			UniqueIdentifier=&quot;{4FC737F1-C7A5-4376-A066-2A32D752A2FF}&quot;&gt;
+			&lt;File
+				RelativePath=&quot;.\log.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\logregex.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\LogUploader.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\Main.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\MonitorOutput.cpp&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\snprintf.c&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\SystemInformation.cpp&quot;&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Header Files&quot;
+			Filter=&quot;h;hpp;hxx;hm;inl;inc;xsd&quot;
+			UniqueIdentifier=&quot;{93995380-89BD-4b04-88EB-625FBE52EBFB}&quot;&gt;
+			&lt;File
+				RelativePath=&quot;.\ErrorLog.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\log.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\logregex.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\LogUploader.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\Main.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\MonitorOutput.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\pcre.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\pcreposix.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\snprintf.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\SystemInformation.h&quot;&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Resource Files&quot;
+			Filter=&quot;rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx&quot;
+			UniqueIdentifier=&quot;{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}&quot;&gt;
+		&lt;/Filter&gt;
+	&lt;/Files&gt;
+	&lt;Globals&gt;
+	&lt;/Globals&gt;
+&lt;/VisualStudioProject&gt;

Added: upwatch/trunk/mswindows/MonitorService/SystemInformation.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorService/SystemInformation.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/SystemInformation.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,245 @@
+#include &quot;.\systeminformation.h&quot;
+
+#include &lt;algorithm&gt;
+#include &lt;functional&gt;
+
+CSystemInformation* CSystemInformation::_SystemInformation = NULL;
+
+// Initializing WMI and return the pointer
+HRESULT CSystemInformation::GetSystemInformation(CSystemInformation** ppSysInfo)
+{
+	HRESULT hr;
+	if (!_SystemInformation)
+	{
+		_SystemInformation = new CSystemInformation();
+		hr = _SystemInformation-&gt;m_hrStatus;
+		if (FAILED(hr))
+            _SystemInformation-&gt;Shutdown();
+	}
+	*ppSysInfo = _SystemInformation;
+	return hr;
+}
+
+// Setup WMI
+CSystemInformation::CSystemInformation()
+:m_pWbemLocator(NULL), m_pWbemServices(NULL), m_bInstanceCreated(FALSE)
+{
+	m_hrStatus = CoInitializeEx(0, COINIT_MULTITHREADED);
+	if (FAILED(m_hrStatus))
+		return;
+	m_hrStatus = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
+	if (FAILED(m_hrStatus))
+		return;
+	m_hrStatus = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_SERVER, IID_IWbemLocator, reinterpret_cast&lt;LPVOID*&gt;(&amp;m_pWbemLocator));
+	if (FAILED(m_hrStatus))
+		return;
+	m_hrStatus = m_pWbemLocator-&gt;ConnectServer(CComBSTR(L&quot;\\\\.\\ROOT\\CIMV2&quot;), NULL, NULL, 0, NULL, 0, 0, &amp;m_pWbemServices);
+	if (FAILED(m_hrStatus))
+		return;
+	m_hrStatus = CoSetProxyBlanket(m_pWbemServices, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
+	if (FAILED(m_hrStatus))
+		return;
+	m_hrStatus = CoCreateInstance(CLSID_WbemRefresher, NULL, CLSCTX_SERVER, IID_IWbemRefresher, reinterpret_cast&lt;LPVOID*&gt;(&amp;m_pWbemRefresher));
+	if (FAILED(m_hrStatus))
+		return;
+	m_pWbemConfigureRefresher = CComQIPtr&lt;IWbemConfigureRefresher&gt;(m_pWbemRefresher);
+}
+
+CSystemInformation::~CSystemInformation()
+{
+	_SystemInformation = NULL;
+}
+
+void CSystemInformation::Shutdown()
+{
+	delete _SystemInformation;
+	CoUninitialize();
+}
+
+// Add WMI queries into db
+ULONG CSystemInformation::AddQuery(const BSTR strQuery)
+{
+	m_bstrQueries[0].push_back(strQuery);
+	return static_cast&lt;ULONG&gt;(m_bstrQueries[0].size() - 1);
+}
+
+// Add WMI performance request into db
+ULONG CSystemInformation::AddPerfMon(LPCWSTR wszClassName)
+{
+	m_bstrQueries[1].push_back(wszClassName);
+	return static_cast&lt;ULONG&gt;(m_bstrQueries[1].size() - 1);
+}
+
+// Refresh the current instance of WMI and store the results
+HRESULT	CSystemInformation::RefreshInstances()
+{
+	if (FAILED(RefreshPerfMonInstances()))
+		return m_hrStatus;
+	return RefreshClassesInstances();
+}
+
+// Class WMI refreshes
+HRESULT	CSystemInformation::RefreshClassesInstances()
+{
+	std::vector&lt;std::wstring&gt;::const_iterator iter = m_bstrQueries[0].begin();
+	ULONG size = static_cast&lt;ULONG&gt;(m_bstrQueries[0].size());
+	m_ppClassObject.clear();
+	for (int i = 0;iter != m_bstrQueries[0].end();iter++, i++)
+	{
+		CComPtr&lt;IEnumWbemClassObject&gt; pEnumObjects;
+		m_hrStatus = m_pWbemServices-&gt;ExecQuery(CComBSTR(L&quot;WQL&quot;), CComBSTR(iter-&gt;c_str()), 
+			WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_ENSURE_LOCATABLE, NULL, &amp;pEnumObjects);
+		if (FAILED(m_hrStatus))
+			break;
+		ULONG j = 0, returned;
+		std::vector&lt;CComPtr&lt;IWbemClassObject&gt; &gt;pObjects(20);
+NextSet:
+		m_hrStatus = pEnumObjects-&gt;Next(INFINITE, 20, &amp;pObjects[j], &amp;returned);
+		j += 20;
+		if (FAILED(m_hrStatus))
+			break;
+		else if (m_hrStatus == WBEM_S_NO_ERROR)
+		{
+			pObjects.resize(j);
+			goto NextSet;
+		}
+		else if (returned &gt; 0)
+		{
+            pObjects.erase(pObjects.begin() + j - 20 + returned, pObjects.end());
+			m_ppClassObject.push_back(pObjects);
+		}
+	}
+	return m_hrStatus;
+}
+
+// PerfMon refreshes
+HRESULT CSystemInformation::RefreshPerfMonInstances()
+{
+	ULONG size = static_cast&lt;ULONG&gt;(m_bstrQueries[1].size());
+	if (!m_bInstanceCreated)
+	{
+		std::vector&lt;std::wstring&gt;::const_iterator iter = m_bstrQueries[1].begin();
+		for (int i = 0;iter != m_bstrQueries[1].end();iter++)
+		{
+			CComPtr&lt;IWbemHiPerfEnum&gt; p;
+			long id;
+			m_hrStatus = m_pWbemConfigureRefresher-&gt;AddEnum(m_pWbemServices, iter-&gt;c_str(), 0, NULL, &amp;p, &amp;id);
+			if (FAILED(m_hrStatus))
+				return m_hrStatus;
+			m_lId.push_back(id);
+			m_ppWbemHiPerfEnum.push_back(p);
+		}
+	}
+	m_hrStatus = m_pWbemRefresher-&gt;Refresh(WBEM_FLAG_REFRESH_AUTO_RECONNECT);
+	if (FAILED(m_hrStatus))
+		return m_hrStatus;
+	m_ppObjectAccess.clear();
+	m_ppObjectAccess.resize(size);
+	for (unsigned i = 0;i &lt; size;i++)
+	{
+		ULONG returned;
+        m_hrStatus = m_ppWbemHiPerfEnum[i]-&gt;GetObjects(0, 0, NULL, &amp;returned);
+		if (m_hrStatus == WBEM_E_BUFFER_TOO_SMALL)
+		{
+			m_ppObjectAccess[i].resize(returned);
+			m_hrStatus = m_ppWbemHiPerfEnum[i]-&gt;GetObjects(0, returned, &amp;m_ppObjectAccess[i][0], &amp;returned);
+			if (SUCCEEDED(m_hrStatus))
+				continue;
+		}
+		break;
+	}
+	if (SUCCEEDED(m_hrStatus))
+		m_bInstanceCreated = TRUE;
+	return m_hrStatus;
+}
+
+// Send the queries to WMI
+HRESULT CSystemInformation::Query(LPCWSTR wszQuery, std::vector&lt;std::vector&lt;CComVariant&gt; &gt;&amp; strPropertyCollections)
+{
+	CComPtr&lt;IEnumWbemClassObject&gt; pEnumObjects;
+	HRESULT m_hrStatus = m_pWbemServices-&gt;ExecQuery(CComBSTR(L&quot;WQL&quot;), CComBSTR(wszQuery), 
+		WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_ENSURE_LOCATABLE, NULL, &amp;pEnumObjects);
+	if (FAILED(m_hrStatus))
+		return m_hrStatus;
+	ULONG j = 0, returned;
+	m_ppAdhocClassObject.clear();
+	m_ppAdhocClassObject.resize(20);
+	while (1)
+	{
+        m_hrStatus = pEnumObjects-&gt;Next(INFINITE, 20, &amp;m_ppAdhocClassObject[j], &amp;returned);
+		j += 20;
+		if (FAILED(m_hrStatus))
+			return m_hrStatus;
+		else if (m_hrStatus == WBEM_S_NO_ERROR)
+		{
+			m_ppAdhocClassObject.resize(j);
+			continue;
+		}
+		else if (returned &gt; 0)
+		{
+			m_ppAdhocClassObject.erase(m_ppAdhocClassObject.begin() + j - 20 + returned, m_ppAdhocClassObject.end());
+			break;
+		}
+	}
+	return m_hrStatus;
+}
+
+// Retrieve the result from our refreshes WMI by using properties names
+HRESULT CSystemInformation::GetResult(LPCWSTR wszName, std::vector&lt;CComVariant&gt; &amp;strProperties)
+{
+	std::vector&lt;CComPtr&lt;IWbemClassObject&gt; &gt;::const_iterator iter = m_ppAdhocClassObject.begin();
+	for (;iter != m_ppAdhocClassObject.end();iter++)
+	{
+		CComVariant Val;
+		m_hrStatus = (*iter)-&gt;Get(wszName, 0, &amp;Val, NULL, NULL);
+		if (FAILED(m_hrStatus))
+			break;
+		strProperties.push_back(Val);
+	}
+	return m_hrStatus;
+}
+
+// Clear all performance data
+void CSystemInformation::ClearInstances()
+{
+	m_bInstanceCreated = FALSE;
+	m_ppObjectAccess.clear();
+	m_ppClassObject.clear();
+	m_ppWbemHiPerfEnum.clear();
+	for (std::vector&lt;long&gt;::const_iterator iter = m_lId.begin();iter != m_lId.end();iter++)
+		m_pWbemConfigureRefresher-&gt;Remove(*iter, 0);
+	m_lId.clear();
+	m_bstrQueries[0].clear();
+	m_bstrQueries[1].clear();
+}
+
+// Get result by using type, index and names
+HRESULT CSystemInformation::GetResult(ULONG ulType, ULONG ulIndex, LPCWSTR wszName, std::vector&lt;CComVariant&gt; &amp;strProperties)
+{
+	strProperties.clear();
+	if (ulType == 1 &amp;&amp; ulIndex &lt; m_ppObjectAccess.size())
+	{
+		for (std::vector&lt;CComPtr&lt;IWbemObjectAccess&gt; &gt;::iterator iter = m_ppObjectAccess[ulIndex].begin();
+		iter != m_ppObjectAccess[ulIndex].end();iter++)
+		{
+			CComVariant Val;
+			m_hrStatus = (*iter)-&gt;Get(wszName, 0, &amp;Val, NULL, NULL);
+			if (FAILED(m_hrStatus))
+				break;
+			strProperties.push_back(Val);
+		}
+	}
+	else if (ulType == 0 &amp;&amp; ulIndex &lt; m_ppClassObject.size())
+	{
+		for (std::vector&lt;CComPtr&lt;IWbemClassObject&gt; &gt;::iterator iter = m_ppClassObject[ulIndex].begin();
+		iter != m_ppClassObject[ulIndex].end();iter++)
+		{
+			CComVariant Val;
+			m_hrStatus = (*iter)-&gt;Get(wszName, 0, &amp;Val, NULL, NULL);
+			if (FAILED(m_hrStatus))
+				break;
+			strProperties.push_back(Val);
+		}
+	}
+	return m_hrStatus;
+}
\ No newline at end of file

Added: upwatch/trunk/mswindows/MonitorService/SystemInformation.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/SystemInformation.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/SystemInformation.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,63 @@
+#pragma once
+
+#pragma comment(lib, &quot;Wbemuuid.lib&quot;)
+
+#define _WIN32_DCOM
+#include &lt;Wbemidl.h&gt;
+#include &lt;atlbase.h&gt;
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+class CSystemInformation
+{
+public:
+	//Load and get the WMI service pointer for retrieving WMI information
+	static	HRESULT GetSystemInformation(CSystemInformation** ppSysInfo);
+	//Shutdown WMI connection
+	void	Shutdown();
+
+	//Refresh WMI Instance for performance update
+	HRESULT	RefreshInstances();
+	//Clear the current performance data
+	void	ClearInstances();
+	//Get the current peroformance data
+	HRESULT GetResult(ULONG ulType, ULONG ulIndex, LPCWSTR wszName, std::vector&lt;CComVariant&gt; &amp;strProperties);
+	HRESULT	GetStatus() { return m_hrStatus; }
+
+	//Add a query into the database to retrieve the required WMI information
+	ULONG	AddQuery(const BSTR strQuery);
+	//Add a performance monitor to the WMI to retrieve the required performance data
+	ULONG	AddPerfMon(LPCWSTR wszClassName);
+
+	//Refresh only non-perfmon WMI queries
+	HRESULT RefreshClassesInstances();
+	//Refresh only WMI performance data
+	HRESULT RefreshPerfMonInstances();
+
+	HRESULT Query(LPCWSTR wszQuery, std::vector&lt;std::vector&lt;CComVariant&gt; &gt;&amp; strPropertyCollections);
+	HRESULT GetResult(LPCWSTR wszName, std::vector&lt;CComVariant&gt; &amp;strProperties);
+
+private:
+	CSystemInformation();
+	~CSystemInformation();
+
+private:
+	CComPtr&lt;IWbemLocator&gt;				m_pWbemLocator;
+	CComPtr&lt;IWbemServices&gt;				m_pWbemServices;
+	CComPtr&lt;IWbemRefresher&gt;				m_pWbemRefresher;
+	CComPtr&lt;IWbemConfigureRefresher&gt;	m_pWbemConfigureRefresher;
+	HRESULT								m_hrStatus;
+	BOOL								m_bInstanceCreated;
+
+	std::vector&lt;CComPtr&lt;IWbemHiPerfEnum&gt; &gt;					m_ppWbemHiPerfEnum;
+	std::vector&lt;std::vector&lt;CComPtr&lt;IWbemClassObject&gt; &gt; &gt;	m_ppClassObject;
+	std::vector&lt;std::vector&lt;CComPtr&lt;IWbemObjectAccess&gt; &gt; &gt;	m_ppObjectAccess;
+	std::vector&lt;CComPtr&lt;IWbemClassObject&gt; &gt;					m_ppAdhocClassObject;
+
+	std::vector&lt;std::wstring&gt;								m_bstrQueries[2];
+	std::vector&lt;long&gt;										m_lId;
+
+private:
+	static CSystemInformation* _SystemInformation;
+};

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/galloca.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/galloca.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/galloca.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,60 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_ALLOCA_H__
+#define __G_ALLOCA_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+#ifdef  __GNUC__
+/* GCC does the right thing */
+# undef alloca
+# define alloca(size)   __builtin_alloca (size)
+#elif defined (GLIB_HAVE_ALLOCA_H)
+/* a native and working alloca.h is there */ 
+# include &lt;alloca.h&gt;
+#else /* !__GNUC__ &amp;&amp; !GLIB_HAVE_ALLOCA_H */
+# ifdef _MSC_VER
+#  include &lt;malloc.h&gt;
+#  define alloca _alloca
+# else /* !_MSC_VER */
+#  ifdef _AIX
+#   pragma alloca
+#  else /* !_AIX */
+#   ifndef alloca /* predefined by HP cc +Olibcalls */
+G_BEGIN_DECLS
+char *alloca ();
+G_END_DECLS
+#   endif /* !alloca */
+#  endif /* !_AIX */
+# endif /* !_MSC_VER */
+#endif /* !__GNUC__ &amp;&amp; !GLIB_HAVE_ALLOCA_H */
+
+#define g_alloca(size)		 alloca (size)
+#define g_newa(struct_type, n_structs)	((struct_type*) g_alloca (sizeof (struct_type) * (gsize) (n_structs)))
+
+
+#endif /* __G_ALLOCA_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/garray.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/garray.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/garray.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,167 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_ARRAY_H__
+#define __G_ARRAY_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GArray		GArray;
+typedef struct _GByteArray	GByteArray;
+typedef struct _GPtrArray	GPtrArray;
+
+struct _GArray
+{
+  gchar *data;
+  guint len;
+};
+
+struct _GByteArray
+{
+  guint8 *data;
+  guint	  len;
+};
+
+struct _GPtrArray
+{
+  gpointer *pdata;
+  guint	    len;
+};
+
+/* Resizable arrays. remove fills any cleared spot and shortens the
+ * array, while preserving the order. remove_fast will distort the
+ * order by moving the last element to the position of the removed.
+ */
+
+#define g_array_append_val(a,v)	  g_array_append_vals (a, &amp;(v), 1)
+#define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &amp;(v), 1)
+#define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &amp;(v), 1)
+#define g_array_index(a,t,i)      (((t*) (a)-&gt;data) [(i)])
+
+GArray* g_array_new               (gboolean          zero_terminated,
+				   gboolean          clear_,
+				   guint             element_size);
+GArray* g_array_sized_new         (gboolean          zero_terminated,
+				   gboolean          clear_,
+				   guint             element_size,
+				   guint             reserved_size);
+gchar*  g_array_free              (GArray           *array,
+				   gboolean          free_segment);
+GArray* g_array_append_vals       (GArray           *array,
+				   gconstpointer     data,
+				   guint             len);
+GArray* g_array_prepend_vals      (GArray           *array,
+				   gconstpointer     data,
+				   guint             len);
+GArray* g_array_insert_vals       (GArray           *array,
+				   guint             index_,
+				   gconstpointer     data,
+				   guint             len);
+GArray* g_array_set_size          (GArray           *array,
+				   guint             length);
+GArray* g_array_remove_index      (GArray           *array,
+				   guint             index_);
+GArray* g_array_remove_index_fast (GArray           *array,
+				   guint             index_);
+GArray* g_array_remove_range      (GArray           *array,
+				   guint             index_,
+				   guint             length);
+void    g_array_sort              (GArray           *array,
+				   GCompareFunc      compare_func);
+void    g_array_sort_with_data    (GArray           *array,
+				   GCompareDataFunc  compare_func,
+				   gpointer          user_data);
+
+/* Resizable pointer array.  This interface is much less complicated
+ * than the above.  Add appends a pointer.  Remove fills any cleared 
+ * spot and shortens the array. remove_fast will again distort order.  
+ */
+#define    g_ptr_array_index(array,index_) ((array)-&gt;pdata)[index_]
+GPtrArray* g_ptr_array_new                (void);
+GPtrArray* g_ptr_array_sized_new          (guint             reserved_size);
+gpointer*  g_ptr_array_free               (GPtrArray        *array,
+					   gboolean          free_seg);
+void       g_ptr_array_set_size           (GPtrArray        *array,
+					   gint              length);
+gpointer   g_ptr_array_remove_index       (GPtrArray        *array,
+					   guint             index_);
+gpointer   g_ptr_array_remove_index_fast  (GPtrArray        *array,
+					   guint             index_);
+gboolean   g_ptr_array_remove             (GPtrArray        *array,
+					   gpointer          data);
+gboolean   g_ptr_array_remove_fast        (GPtrArray        *array,
+					   gpointer          data);
+void       g_ptr_array_remove_range       (GPtrArray        *array,
+					   guint             index_,
+					   guint             length);
+void       g_ptr_array_add                (GPtrArray        *array,
+					   gpointer          data);
+void       g_ptr_array_sort               (GPtrArray        *array,
+					   GCompareFunc      compare_func);
+void       g_ptr_array_sort_with_data     (GPtrArray        *array,
+					   GCompareDataFunc  compare_func,
+					   gpointer          user_data);
+void       g_ptr_array_foreach            (GPtrArray        *array,
+					   GFunc             func,
+					   gpointer          user_data);
+
+
+/* Byte arrays, an array of guint8.  Implemented as a GArray,
+ * but type-safe.
+ */
+
+GByteArray* g_byte_array_new               (void);
+GByteArray* g_byte_array_sized_new         (guint             reserved_size);
+guint8*     g_byte_array_free              (GByteArray       *array,
+					    gboolean          free_segment);
+GByteArray* g_byte_array_append            (GByteArray       *array,
+					    const guint8     *data,
+					    guint             len);
+GByteArray* g_byte_array_prepend           (GByteArray       *array,
+					    const guint8     *data,
+					    guint             len);
+GByteArray* g_byte_array_set_size          (GByteArray       *array,
+					    guint             length);
+GByteArray* g_byte_array_remove_index      (GByteArray       *array,
+					    guint             index_);
+GByteArray* g_byte_array_remove_index_fast (GByteArray       *array,
+					    guint             index_);
+GByteArray* g_byte_array_remove_range      (GByteArray       *array,
+					    guint             index_,
+					    guint             length);
+void        g_byte_array_sort              (GByteArray       *array,
+					    GCompareFunc      compare_func);
+void        g_byte_array_sort_with_data    (GByteArray       *array,
+					    GCompareDataFunc  compare_func,
+					    gpointer          user_data);
+
+
+G_END_DECLS
+
+#endif /* __G_ARRAY_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gasyncqueue.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gasyncqueue.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gasyncqueue.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,92 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_ASYNCQUEUE_H__
+#define __G_ASYNCQUEUE_H__
+
+#include &lt;glib/gthread.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GAsyncQueue     GAsyncQueue;
+
+/* Asyncronous Queues, can be used to communicate between threads
+ */
+
+/* Get a new GAsyncQueue with the ref_count 1 */
+GAsyncQueue*  g_async_queue_new                (void);
+
+/* Lock and unlock a GAsyncQueue. All functions lock the queue for
+ * themselves, but in certain cirumstances you want to hold the lock longer,
+ * thus you lock the queue, call the *_unlocked functions and unlock it again.
+ */
+void          g_async_queue_lock               (GAsyncQueue *queue);
+void          g_async_queue_unlock             (GAsyncQueue *queue);
+
+/* Ref and unref the GAsyncQueue. */
+void          g_async_queue_ref                (GAsyncQueue *queue);
+void          g_async_queue_unref              (GAsyncQueue *queue);
+#ifndef G_DISABLE_DEPRECATED
+/* You don't have to hold the lock for calling *_ref and *_unref anymore. */
+void          g_async_queue_ref_unlocked       (GAsyncQueue *queue);
+void          g_async_queue_unref_and_unlock   (GAsyncQueue *queue);
+#endif /* !G_DISABLE_DEPRECATED */
+
+/* Push data into the async queue. Must not be NULL. */
+void          g_async_queue_push               (GAsyncQueue *queue,
+                                                gpointer     data);
+void          g_async_queue_push_unlocked      (GAsyncQueue *queue,
+                                                gpointer     data);
+
+/* Pop data from the async queue. When no data is there, the thread is blocked
+ * until data arrives. */
+gpointer      g_async_queue_pop                (GAsyncQueue *queue);
+gpointer      g_async_queue_pop_unlocked       (GAsyncQueue *queue);
+
+/* Try to pop data. NULL is returned in case of empty queue. */
+gpointer      g_async_queue_try_pop            (GAsyncQueue *queue);
+gpointer      g_async_queue_try_pop_unlocked   (GAsyncQueue *queue);
+
+/* Wait for data until at maximum until end_time is reached. NULL is returned
+ * in case of empty queue. */
+gpointer      g_async_queue_timed_pop          (GAsyncQueue *queue,
+                                                GTimeVal    *end_time);
+gpointer      g_async_queue_timed_pop_unlocked (GAsyncQueue *queue,
+                                                GTimeVal    *end_time);
+
+/* Return the length of the queue. Negative values mean that threads
+ * are waiting, positve values mean that there are entries in the
+ * queue. Actually this function returns the length of the queue minus
+ * the number of waiting threads, g_async_queue_length == 0 could also
+ * mean 'n' entries in the queue and 'n' thread waiting. Such can
+ * happen due to locking of the queue or due to scheduling. */
+gint          g_async_queue_length             (GAsyncQueue *queue);
+gint          g_async_queue_length_unlocked    (GAsyncQueue *queue);
+
+G_END_DECLS
+
+#endif /* __G_ASYNCQUEUE_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gatomic.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gatomic.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gatomic.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,62 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * g_atomic_*: atomic operations.
+ * Copyright (C) 2003 Sebastian Wilhelmi
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+ 
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A>
+ */
+ 
+#ifndef __G_ATOMIC_H__
+#define __G_ATOMIC_H__
+ 
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+ 
+gint     g_atomic_int_exchange_and_add         (gint     *atomic, 
+						gint      val);
+void     g_atomic_int_add                      (gint     *atomic, 
+						gint      val);
+gboolean g_atomic_int_compare_and_exchange     (gint     *atomic, 
+						gint      oldval, 
+						gint      newval);
+gboolean g_atomic_pointer_compare_and_exchange (gpointer *atomic, 
+						gpointer  oldval, 
+						gpointer  newval);
+
+#ifdef G_ATOMIC_OP_MEMORY_BARRIER_NEEDED
+gint     g_atomic_int_get                      (gint     *atomic);
+gpointer g_atomic_pointer_get                  (gpointer *atomic);
+#else /* !G_ATOMIC_OP_MEMORY_BARRIER_NEEDED */
+# define g_atomic_int_get(atomic) (*(atomic))
+# define g_atomic_pointer_get(atomic) (*(atomic))
+#endif /* G_ATOMIC_OP_MEMORY_BARRIER_NEEDED */
+
+#define g_atomic_int_inc(atomic) (g_atomic_int_add ((atomic), 1))
+#define g_atomic_int_dec_and_test(atomic)				\
+  (g_atomic_int_exchange_and_add ((atomic), -1) == 1)
+
+G_END_DECLS
+ 
+#endif /* __G_ATOMIC_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gbacktrace.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gbacktrace.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gbacktrace.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,61 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_BACKTRACE_H__
+#define __G_BACKTRACE_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+/* Fatal error handlers.
+ * g_on_error_query() will prompt the user to either
+ * [E]xit, [H]alt, [P]roceed or show [S]tack trace.
+ * g_on_error_stack_trace() invokes gdb, which attaches to the current
+ * process and shows a stack trace.
+ * These function may cause different actions on non-unix platforms.
+ * The prg_name arg is required by gdb to find the executable, if it is
+ * passed as NULL, g_on_error_query() will try g_get_prgname().
+ */
+void g_on_error_query (const gchar *prg_name);
+void g_on_error_stack_trace (const gchar *prg_name);
+
+/* Hacker macro to place breakpoints for selected machines.
+ * Actual use is strongly discouraged of course ;)
+ */
+#if (defined (__i386__) || defined (__x86_64__)) &amp;&amp; defined (__GNUC__) &amp;&amp; __GNUC__ &gt;= 2
+#  define G_BREAKPOINT()	G_STMT_START{ __asm__ __volatile__ (&quot;int $03&quot;); }G_STMT_END
+#elif defined (_MSC_VER) &amp;&amp; defined (_M_IX86)
+#  define G_BREAKPOINT()	G_STMT_START{ __asm int 3h }G_STMT_END
+#elif defined (__alpha__) &amp;&amp; !defined(__osf__) &amp;&amp; defined (__GNUC__) &amp;&amp; __GNUC__ &gt;= 2
+#  define G_BREAKPOINT()	G_STMT_START{ __asm__ __volatile__ (&quot;bpt&quot;); }G_STMT_END
+#else	/* !__i386__ &amp;&amp; !__alpha__ */
+#  define G_BREAKPOINT()	G_STMT_START{ raise (SIGTRAP); }G_STMT_END
+#endif	/* __i386__ */
+
+G_END_DECLS
+
+#endif /* __G_BACKTRACE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcache.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcache.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcache.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,66 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_CACHE_H__
+#define __G_CACHE_H__
+
+#include &lt;glib/glist.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GCache          GCache;
+
+typedef gpointer        (*GCacheNewFunc)        (gpointer       key);
+typedef gpointer        (*GCacheDupFunc)        (gpointer       value);
+typedef void            (*GCacheDestroyFunc)    (gpointer       value);
+
+/* Caches
+ */
+GCache*  g_cache_new           (GCacheNewFunc      value_new_func,
+                                GCacheDestroyFunc  value_destroy_func,
+                                GCacheDupFunc      key_dup_func,
+                                GCacheDestroyFunc  key_destroy_func,
+                                GHashFunc          hash_key_func,
+                                GHashFunc          hash_value_func,
+                                GEqualFunc         key_equal_func);
+void     g_cache_destroy       (GCache            *cache);
+gpointer g_cache_insert        (GCache            *cache,
+                                gpointer           key);
+void     g_cache_remove        (GCache            *cache,
+                                gconstpointer      value);
+void     g_cache_key_foreach   (GCache            *cache,
+                                GHFunc             func,
+                                gpointer           user_data);
+void     g_cache_value_foreach (GCache            *cache,
+                                GHFunc             func,
+                                gpointer           user_data);
+
+G_END_DECLS
+
+#endif /* __G_CACHE_H__ */
+
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcompletion.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcompletion.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gcompletion.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,74 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_COMPLETION_H__
+#define __G_COMPLETION_H__
+
+#include &lt;glib/glist.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GCompletion     GCompletion;
+
+typedef gchar*          (*GCompletionFunc)      (gpointer);
+
+/* GCompletion
+ */
+
+typedef gint (*GCompletionStrncmpFunc) (const gchar *s1,
+					const gchar *s2,
+					gsize        n);
+
+struct _GCompletion
+{
+  GList* items;
+  GCompletionFunc func;
+ 
+  gchar* prefix;
+  GList* cache;
+  GCompletionStrncmpFunc strncmp_func;
+};
+
+GCompletion* g_completion_new           (GCompletionFunc func);
+void         g_completion_add_items     (GCompletion*    cmp,
+                                         GList*          items);
+void         g_completion_remove_items  (GCompletion*    cmp,
+                                         GList*          items);
+void         g_completion_clear_items   (GCompletion*    cmp);
+GList*       g_completion_complete      (GCompletion*    cmp,
+                                         const gchar*    prefix,
+                                         gchar**         new_prefix);
+GList*       g_completion_complete_utf8 (GCompletion  *cmp,
+                                         const gchar*    prefix,
+                                         gchar**         new_prefix);
+void         g_completion_set_compare   (GCompletion *cmp,
+				         GCompletionStrncmpFunc strncmp_func);
+void         g_completion_free          (GCompletion*    cmp);
+
+G_END_DECLS
+
+#endif /* __G_COMPLETION_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gconvert.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gconvert.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gconvert.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,123 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_CONVERT_H__
+#define __G_CONVERT_H__
+
+#include &lt;stddef.h&gt;      /* For size_t */
+#include &lt;glib/gerror.h&gt;
+
+G_BEGIN_DECLS
+
+typedef enum 
+{
+  G_CONVERT_ERROR_NO_CONVERSION,
+  G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
+  G_CONVERT_ERROR_FAILED,
+  G_CONVERT_ERROR_PARTIAL_INPUT,
+  G_CONVERT_ERROR_BAD_URI,
+  G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
+} GConvertError;
+
+#define G_CONVERT_ERROR g_convert_error_quark()
+GQuark g_convert_error_quark (void);
+
+/* Thin wrappers around iconv
+ */
+typedef struct _GIConv *GIConv;
+
+GIConv g_iconv_open   (const gchar  *to_codeset,
+		       const gchar  *from_codeset);
+size_t g_iconv        (GIConv        converter,
+		       gchar       **inbuf,
+		       gsize        *inbytes_left,
+		       gchar       **outbuf,
+		       gsize        *outbytes_left);
+gint   g_iconv_close  (GIConv        converter);
+
+
+gchar* g_convert               (const gchar  *str,
+				gssize        len,            
+				const gchar  *to_codeset,
+				const gchar  *from_codeset,
+				gsize        *bytes_read,     
+				gsize        *bytes_written,  
+				GError      **error);
+gchar* g_convert_with_iconv    (const gchar  *str,
+				gssize        len,
+				GIConv        converter,
+				gsize        *bytes_read,     
+				gsize        *bytes_written,  
+				GError      **error);
+gchar* g_convert_with_fallback (const gchar  *str,
+				gssize        len,            
+				const gchar  *to_codeset,
+				const gchar  *from_codeset,
+				gchar        *fallback,
+				gsize        *bytes_read,     
+				gsize        *bytes_written,  
+				GError      **error);
+
+
+/* Convert between libc's idea of strings and UTF-8.
+ */
+gchar* g_locale_to_utf8   (const gchar  *opsysstring,
+			   gssize        len,            
+			   gsize        *bytes_read,     
+			   gsize        *bytes_written,  
+			   GError      **error);
+gchar* g_locale_from_utf8 (const gchar  *utf8string,
+			   gssize        len,            
+			   gsize        *bytes_read,     
+			   gsize        *bytes_written,  
+			   GError      **error);
+
+/* Convert between the operating system (or C runtime)
+ * representation of file names and UTF-8.
+ */
+gchar* g_filename_to_utf8   (const gchar  *opsysstring,
+			     gssize        len,            
+			     gsize        *bytes_read,     
+			     gsize        *bytes_written,  
+			     GError      **error);
+gchar* g_filename_from_utf8 (const gchar  *utf8string,
+			     gssize        len,            
+			     gsize        *bytes_read,     
+			     gsize        *bytes_written,  
+			     GError      **error);
+
+gchar *g_filename_from_uri (const gchar *uri,
+			    gchar      **hostname,
+			    GError     **error);
+  
+gchar *g_filename_to_uri   (const gchar *filename,
+			    const gchar *hostname,
+			    GError     **error);
+
+
+G_END_DECLS
+
+#endif /* __G_CONVERT_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdataset.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdataset.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdataset.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,106 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_DATASET_H__
+#define __G_DATASET_H__
+
+#include &lt;glib/gquark.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GData           GData;
+
+typedef void            (*GDataForeachFunc)     (GQuark         key_id,
+                                                 gpointer       data,
+                                                 gpointer       user_data);
+
+/* Keyed Data List
+ */
+void      g_datalist_init                (GData          **datalist);
+void      g_datalist_clear               (GData          **datalist);
+gpointer  g_datalist_id_get_data         (GData          **datalist,
+                                          GQuark           key_id);
+void      g_datalist_id_set_data_full    (GData          **datalist,
+                                          GQuark           key_id,
+                                          gpointer         data,
+                                          GDestroyNotify   destroy_func);
+gpointer  g_datalist_id_remove_no_notify (GData          **datalist,
+                                          GQuark           key_id);
+void      g_datalist_foreach             (GData          **datalist,
+                                          GDataForeachFunc func,
+                                          gpointer         user_data);
+#define   g_datalist_id_set_data(dl, q, d)      \
+     g_datalist_id_set_data_full ((dl), (q), (d), NULL)
+#define   g_datalist_id_remove_data(dl, q)      \
+     g_datalist_id_set_data ((dl), (q), NULL)
+#define   g_datalist_get_data(dl, k)            \
+     (g_datalist_id_get_data ((dl), g_quark_try_string (k)))
+#define   g_datalist_set_data_full(dl, k, d, f) \
+     g_datalist_id_set_data_full ((dl), g_quark_from_string (k), (d), (f))
+#define   g_datalist_remove_no_notify(dl, k)    \
+     g_datalist_id_remove_no_notify ((dl), g_quark_try_string (k))
+#define   g_datalist_set_data(dl, k, d)         \
+     g_datalist_set_data_full ((dl), (k), (d), NULL)
+#define   g_datalist_remove_data(dl, k)         \
+     g_datalist_id_set_data ((dl), g_quark_try_string (k), NULL)
+
+
+/* Location Associated Keyed Data
+ */
+void      g_dataset_destroy             (gconstpointer    dataset_location);
+gpointer  g_dataset_id_get_data         (gconstpointer    dataset_location,
+                                         GQuark           key_id);
+void      g_dataset_id_set_data_full    (gconstpointer    dataset_location,
+                                         GQuark           key_id,
+                                         gpointer         data,
+                                         GDestroyNotify   destroy_func);
+gpointer  g_dataset_id_remove_no_notify (gconstpointer    dataset_location,
+                                         GQuark           key_id);
+void      g_dataset_foreach             (gconstpointer    dataset_location,
+                                         GDataForeachFunc func,
+                                         gpointer         user_data);
+#define   g_dataset_id_set_data(l, k, d)        \
+     g_dataset_id_set_data_full ((l), (k), (d), NULL)
+#define   g_dataset_id_remove_data(l, k)        \
+     g_dataset_id_set_data ((l), (k), NULL)
+#define   g_dataset_get_data(l, k)              \
+     (g_dataset_id_get_data ((l), g_quark_try_string (k)))
+#define   g_dataset_set_data_full(l, k, d, f)   \
+     g_dataset_id_set_data_full ((l), g_quark_from_string (k), (d), (f))
+#define   g_dataset_remove_no_notify(l, k)      \
+     g_dataset_id_remove_no_notify ((l), g_quark_try_string (k))
+#define   g_dataset_set_data(l, k, d)           \
+     g_dataset_set_data_full ((l), (k), (d), NULL)
+#define   g_dataset_remove_data(l, k)           \
+     g_dataset_id_set_data ((l), g_quark_try_string (k), NULL)
+
+G_END_DECLS
+
+#endif /* __G_DATASET_H__ */
+
+
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdate.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdate.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdate.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,252 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_DATE_H__
+#define __G_DATE_H__
+
+#include &lt;glib/gquark.h&gt;
+
+G_BEGIN_DECLS
+
+/* GDate
+ *
+ * Date calculations (not time for now, to be resolved). These are a
+ * mutant combination of Steffen Beyer's DateCalc routines
+ * (<A HREF="http://www.perl.com/CPAN/authors/id/STBEY/">http://www.perl.com/CPAN/authors/id/STBEY/</A>) and Jon Trowbridge's
+ * date routines (written for in-house software).  Written by Havoc
+ * Pennington &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">hp at pobox.com</A>&gt;
+ */
+
+typedef gint32  GTime;
+typedef guint16 GDateYear;
+typedef guint8  GDateDay;   /* day of the month */
+typedef struct _GDate GDate;
+/* make struct tm known without having to include time.h */
+struct tm;
+
+/* enum used to specify order of appearance in parsed date strings */
+typedef enum
+{
+  G_DATE_DAY   = 0,
+  G_DATE_MONTH = 1,
+  G_DATE_YEAR  = 2
+} GDateDMY;
+
+/* actual week and month values */
+typedef enum
+{
+  G_DATE_BAD_WEEKDAY  = 0,
+  G_DATE_MONDAY       = 1,
+  G_DATE_TUESDAY      = 2,
+  G_DATE_WEDNESDAY    = 3,
+  G_DATE_THURSDAY     = 4,
+  G_DATE_FRIDAY       = 5,
+  G_DATE_SATURDAY     = 6,
+  G_DATE_SUNDAY       = 7
+} GDateWeekday;
+typedef enum
+{
+  G_DATE_BAD_MONTH = 0,
+  G_DATE_JANUARY   = 1,
+  G_DATE_FEBRUARY  = 2,
+  G_DATE_MARCH     = 3,
+  G_DATE_APRIL     = 4,
+  G_DATE_MAY       = 5,
+  G_DATE_JUNE      = 6,
+  G_DATE_JULY      = 7,
+  G_DATE_AUGUST    = 8,
+  G_DATE_SEPTEMBER = 9,
+  G_DATE_OCTOBER   = 10,
+  G_DATE_NOVEMBER  = 11,
+  G_DATE_DECEMBER  = 12
+} GDateMonth;
+
+#define G_DATE_BAD_JULIAN 0U
+#define G_DATE_BAD_DAY    0U
+#define G_DATE_BAD_YEAR   0U
+
+/* Note: directly manipulating structs is generally a bad idea, but
+ * in this case it's an *incredibly* bad idea, because all or part
+ * of this struct can be invalid at any given time. Use the functions,
+ * or you will get hosed, I promise.
+ */
+struct _GDate
+{
+  guint julian_days : 32; /* julian days representation - we use a
+                           *  bitfield hoping that 64 bit platforms
+                           *  will pack this whole struct in one big
+                           *  int
+                           */
+
+  guint julian : 1;    /* julian is valid */
+  guint dmy    : 1;    /* dmy is valid */
+
+  /* DMY representation */
+  guint day    : 6;
+  guint month  : 4;
+  guint year   : 16;
+};
+
+/* g_date_new() returns an invalid date, you then have to _set() stuff
+ * to get a usable object. You can also allocate a GDate statically,
+ * then call g_date_clear() to initialize.
+ */
+GDate*       g_date_new                   (void);
+GDate*       g_date_new_dmy               (GDateDay     day,
+                                           GDateMonth   month,
+                                           GDateYear    year);
+GDate*       g_date_new_julian            (guint32      julian_day);
+void         g_date_free                  (GDate       *date);
+
+/* check g_date_valid() after doing an operation that might fail, like
+ * _parse.  Almost all g_date operations are undefined on invalid
+ * dates (the exceptions are the mutators, since you need those to
+ * return to validity).
+ */
+gboolean     g_date_valid                 (const GDate *date);
+gboolean     g_date_valid_day             (GDateDay     day) G_GNUC_CONST;
+gboolean     g_date_valid_month           (GDateMonth month) G_GNUC_CONST;
+gboolean     g_date_valid_year            (GDateYear  year) G_GNUC_CONST;
+gboolean     g_date_valid_weekday         (GDateWeekday weekday) G_GNUC_CONST;
+gboolean     g_date_valid_julian          (guint32 julian_date) G_GNUC_CONST;
+gboolean     g_date_valid_dmy             (GDateDay     day,
+                                           GDateMonth   month,
+                                           GDateYear    year) G_GNUC_CONST;
+
+GDateWeekday g_date_get_weekday           (const GDate *date);
+GDateMonth   g_date_get_month             (const GDate *date);
+GDateYear    g_date_get_year              (const GDate *date);
+GDateDay     g_date_get_day               (const GDate *date);
+guint32      g_date_get_julian            (const GDate *date);
+guint        g_date_get_day_of_year       (const GDate *date);
+/* First monday/sunday is the start of week 1; if we haven't reached
+ * that day, return 0. These are not ISO weeks of the year; that
+ * routine needs to be added.
+ * these functions return the number of weeks, starting on the
+ * corrsponding day
+ */
+guint        g_date_get_monday_week_of_year (const GDate *date);
+guint        g_date_get_sunday_week_of_year (const GDate *date);
+
+/* If you create a static date struct you need to clear it to get it
+ * in a sane state before use. You can clear a whole array at
+ * once with the ndates argument.
+ */
+void         g_date_clear                 (GDate       *date,
+                                           guint        n_dates);
+
+/* The parse routine is meant for dates typed in by a user, so it
+ * permits many formats but tries to catch common typos. If your data
+ * needs to be strictly validated, it is not an appropriate function.
+ */
+void         g_date_set_parse             (GDate       *date,
+                                           const gchar *str);
+void         g_date_set_time              (GDate       *date,
+                                           GTime        time_);
+void         g_date_set_month             (GDate       *date,
+                                           GDateMonth   month);
+void         g_date_set_day               (GDate       *date,
+                                           GDateDay     day);
+void         g_date_set_year              (GDate       *date,
+                                           GDateYear    year);
+void         g_date_set_dmy               (GDate       *date,
+                                           GDateDay     day,
+                                           GDateMonth   month,
+                                           GDateYear    y);
+void         g_date_set_julian            (GDate       *date,
+                                           guint32      julian_date);
+gboolean     g_date_is_first_of_month     (const GDate *date);
+gboolean     g_date_is_last_of_month      (const GDate *date);
+
+/* To go forward by some number of weeks just go forward weeks*7 days */
+void         g_date_add_days              (GDate       *date,
+                                           guint        n_days);
+void         g_date_subtract_days         (GDate       *date,
+                                           guint        n_days);
+
+/* If you add/sub months while day &gt; 28, the day might change */
+void         g_date_add_months            (GDate       *date,
+                                           guint        n_months);
+void         g_date_subtract_months       (GDate       *date,
+                                           guint        n_months);
+
+/* If it's feb 29, changing years can move you to the 28th */
+void         g_date_add_years             (GDate       *date,
+                                           guint        n_years);
+void         g_date_subtract_years        (GDate       *date,
+                                           guint        n_years);
+gboolean     g_date_is_leap_year          (GDateYear    year) G_GNUC_CONST;
+guint8       g_date_get_days_in_month     (GDateMonth   month,
+                                           GDateYear    year) G_GNUC_CONST;
+guint8       g_date_get_monday_weeks_in_year  (GDateYear    year) G_GNUC_CONST;
+guint8       g_date_get_sunday_weeks_in_year  (GDateYear    year) G_GNUC_CONST;
+
+/* Returns the number of days between the two dates.  If date2 comes
+   before date1, a negative value is return. */
+gint         g_date_days_between          (const GDate *date1,
+					   const GDate *date2);
+
+/* qsort-friendly (with a cast...) */
+gint         g_date_compare               (const GDate *lhs,
+                                           const GDate *rhs);
+void         g_date_to_struct_tm          (const GDate *date,
+                                           struct tm   *tm);
+
+void         g_date_clamp                 (GDate *date,
+					   const GDate *min_date,
+					   const GDate *max_date);
+
+/* Swap date1 and date2's values if date1 &gt; date2. */
+void         g_date_order                 (GDate *date1, GDate *date2);
+
+/* Just like strftime() except you can only use date-related formats.
+ *   Using a time format is undefined.
+ */
+gsize        g_date_strftime              (gchar       *s,
+                                           gsize        slen,
+                                           const gchar *format,
+                                           const GDate *date);
+
+#ifndef G_DISABLE_DEPRECATED
+
+#define g_date_weekday 			g_date_get_weekday
+#define g_date_month 			g_date_get_month
+#define g_date_year 			g_date_get_year
+#define g_date_day 			g_date_get_day
+#define g_date_julian 			g_date_get_julian
+#define g_date_day_of_year 		g_date_get_day_of_year
+#define g_date_monday_week_of_year 	g_date_get_monday_week_of_year
+#define g_date_sunday_week_of_year 	g_date_get_sunday_week_of_year
+#define g_date_days_in_month 		g_date_get_days_in_month
+#define g_date_monday_weeks_in_year 	g_date_get_monday_weeks_in_year
+#define g_date_sunday_weeks_in_year	g_date_get_sunday_weeks_in_year
+
+#endif /* G_DISABLE_DEPRECATED */
+
+G_END_DECLS
+
+#endif /* __G_DATE_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdir.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdir.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gdir.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,41 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * gdir.c: Simplified wrapper around the DIRENT functions.
+ *
+ * Copyright 2001 Hans Breuer
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_DIR_H__
+#define __G_DIR_H__
+
+#include &lt;glib/gerror.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GDir GDir;
+
+GDir    *               g_dir_open      (const gchar  *path,
+					 guint         flags,
+					 GError      **error);
+G_CONST_RETURN gchar   *g_dir_read_name (GDir         *dir);
+void                    g_dir_rewind    (GDir         *dir);
+void                    g_dir_close     (GDir         *dir);
+
+G_END_DECLS
+
+#endif /* __G_DIR_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gerror.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gerror.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gerror.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,74 @@
+/* gerror.h - Error reporting system
+ *
+ *  Copyright 2000 Red Hat, Inc.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *   Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_ERROR_H__
+#define __G_ERROR_H__
+
+#include &lt;glib/gquark.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GError GError;
+
+struct _GError
+{
+  GQuark       domain;
+  gint         code;
+  gchar       *message;
+};
+
+GError*  g_error_new           (GQuark         domain,
+                                gint           code,
+                                const gchar   *format,
+                                ...) G_GNUC_PRINTF (3, 4);
+
+GError*  g_error_new_literal   (GQuark         domain,
+                                gint           code,
+                                const gchar   *message);
+
+void     g_error_free          (GError        *error);
+GError*  g_error_copy          (const GError  *error);
+
+gboolean g_error_matches       (const GError  *error,
+                                GQuark         domain,
+                                gint           code);
+
+/* if (err) *err = g_error_new(domain, code, format, ...), also has
+ * some sanity checks.
+ */
+void     g_set_error           (GError       **err,
+                                GQuark         domain,
+                                gint           code,
+                                const gchar   *format,
+                                ...) G_GNUC_PRINTF (4, 5);
+
+/* if (dest) *dest = src; also has some sanity checks.
+ */
+void     g_propagate_error     (GError       **dest,
+				GError        *src);
+
+/* if (err &amp;&amp; *err) { g_error_free(*err); *err = NULL; } */
+void     g_clear_error         (GError       **err);
+
+
+G_END_DECLS
+
+#endif /* __G_ERROR_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gfileutils.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gfileutils.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gfileutils.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,102 @@
+/* gfileutils.h - File utility functions
+ *
+ *  Copyright 2000 Red Hat, Inc.
+ *
+ * GLib is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * GLib is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with GLib; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *   Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_FILEUTILS_H__
+#define __G_FILEUTILS_H__
+
+#include &lt;glib/gerror.h&gt;
+
+G_BEGIN_DECLS
+
+#define G_FILE_ERROR g_file_error_quark ()
+
+typedef enum
+{
+  G_FILE_ERROR_EXIST,
+  G_FILE_ERROR_ISDIR,
+  G_FILE_ERROR_ACCES,
+  G_FILE_ERROR_NAMETOOLONG,
+  G_FILE_ERROR_NOENT,
+  G_FILE_ERROR_NOTDIR,
+  G_FILE_ERROR_NXIO,
+  G_FILE_ERROR_NODEV,
+  G_FILE_ERROR_ROFS,
+  G_FILE_ERROR_TXTBSY,
+  G_FILE_ERROR_FAULT,
+  G_FILE_ERROR_LOOP,
+  G_FILE_ERROR_NOSPC,
+  G_FILE_ERROR_NOMEM,
+  G_FILE_ERROR_MFILE,
+  G_FILE_ERROR_NFILE,
+  G_FILE_ERROR_BADF,
+  G_FILE_ERROR_INVAL,
+  G_FILE_ERROR_PIPE,
+  G_FILE_ERROR_AGAIN,
+  G_FILE_ERROR_INTR,
+  G_FILE_ERROR_IO,
+  G_FILE_ERROR_PERM,
+  G_FILE_ERROR_FAILED
+} GFileError;
+
+/* For backward-compat reasons, these are synced to an old 
+ * anonymous enum in libgnome. But don't use that enum
+ * in new code.
+ */
+typedef enum
+{
+  G_FILE_TEST_IS_REGULAR    = 1 &lt;&lt; 0,
+  G_FILE_TEST_IS_SYMLINK    = 1 &lt;&lt; 1,
+  G_FILE_TEST_IS_DIR        = 1 &lt;&lt; 2,
+  G_FILE_TEST_IS_EXECUTABLE = 1 &lt;&lt; 3,
+  G_FILE_TEST_EXISTS        = 1 &lt;&lt; 4
+} GFileTest;
+
+GQuark     g_file_error_quark      (void);
+/* So other code can generate a GFileError */
+GFileError g_file_error_from_errno (gint err_no);
+
+gboolean g_file_test         (const gchar  *filename,
+                              GFileTest     test);
+gboolean g_file_get_contents (const gchar  *filename,
+                              gchar       **contents,
+                              gsize        *length,    
+                              GError      **error);
+gchar   *g_file_read_link    (const gchar  *filename,
+			      GError      **error);
+
+/* Wrapper / workalike for mkstemp() */
+gint    g_mkstemp            (gchar        *tmpl);
+
+/* Wrapper for g_mkstemp */
+gint    g_file_open_tmp      (const gchar  *tmpl,
+			      gchar       **name_used,
+			      GError      **error);
+
+gchar *g_build_path     (const gchar *separator,
+			 const gchar *first_element,
+			 ...);
+gchar *g_build_filename (const gchar *first_element,
+			 ...);
+
+G_END_DECLS
+
+#endif /* __G_FILEUTILS_H__ */
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghash.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghash.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghash.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,111 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_HASH_H__
+#define __G_HASH_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GHashTable  GHashTable;
+
+typedef gboolean  (*GHRFunc)  (gpointer  key,
+                               gpointer  value,
+                               gpointer  user_data);
+
+/* Hash tables
+ */
+GHashTable* g_hash_table_new		   (GHashFunc	    hash_func,
+					    GEqualFunc	    key_equal_func);
+GHashTable* g_hash_table_new_full      	   (GHashFunc	    hash_func,
+					    GEqualFunc	    key_equal_func,
+					    GDestroyNotify  key_destroy_func,
+					    GDestroyNotify  value_destroy_func);
+void	    g_hash_table_destroy	   (GHashTable	   *hash_table);
+void	    g_hash_table_insert		   (GHashTable	   *hash_table,
+					    gpointer	    key,
+					    gpointer	    value);
+void        g_hash_table_replace           (GHashTable     *hash_table,
+					    gpointer	    key,
+					    gpointer	    value);
+gboolean    g_hash_table_remove		   (GHashTable	   *hash_table,
+					    gconstpointer   key);
+gboolean    g_hash_table_steal             (GHashTable     *hash_table,
+					    gconstpointer   key);
+gpointer    g_hash_table_lookup		   (GHashTable	   *hash_table,
+					    gconstpointer   key);
+gboolean    g_hash_table_lookup_extended   (GHashTable	   *hash_table,
+					    gconstpointer   lookup_key,
+					    gpointer	   *orig_key,
+					    gpointer	   *value);
+void	    g_hash_table_foreach	   (GHashTable	   *hash_table,
+					    GHFunc	    func,
+					    gpointer	    user_data);
+gpointer    g_hash_table_find	   (GHashTable	   *hash_table,
+					    GHRFunc	    predicate,
+					    gpointer	    user_data);
+guint	    g_hash_table_foreach_remove	   (GHashTable	   *hash_table,
+					    GHRFunc	    func,
+					    gpointer	    user_data);
+guint	    g_hash_table_foreach_steal	   (GHashTable	   *hash_table,
+					    GHRFunc	    func,
+					    gpointer	    user_data);
+guint	    g_hash_table_size		   (GHashTable	   *hash_table);
+
+#ifndef G_DISABLE_DEPRECATED
+
+/* The following two functions are deprecated and will be removed in
+ * the next major release. They do no good. */
+#define g_hash_table_freeze(hash_table) ((void)0)
+#define g_hash_table_thaw(hash_table) ((void)0)
+
+#endif /* G_DISABLE_DEPRECATED */
+
+/* Hash Functions
+ */
+gboolean g_str_equal (gconstpointer  v,
+                      gconstpointer  v2);
+guint    g_str_hash  (gconstpointer  v);
+
+gboolean g_int_equal (gconstpointer  v,
+                      gconstpointer  v2);
+guint    g_int_hash  (gconstpointer  v);
+
+/* This &quot;hash&quot; function will just return the key's address as an
+ * unsigned integer. Useful for hashing on plain addresses or
+ * simple integer values.
+ * Passing NULL into g_hash_table_new() as GHashFunc has the
+ * same effect as passing g_direct_hash().
+ */
+guint    g_direct_hash  (gconstpointer  v) G_GNUC_CONST;
+gboolean g_direct_equal (gconstpointer  v,
+                         gconstpointer  v2) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_HASH_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghook.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghook.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/ghook.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,178 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_HOOK_H__
+#define __G_HOOK_H__
+
+#include &lt;glib/gmem.h&gt;
+
+G_BEGIN_DECLS
+
+
+/* --- typedefs --- */
+typedef struct _GHook		GHook;
+typedef struct _GHookList	GHookList;
+
+typedef gint		(*GHookCompareFunc)	(GHook		*new_hook,
+						 GHook		*sibling);
+typedef gboolean	(*GHookFindFunc)	(GHook		*hook,
+						 gpointer	 data);
+typedef void		(*GHookMarshaller)	(GHook		*hook,
+						 gpointer	 marshal_data);
+typedef gboolean	(*GHookCheckMarshaller)	(GHook		*hook,
+						 gpointer	 marshal_data);
+typedef void		(*GHookFunc)		(gpointer	 data);
+typedef gboolean	(*GHookCheckFunc)	(gpointer	 data);
+typedef void		(*GHookFinalizeFunc)	(GHookList      *hook_list,
+						 GHook          *hook);
+typedef enum
+{
+  G_HOOK_FLAG_ACTIVE	    = 1 &lt;&lt; 0,
+  G_HOOK_FLAG_IN_CALL	    = 1 &lt;&lt; 1,
+  G_HOOK_FLAG_MASK	    = 0x0f
+} GHookFlagMask;
+#define G_HOOK_FLAG_USER_SHIFT	(4)
+
+
+/* --- structures --- */
+struct _GHookList
+{
+  gulong	    seq_id;
+  guint		    hook_size : 16;
+  guint		    is_setup : 1;
+  GHook		   *hooks;
+  GMemChunk	   *hook_memchunk;
+  GHookFinalizeFunc finalize_hook;
+  gpointer	    dummy[2];
+};
+struct _GHook
+{
+  gpointer	 data;
+  GHook		*next;
+  GHook		*prev;
+  guint		 ref_count;
+  gulong	 hook_id;
+  guint		 flags;
+  gpointer	 func;
+  GDestroyNotify destroy;
+};
+
+
+/* --- macros --- */
+#define	G_HOOK(hook)			((GHook*) (hook))
+#define	G_HOOK_FLAGS(hook)		(G_HOOK (hook)-&gt;flags)
+#define	G_HOOK_ACTIVE(hook)		((G_HOOK_FLAGS (hook) &amp; \
+					  G_HOOK_FLAG_ACTIVE) != 0)
+#define	G_HOOK_IN_CALL(hook)		((G_HOOK_FLAGS (hook) &amp; \
+					  G_HOOK_FLAG_IN_CALL) != 0)
+#define G_HOOK_IS_VALID(hook)		(G_HOOK (hook)-&gt;hook_id != 0 &amp;&amp; \
+					 (G_HOOK_FLAGS (hook) &amp; \
+                                          G_HOOK_FLAG_ACTIVE))
+#define G_HOOK_IS_UNLINKED(hook)	(G_HOOK (hook)-&gt;next == NULL &amp;&amp; \
+					 G_HOOK (hook)-&gt;prev == NULL &amp;&amp; \
+					 G_HOOK (hook)-&gt;hook_id == 0 &amp;&amp; \
+					 G_HOOK (hook)-&gt;ref_count == 0)
+
+
+/* --- prototypes --- */
+/* callback maintenance functions */
+void	 g_hook_list_init		(GHookList		*hook_list,
+					 guint			 hook_size);
+void	 g_hook_list_clear		(GHookList		*hook_list);
+GHook*	 g_hook_alloc			(GHookList		*hook_list);
+void	 g_hook_free			(GHookList		*hook_list,
+					 GHook			*hook);
+void	 g_hook_ref			(GHookList		*hook_list,
+					 GHook			*hook);
+void	 g_hook_unref			(GHookList		*hook_list,
+					 GHook			*hook);
+gboolean g_hook_destroy			(GHookList		*hook_list,
+					 gulong			 hook_id);
+void	 g_hook_destroy_link		(GHookList		*hook_list,
+					 GHook			*hook);
+void	 g_hook_prepend			(GHookList		*hook_list,
+					 GHook			*hook);
+void	 g_hook_insert_before		(GHookList		*hook_list,
+					 GHook			*sibling,
+					 GHook			*hook);
+void	 g_hook_insert_sorted		(GHookList		*hook_list,
+					 GHook			*hook,
+					 GHookCompareFunc	 func);
+GHook*	 g_hook_get			(GHookList		*hook_list,
+					 gulong			 hook_id);
+GHook*	 g_hook_find			(GHookList		*hook_list,
+					 gboolean		 need_valids,
+					 GHookFindFunc		 func,
+					 gpointer		 data);
+GHook*	 g_hook_find_data		(GHookList		*hook_list,
+					 gboolean		 need_valids,
+					 gpointer		 data);
+GHook*	 g_hook_find_func		(GHookList		*hook_list,
+					 gboolean		 need_valids,
+					 gpointer		 func);
+GHook*	 g_hook_find_func_data		(GHookList		*hook_list,
+					 gboolean		 need_valids,
+					 gpointer		 func,
+					 gpointer		 data);
+/* return the first valid hook, and increment its reference count */
+GHook*	 g_hook_first_valid		(GHookList		*hook_list,
+					 gboolean		 may_be_in_call);
+/* return the next valid hook with incremented reference count, and
+ * decrement the reference count of the original hook
+ */
+GHook*	 g_hook_next_valid		(GHookList		*hook_list,
+					 GHook			*hook,
+					 gboolean		 may_be_in_call);
+/* GHookCompareFunc implementation to insert hooks sorted by their id */
+gint	 g_hook_compare_ids		(GHook			*new_hook,
+					 GHook			*sibling);
+/* convenience macros */
+#define	 g_hook_append( hook_list, hook )  \
+     g_hook_insert_before ((hook_list), NULL, (hook))
+/* invoke all valid hooks with the (*GHookFunc) signature.
+ */
+void	 g_hook_list_invoke		(GHookList		*hook_list,
+					 gboolean		 may_recurse);
+/* invoke all valid hooks with the (*GHookCheckFunc) signature,
+ * and destroy the hook if FALSE is returned.
+ */
+void	 g_hook_list_invoke_check	(GHookList		*hook_list,
+					 gboolean		 may_recurse);
+/* invoke a marshaller on all valid hooks.
+ */
+void	 g_hook_list_marshal		(GHookList		*hook_list,
+					 gboolean		 may_recurse,
+					 GHookMarshaller	 marshaller,
+					 gpointer		 marshal_data);
+void	 g_hook_list_marshal_check	(GHookList		*hook_list,
+					 gboolean		 may_recurse,
+					 GHookCheckMarshaller	 marshaller,
+					 gpointer		 marshal_data);
+
+G_END_DECLS
+
+#endif /* __G_HOOK_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n-lib.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n-lib.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n-lib.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,55 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997, 2002  Peter Mattis, Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_I18N_LIB_H__
+#define __G_I18N_LIB_H__
+
+#include &lt;glib/gstrfuncs.h&gt;
+
+#ifdef ENABLE_NLS
+
+#include &lt;libintl.h&gt;
+
+#ifndef GETTEXT_PACKAGE
+#error You must define GETTEXT_PACKAGE before including gi18n-lib.h.
+#endif
+
+#define _(String) dgettext (GETTEXT_PACKAGE, String)
+#define Q_(String) g_strip_context ((String), dgettext (GETTEXT_PACKAGE, String))
+#ifdef gettext_noop
+#define N_(String) gettext_noop (String)
+#else
+#define N_(String) (String)
+#endif
+
+#else /* NLS is disabled */
+
+#define _(String) (String)
+#define Q_(String) (String)
+#define N_(String) (String)
+#define textdomain(String) (String)
+#define gettext(String) (String)
+#define dgettext(Domain,String) (String)
+#define dcgettext(Domain,String,Type) (String)
+#define bindtextdomain(Domain,Directory) (Domain) 
+
+#endif
+
+#endif  /* __G_I18N_LIB_H__ */
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gi18n.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,50 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997, 2002  Peter Mattis, Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_I18N_H__
+#define __G_I18N_H__
+
+#include &lt;glib/gstrfuncs.h&gt;
+
+#ifdef ENABLE_NLS
+
+#include &lt;libintl.h&gt;
+#define _(String) gettext (String)
+#define Q_(String) g_strip_context ((String), gettext (String))
+#ifdef gettext_noop
+#define N_(String) gettext_noop (String)
+#else
+#define N_(String) (String)
+#endif
+
+#else /* NLS is disabled */
+
+#define _(String) (String)
+#define Q_(String) (String)
+#define N_(String) (String)
+#define textdomain(String) (String)
+#define gettext(String) (String)
+#define dgettext(Domain,String) (String)
+#define dcgettext(Domain,String,Type) (String)
+#define bindtextdomain(Domain,Directory) (Domain) 
+
+#endif
+
+#endif  /* __G_I18N_H__ */
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/giochannel.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/giochannel.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/giochannel.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,350 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_IOCHANNEL_H__
+#define __G_IOCHANNEL_H__
+
+#include &lt;glib/gconvert.h&gt;
+#include &lt;glib/gmain.h&gt;
+#include &lt;glib/gstring.h&gt;
+
+G_BEGIN_DECLS
+
+/* GIOChannel
+ */
+
+typedef struct _GIOChannel	GIOChannel;
+typedef struct _GIOFuncs        GIOFuncs;
+
+typedef enum
+{
+  G_IO_ERROR_NONE,
+  G_IO_ERROR_AGAIN,
+  G_IO_ERROR_INVAL,
+  G_IO_ERROR_UNKNOWN
+} GIOError;
+
+#define G_IO_CHANNEL_ERROR g_io_channel_error_quark()
+
+typedef enum
+{
+  /* Derived from errno */
+  G_IO_CHANNEL_ERROR_FBIG,
+  G_IO_CHANNEL_ERROR_INVAL,
+  G_IO_CHANNEL_ERROR_IO,
+  G_IO_CHANNEL_ERROR_ISDIR,
+  G_IO_CHANNEL_ERROR_NOSPC,
+  G_IO_CHANNEL_ERROR_NXIO,
+  G_IO_CHANNEL_ERROR_OVERFLOW,
+  G_IO_CHANNEL_ERROR_PIPE,
+  /* Other */
+  G_IO_CHANNEL_ERROR_FAILED
+} GIOChannelError;
+
+typedef enum
+{
+  G_IO_STATUS_ERROR,
+  G_IO_STATUS_NORMAL,
+  G_IO_STATUS_EOF,
+  G_IO_STATUS_AGAIN
+} GIOStatus;
+
+typedef enum
+{
+  G_SEEK_CUR,
+  G_SEEK_SET,
+  G_SEEK_END
+} GSeekType;
+
+typedef enum
+{
+  G_IO_IN	GLIB_SYSDEF_POLLIN,
+  G_IO_OUT	GLIB_SYSDEF_POLLOUT,
+  G_IO_PRI	GLIB_SYSDEF_POLLPRI,
+  G_IO_ERR	GLIB_SYSDEF_POLLERR,
+  G_IO_HUP	GLIB_SYSDEF_POLLHUP,
+  G_IO_NVAL	GLIB_SYSDEF_POLLNVAL
+} GIOCondition;
+
+typedef enum
+{
+  G_IO_FLAG_APPEND = 1 &lt;&lt; 0,
+  G_IO_FLAG_NONBLOCK = 1 &lt;&lt; 1,
+  G_IO_FLAG_IS_READABLE = 1 &lt;&lt; 2,	/* Read only flag */
+  G_IO_FLAG_IS_WRITEABLE = 1 &lt;&lt; 3,	/* Read only flag */
+  G_IO_FLAG_IS_SEEKABLE = 1 &lt;&lt; 4,	/* Read only flag */
+  G_IO_FLAG_MASK = (1 &lt;&lt; 5) - 1,
+  G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
+  G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
+} GIOFlags;
+
+struct _GIOChannel
+{
+  /*&lt; private &gt;*/
+  guint ref_count;
+  GIOFuncs *funcs;
+
+  gchar *encoding;
+  GIConv read_cd;
+  GIConv write_cd;
+  gchar *line_term;		/* String which indicates the end of a line of text */
+  guint line_term_len;		/* So we can have null in the line term */
+
+  gsize buf_size;
+  GString *read_buf;		/* Raw data from the channel */
+  GString *encoded_read_buf;    /* Channel data converted to UTF-8 */
+  GString *write_buf;		/* Data ready to be written to the file */
+  gchar partial_write_buf[6];	/* UTF-8 partial characters, null terminated */
+
+  /* Group the flags together, immediately after partial_write_buf, to save memory */
+
+  guint use_buffer     : 1;	/* The encoding uses the buffers */
+  guint do_encode      : 1;	/* The encoding uses the GIConv coverters */
+  guint close_on_unref : 1;	/* Close the channel on final unref */
+  guint is_readable    : 1;	/* Cached GIOFlag */
+  guint is_writeable   : 1;	/* ditto */
+  guint is_seekable    : 1;	/* ditto */
+
+  gpointer reserved1;	
+  gpointer reserved2;	
+};
+
+typedef gboolean (*GIOFunc) (GIOChannel   *source,
+			     GIOCondition  condition,
+			     gpointer      data);
+struct _GIOFuncs
+{
+  GIOStatus (*io_read)           (GIOChannel   *channel, 
+			          gchar        *buf, 
+				  gsize         count,
+				  gsize        *bytes_read,
+				  GError      **err);
+  GIOStatus (*io_write)          (GIOChannel   *channel, 
+				  const gchar  *buf, 
+				  gsize         count,
+				  gsize        *bytes_written,
+				  GError      **err);
+  GIOStatus (*io_seek)           (GIOChannel   *channel, 
+				  gint64        offset, 
+				  GSeekType     type,
+				  GError      **err);
+  GIOStatus  (*io_close)         (GIOChannel   *channel,
+				  GError      **err);
+  GSource*   (*io_create_watch)  (GIOChannel   *channel,
+				  GIOCondition  condition);
+  void       (*io_free)          (GIOChannel   *channel);
+  GIOStatus  (*io_set_flags)     (GIOChannel   *channel,
+                                  GIOFlags      flags,
+				  GError      **err);
+  GIOFlags   (*io_get_flags)     (GIOChannel   *channel);
+};
+
+void        g_io_channel_init   (GIOChannel    *channel);
+void        g_io_channel_ref    (GIOChannel    *channel);
+void        g_io_channel_unref  (GIOChannel    *channel);
+
+#ifndef G_DISABLE_DEPRECATED
+GIOError    g_io_channel_read   (GIOChannel    *channel, 
+			         gchar         *buf, 
+			         gsize          count,
+			         gsize         *bytes_read);
+GIOError  g_io_channel_write    (GIOChannel    *channel, 
+			         const gchar   *buf, 
+			         gsize          count,
+			         gsize         *bytes_written);
+GIOError  g_io_channel_seek     (GIOChannel    *channel,
+			         gint64         offset, 
+			         GSeekType      type);
+void      g_io_channel_close    (GIOChannel    *channel);
+#endif /* G_DISABLE_DEPRECATED */
+
+GIOStatus g_io_channel_shutdown (GIOChannel      *channel,
+				 gboolean         flush,
+				 GError         **err);
+guint     g_io_add_watch_full   (GIOChannel      *channel,
+				 gint             priority,
+				 GIOCondition     condition,
+				 GIOFunc          func,
+				 gpointer         user_data,
+				 GDestroyNotify   notify);
+GSource * g_io_create_watch     (GIOChannel      *channel,
+				 GIOCondition     condition);
+guint     g_io_add_watch        (GIOChannel      *channel,
+				 GIOCondition     condition,
+				 GIOFunc          func,
+				 gpointer         user_data);
+
+/* character encoding conversion involved functions.
+ */
+
+void                  g_io_channel_set_buffer_size      (GIOChannel   *channel,
+							 gsize         size);
+gsize                 g_io_channel_get_buffer_size      (GIOChannel   *channel);
+GIOCondition          g_io_channel_get_buffer_condition (GIOChannel   *channel);
+GIOStatus             g_io_channel_set_flags            (GIOChannel   *channel,
+							 GIOFlags      flags,
+							 GError      **error);
+GIOFlags              g_io_channel_get_flags            (GIOChannel   *channel);
+void                  g_io_channel_set_line_term        (GIOChannel   *channel,
+							 const gchar  *line_term,
+							 gint          length);
+G_CONST_RETURN gchar* g_io_channel_get_line_term        (GIOChannel   *channel,
+							 gint         *length);
+void		      g_io_channel_set_buffered		(GIOChannel   *channel,
+							 gboolean      buffered);
+gboolean	      g_io_channel_get_buffered		(GIOChannel   *channel);
+GIOStatus             g_io_channel_set_encoding         (GIOChannel   *channel,
+							 const gchar  *encoding,
+							 GError      **error);
+G_CONST_RETURN gchar* g_io_channel_get_encoding         (GIOChannel   *channel);
+void                  g_io_channel_set_close_on_unref	(GIOChannel   *channel,
+							 gboolean      do_close);
+gboolean              g_io_channel_get_close_on_unref	(GIOChannel   *channel);
+
+
+GIOStatus   g_io_channel_flush            (GIOChannel   *channel,
+					   GError      **error);
+GIOStatus   g_io_channel_read_line        (GIOChannel   *channel,
+					   gchar       **str_return,
+					   gsize        *length,
+					   gsize        *terminator_pos,
+					   GError      **error);
+GIOStatus   g_io_channel_read_line_string (GIOChannel   *channel,
+					   GString      *buffer,
+					   gsize        *terminator_pos,
+					   GError      **error);
+GIOStatus   g_io_channel_read_to_end      (GIOChannel   *channel,
+					   gchar       **str_return,
+					   gsize        *length,
+					   GError      **error);
+GIOStatus   g_io_channel_read_chars       (GIOChannel   *channel,
+					   gchar        *buf,
+					   gsize         count,
+					   gsize        *bytes_read,
+					   GError      **error);
+GIOStatus   g_io_channel_read_unichar     (GIOChannel   *channel,
+					   gunichar     *thechar,
+					   GError      **error);
+GIOStatus   g_io_channel_write_chars      (GIOChannel   *channel,
+					   const gchar  *buf,
+					   gssize        count,
+					   gsize        *bytes_written,
+					   GError      **error);
+GIOStatus   g_io_channel_write_unichar    (GIOChannel   *channel,
+					   gunichar      thechar,
+					   GError      **error);
+GIOStatus   g_io_channel_seek_position    (GIOChannel   *channel,
+					   gint64        offset,
+					   GSeekType     type,
+					   GError      **error);
+GIOChannel* g_io_channel_new_file         (const gchar  *filename,
+					   const gchar  *mode,
+					   GError      **error);
+
+/* Error handling */
+
+GQuark          g_io_channel_error_quark      (void);
+GIOChannelError g_io_channel_error_from_errno (gint en);
+
+/* On Unix, IO channels created with this function for any file
+ * descriptor or socket.
+ *
+ * On Win32, this can be used either for files opened with the MSVCRT
+ * (the Microsoft run-time C library) _open() or _pipe, including file
+ * descriptors 0, 1 and 2 (corresponding to stdin, stdout and stderr),
+ * or for Winsock SOCKETs. If the parameter is a legal file
+ * descriptor, it is assumed to be such, otherwise it should be a
+ * SOCKET. This relies on SOCKETs and file descriptors not
+ * overlapping. If you want to be certain, call either
+ * g_io_channel_win32_new_fd() or g_io_channel_win32_new_socket()
+ * instead as appropriate.
+ *
+ * The term file descriptor as used in the context of Win32 refers to
+ * the emulated Unix-like file descriptors MSVCRT provides. The native
+ * corresponding concept is file HANDLE. There isn't as of yet a way to
+ * get GIOChannels for Win32 file HANDLEs.
+ */
+GIOChannel* g_io_channel_unix_new    (int         fd);
+gint        g_io_channel_unix_get_fd (GIOChannel *channel);
+
+
+/* Hook for GClosure / GSource integration. Don't touch */
+GLIB_VAR GSourceFuncs g_io_watch_funcs;
+
+#ifdef G_OS_WIN32
+
+/* You can use this &quot;pseudo file descriptor&quot; in a GPollFD to add
+ * polling for Windows messages. GTK applications should not do that.
+ */
+
+#define G_WIN32_MSG_HANDLE 19981206
+
+/* Use this to get a GPollFD from a GIOChannel, so that you can call
+ * g_io_channel_win32_poll(). After calling this you should only use
+ * g_io_channel_read() to read from the GIOChannel, i.e. never read()
+ * from the underlying file descriptor. For SOCKETs, it is possible to call
+ * recv().
+ */
+void        g_io_channel_win32_make_pollfd (GIOChannel   *channel,
+					    GIOCondition  condition,
+					    GPollFD      *fd);
+
+/* This can be used to wait a until at least one of the channels is readable.
+ * On Unix you would do a select() on the file descriptors of the channels.
+ */
+gint        g_io_channel_win32_poll   (GPollFD    *fds,
+				       gint        n_fds,
+				       gint        timeout_);
+
+/* Create an IO channel for Windows messages for window handle hwnd. */
+GIOChannel *g_io_channel_win32_new_messages (guint hwnd);
+
+/* Create an IO channel for C runtime (emulated Unix-like) file
+ * descriptors. After calling g_io_add_watch() on a IO channel
+ * returned by this function, you shouldn't call read() on the file
+ * descriptor. This is because adding polling for a file descriptor is
+ * implemented on Win32 by starting a thread that sits blocked in a
+ * read() from the file descriptor most of the time. All reads from
+ * the file descriptor should be done by this internal GLib
+ * thread. Your code should call only g_io_channel_read().
+ */
+GIOChannel* g_io_channel_win32_new_fd (gint         fd);
+
+/* Get the C runtime file descriptor of a channel. */
+gint        g_io_channel_win32_get_fd (GIOChannel *channel);
+
+/* Create an IO channel for a winsock socket. The parameter should be
+ * a SOCKET. Contrary to IO channels for file descriptors (on *Win32),
+ * you can use normal recv() or recvfrom() on sockets even if GLib
+ * is polling them.
+ */
+GIOChannel *g_io_channel_win32_new_socket (gint socket);
+
+#endif
+
+G_END_DECLS
+
+#endif /* __G_IOCHANNEL_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/glist.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/glist.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/glist.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,108 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_LIST_H__
+#define __G_LIST_H__
+
+#include &lt;glib/gmem.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GList		GList;
+
+struct _GList
+{
+  gpointer data;
+  GList *next;
+  GList *prev;
+};
+
+/* Doubly linked lists
+ */
+void     g_list_push_allocator (GAllocator       *allocator);
+void     g_list_pop_allocator  (void);
+GList*   g_list_alloc          (void);
+void     g_list_free           (GList            *list);
+void     g_list_free_1         (GList            *list);
+GList*   g_list_append         (GList            *list,
+				gpointer          data);
+GList*   g_list_prepend        (GList            *list,
+				gpointer          data);
+GList*   g_list_insert         (GList            *list,
+				gpointer          data,
+				gint              position);
+GList*   g_list_insert_sorted  (GList            *list,
+				gpointer          data,
+				GCompareFunc      func);
+GList*   g_list_insert_before  (GList            *list,
+				GList            *sibling,
+				gpointer          data);
+GList*   g_list_concat         (GList            *list1,
+				GList            *list2);
+GList*   g_list_remove         (GList            *list,
+				gconstpointer     data);
+GList*   g_list_remove_all     (GList            *list,
+				gconstpointer     data);
+GList*   g_list_remove_link    (GList            *list,
+				GList            *llink);
+GList*   g_list_delete_link    (GList            *list,
+				GList            *link_);
+GList*   g_list_reverse        (GList            *list);
+GList*   g_list_copy           (GList            *list);
+GList*   g_list_nth            (GList            *list,
+				guint             n);
+GList*   g_list_nth_prev       (GList            *list,
+				guint             n);
+GList*   g_list_find           (GList            *list,
+				gconstpointer     data);
+GList*   g_list_find_custom    (GList            *list,
+				gconstpointer     data,
+				GCompareFunc      func);
+gint     g_list_position       (GList            *list,
+				GList            *llink);
+gint     g_list_index          (GList            *list,
+				gconstpointer     data);
+GList*   g_list_last           (GList            *list);
+GList*   g_list_first          (GList            *list);
+guint    g_list_length         (GList            *list);
+void     g_list_foreach        (GList            *list,
+				GFunc             func,
+				gpointer          user_data);
+GList*   g_list_sort           (GList            *list,
+				GCompareFunc      compare_func);
+GList*   g_list_sort_with_data (GList            *list,
+				GCompareDataFunc  compare_func,
+				gpointer          user_data);
+gpointer g_list_nth_data       (GList            *list,
+				guint             n);
+
+#define g_list_previous(list)	((list) ? (((GList *)(list))-&gt;prev) : NULL)
+#define g_list_next(list)	((list) ? (((GList *)(list))-&gt;next) : NULL)
+
+G_END_DECLS
+
+#endif /* __G_LIST_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmacros.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmacros.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmacros.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,242 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+/* This file must not include any other glib header file and must thus
+ * not refer to variables from glibconfig.h 
+ */
+
+#ifndef __G_MACROS_H__
+#define __G_MACROS_H__
+
+/* We include stddef.h to get the system's definition of NULL
+ */
+#include &lt;stddef.h&gt;
+
+/* Here we provide G_GNUC_EXTENSION as an alias for __extension__,
+ * where this is valid. This allows for warningless compilation of
+ * &quot;long long&quot; types even in the presence of '-ansi -pedantic'. 
+ */
+#if     __GNUC__ &gt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt;= 8)
+#  define G_GNUC_EXTENSION __extension__
+#else
+#  define G_GNUC_EXTENSION
+#endif
+
+/* Provide macros to feature the GCC function attribute.
+ */
+#if    __GNUC__ &gt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt;= 96)
+#define G_GNUC_PURE                            \
+  __attribute__((__pure__))
+#else
+#define G_GNUC_PURE
+#endif
+
+#if     __GNUC__ &gt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt; 4)
+#define G_GNUC_PRINTF( format_idx, arg_idx )    \
+  __attribute__((__format__ (__printf__, format_idx, arg_idx)))
+#define G_GNUC_SCANF( format_idx, arg_idx )     \
+  __attribute__((__format__ (__scanf__, format_idx, arg_idx)))
+#define G_GNUC_FORMAT( arg_idx )                \
+  __attribute__((__format_arg__ (arg_idx)))
+#define G_GNUC_NORETURN                         \
+  __attribute__((__noreturn__))
+#define G_GNUC_CONST                            \
+  __attribute__((__const__))
+#define G_GNUC_UNUSED                           \
+  __attribute__((__unused__))
+#define G_GNUC_NO_INSTRUMENT			\
+  __attribute__((__no_instrument_function__))
+#else   /* !__GNUC__ */
+#define G_GNUC_PRINTF( format_idx, arg_idx )
+#define G_GNUC_SCANF( format_idx, arg_idx )
+#define G_GNUC_FORMAT( arg_idx )
+#define G_GNUC_NORETURN
+#define G_GNUC_CONST
+#define G_GNUC_UNUSED
+#define G_GNUC_NO_INSTRUMENT
+#endif  /* !__GNUC__ */
+
+#if    __GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 1)
+#define G_GNUC_DEPRECATED                            \
+  __attribute__((__deprecated__))
+#else
+#define G_GNUC_DEPRECATED
+#endif /* __GNUC__ */
+
+/* Wrap the gcc __PRETTY_FUNCTION__ and __FUNCTION__ variables with
+ * macros, so we can refer to them as strings unconditionally.
+ * usage not-recommended since gcc-3.0
+ */
+#if defined (__GNUC__) &amp;&amp; (__GNUC__ &lt; 3)
+#define G_GNUC_FUNCTION         __FUNCTION__
+#define G_GNUC_PRETTY_FUNCTION  __PRETTY_FUNCTION__
+#else   /* !__GNUC__ */
+#define G_GNUC_FUNCTION         &quot;&quot;
+#define G_GNUC_PRETTY_FUNCTION  &quot;&quot;
+#endif  /* !__GNUC__ */
+
+#define G_STRINGIFY(macro_or_string)	G_STRINGIFY_ARG (macro_or_string)
+#define	G_STRINGIFY_ARG(contents)	#contents
+
+/* Provide a string identifying the current code position */
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3) &amp;&amp; !defined(__cplusplus)
+#  define G_STRLOC	__FILE__ &quot;:&quot; G_STRINGIFY (__LINE__) &quot;:&quot; __PRETTY_FUNCTION__ &quot;()&quot;
+#else
+#  define G_STRLOC	__FILE__ &quot;:&quot; G_STRINGIFY (__LINE__)
+#endif
+
+/* Provide a string identifying the current function, non-concatenatable */
+#if defined (__GNUC__)
+#  define G_STRFUNC     ((const char*) (__PRETTY_FUNCTION__))
+#elif defined (G_HAVE_ISO_VARARGS)
+#  define G_STRFUNC     ((const char*) (__func__))
+#else
+#  define G_STRFUNC     ((const char*) (&quot;???&quot;))
+#endif
+
+/* Guard C code in headers, while including them from C++ */
+#ifdef  __cplusplus
+# define G_BEGIN_DECLS  extern &quot;C&quot; {
+# define G_END_DECLS    }
+#else
+# define G_BEGIN_DECLS
+# define G_END_DECLS
+#endif
+
+/* Provide definitions for some commonly used macros.
+ *  Some of them are only provided if they haven't already
+ *  been defined. It is assumed that if they are already
+ *  defined then the current definition is correct.
+ */
+#ifndef NULL
+#  ifdef __cplusplus
+#    define NULL        (0L)
+#  else /* !__cplusplus */
+#    define NULL        ((void*) 0)
+#  endif /* !__cplusplus */
+#endif
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+#undef	MAX
+#define MAX(a, b)  (((a) &gt; (b)) ? (a) : (b))
+
+#undef	MIN
+#define MIN(a, b)  (((a) &lt; (b)) ? (a) : (b))
+
+#undef	ABS
+#define ABS(a)	   (((a) &lt; 0) ? -(a) : (a))
+
+#undef	CLAMP
+#define CLAMP(x, low, high)  (((x) &gt; (high)) ? (high) : (((x) &lt; (low)) ? (low) : (x)))
+
+/* Count the number of elements in an array. The array must be defined
+ * as such; using this with a dynamically allocated array will give
+ * incorrect results.
+ */
+#define G_N_ELEMENTS(arr)		(sizeof (arr) / sizeof ((arr)[0]))
+
+/* Macros by analogy to GINT_TO_POINTER, GPOINTER_TO_INT
+ */
+#define GPOINTER_TO_SIZE(p)	((gsize) (p))
+#define GSIZE_TO_POINTER(s)	((gpointer) (gsize) (s))
+
+/* Provide convenience macros for handling structure
+ * fields through their offsets.
+ */
+#define G_STRUCT_OFFSET(struct_type, member)	\
+    ((glong) ((guint8*) &amp;((struct_type*) 0)-&gt;member))
+#define G_STRUCT_MEMBER_P(struct_p, struct_offset)   \
+    ((gpointer) ((guint8*) (struct_p) + (glong) (struct_offset)))
+#define G_STRUCT_MEMBER(member_type, struct_p, struct_offset)   \
+    (*(member_type*) G_STRUCT_MEMBER_P ((struct_p), (struct_offset)))
+
+/* Provide simple macro statement wrappers (adapted from Perl):
+ *  G_STMT_START { statements; } G_STMT_END;
+ *  can be used as a single statement, as in
+ *  if (x) G_STMT_START { ... } G_STMT_END; else ...
+ *
+ *  For gcc we will wrap the statements within `({' and `})' braces.
+ *  For SunOS they will be wrapped within `if (1)' and `else (void) 0',
+ *  and otherwise within `do' and `while (0)'.
+ */
+#if !(defined (G_STMT_START) &amp;&amp; defined (G_STMT_END))
+#  if defined (__GNUC__) &amp;&amp; !defined (__STRICT_ANSI__) &amp;&amp; !defined (__cplusplus)
+#    define G_STMT_START	(void) __extension__ (
+#    define G_STMT_END		)
+#  else
+#    if (defined (sun) || defined (__sun__))
+#      define G_STMT_START	if (1)
+#      define G_STMT_END	else (void)0
+#    else
+#      define G_STMT_START	do
+#      define G_STMT_END	while (0)
+#    endif
+#  endif
+#endif
+
+/* Allow the app programmer to select whether or not return values
+ * (usually char*) are const or not.  Don't try using this feature for
+ * functions with C++ linkage.
+ */
+#ifdef G_DISABLE_CONST_RETURNS
+#define G_CONST_RETURN
+#else
+#define G_CONST_RETURN const
+#endif
+
+/*
+ * The G_LIKELY and G_UNLIKELY macros let the programmer give hints to 
+ * the compiler about the expected result of an expression. Some compilers
+ * can use this information for optimizations.
+ *
+ * The _G_BOOLEAN_EXPR macro is intended to trigger a gcc warning when
+ * putting assignments in g_return_if_fail ().  
+ */
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 2) &amp;&amp; defined(__OPTIMIZE__)
+#define _G_BOOLEAN_EXPR(expr)                   \
+ __extension__ ({                               \
+   int _g_boolean_var_;                         \
+   if (expr)                                    \
+      _g_boolean_var_ = 1;                      \
+   else                                         \
+      _g_boolean_var_ = 0;                      \
+   _g_boolean_var_;                             \
+})
+#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))
+#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))
+#else
+#define G_LIKELY(expr) (expr)
+#define G_UNLIKELY(expr) (expr)
+#endif
+
+#endif /* __G_MACROS_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmain.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmain.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmain.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,318 @@
+/* gmain.h - the GLib Main loop
+ * Copyright (C) 1998-2000 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_MAIN_H__
+#define __G_MAIN_H__
+
+#include &lt;glib/gslist.h&gt;
+#include &lt;glib/gthread.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GMainContext	        GMainContext;	/* Opaque */
+typedef struct _GMainLoop	        GMainLoop;	/* Opaque */
+typedef struct _GSource	                GSource;
+typedef struct _GSourceCallbackFuncs	GSourceCallbackFuncs;
+typedef struct _GSourceFuncs	        GSourceFuncs;
+
+typedef gboolean (*GSourceFunc)       (gpointer data);
+typedef void     (*GChildWatchFunc)   (GPid     pid,
+				       gint     status,
+				       gpointer data);
+struct _GSource
+{
+  /*&lt; private &gt;*/
+  gpointer callback_data;
+  GSourceCallbackFuncs *callback_funcs;
+
+  GSourceFuncs *source_funcs;
+  guint ref_count;
+
+  GMainContext *context;
+
+  gint priority;
+  guint flags;
+  guint source_id;
+
+  GSList *poll_fds;
+  
+  GSource *prev;
+  GSource *next;
+
+  gpointer reserved1;
+  gpointer reserved2;
+};
+
+struct _GSourceCallbackFuncs
+{
+  void (*ref)   (gpointer     cb_data);
+  void (*unref) (gpointer     cb_data);
+  void (*get)   (gpointer     cb_data,
+		 GSource     *source, 
+		 GSourceFunc *func,
+		 gpointer    *data);
+};
+
+typedef void (*GSourceDummyMarshal) (void);
+
+struct _GSourceFuncs
+{
+  gboolean (*prepare)  (GSource    *source,
+			gint       *timeout_);
+  gboolean (*check)    (GSource    *source);
+  gboolean (*dispatch) (GSource    *source,
+			GSourceFunc callback,
+			gpointer    user_data);
+  void     (*finalize) (GSource    *source); /* Can be NULL */
+
+  /* For use by g_source_set_closure */
+  GSourceFunc     closure_callback;	   
+  GSourceDummyMarshal closure_marshal; /* Really is of type GClosureMarshal */
+};
+
+/* Any definitions using GPollFD or GPollFunc are primarily
+ * for Unix and not guaranteed to be the compatible on all
+ * operating systems on which GLib runs. Right now, the
+ * GLib does use these functions on Win32 as well, but interprets
+ * them in a fairly different way than on Unix. If you use
+ * these definitions, you are should be prepared to recode
+ * for different operating systems.
+ *
+ *
+ * On Win32, the fd in a GPollFD should be Win32 HANDLE (*not* a file
+ * descriptor as provided by the C runtime) that can be used by
+ * MsgWaitForMultipleObjects. This does *not* include file handles
+ * from CreateFile, SOCKETs, nor pipe handles. (But you can use
+ * WSAEventSelect to signal events when a SOCKET is readable).
+ *
+ * On Win32, fd can also be the special value G_WIN32_MSG_HANDLE to
+ * indicate polling for messages.
+ *
+ * But note that G_WIN32_MSG_HANDLE GPollFDs should not be used by GDK
+ * (GTK) programs, as GDK itself wants to read messages and convert them
+ * to GDK events.
+ *
+ * So, unless you really know what you are doing, it's best not to try
+ * to use the main loop polling stuff for your own needs on
+ * Win32. It's really only written for the GIMP's needs so
+ * far.
+ */
+typedef struct _GPollFD GPollFD;
+typedef gint	(*GPollFunc)	(GPollFD *ufds,
+				 guint	  nfsd,
+				 gint     timeout_);
+
+struct _GPollFD
+{
+  gint		fd;
+  gushort 	events;
+  gushort 	revents;
+};
+
+/* Standard priorities */
+
+#define G_PRIORITY_HIGH            -100
+#define G_PRIORITY_DEFAULT          0
+#define G_PRIORITY_HIGH_IDLE        100
+#define G_PRIORITY_DEFAULT_IDLE     200
+#define G_PRIORITY_LOW	            300
+
+/* GMainContext: */
+
+GMainContext *g_main_context_new       (void);
+void          g_main_context_ref       (GMainContext *context);
+void          g_main_context_unref     (GMainContext *context);
+GMainContext *g_main_context_default   (void);
+
+gboolean      g_main_context_iteration (GMainContext *context,
+					gboolean      may_block);
+gboolean      g_main_context_pending   (GMainContext *context);
+
+/* For implementation of legacy interfaces
+ */
+GSource      *g_main_context_find_source_by_id              (GMainContext *context,
+							     guint         source_id);
+GSource      *g_main_context_find_source_by_user_data       (GMainContext *context,
+							     gpointer      user_data);
+GSource      *g_main_context_find_source_by_funcs_user_data (GMainContext *context,
+ 							     GSourceFuncs *funcs,
+							     gpointer      user_data);
+
+/* Low level functions for implementing custom main loops.
+ */
+void     g_main_context_wakeup  (GMainContext *context);
+gboolean g_main_context_acquire (GMainContext *context);
+void     g_main_context_release (GMainContext *context);
+gboolean g_main_context_wait    (GMainContext *context,
+				 GCond        *cond,
+				 GMutex       *mutex);
+
+gboolean g_main_context_prepare  (GMainContext *context,
+				  gint         *priority);
+gint     g_main_context_query    (GMainContext *context,
+				  gint          max_priority,
+				  gint         *timeout_,
+				  GPollFD      *fds,
+				  gint          n_fds);
+gint     g_main_context_check    (GMainContext *context,
+				  gint          max_priority,
+				  GPollFD      *fds,
+				  gint          n_fds);
+void     g_main_context_dispatch (GMainContext *context);
+
+void      g_main_context_set_poll_func (GMainContext *context,
+					GPollFunc     func);
+GPollFunc g_main_context_get_poll_func (GMainContext *context);
+
+/* Low level functions for use by source implementations
+ */
+void g_main_context_add_poll      (GMainContext *context,
+				   GPollFD      *fd,
+				   gint          priority);
+void g_main_context_remove_poll   (GMainContext *context,
+				   GPollFD      *fd);
+
+int g_main_depth (void);
+
+/* GMainLoop: */
+
+GMainLoop *g_main_loop_new        (GMainContext *context,
+			    	   gboolean      is_running);
+void       g_main_loop_run        (GMainLoop    *loop);
+void       g_main_loop_quit       (GMainLoop    *loop);
+GMainLoop *g_main_loop_ref        (GMainLoop    *loop);
+void       g_main_loop_unref      (GMainLoop    *loop);
+gboolean   g_main_loop_is_running (GMainLoop    *loop);
+GMainContext *g_main_loop_get_context (GMainLoop    *loop);
+
+/* GSource: */
+
+GSource *g_source_new             (GSourceFuncs   *source_funcs,
+				   guint           struct_size);
+GSource *g_source_ref             (GSource        *source);
+void     g_source_unref           (GSource        *source);
+
+guint    g_source_attach          (GSource        *source,
+				   GMainContext   *context);
+void     g_source_destroy         (GSource        *source);
+
+void     g_source_set_priority    (GSource        *source,
+				   gint            priority);
+gint     g_source_get_priority    (GSource        *source);
+void     g_source_set_can_recurse (GSource        *source,
+				   gboolean        can_recurse);
+gboolean g_source_get_can_recurse (GSource        *source);
+guint    g_source_get_id          (GSource        *source);
+
+GMainContext *g_source_get_context (GSource       *source);
+
+void g_source_set_callback          (GSource              *source,
+				     GSourceFunc           func,
+				     gpointer              data,
+				     GDestroyNotify        notify);
+
+
+/* Used to implement g_source_connect_closure and internally*/
+void g_source_set_callback_indirect (GSource              *source,
+				     gpointer              callback_data,
+				     GSourceCallbackFuncs *callback_funcs);
+
+void     g_source_add_poll         (GSource        *source,
+				    GPollFD        *fd);
+void     g_source_remove_poll      (GSource        *source,
+				    GPollFD        *fd);
+
+void     g_source_get_current_time (GSource        *source,
+				    GTimeVal       *timeval);
+
+ /* void g_source_connect_closure (GSource        *source,
+                                  GClosure       *closure);
+ */
+
+/* Specific source types
+ */
+GSource *g_idle_source_new        (void);
+GSource *g_child_watch_source_new (GPid pid);
+GSource *g_timeout_source_new     (guint interval);
+
+/* Miscellaneous functions
+ */
+void g_get_current_time		        (GTimeVal	*result);
+
+/* ============== Compat main loop stuff ================== */
+
+#ifndef G_DISABLE_DEPRECATED
+
+/* Legacy names for GMainLoop functions
+ */
+#define 	g_main_new(is_running)	g_main_loop_new (NULL, is_running);
+#define         g_main_run(loop)        g_main_loop_run(loop)
+#define         g_main_quit(loop)       g_main_loop_quit(loop)
+#define         g_main_destroy(loop)    g_main_loop_unref(loop)
+#define         g_main_is_running(loop) g_main_loop_is_running(loop)
+
+/* Functions to manipulate the default main loop
+ */
+
+#define	g_main_iteration(may_block) g_main_context_iteration      (NULL, may_block)
+#define g_main_pending()            g_main_context_pending        (NULL)
+
+#define g_main_set_poll_func(func)   g_main_context_set_poll_func (NULL, func)
+
+#endif /* G_DISABLE_DEPRECATED */
+
+/* Source manipulation by ID */
+gboolean g_source_remove                     (guint          tag);
+gboolean g_source_remove_by_user_data        (gpointer       user_data);
+gboolean g_source_remove_by_funcs_user_data  (GSourceFuncs  *funcs,
+					      gpointer       user_data);
+
+/* Idles, child watchers and timeouts */
+guint    g_timeout_add_full     (gint            priority,
+				 guint           interval,
+				 GSourceFunc     function,
+				 gpointer        data,
+				 GDestroyNotify  notify);
+guint    g_timeout_add          (guint           interval,
+				 GSourceFunc     function,
+				 gpointer        data);
+guint    g_child_watch_add_full (gint            priority,
+				 GPid            pid,
+				 GChildWatchFunc function,
+				 gpointer        data,
+				 GDestroyNotify  notify);
+guint    g_child_watch_add      (GPid            pid,
+				 GChildWatchFunc function,
+				 gpointer        data);
+guint    g_idle_add             (GSourceFunc     function,
+				 gpointer        data);
+guint    g_idle_add_full        (gint            priority,
+				 GSourceFunc     function,
+				 gpointer        data,
+				 GDestroyNotify  notify);
+gboolean g_idle_remove_by_data  (gpointer        data);
+
+/* Hook for GClosure / GSource integration. Don't touch */
+GLIB_VAR GSourceFuncs g_timeout_funcs;
+GLIB_VAR GSourceFuncs g_child_watch_funcs;
+GLIB_VAR GSourceFuncs g_idle_funcs;
+
+G_END_DECLS
+
+#endif /* __G_MAIN_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmarkup.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmarkup.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmarkup.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,131 @@
+/* gmarkup.h - Simple XML-like string parser/writer
+ *
+ *  Copyright 2000 Red Hat, Inc.
+ *
+ * GLib is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * GLib is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with GLib; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *   Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_MARKUP_H__
+#define __G_MARKUP_H__
+
+#include &lt;stdarg.h&gt;
+
+#include &lt;glib/gerror.h&gt;
+
+G_BEGIN_DECLS
+
+typedef enum
+{
+  G_MARKUP_ERROR_BAD_UTF8,
+  G_MARKUP_ERROR_EMPTY,
+  G_MARKUP_ERROR_PARSE,
+  /* These three are primarily intended for specific GMarkupParser
+   * implementations to set.
+   */
+  G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+  G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
+  G_MARKUP_ERROR_INVALID_CONTENT
+} GMarkupError;
+
+#define G_MARKUP_ERROR g_markup_error_quark ()
+
+GQuark g_markup_error_quark (void);
+
+typedef enum
+{
+  /* Hmm, can't think of any at the moment */
+  G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 &lt;&lt; 0
+  
+} GMarkupParseFlags;
+
+typedef struct _GMarkupParseContext GMarkupParseContext;
+typedef struct _GMarkupParser GMarkupParser;
+
+struct _GMarkupParser
+{
+  /* Called for open tags &lt;foo bar=&quot;baz&quot;&gt; */
+  void (*start_element)  (GMarkupParseContext *context,
+                          const gchar         *element_name,
+                          const gchar        **attribute_names,
+                          const gchar        **attribute_values,
+                          gpointer             user_data,
+                          GError             **error);
+
+  /* Called for close tags &lt;/foo&gt; */
+  void (*end_element)    (GMarkupParseContext *context,
+                          const gchar         *element_name,
+                          gpointer             user_data,
+                          GError             **error);
+
+  /* Called for character data */
+  /* text is not nul-terminated */
+  void (*text)           (GMarkupParseContext *context,
+                          const gchar         *text,
+                          gsize                text_len,  
+                          gpointer             user_data,
+                          GError             **error);
+
+  /* Called for strings that should be re-saved verbatim in this same
+   * position, but are not otherwise interpretable.  At the moment
+   * this includes comments and processing instructions.
+   */
+  /* text is not nul-terminated. */
+  void (*passthrough)    (GMarkupParseContext *context,
+                          const gchar         *passthrough_text,
+                          gsize                text_len,  
+                          gpointer             user_data,
+                          GError             **error);
+
+  /* Called on error, including one set by other
+   * methods in the vtable. The GError should not be freed.
+   */
+  void (*error)          (GMarkupParseContext *context,
+                          GError              *error,
+                          gpointer             user_data);
+};
+
+GMarkupParseContext *g_markup_parse_context_new   (const GMarkupParser *parser,
+                                                   GMarkupParseFlags    flags,
+                                                   gpointer             user_data,
+                                                   GDestroyNotify       user_data_dnotify);
+void                 g_markup_parse_context_free  (GMarkupParseContext *context);
+gboolean             g_markup_parse_context_parse (GMarkupParseContext *context,
+                                                   const gchar         *text,
+                                                   gssize               text_len,  
+                                                   GError             **error);
+                                                   
+gboolean             g_markup_parse_context_end_parse (GMarkupParseContext *context,
+                                                       GError             **error);
+G_CONST_RETURN gchar *g_markup_parse_context_get_element (GMarkupParseContext *context);
+
+/* For user-constructed error messages, has no precise semantics */
+void                 g_markup_parse_context_get_position (GMarkupParseContext *context,
+                                                          gint                *line_number,
+                                                          gint                *char_number);
+
+/* useful when saving */
+gchar* g_markup_escape_text (const gchar *text,
+                             gssize       length);  
+
+gchar *g_markup_printf_escaped (const char *format,
+				...) G_GNUC_PRINTF (1, 2);
+gchar *g_markup_vprintf_escaped (const char *format,
+				 va_list     args);
+
+G_END_DECLS
+
+#endif /* __G_MARKUP_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmem.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmem.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmem.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,174 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_MEM_H__
+#define __G_MEM_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GAllocator GAllocator;
+typedef struct _GMemChunk  GMemChunk;
+typedef struct _GMemVTable GMemVTable;
+
+
+#if GLIB_SIZEOF_VOID_P &gt; GLIB_SIZEOF_LONG
+#  define G_MEM_ALIGN	GLIB_SIZEOF_VOID_P
+#else	/* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
+#  define G_MEM_ALIGN	GLIB_SIZEOF_LONG
+#endif	/* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
+
+
+/* Memory allocation functions
+ */
+gpointer g_malloc         (gulong	 n_bytes);
+gpointer g_malloc0        (gulong	 n_bytes);
+gpointer g_realloc        (gpointer	 mem,
+			   gulong	 n_bytes);
+void	 g_free	          (gpointer	 mem);
+gpointer g_try_malloc     (gulong	 n_bytes);
+gpointer g_try_realloc    (gpointer	 mem,
+			   gulong	 n_bytes);
+
+
+/* Convenience memory allocators
+ */
+#define g_new(struct_type, n_structs)		\
+    ((struct_type *) g_malloc (((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))
+#define g_new0(struct_type, n_structs)		\
+    ((struct_type *) g_malloc0 (((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))
+#define g_renew(struct_type, mem, n_structs)	\
+    ((struct_type *) g_realloc ((mem), ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))
+
+
+/* Memory allocation virtualization for debugging purposes
+ * g_mem_set_vtable() has to be the very first GLib function called
+ * if being used
+ */
+struct _GMemVTable
+{
+  gpointer (*malloc)      (gsize    n_bytes);
+  gpointer (*realloc)     (gpointer mem,
+			   gsize    n_bytes);
+  void     (*free)        (gpointer mem);
+  /* optional; set to NULL if not used ! */
+  gpointer (*calloc)      (gsize    n_blocks,
+			   gsize    n_block_bytes);
+  gpointer (*try_malloc)  (gsize    n_bytes);
+  gpointer (*try_realloc) (gpointer mem,
+			   gsize    n_bytes);
+};
+void	 g_mem_set_vtable (GMemVTable	*vtable);
+gboolean g_mem_is_system_malloc (void);
+
+/* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
+ */
+GLIB_VAR GMemVTable	*glib_mem_profiler_table;
+void	g_mem_profile	(void);
+
+
+/* Memchunk convenience functions
+ */
+#define g_mem_chunk_create(type, pre_alloc, alloc_type)	( \
+  g_mem_chunk_new (#type &quot; mem chunks (&quot; #pre_alloc &quot;)&quot;, \
+		   sizeof (type), \
+		   sizeof (type) * (pre_alloc), \
+		   (alloc_type)) \
+)
+#define g_chunk_new(type, chunk)	( \
+  (type *) g_mem_chunk_alloc (chunk) \
+)
+#define g_chunk_new0(type, chunk)	( \
+  (type *) g_mem_chunk_alloc0 (chunk) \
+)
+#define g_chunk_free(mem, mem_chunk)	G_STMT_START { \
+  g_mem_chunk_free ((mem_chunk), (mem)); \
+} G_STMT_END
+
+
+/* &quot;g_mem_chunk_new&quot; creates a new memory chunk.
+ * Memory chunks are used to allocate pieces of memory which are
+ *  always the same size. Lists are a good example of such a data type.
+ * The memory chunk allocates and frees blocks of memory as needed.
+ *  Just be sure to call &quot;g_mem_chunk_free&quot; and not &quot;g_free&quot; on data
+ *  allocated in a mem chunk. (&quot;g_free&quot; will most likely cause a seg
+ *  fault...somewhere).
+ *
+ * Oh yeah, GMemChunk is an opaque data type. (You don't really
+ *  want to know what's going on inside do you?)
+ */
+
+/* ALLOC_ONLY MemChunks can only allocate memory. The free operation
+ *  is interpreted as a no op. ALLOC_ONLY MemChunks save 4 bytes per
+ *  atom. (They are also useful for lists which use MemChunk to allocate
+ *  memory but are also part of the MemChunk implementation).
+ * ALLOC_AND_FREE MemChunks can allocate and free memory.
+ */
+
+#define G_ALLOC_ONLY	  1
+#define G_ALLOC_AND_FREE  2
+
+GMemChunk* g_mem_chunk_new     (const gchar *name,
+				gint         atom_size,
+				gulong       area_size,
+				gint         type);
+void       g_mem_chunk_destroy (GMemChunk   *mem_chunk);
+gpointer   g_mem_chunk_alloc   (GMemChunk   *mem_chunk);
+gpointer   g_mem_chunk_alloc0  (GMemChunk   *mem_chunk);
+void       g_mem_chunk_free    (GMemChunk   *mem_chunk,
+				gpointer     mem);
+void       g_mem_chunk_clean   (GMemChunk   *mem_chunk);
+void       g_mem_chunk_reset   (GMemChunk   *mem_chunk);
+void       g_mem_chunk_print   (GMemChunk   *mem_chunk);
+void       g_mem_chunk_info    (void);
+
+/* Ah yes...we have a &quot;g_blow_chunks&quot; function.
+ * &quot;g_blow_chunks&quot; simply compresses all the chunks. This operation
+ *  consists of freeing every memory area that should be freed (but
+ *  which we haven't gotten around to doing yet). And, no,
+ *  &quot;g_blow_chunks&quot; doesn't follow the naming scheme, but it is a
+ *  much better name than &quot;g_mem_chunk_clean_all&quot; or something
+ *  similar.
+ */
+void	   g_blow_chunks (void);
+
+
+/* Generic allocators
+ */
+GAllocator* g_allocator_new   (const gchar  *name,
+			       guint         n_preallocs);
+void        g_allocator_free  (GAllocator   *allocator);
+
+/* internal */
+#define	G_ALLOCATOR_LIST	(1)
+#define	G_ALLOCATOR_SLIST	(2)
+#define	G_ALLOCATOR_NODE	(3)
+
+
+G_END_DECLS
+
+#endif /* __G_MEM_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmessages.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmessages.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gmessages.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,348 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_MESSAGES_H__
+#define __G_MESSAGES_H__
+
+#include &lt;stdarg.h&gt;
+#include &lt;glib/gtypes.h&gt;
+#include &lt;glib/gmacros.h&gt;
+
+/* Suppress warnings when GCC is in -pedantic mode and not -std=c99
+ */
+#if (__GNUC__ &gt;= 3 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt;= 96))
+#pragma GCC system_header
+#endif
+
+G_BEGIN_DECLS
+
+/* calculate a string size, guaranteed to fit format + args.
+ */
+gsize	g_printf_string_upper_bound (const gchar* format,
+				     va_list	  args);
+
+/* Log level shift offset for user defined
+ * log levels (0-7 are used by GLib).
+ */
+#define G_LOG_LEVEL_USER_SHIFT  (8)
+
+/* Glib log levels and flags.
+ */
+typedef enum
+{
+  /* log flags */
+  G_LOG_FLAG_RECURSION          = 1 &lt;&lt; 0,
+  G_LOG_FLAG_FATAL              = 1 &lt;&lt; 1,
+
+  /* GLib log levels */
+  G_LOG_LEVEL_ERROR             = 1 &lt;&lt; 2,       /* always fatal */
+  G_LOG_LEVEL_CRITICAL          = 1 &lt;&lt; 3,
+  G_LOG_LEVEL_WARNING           = 1 &lt;&lt; 4,
+  G_LOG_LEVEL_MESSAGE           = 1 &lt;&lt; 5,
+  G_LOG_LEVEL_INFO              = 1 &lt;&lt; 6,
+  G_LOG_LEVEL_DEBUG             = 1 &lt;&lt; 7,
+
+  G_LOG_LEVEL_MASK              = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
+} GLogLevelFlags;
+
+/* GLib log levels that are considered fatal by default */
+#define G_LOG_FATAL_MASK        (G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR)
+
+typedef void            (*GLogFunc)             (const gchar   *log_domain,
+                                                 GLogLevelFlags log_level,
+                                                 const gchar   *message,
+                                                 gpointer       user_data);
+
+/* Logging mechanism
+ */
+guint           g_log_set_handler       (const gchar    *log_domain,
+                                         GLogLevelFlags  log_levels,
+                                         GLogFunc        log_func,
+                                         gpointer        user_data);
+void            g_log_remove_handler    (const gchar    *log_domain,
+                                         guint           handler_id);
+void            g_log_default_handler   (const gchar    *log_domain,
+                                         GLogLevelFlags  log_level,
+                                         const gchar    *message,
+                                         gpointer        unused_data);
+void            g_log                   (const gchar    *log_domain,
+                                         GLogLevelFlags  log_level,
+                                         const gchar    *format,
+                                         ...) G_GNUC_PRINTF (3, 4);
+void            g_logv                  (const gchar    *log_domain,
+                                         GLogLevelFlags  log_level,
+                                         const gchar    *format,
+                                         va_list         args);
+GLogLevelFlags  g_log_set_fatal_mask    (const gchar    *log_domain,
+                                         GLogLevelFlags  fatal_mask);
+GLogLevelFlags  g_log_set_always_fatal  (GLogLevelFlags  fatal_mask);
+
+/* internal */
+void	_g_log_fallback_handler	(const gchar   *log_domain,
+				 GLogLevelFlags log_level,
+				 const gchar   *message,
+				 gpointer       unused_data);
+
+
+#ifndef G_LOG_DOMAIN
+#define G_LOG_DOMAIN    ((gchar*) 0)
+#endif  /* G_LOG_DOMAIN */
+#ifdef G_HAVE_ISO_VARARGS
+#define g_error(...)    g_log (G_LOG_DOMAIN,         \
+                               G_LOG_LEVEL_ERROR,    \
+                               __VA_ARGS__)
+#define g_message(...)  g_log (G_LOG_DOMAIN,         \
+                               G_LOG_LEVEL_MESSAGE,  \
+                               __VA_ARGS__)
+#define g_critical(...) g_log (G_LOG_DOMAIN,         \
+                               G_LOG_LEVEL_CRITICAL, \
+                               __VA_ARGS__)
+#define g_warning(...)  g_log (G_LOG_DOMAIN,         \
+                               G_LOG_LEVEL_WARNING,  \
+                               __VA_ARGS__)
+#elif defined(G_HAVE_GNUC_VARARGS)
+#define g_error(format...)      g_log (G_LOG_DOMAIN,         \
+                                       G_LOG_LEVEL_ERROR,    \
+                                       format)
+#define g_message(format...)    g_log (G_LOG_DOMAIN,         \
+                                       G_LOG_LEVEL_MESSAGE,  \
+                                       format)
+#define g_critical(format...)   g_log (G_LOG_DOMAIN,         \
+                                       G_LOG_LEVEL_CRITICAL, \
+                                       format)
+#define g_warning(format...)    g_log (G_LOG_DOMAIN,         \
+                                       G_LOG_LEVEL_WARNING,  \
+                                       format)
+#else   /* no varargs macros */
+static void
+g_error (const gchar *format,
+         ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format, args);
+  va_end (args);
+}
+static void
+g_message (const gchar *format,
+           ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, format, args);
+  va_end (args);
+}
+static void
+g_critical (const gchar *format,
+            ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, format, args);
+  va_end (args);
+}
+static void
+g_warning (const gchar *format,
+           ...)
+{
+  va_list args;
+  va_start (args, format);
+  g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, format, args);
+  va_end (args);
+}
+#endif  /* !__GNUC__ */
+
+typedef void    (*GPrintFunc)           (const gchar    *string);
+void            g_print                 (const gchar    *format,
+                                         ...) G_GNUC_PRINTF (1, 2);
+GPrintFunc      g_set_print_handler     (GPrintFunc      func);
+void            g_printerr              (const gchar    *format,
+                                         ...) G_GNUC_PRINTF (1, 2);
+GPrintFunc      g_set_printerr_handler  (GPrintFunc      func);
+
+
+/* Provide macros for error handling. The &quot;assert&quot; macros will
+ *  exit on failure. The &quot;return&quot; macros will exit the current
+ *  function. Two different definitions are given for the macros
+ *  if G_DISABLE_ASSERT is not defined, in order to support gcc's
+ *  __PRETTY_FUNCTION__ capability.
+ */
+
+#ifdef G_DISABLE_ASSERT
+
+#define g_assert(expr)		G_STMT_START{ (void)0; }G_STMT_END
+#define g_assert_not_reached()	G_STMT_START{ (void)0; }G_STMT_END
+
+#else /* !G_DISABLE_ASSERT */
+
+#ifdef __GNUC__
+
+#define g_assert(expr)			G_STMT_START{		\
+     if G_LIKELY(expr) { } else 				\
+        g_log (G_LOG_DOMAIN,					\
+	      G_LOG_LEVEL_ERROR,				\
+	      &quot;file %s: line %d (%s): assertion failed: (%s)&quot;,	\
+	      __FILE__,						\
+	      __LINE__,						\
+	      __PRETTY_FUNCTION__,				\
+	      #expr);			}G_STMT_END
+
+#define g_assert_not_reached()		G_STMT_START{		\
+     g_log (G_LOG_DOMAIN,					\
+	    G_LOG_LEVEL_ERROR,					\
+	    &quot;file %s: line %d (%s): should not be reached&quot;,	\
+	    __FILE__,						\
+	    __LINE__,						\
+	    __PRETTY_FUNCTION__);	}G_STMT_END
+
+#else /* !__GNUC__ */
+
+#define g_assert(expr)			G_STMT_START{		\
+     if (expr) { } else						\
+       g_log (G_LOG_DOMAIN,					\
+	      G_LOG_LEVEL_ERROR,				\
+	      &quot;file %s: line %d: assertion failed: (%s)&quot;,	\
+	      __FILE__,						\
+	      __LINE__,						\
+	      #expr);			}G_STMT_END
+
+#define g_assert_not_reached()		G_STMT_START{	\
+     g_log (G_LOG_DOMAIN,				\
+	    G_LOG_LEVEL_ERROR,				\
+	    &quot;file %s: line %d: should not be reached&quot;,	\
+	    __FILE__,					\
+	    __LINE__);		}G_STMT_END
+
+#endif /* __GNUC__ */
+
+#endif /* !G_DISABLE_ASSERT */
+
+
+#ifdef G_DISABLE_CHECKS
+
+#define g_return_if_fail(expr)			G_STMT_START{ (void)0; }G_STMT_END
+#define g_return_val_if_fail(expr,val)		G_STMT_START{ (void)0; }G_STMT_END
+#define g_return_if_reached()			G_STMT_START{ return; }G_STMT_END
+#define g_return_val_if_reached(val)		G_STMT_START{ return (val); }G_STMT_END
+
+#else /* !G_DISABLE_CHECKS */
+
+#ifdef __GNUC__
+
+#define g_return_if_fail(expr)		G_STMT_START{			\
+     if G_LIKELY(expr) { } else       					\
+       {								\
+	 g_log (G_LOG_DOMAIN,						\
+		G_LOG_LEVEL_CRITICAL,					\
+		&quot;file %s: line %d (%s): assertion `%s' failed&quot;,		\
+		__FILE__,						\
+		__LINE__,						\
+		__PRETTY_FUNCTION__,					\
+		#expr);							\
+	 return;							\
+       };				}G_STMT_END
+
+#define g_return_val_if_fail(expr,val)	G_STMT_START{			\
+     if G_LIKELY(expr) { } else						\
+       {								\
+	 g_log (G_LOG_DOMAIN,						\
+		G_LOG_LEVEL_CRITICAL,					\
+		&quot;file %s: line %d (%s): assertion `%s' failed&quot;,		\
+		__FILE__,						\
+		__LINE__,						\
+		__PRETTY_FUNCTION__,					\
+		#expr);							\
+	 return (val);							\
+       };				}G_STMT_END
+
+#define g_return_if_reached()		G_STMT_START{			\
+     g_log (G_LOG_DOMAIN,						\
+	    G_LOG_LEVEL_CRITICAL,					\
+	    &quot;file %s: line %d (%s): should not be reached&quot;,		\
+	    __FILE__,							\
+	    __LINE__,							\
+	    __PRETTY_FUNCTION__);					\
+     return;				}G_STMT_END
+
+#define g_return_val_if_reached(val)	G_STMT_START{			\
+     g_log (G_LOG_DOMAIN,						\
+	    G_LOG_LEVEL_CRITICAL,					\
+	    &quot;file %s: line %d (%s): should not be reached&quot;,		\
+	    __FILE__,							\
+	    __LINE__,							\
+	    __PRETTY_FUNCTION__);					\
+     return (val);			}G_STMT_END
+
+#else /* !__GNUC__ */
+
+#define g_return_if_fail(expr)		G_STMT_START{		\
+     if (expr) { } else						\
+       {							\
+	 g_log (G_LOG_DOMAIN,					\
+		G_LOG_LEVEL_CRITICAL,				\
+		&quot;file %s: line %d: assertion `%s' failed&quot;,	\
+		__FILE__,					\
+		__LINE__,					\
+		#expr);						\
+	 return;						\
+       };				}G_STMT_END
+
+#define g_return_val_if_fail(expr, val)	G_STMT_START{		\
+     if (expr) { } else						\
+       {							\
+	 g_log (G_LOG_DOMAIN,					\
+		G_LOG_LEVEL_CRITICAL,				\
+		&quot;file %s: line %d: assertion `%s' failed&quot;,	\
+		__FILE__,					\
+		__LINE__,					\
+		#expr);						\
+	 return (val);						\
+       };				}G_STMT_END
+
+#define g_return_if_reached()		G_STMT_START{		\
+     g_log (G_LOG_DOMAIN,					\
+	    G_LOG_LEVEL_CRITICAL,				\
+	    &quot;file %s: line %d: should not be reached&quot;,		\
+	    __FILE__,						\
+	    __LINE__);						\
+     return;				}G_STMT_END
+
+#define g_return_val_if_reached(val)	G_STMT_START{		\
+     g_log (G_LOG_DOMAIN,					\
+	    G_LOG_LEVEL_CRITICAL,				\
+	    &quot;file %s: line %d: should not be reached&quot;,		\
+	    __FILE__,						\
+	    __LINE__);						\
+     return (val);			}G_STMT_END
+
+#endif /* !__GNUC__ */
+
+#endif /* !G_DISABLE_CHECKS */
+
+G_END_DECLS
+
+#endif /* __G_MESSAGES_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gnode.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gnode.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gnode.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,168 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_NODE_H__
+#define __G_NODE_H__
+
+#include &lt;glib/gmem.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GNode		GNode;
+
+/* Tree traverse flags */
+typedef enum
+{
+  G_TRAVERSE_LEAFS      = 1 &lt;&lt; 0,
+  G_TRAVERSE_NON_LEAFS  = 1 &lt;&lt; 1,
+  G_TRAVERSE_ALL        = G_TRAVERSE_LEAFS | G_TRAVERSE_NON_LEAFS,
+  G_TRAVERSE_MASK       = 0x03
+} GTraverseFlags;
+
+/* Tree traverse orders */
+typedef enum
+{
+  G_IN_ORDER,
+  G_PRE_ORDER,
+  G_POST_ORDER,
+  G_LEVEL_ORDER
+} GTraverseType;
+
+typedef gboolean	(*GNodeTraverseFunc)	(GNode	       *node,
+						 gpointer	data);
+typedef void		(*GNodeForeachFunc)	(GNode	       *node,
+						 gpointer	data);
+typedef gpointer	(*GCopyFunc)            (gconstpointer  src,
+                                                 gpointer       data);
+
+/* N-way tree implementation
+ */
+struct _GNode
+{
+  gpointer data;
+  GNode	  *next;
+  GNode	  *prev;
+  GNode	  *parent;
+  GNode	  *children;
+};
+
+#define	 G_NODE_IS_ROOT(node)	(((GNode*) (node))-&gt;parent == NULL &amp;&amp; \
+				 ((GNode*) (node))-&gt;prev == NULL &amp;&amp; \
+				 ((GNode*) (node))-&gt;next == NULL)
+#define	 G_NODE_IS_LEAF(node)	(((GNode*) (node))-&gt;children == NULL)
+
+void     g_node_push_allocator  (GAllocator       *allocator);
+void     g_node_pop_allocator   (void);
+GNode*	 g_node_new		(gpointer	   data);
+void	 g_node_destroy		(GNode		  *root);
+void	 g_node_unlink		(GNode		  *node);
+GNode*   g_node_copy_deep       (GNode            *node,
+				 GCopyFunc         copy_func,
+				 gpointer          data);
+GNode*   g_node_copy            (GNode            *node);
+GNode*	 g_node_insert		(GNode		  *parent,
+				 gint		   position,
+				 GNode		  *node);
+GNode*	 g_node_insert_before	(GNode		  *parent,
+				 GNode		  *sibling,
+				 GNode		  *node);
+GNode*   g_node_insert_after    (GNode            *parent,
+				 GNode            *sibling,
+				 GNode            *node); 
+GNode*	 g_node_prepend		(GNode		  *parent,
+				 GNode		  *node);
+guint	 g_node_n_nodes		(GNode		  *root,
+				 GTraverseFlags	   flags);
+GNode*	 g_node_get_root	(GNode		  *node);
+gboolean g_node_is_ancestor	(GNode		  *node,
+				 GNode		  *descendant);
+guint	 g_node_depth		(GNode		  *node);
+GNode*	 g_node_find		(GNode		  *root,
+				 GTraverseType	   order,
+				 GTraverseFlags	   flags,
+				 gpointer	   data);
+
+/* convenience macros */
+#define g_node_append(parent, node)				\
+     g_node_insert_before ((parent), NULL, (node))
+#define	g_node_insert_data(parent, position, data)		\
+     g_node_insert ((parent), (position), g_node_new (data))
+#define	g_node_insert_data_before(parent, sibling, data)	\
+     g_node_insert_before ((parent), (sibling), g_node_new (data))
+#define	g_node_prepend_data(parent, data)			\
+     g_node_prepend ((parent), g_node_new (data))
+#define	g_node_append_data(parent, data)			\
+     g_node_insert_before ((parent), NULL, g_node_new (data))
+
+/* traversal function, assumes that `node' is root
+ * (only traverses `node' and its subtree).
+ * this function is just a high level interface to
+ * low level traversal functions, optimized for speed.
+ */
+void	 g_node_traverse	(GNode		  *root,
+				 GTraverseType	   order,
+				 GTraverseFlags	   flags,
+				 gint		   max_depth,
+				 GNodeTraverseFunc func,
+				 gpointer	   data);
+
+/* return the maximum tree height starting with `node', this is an expensive
+ * operation, since we need to visit all nodes. this could be shortened by
+ * adding `guint height' to struct _GNode, but then again, this is not very
+ * often needed, and would make g_node_insert() more time consuming.
+ */
+guint	 g_node_max_height	 (GNode *root);
+
+void	 g_node_children_foreach (GNode		  *node,
+				  GTraverseFlags   flags,
+				  GNodeForeachFunc func,
+				  gpointer	   data);
+void	 g_node_reverse_children (GNode		  *node);
+guint	 g_node_n_children	 (GNode		  *node);
+GNode*	 g_node_nth_child	 (GNode		  *node,
+				  guint		   n);
+GNode*	 g_node_last_child	 (GNode		  *node);
+GNode*	 g_node_find_child	 (GNode		  *node,
+				  GTraverseFlags   flags,
+				  gpointer	   data);
+gint	 g_node_child_position	 (GNode		  *node,
+				  GNode		  *child);
+gint	 g_node_child_index	 (GNode		  *node,
+				  gpointer	   data);
+
+GNode*	 g_node_first_sibling	 (GNode		  *node);
+GNode*	 g_node_last_sibling	 (GNode		  *node);
+
+#define	 g_node_prev_sibling(node)	((node) ? \
+					 ((GNode*) (node))-&gt;prev : NULL)
+#define	 g_node_next_sibling(node)	((node) ? \
+					 ((GNode*) (node))-&gt;next : NULL)
+#define	 g_node_first_child(node)	((node) ? \
+					 ((GNode*) (node))-&gt;children : NULL)
+
+G_END_DECLS
+
+#endif /* __G_NODE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gpattern.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gpattern.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gpattern.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,44 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997, 1999  Peter Mattis, Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_PATTERN_H__
+#define __G_PATTERN_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+
+typedef struct _GPatternSpec    GPatternSpec;
+
+GPatternSpec* g_pattern_spec_new       (const gchar  *pattern);
+void          g_pattern_spec_free      (GPatternSpec *pspec);
+gboolean      g_pattern_spec_equal     (GPatternSpec *pspec1,
+					GPatternSpec *pspec2);
+gboolean      g_pattern_match          (GPatternSpec *pspec,
+					guint         string_length,
+					const gchar  *string,
+					const gchar  *string_reversed);
+gboolean      g_pattern_match_string   (GPatternSpec *pspec,
+					const gchar  *string);
+gboolean      g_pattern_match_simple   (const gchar  *pattern,
+					const gchar  *string);
+
+G_END_DECLS
+
+#endif /* __G_PATTERN_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprimes.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprimes.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprimes.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,47 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_PRIMES_H__
+#define __G_PRIMES_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+/* Prime numbers.
+ */
+
+/* This function returns prime numbers spaced by approximately 1.5-2.0
+ * and is for use in resizing data structures which prefer
+ * prime-valued sizes.	The closest spaced prime function returns the
+ * next largest prime, or the highest it knows about which is about
+ * MAXINT/4.
+ */
+guint	   g_spaced_primes_closest (guint num) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_PRIMES_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprintf.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprintf.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gprintf.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,62 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997, 2002  Peter Mattis, Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_PRINTF_H__
+#define __G_PRINTF_H__
+
+#include &lt;glib/gtypes.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+
+G_BEGIN_DECLS
+
+gint                  g_printf    (gchar const *format,
+                                   ...) G_GNUC_PRINTF (1, 2);            
+gint                  g_fprintf   (FILE        *file,
+				   gchar const *format,
+				   ...) G_GNUC_PRINTF (2, 3);
+gint                  g_sprintf   (gchar       *string,
+				   gchar const *format,
+				   ...) G_GNUC_PRINTF (2, 3);
+gint                  g_snprintf  (gchar       *string,
+				   gulong       n,
+				   gchar const *format,
+				   ...) G_GNUC_PRINTF (3, 4);
+
+gint                  g_vprintf   (gchar const *format,
+                                   va_list      args);            
+gint                  g_vfprintf  (FILE        *file,
+				   gchar const *format,
+				   va_list      args);
+gint                  g_vsprintf  (gchar       *string,
+				   gchar const *format,
+				   va_list      args);
+gint                  g_vsnprintf (gchar       *string,
+				   gulong       n,
+				   gchar const *format,
+				   va_list      args);
+gint                  g_vasprintf (gchar      **string,
+				   gchar const *format,
+				   va_list      args);
+
+G_END_DECLS
+
+#endif /* __G_PRINTF_H__ */
+
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqsort.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqsort.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqsort.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,44 @@
+ /* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+
+#ifndef __G_QSORT_H__
+#define __G_QSORT_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+void g_qsort_with_data (gconstpointer    pbase,
+			gint             total_elems,
+			gsize            size,
+			GCompareDataFunc compare_func,
+			gpointer         user_data);
+
+G_END_DECLS
+
+#endif /* __G_QSORT_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gquark.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gquark.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gquark.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,46 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_QUARK_H__
+#define __G_QUARK_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef guint32 GQuark;
+
+/* Quarks (string&lt;-&gt;id association)
+ */
+GQuark                g_quark_try_string         (const gchar *string);
+GQuark                g_quark_from_static_string (const gchar *string);
+GQuark                g_quark_from_string        (const gchar *string);
+G_CONST_RETURN gchar* g_quark_to_string          (GQuark       quark) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_QUARK_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqueue.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqueue.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gqueue.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,119 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_QUEUE_H__
+#define __G_QUEUE_H__
+
+#include &lt;glib/glist.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GQueue		GQueue;
+
+struct _GQueue
+{
+  GList *head;
+  GList *tail;
+  guint  length;
+};
+
+/* Queues
+ */
+GQueue*  g_queue_new            (void);
+void     g_queue_free           (GQueue           *queue);
+gboolean g_queue_is_empty       (GQueue           *queue);
+guint    g_queue_get_length     (GQueue           *queue);
+void     g_queue_reverse        (GQueue           *queue);
+GQueue * g_queue_copy           (GQueue           *queue);
+void     g_queue_foreach        (GQueue           *queue,
+				 GFunc             func,
+				 gpointer          user_data);
+GList *  g_queue_find           (GQueue           *queue,
+				 gconstpointer     data);
+GList *  g_queue_find_custom    (GQueue           *queue,
+				 gconstpointer     data,
+				 GCompareFunc      func);
+void     g_queue_sort           (GQueue           *queue,
+				 GCompareDataFunc  compare_func,
+				 gpointer          user_data);
+
+void     g_queue_push_head      (GQueue           *queue,
+				 gpointer          data);
+void     g_queue_push_tail      (GQueue           *queue,
+				 gpointer          data);
+void     g_queue_push_nth       (GQueue           *queue,
+				 gpointer          data,
+				 gint              n);
+gpointer g_queue_pop_head       (GQueue           *queue);
+gpointer g_queue_pop_tail       (GQueue           *queue);
+gpointer g_queue_pop_nth        (GQueue           *queue,
+				 guint             n);
+gpointer g_queue_peek_head      (GQueue           *queue);
+gpointer g_queue_peek_tail      (GQueue           *queue);
+gpointer g_queue_peek_nth       (GQueue           *queue,
+				 guint             n);
+gint     g_queue_index          (GQueue           *queue,
+				 gconstpointer     data);
+void     g_queue_remove         (GQueue           *queue,
+				 gconstpointer     data);
+void     g_queue_remove_all     (GQueue           *queue,
+				 gconstpointer     data);
+void     g_queue_insert_before  (GQueue           *queue,
+				 GList            *sibling,
+				 gpointer          data);
+void     g_queue_insert_after   (GQueue           *queue,
+				 GList            *sibling,
+				 gpointer          data);
+void     g_queue_insert_sorted  (GQueue           *queue,
+				 gpointer          data,
+				 GCompareDataFunc  func,
+				 gpointer          user_data);
+
+void     g_queue_push_head_link (GQueue           *queue,
+				 GList            *link_);
+void     g_queue_push_tail_link (GQueue           *queue,
+				 GList            *link_);
+void     g_queue_push_nth_link  (GQueue           *queue,
+				 gint              n,
+				 GList            *link_);
+GList*   g_queue_pop_head_link  (GQueue           *queue);
+GList*   g_queue_pop_tail_link  (GQueue           *queue);
+GList*   g_queue_pop_nth_link   (GQueue           *queue,
+				 guint             n);
+GList*   g_queue_peek_head_link (GQueue           *queue);
+GList*   g_queue_peek_tail_link (GQueue           *queue);
+GList*   g_queue_peek_nth_link  (GQueue           *queue,
+				 guint             n);
+gint     g_queue_link_index     (GQueue           *queue,
+				 GList            *link_);
+void     g_queue_unlink         (GQueue           *queue,
+				 GList            *link_);
+void     g_queue_delete_link    (GQueue           *queue,
+				 GList            *link_);
+
+G_END_DECLS
+
+#endif /* __G_QUEUE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grand.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grand.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grand.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,87 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_RAND_H__
+#define __G_RAND_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GRand           GRand;
+
+/* GRand - a good and fast random number generator: Mersenne Twister
+ * see <A HREF="http://www.math.keio.ac.jp/~matumoto/emt.html">http://www.math.keio.ac.jp/~matumoto/emt.html</A> for more info.
+ * The range functions return a value in the intervall [begin, end).
+ * int          -&gt; [0..2^32-1]
+ * int_range    -&gt; [begin..end-1]
+ * double       -&gt; [0..1)
+ * double_range -&gt; [begin..end)
+ */
+
+GRand*  g_rand_new_with_seed  (guint32  seed);
+GRand*  g_rand_new_with_seed_array (const guint32 *seed,
+				    guint seed_length);
+GRand*  g_rand_new            (void);
+void    g_rand_free           (GRand   *rand_);
+GRand*  g_rand_copy           (GRand   *rand_);
+void    g_rand_set_seed       (GRand   *rand_,
+			       guint32  seed);
+void	g_rand_set_seed_array (GRand   *rand_,
+			       const guint32 *seed,
+			       guint    seed_length);
+
+#define g_rand_boolean(rand_) ((g_rand_int (rand_) &amp; (1 &lt;&lt; 15)) != 0)
+
+guint32 g_rand_int            (GRand   *rand_);
+gint32  g_rand_int_range      (GRand   *rand_,
+			       gint32   begin,
+			       gint32   end);
+gdouble g_rand_double         (GRand   *rand_);
+gdouble g_rand_double_range   (GRand   *rand_,
+			       gdouble  begin,
+			       gdouble  end);
+void    g_random_set_seed     (guint32  seed);
+
+#define g_random_boolean() ((g_random_int () &amp; (1 &lt;&lt; 15)) != 0)
+
+guint32 g_random_int          (void);
+gint32  g_random_int_range    (gint32   begin,
+			       gint32   end);
+gdouble g_random_double       (void);
+gdouble g_random_double_range (gdouble  begin,
+			       gdouble  end);
+
+
+G_END_DECLS
+
+#endif /* __G_RAND_H__ */
+
+
+
+
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grel.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grel.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/grel.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,94 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_REL_H__
+#define __G_REL_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GRelation       GRelation;
+typedef struct _GTuples         GTuples;
+
+struct _GTuples
+{
+  guint len;
+};
+
+/* GRelation
+ *
+ * Indexed Relations.  Imagine a really simple table in a
+ * database.  Relations are not ordered.  This data type is meant for
+ * maintaining a N-way mapping.
+ *
+ * g_relation_new() creates a relation with FIELDS fields
+ *
+ * g_relation_destroy() frees all resources
+ * g_tuples_destroy() frees the result of g_relation_select()
+ *
+ * g_relation_index() indexes relation FIELD with the provided
+ *   equality and hash functions.  this must be done before any
+ *   calls to insert are made.
+ *
+ * g_relation_insert() inserts a new tuple.  you are expected to
+ *   provide the right number of fields.
+ *
+ * g_relation_delete() deletes all relations with KEY in FIELD
+ * g_relation_select() returns ...
+ * g_relation_count() counts ...
+ */
+
+GRelation* g_relation_new     (gint         fields);
+void       g_relation_destroy (GRelation   *relation);
+void       g_relation_index   (GRelation   *relation,
+                               gint         field,
+                               GHashFunc    hash_func,
+                               GEqualFunc   key_equal_func);
+void       g_relation_insert  (GRelation   *relation,
+                               ...);
+gint       g_relation_delete  (GRelation   *relation,
+                               gconstpointer  key,
+                               gint         field);
+GTuples*   g_relation_select  (GRelation   *relation,
+                               gconstpointer  key,
+                               gint         field);
+gint       g_relation_count   (GRelation   *relation,
+                               gconstpointer  key,
+                               gint         field);
+gboolean   g_relation_exists  (GRelation   *relation,
+                               ...);
+void       g_relation_print   (GRelation   *relation);
+
+void       g_tuples_destroy   (GTuples     *tuples);
+gpointer   g_tuples_index     (GTuples     *tuples,
+                               gint         index_,
+                               gint         field);
+
+G_END_DECLS
+
+#endif /* __G_REL_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gscanner.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gscanner.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gscanner.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,274 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_SCANNER_H__
+#define __G_SCANNER_H__
+
+#include &lt;glib/ghash.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GScanner	GScanner;
+typedef struct _GScannerConfig	GScannerConfig;
+typedef union  _GTokenValue     GTokenValue;
+
+typedef void		(*GScannerMsgFunc)	(GScanner      *scanner,
+						 gchar	       *message,
+						 gboolean	error);
+
+/* GScanner: Flexible lexical scanner for general purpose.
+ */
+
+/* Character sets */
+#define G_CSET_A_2_Z	&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
+#define G_CSET_a_2_z	&quot;abcdefghijklmnopqrstuvwxyz&quot;
+#define G_CSET_DIGITS	&quot;0123456789&quot;
+#define G_CSET_LATINC	&quot;\300\301\302\303\304\305\306&quot;\
+			&quot;\307\310\311\312\313\314\315\316\317\320&quot;\
+			&quot;\321\322\323\324\325\326&quot;\
+			&quot;\330\331\332\333\334\335\336&quot;
+#define G_CSET_LATINS	&quot;\337\340\341\342\343\344\345\346&quot;\
+			&quot;\347\350\351\352\353\354\355\356\357\360&quot;\
+			&quot;\361\362\363\364\365\366&quot;\
+			&quot;\370\371\372\373\374\375\376\377&quot;
+
+/* Error types */
+typedef enum
+{
+  G_ERR_UNKNOWN,
+  G_ERR_UNEXP_EOF,
+  G_ERR_UNEXP_EOF_IN_STRING,
+  G_ERR_UNEXP_EOF_IN_COMMENT,
+  G_ERR_NON_DIGIT_IN_CONST,
+  G_ERR_DIGIT_RADIX,
+  G_ERR_FLOAT_RADIX,
+  G_ERR_FLOAT_MALFORMED
+} GErrorType;
+
+/* Token types */
+typedef enum
+{
+  G_TOKEN_EOF			=   0,
+  
+  G_TOKEN_LEFT_PAREN		= '(',
+  G_TOKEN_RIGHT_PAREN		= ')',
+  G_TOKEN_LEFT_CURLY		= '{',
+  G_TOKEN_RIGHT_CURLY		= '}',
+  G_TOKEN_LEFT_BRACE		= '[',
+  G_TOKEN_RIGHT_BRACE		= ']',
+  G_TOKEN_EQUAL_SIGN		= '=',
+  G_TOKEN_COMMA			= ',',
+  
+  G_TOKEN_NONE			= 256,
+  
+  G_TOKEN_ERROR,
+  
+  G_TOKEN_CHAR,
+  G_TOKEN_BINARY,
+  G_TOKEN_OCTAL,
+  G_TOKEN_INT,
+  G_TOKEN_HEX,
+  G_TOKEN_FLOAT,
+  G_TOKEN_STRING,
+  
+  G_TOKEN_SYMBOL,
+  G_TOKEN_IDENTIFIER,
+  G_TOKEN_IDENTIFIER_NULL,
+  
+  G_TOKEN_COMMENT_SINGLE,
+  G_TOKEN_COMMENT_MULTI,
+  G_TOKEN_LAST
+} GTokenType;
+
+union	_GTokenValue
+{
+  gpointer	v_symbol;
+  gchar		*v_identifier;
+  gulong	v_binary;
+  gulong	v_octal;
+  gulong	v_int;
+  guint64       v_int64;
+  gdouble	v_float;
+  gulong	v_hex;
+  gchar		*v_string;
+  gchar		*v_comment;
+  guchar	v_char;
+  guint		v_error;
+};
+
+struct	_GScannerConfig
+{
+  /* Character sets
+   */
+  gchar		*cset_skip_characters;		/* default: &quot; \t\n&quot; */
+  gchar		*cset_identifier_first;
+  gchar		*cset_identifier_nth;
+  gchar		*cpair_comment_single;		/* default: &quot;#\n&quot; */
+  
+  /* Should symbol lookup work case sensitive?
+   */
+  guint		case_sensitive : 1;
+  
+  /* Boolean values to be adjusted &quot;on the fly&quot;
+   * to configure scanning behaviour.
+   */
+  guint		skip_comment_multi : 1;		/* C like comment */
+  guint		skip_comment_single : 1;	/* single line comment */
+  guint		scan_comment_multi : 1;		/* scan multi line comments? */
+  guint		scan_identifier : 1;
+  guint		scan_identifier_1char : 1;
+  guint		scan_identifier_NULL : 1;
+  guint		scan_symbols : 1;
+  guint		scan_binary : 1;
+  guint		scan_octal : 1;
+  guint		scan_float : 1;
+  guint		scan_hex : 1;			/* `0x0ff0' */
+  guint		scan_hex_dollar : 1;		/* `$0ff0' */
+  guint		scan_string_sq : 1;		/* string: 'anything' */
+  guint		scan_string_dq : 1;		/* string: &quot;\\-escapes!\n&quot; */
+  guint		numbers_2_int : 1;		/* bin, octal, hex =&gt; int */
+  guint		int_2_float : 1;		/* int =&gt; G_TOKEN_FLOAT? */
+  guint		identifier_2_string : 1;
+  guint		char_2_token : 1;		/* return G_TOKEN_CHAR? */
+  guint		symbol_2_token : 1;
+  guint		scope_0_fallback : 1;		/* try scope 0 on lookups? */
+  guint		store_int64 : 1; 		/* use value.v_int64 rather than v_int */
+  guint		padding_dummy;
+};
+
+struct	_GScanner
+{
+  /* unused fields */
+  gpointer		user_data;
+  guint			max_parse_errors;
+  
+  /* g_scanner_error() increments this field */
+  guint			parse_errors;
+  
+  /* name of input stream, featured by the default message handler */
+  const gchar		*input_name;
+  
+  /* quarked data */
+  GData			*qdata;
+  
+  /* link into the scanner configuration */
+  GScannerConfig	*config;
+  
+  /* fields filled in after g_scanner_get_next_token() */
+  GTokenType		token;
+  GTokenValue		value;
+  guint			line;
+  guint			position;
+  
+  /* fields filled in after g_scanner_peek_next_token() */
+  GTokenType		next_token;
+  GTokenValue		next_value;
+  guint			next_line;
+  guint			next_position;
+  
+  /* to be considered private */
+  GHashTable		*symbol_table;
+  gint			input_fd;
+  const gchar		*text;
+  const gchar		*text_end;
+  gchar			*buffer;
+  guint			scope_id;
+  
+  /* handler function for _warn and _error */
+  GScannerMsgFunc	msg_handler;
+};
+
+GScanner*	g_scanner_new			(const GScannerConfig *config_templ);
+void		g_scanner_destroy		(GScanner	*scanner);
+void		g_scanner_input_file		(GScanner	*scanner,
+						 gint		input_fd);
+void		g_scanner_sync_file_offset	(GScanner	*scanner);
+void		g_scanner_input_text		(GScanner	*scanner,
+						 const	gchar	*text,
+						 guint		text_len);
+GTokenType	g_scanner_get_next_token	(GScanner	*scanner);
+GTokenType	g_scanner_peek_next_token	(GScanner	*scanner);
+GTokenType	g_scanner_cur_token		(GScanner	*scanner);
+GTokenValue	g_scanner_cur_value		(GScanner	*scanner);
+guint		g_scanner_cur_line		(GScanner	*scanner);
+guint		g_scanner_cur_position		(GScanner	*scanner);
+gboolean	g_scanner_eof			(GScanner	*scanner);
+guint		g_scanner_set_scope		(GScanner	*scanner,
+						 guint		 scope_id);
+void		g_scanner_scope_add_symbol	(GScanner	*scanner,
+						 guint		 scope_id,
+						 const gchar	*symbol,
+						 gpointer	value);
+void		g_scanner_scope_remove_symbol	(GScanner	*scanner,
+						 guint		 scope_id,
+						 const gchar	*symbol);
+gpointer	g_scanner_scope_lookup_symbol	(GScanner	*scanner,
+						 guint		 scope_id,
+						 const gchar	*symbol);
+void		g_scanner_scope_foreach_symbol	(GScanner	*scanner,
+						 guint		 scope_id,
+						 GHFunc		 func,
+						 gpointer	 user_data);
+gpointer	g_scanner_lookup_symbol		(GScanner	*scanner,
+						 const gchar	*symbol);
+void		g_scanner_unexp_token		(GScanner	*scanner,
+						 GTokenType	expected_token,
+						 const gchar	*identifier_spec,
+						 const gchar	*symbol_spec,
+						 const gchar	*symbol_name,
+						 const gchar	*message,
+						 gint		 is_error);
+void		g_scanner_error			(GScanner	*scanner,
+						 const gchar	*format,
+						 ...) G_GNUC_PRINTF (2,3);
+void		g_scanner_warn			(GScanner	*scanner,
+						 const gchar	*format,
+						 ...) G_GNUC_PRINTF (2,3);
+
+#ifndef G_DISABLE_DEPRECATED
+
+/* keep downward source compatibility */
+#define		g_scanner_add_symbol( scanner, symbol, value )	G_STMT_START { \
+  g_scanner_scope_add_symbol ((scanner), 0, (symbol), (value)); \
+} G_STMT_END
+#define		g_scanner_remove_symbol( scanner, symbol )	G_STMT_START { \
+  g_scanner_scope_remove_symbol ((scanner), 0, (symbol)); \
+} G_STMT_END
+#define		g_scanner_foreach_symbol( scanner, func, data )	G_STMT_START { \
+  g_scanner_scope_foreach_symbol ((scanner), 0, (func), (data)); \
+} G_STMT_END
+
+/* The following two functions are deprecated and will be removed in
+ * the next major release. They do no good. */
+#define g_scanner_freeze_symbol_table(scanner) ((void)0)
+#define g_scanner_thaw_symbol_table(scanner) ((void)0)
+
+#endif /* G_DISABLE_DEPRECATED */
+
+G_END_DECLS
+
+#endif /* __G_SCANNER_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gshell.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gshell.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gshell.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,53 @@
+/* gshell.h - Shell-related utilities
+ *
+ *  Copyright 2000 Red Hat, Inc.
+ *
+ * GLib is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * GLib is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with GLib; see the file COPYING.LIB.  If not, write
+ * to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_SHELL_H__
+#define __G_SHELL_H__
+
+#include &lt;glib/gerror.h&gt;
+
+G_BEGIN_DECLS
+
+#define G_SHELL_ERROR g_shell_error_quark ()
+
+typedef enum
+{
+  /* mismatched or otherwise mangled quoting */
+  G_SHELL_ERROR_BAD_QUOTING,
+  /* string to be parsed was empty */
+  G_SHELL_ERROR_EMPTY_STRING,
+  G_SHELL_ERROR_FAILED
+} GShellError;
+
+GQuark g_shell_error_quark (void);
+
+gchar*   g_shell_quote      (const gchar   *unquoted_string);
+gchar*   g_shell_unquote    (const gchar   *quoted_string,
+                             GError       **error);
+gboolean g_shell_parse_argv (const gchar   *command_line,
+                             gint          *argcp,
+                             gchar       ***argvp,
+                             GError       **error);
+
+G_END_DECLS
+
+#endif /* __G_SHELL_H__ */
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gslist.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gslist.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gslist.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,102 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_SLIST_H__
+#define __G_SLIST_H__
+
+#include &lt;glib/gmem.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GSList		GSList;
+
+struct _GSList
+{
+  gpointer data;
+  GSList *next;
+};
+
+/* Singly linked lists
+ */
+void     g_slist_push_allocator (GAllocator       *allocator);
+void     g_slist_pop_allocator  (void);
+GSList*  g_slist_alloc          (void);
+void     g_slist_free           (GSList           *list);
+void     g_slist_free_1         (GSList           *list);
+GSList*  g_slist_append         (GSList           *list,
+				 gpointer          data);
+GSList*  g_slist_prepend        (GSList           *list,
+				 gpointer          data);
+GSList*  g_slist_insert         (GSList           *list,
+				 gpointer          data,
+				 gint              position);
+GSList*  g_slist_insert_sorted  (GSList           *list,
+				 gpointer          data,
+				 GCompareFunc      func);
+GSList*  g_slist_insert_before  (GSList           *slist,
+				 GSList           *sibling,
+				 gpointer          data);
+GSList*  g_slist_concat         (GSList           *list1,
+				 GSList           *list2);
+GSList*  g_slist_remove         (GSList           *list,
+				 gconstpointer     data);
+GSList*  g_slist_remove_all     (GSList           *list,
+				 gconstpointer     data);
+GSList*  g_slist_remove_link    (GSList           *list,
+				 GSList           *link_);
+GSList*  g_slist_delete_link    (GSList           *list,
+				 GSList           *link_);
+GSList*  g_slist_reverse        (GSList           *list);
+GSList*  g_slist_copy           (GSList           *list);
+GSList*  g_slist_nth            (GSList           *list,
+				 guint             n);
+GSList*  g_slist_find           (GSList           *list,
+				 gconstpointer     data);
+GSList*  g_slist_find_custom    (GSList           *list,
+				 gconstpointer     data,
+				 GCompareFunc      func);
+gint     g_slist_position       (GSList           *list,
+				 GSList           *llink);
+gint     g_slist_index          (GSList           *list,
+				 gconstpointer     data);
+GSList*  g_slist_last           (GSList           *list);
+guint    g_slist_length         (GSList           *list);
+void     g_slist_foreach        (GSList           *list,
+				 GFunc             func,
+				 gpointer          user_data);
+GSList*  g_slist_sort           (GSList           *list,
+				 GCompareFunc      compare_func);
+GSList*  g_slist_sort_with_data (GSList           *list,
+				 GCompareDataFunc  compare_func,
+				 gpointer          user_data);
+gpointer g_slist_nth_data       (GSList           *list,
+				 guint             n);
+#define  g_slist_next(slist)	((slist) ? (((GSList *)(slist))-&gt;next) : NULL)
+
+G_END_DECLS
+
+#endif /* __G_SLIST_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gspawn.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gspawn.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gspawn.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,130 @@
+/* gspawn.h - Process launching
+ *
+ *  Copyright 2000 Red Hat, Inc.
+ *
+ * GLib is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * GLib is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with GLib; see the file COPYING.LIB.  If not, write
+ * to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_SPAWN_H__
+#define __G_SPAWN_H__
+
+#include &lt;glib/gerror.h&gt;
+
+G_BEGIN_DECLS
+
+/* I'm not sure I remember our proposed naming convention here. */
+#define G_SPAWN_ERROR g_spawn_error_quark ()
+
+typedef enum
+{
+  G_SPAWN_ERROR_FORK,   /* fork failed due to lack of memory */
+  G_SPAWN_ERROR_READ,   /* read or select on pipes failed */
+  G_SPAWN_ERROR_CHDIR,  /* changing to working dir failed */
+  G_SPAWN_ERROR_ACCES,  /* execv() returned EACCES */
+  G_SPAWN_ERROR_PERM,   /* execv() returned EPERM */
+  G_SPAWN_ERROR_2BIG,   /* execv() returned E2BIG */
+  G_SPAWN_ERROR_NOEXEC, /* execv() returned ENOEXEC */
+  G_SPAWN_ERROR_NAMETOOLONG, /* &quot;&quot;  &quot;&quot; ENAMETOOLONG */
+  G_SPAWN_ERROR_NOENT,       /* &quot;&quot;  &quot;&quot; ENOENT */
+  G_SPAWN_ERROR_NOMEM,       /* &quot;&quot;  &quot;&quot; ENOMEM */
+  G_SPAWN_ERROR_NOTDIR,      /* &quot;&quot;  &quot;&quot; ENOTDIR */
+  G_SPAWN_ERROR_LOOP,        /* &quot;&quot;  &quot;&quot; ELOOP   */
+  G_SPAWN_ERROR_TXTBUSY,     /* &quot;&quot;  &quot;&quot; ETXTBUSY */
+  G_SPAWN_ERROR_IO,          /* &quot;&quot;  &quot;&quot; EIO */
+  G_SPAWN_ERROR_NFILE,       /* &quot;&quot;  &quot;&quot; ENFILE */
+  G_SPAWN_ERROR_MFILE,       /* &quot;&quot;  &quot;&quot; EMFLE */
+  G_SPAWN_ERROR_INVAL,       /* &quot;&quot;  &quot;&quot; EINVAL */
+  G_SPAWN_ERROR_ISDIR,       /* &quot;&quot;  &quot;&quot; EISDIR */
+  G_SPAWN_ERROR_LIBBAD,      /* &quot;&quot;  &quot;&quot; ELIBBAD */
+  G_SPAWN_ERROR_FAILED       /* other fatal failure, error-&gt;message
+                              * should explain
+                              */
+} GSpawnError;
+
+typedef void (* GSpawnChildSetupFunc) (gpointer user_data);
+
+typedef enum
+{
+  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 &lt;&lt; 0,
+  G_SPAWN_DO_NOT_REAP_CHILD      = 1 &lt;&lt; 1,
+  /* look for argv[0] in the path i.e. use execvp() */
+  G_SPAWN_SEARCH_PATH            = 1 &lt;&lt; 2,
+  /* Dump output to /dev/null */
+  G_SPAWN_STDOUT_TO_DEV_NULL     = 1 &lt;&lt; 3,
+  G_SPAWN_STDERR_TO_DEV_NULL     = 1 &lt;&lt; 4,
+  G_SPAWN_CHILD_INHERITS_STDIN   = 1 &lt;&lt; 5,
+  G_SPAWN_FILE_AND_ARGV_ZERO     = 1 &lt;&lt; 6
+} GSpawnFlags;
+
+GQuark g_spawn_error_quark (void);
+
+gboolean g_spawn_async (const gchar           *working_directory,
+                        gchar                **argv,
+                        gchar                **envp,
+                        GSpawnFlags            flags,
+                        GSpawnChildSetupFunc   child_setup,
+                        gpointer               user_data,
+                        GPid                  *child_pid,
+                        GError               **error);
+
+
+/* Opens pipes for non-NULL standard_output, standard_input, standard_error,
+ * and returns the parent's end of the pipes.
+ */
+gboolean g_spawn_async_with_pipes (const gchar          *working_directory,
+                                   gchar               **argv,
+                                   gchar               **envp,
+                                   GSpawnFlags           flags,
+                                   GSpawnChildSetupFunc  child_setup,
+                                   gpointer              user_data,
+                                   GPid                 *child_pid,
+                                   gint                 *standard_input,
+                                   gint                 *standard_output,
+                                   gint                 *standard_error,
+                                   GError              **error);
+
+
+/* If standard_output or standard_error are non-NULL, the full
+ * standard output or error of the command will be placed there.
+ */
+
+gboolean g_spawn_sync         (const gchar          *working_directory,
+                               gchar               **argv,
+                               gchar               **envp,
+                               GSpawnFlags           flags,
+                               GSpawnChildSetupFunc  child_setup,
+                               gpointer              user_data,
+                               gchar               **standard_output,
+                               gchar               **standard_error,
+                               gint                 *exit_status,
+                               GError              **error);
+
+gboolean g_spawn_command_line_sync  (const gchar          *command_line,
+                                     gchar               **standard_output,
+                                     gchar               **standard_error,
+                                     gint                 *exit_status,
+                                     GError              **error);
+gboolean g_spawn_command_line_async (const gchar          *command_line,
+                                     GError              **error);
+
+void g_spawn_close_pid (GPid pid);
+
+
+G_END_DECLS
+
+#endif /* __G_SPAWN_H__ */
+
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstrfuncs.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstrfuncs.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstrfuncs.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,242 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_STRFUNCS_H__
+#define __G_STRFUNCS_H__
+
+#include &lt;stdarg.h&gt;
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+/* Functions like the ones in &lt;ctype.h&gt; that are not affected by locale. */
+typedef enum {
+  G_ASCII_ALNUM  = 1 &lt;&lt; 0,
+  G_ASCII_ALPHA  = 1 &lt;&lt; 1,
+  G_ASCII_CNTRL  = 1 &lt;&lt; 2,
+  G_ASCII_DIGIT  = 1 &lt;&lt; 3,
+  G_ASCII_GRAPH  = 1 &lt;&lt; 4,
+  G_ASCII_LOWER  = 1 &lt;&lt; 5,
+  G_ASCII_PRINT  = 1 &lt;&lt; 6,
+  G_ASCII_PUNCT  = 1 &lt;&lt; 7,
+  G_ASCII_SPACE  = 1 &lt;&lt; 8,
+  G_ASCII_UPPER  = 1 &lt;&lt; 9,
+  G_ASCII_XDIGIT = 1 &lt;&lt; 10
+} GAsciiType;
+
+GLIB_VAR const guint16 * const g_ascii_table;
+
+#define g_ascii_isalnum(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_ALNUM) != 0)
+
+#define g_ascii_isalpha(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_ALPHA) != 0)
+
+#define g_ascii_iscntrl(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_CNTRL) != 0)
+
+#define g_ascii_isdigit(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_DIGIT) != 0)
+
+#define g_ascii_isgraph(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_GRAPH) != 0)
+
+#define g_ascii_islower(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_LOWER) != 0)
+
+#define g_ascii_isprint(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_PRINT) != 0)
+
+#define g_ascii_ispunct(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_PUNCT) != 0)
+
+#define g_ascii_isspace(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_SPACE) != 0)
+
+#define g_ascii_isupper(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_UPPER) != 0)
+
+#define g_ascii_isxdigit(c) \
+  ((g_ascii_table[(guchar) (c)] &amp; G_ASCII_XDIGIT) != 0)
+
+gchar                 g_ascii_tolower  (gchar        c) G_GNUC_CONST;
+gchar                 g_ascii_toupper  (gchar        c) G_GNUC_CONST;
+
+gint                  g_ascii_digit_value  (gchar    c) G_GNUC_CONST;
+gint                  g_ascii_xdigit_value (gchar    c) G_GNUC_CONST;
+
+/* String utility functions that modify a string argument or
+ * return a constant string that must not be freed.
+ */
+#define	 G_STR_DELIMITERS	&quot;_-|&gt; &lt;.&quot;
+gchar*	              g_strdelimit     (gchar	     *string,
+					const gchar  *delimiters,
+					gchar	      new_delimiter);
+gchar*	              g_strcanon       (gchar        *string,
+					const gchar  *valid_chars,
+					gchar         substitutor);
+G_CONST_RETURN gchar* g_strerror       (gint	      errnum) G_GNUC_CONST;
+G_CONST_RETURN gchar* g_strsignal      (gint	      signum) G_GNUC_CONST;
+gchar*	              g_strreverse     (gchar	     *string);
+gsize	              g_strlcpy	       (gchar	     *dest,
+					const gchar  *src,
+					gsize         dest_size);
+gsize	              g_strlcat        (gchar	     *dest,
+					const gchar  *src,
+					gsize         dest_size);
+gchar *               g_strstr_len     (const gchar  *haystack,
+					gssize        haystack_len,
+					const gchar  *needle);
+gchar *               g_strrstr        (const gchar  *haystack,
+					const gchar  *needle);
+gchar *               g_strrstr_len    (const gchar  *haystack,
+					gssize        haystack_len,
+					const gchar  *needle);
+
+gboolean              g_str_has_suffix (const gchar  *str,
+					const gchar  *suffix);
+gboolean              g_str_has_prefix (const gchar  *str,
+					const gchar  *prefix);
+
+/* String to/from double conversion functions */
+
+gdouble	              g_strtod         (const gchar  *nptr,
+					gchar	    **endptr);
+gdouble	              g_ascii_strtod   (const gchar  *nptr,
+					gchar	    **endptr);
+guint64		      g_ascii_strtoull (const gchar *nptr,
+					gchar      **endptr,
+					guint        base);
+/* 29 bytes should enough for all possible values that
+ * g_ascii_dtostr can produce.
+ * Then add 10 for good measure */
+#define G_ASCII_DTOSTR_BUF_SIZE (29 + 10)
+gchar *               g_ascii_dtostr   (gchar        *buffer,
+					gint          buf_len,
+					gdouble       d);
+gchar *               g_ascii_formatd  (gchar        *buffer,
+					gint          buf_len,
+					const gchar  *format,
+					gdouble       d);
+
+/* removes leading spaces */
+gchar*                g_strchug        (gchar        *string);
+/* removes trailing spaces */
+gchar*                g_strchomp       (gchar        *string);
+/* removes leading &amp; trailing spaces */
+#define g_strstrip( string )	g_strchomp (g_strchug (string))
+
+gint                  g_ascii_strcasecmp  (const gchar *s1,
+					   const gchar *s2);
+gint                  g_ascii_strncasecmp (const gchar *s1,
+					   const gchar *s2,
+					   gsize        n);
+gchar*                g_ascii_strdown     (const gchar *str,
+					   gssize       len);
+gchar*                g_ascii_strup       (const gchar *str,
+					   gssize       len);
+
+#ifndef G_DISABLE_DEPRECATED
+
+/* The following four functions are deprecated and will be removed in
+ * the next major release. They use the locale-specific tolower and
+ * toupper, which is almost never the right thing.
+ */
+
+gint	              g_strcasecmp     (const gchar *s1,
+					const gchar *s2);
+gint	              g_strncasecmp    (const gchar *s1,
+					const gchar *s2,
+					guint        n);
+gchar*	              g_strdown	       (gchar	     *string);
+gchar*	              g_strup	       (gchar	     *string);
+
+#endif /* G_DISABLE_DEPRECATED */
+
+/* String utility functions that return a newly allocated string which
+ * ought to be freed with g_free from the caller at some point.
+ */
+gchar*	              g_strdup	       (const gchar *str);
+gchar*	              g_strdup_printf  (const gchar *format,
+					...) G_GNUC_PRINTF (1, 2);
+gchar*	              g_strdup_vprintf (const gchar *format,
+					va_list      args);
+gchar*	              g_strndup	       (const gchar *str,
+					gsize        n);  
+gchar*	              g_strnfill       (gsize        length,  
+					gchar        fill_char);
+gchar*	              g_strconcat      (const gchar *string1,
+					...); /* NULL terminated */
+gchar*                g_strjoin	       (const gchar  *separator,
+					...); /* NULL terminated */
+/* Make a copy of a string interpreting C string -style escape
+ * sequences. Inverse of g_strescape. The recognized sequences are \b
+ * \f \n \r \t \\ \&quot; and the octal format.
+ */
+gchar*                g_strcompress    (const gchar *source);
+
+/* Copy a string escaping nonprintable characters like in C strings.
+ * Inverse of g_strcompress. The exceptions parameter, if non-NULL, points
+ * to a string containing characters that are not to be escaped.
+ *
+ * Deprecated API: gchar* g_strescape (const gchar *source);
+ * Luckily this function wasn't used much, using NULL as second parameter
+ * provides mostly identical semantics.
+ */
+gchar*                g_strescape      (const gchar *source,
+					const gchar *exceptions);
+
+gpointer              g_memdup	       (gconstpointer mem,
+					guint	       byte_size);
+
+/* NULL terminated string arrays.
+ * g_strsplit(), g_strsplit_set() split up string into max_tokens tokens
+ * at delim and return a newly allocated string array.
+ * g_strjoinv() concatenates all of str_array's strings, sliding in an
+ * optional separator, the returned string is newly allocated.
+ * g_strfreev() frees the array itself and all of its strings.
+ * g_strdupv() copies a NULL-terminated array of strings
+ */
+gchar**	              g_strsplit       (const gchar  *string,
+					const gchar  *delimiter,
+					gint          max_tokens);
+gchar **	      g_strsplit_set   (const gchar *string,
+					const gchar *delimiters,
+					gint         max_tokens);
+gchar*                g_strjoinv       (const gchar  *separator,
+					gchar       **str_array);
+void                  g_strfreev       (gchar       **str_array);
+gchar**               g_strdupv        (gchar       **str_array);
+
+gchar*                g_stpcpy         (gchar        *dest,
+                                        const char   *src);
+
+G_CONST_RETURN gchar *g_strip_context  (const gchar *msgid, 
+					const gchar *msgval);
+
+G_END_DECLS
+
+#endif /* __G_STRFUNCS_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstring.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstring.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gstring.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,157 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_STRING_H__
+#define __G_STRING_H__
+
+#include &lt;glib/gtypes.h&gt;
+#include &lt;glib/gunicode.h&gt;
+#include &lt;glib/gutils.h&gt;  /* for G_CAN_INLINE */
+
+G_BEGIN_DECLS
+
+typedef struct _GString		GString;
+typedef struct _GStringChunk	GStringChunk;
+
+struct _GString
+{
+  gchar  *str;
+  gsize len;    
+  gsize allocated_len;
+};
+
+/* String Chunks
+ */
+GStringChunk* g_string_chunk_new	   (gsize size);  
+void	      g_string_chunk_free	   (GStringChunk *chunk);
+gchar*	      g_string_chunk_insert	   (GStringChunk *chunk,
+					    const gchar	 *string);
+gchar*	      g_string_chunk_insert_len	   (GStringChunk *chunk,
+					    const gchar	 *string,
+					    gssize        len);
+gchar*	      g_string_chunk_insert_const  (GStringChunk *chunk,
+					    const gchar	 *string);
+
+
+/* Strings
+ */
+GString*     g_string_new	        (const gchar	 *init);
+GString*     g_string_new_len           (const gchar     *init,
+                                         gssize           len);   
+GString*     g_string_sized_new         (gsize            dfl_size);  
+gchar*	     g_string_free	        (GString	 *string,
+					 gboolean	  free_segment);
+gboolean     g_string_equal             (const GString	 *v,
+					 const GString 	 *v2);
+guint        g_string_hash              (const GString   *str);
+GString*     g_string_assign            (GString	 *string,
+					 const gchar	 *rval);
+GString*     g_string_truncate          (GString	 *string,
+					 gsize		  len);    
+GString*     g_string_set_size          (GString         *string,
+					 gsize            len);
+GString*     g_string_insert_len        (GString         *string,
+                                         gssize           pos,   
+                                         const gchar     *val,
+                                         gssize           len);  
+GString*     g_string_append            (GString	 *string,
+			                 const gchar	 *val);
+GString*     g_string_append_len        (GString	 *string,
+			                 const gchar	 *val,
+                                         gssize           len);  
+GString*     g_string_append_c          (GString	 *string,
+					 gchar		  c);
+GString*     g_string_append_unichar    (GString	 *string,
+					 gunichar	  wc);
+GString*     g_string_prepend           (GString	 *string,
+					 const gchar	 *val);
+GString*     g_string_prepend_c         (GString	 *string,
+					 gchar		  c);
+GString*     g_string_prepend_unichar   (GString	 *string,
+					 gunichar	  wc);
+GString*     g_string_prepend_len       (GString	 *string,
+			                 const gchar	 *val,
+                                         gssize           len);  
+GString*     g_string_insert            (GString	 *string,
+					 gssize		  pos,    
+					 const gchar	 *val);
+GString*     g_string_insert_c          (GString	 *string,
+					 gssize		  pos,    
+					 gchar		  c);
+GString*     g_string_insert_unichar    (GString	 *string,
+					 gssize		  pos,    
+					 gunichar	  wc);
+GString*     g_string_erase	        (GString	 *string,
+					 gssize		  pos,
+					 gssize		  len);
+GString*     g_string_ascii_down        (GString	 *string);
+GString*     g_string_ascii_up          (GString	 *string);
+void         g_string_printf            (GString	 *string,
+					 const gchar	 *format,
+					 ...) G_GNUC_PRINTF (2, 3);
+void         g_string_append_printf     (GString	 *string,
+					 const gchar	 *format,
+					 ...) G_GNUC_PRINTF (2, 3);
+
+/* -- optimize g_strig_append_c --- */
+#ifdef G_CAN_INLINE
+static inline GString*
+g_string_append_c_inline (GString *gstring,
+                          gchar    c)
+{
+  if (gstring-&gt;len &lt; gstring-&gt;allocated_len &amp;&amp; 0)
+    {
+      gstring-&gt;str[gstring-&gt;len++] = c;
+      gstring-&gt;str[gstring-&gt;len] = 0;
+    }
+  else
+    g_string_insert_c (gstring, -1, c);
+  return gstring;
+}
+#define g_string_append_c(gstr,c)       g_string_append_c_inline (gstr, c)
+#endif /* G_CAN_INLINE */
+
+
+#ifndef G_DISABLE_DEPRECATED
+
+/* The following two functions are deprecated and will be removed in
+ * the next major release. They use the locale-specific tolower and
+ * toupper, which is almost never the right thing.
+ */
+
+GString*     g_string_down              (GString	 *string);
+GString*     g_string_up                (GString	 *string);
+
+/* These aliases are included for compatibility. */
+#define	g_string_sprintf	g_string_printf
+#define	g_string_sprintfa	g_string_append_printf
+
+#endif /* G_DISABLE_DEPRECATED */
+
+G_END_DECLS
+
+#endif /* __G_STRING_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthread.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthread.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthread.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,373 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_THREAD_H__
+#define __G_THREAD_H__
+
+#include &lt;glib/gerror.h&gt;
+#include &lt;glib/gtypes.h&gt;
+#include &lt;glib/gatomic.h&gt;  /* for g_atomic_pointer_get */
+
+G_BEGIN_DECLS
+
+/* GLib Thread support
+ */
+
+extern GQuark g_thread_error_quark (void);
+#define G_THREAD_ERROR g_thread_error_quark ()
+
+typedef enum
+{
+  G_THREAD_ERROR_AGAIN /* Resource temporarily unavailable */
+} GThreadError;
+
+typedef gpointer (*GThreadFunc) (gpointer data);
+
+typedef enum
+{
+  G_THREAD_PRIORITY_LOW,
+  G_THREAD_PRIORITY_NORMAL,
+  G_THREAD_PRIORITY_HIGH,
+  G_THREAD_PRIORITY_URGENT
+} GThreadPriority;
+
+typedef struct _GThread         GThread;
+struct  _GThread
+{
+  /*&lt; private &gt;*/
+  GThreadFunc func;
+  gpointer data;
+  gboolean joinable;
+  GThreadPriority priority;
+};
+
+typedef struct _GMutex          GMutex;
+typedef struct _GCond           GCond;
+typedef struct _GPrivate        GPrivate;
+typedef struct _GStaticPrivate  GStaticPrivate;
+
+typedef struct _GThreadFunctions GThreadFunctions;
+struct _GThreadFunctions
+{
+  GMutex*  (*mutex_new)           (void);
+  void     (*mutex_lock)          (GMutex               *mutex);
+  gboolean (*mutex_trylock)       (GMutex               *mutex);
+  void     (*mutex_unlock)        (GMutex               *mutex);
+  void     (*mutex_free)          (GMutex               *mutex);
+  GCond*   (*cond_new)            (void);
+  void     (*cond_signal)         (GCond                *cond);
+  void     (*cond_broadcast)      (GCond                *cond);
+  void     (*cond_wait)           (GCond                *cond,
+                                   GMutex               *mutex);
+  gboolean (*cond_timed_wait)     (GCond                *cond,
+                                   GMutex               *mutex,
+                                   GTimeVal             *end_time);
+  void      (*cond_free)          (GCond                *cond);
+  GPrivate* (*private_new)        (GDestroyNotify        destructor);
+  gpointer  (*private_get)        (GPrivate             *private_key);
+  void      (*private_set)        (GPrivate             *private_key,
+                                   gpointer              data);
+  void      (*thread_create)      (GThreadFunc           func,
+                                   gpointer              data,
+                                   gulong                stack_size,
+                                   gboolean              joinable,
+                                   gboolean              bound,
+                                   GThreadPriority       priority,
+                                   gpointer              thread,
+                                   GError              **error);
+  void      (*thread_yield)       (void);
+  void      (*thread_join)        (gpointer              thread);
+  void      (*thread_exit)        (void);
+  void      (*thread_set_priority)(gpointer              thread,
+                                   GThreadPriority       priority);
+  void      (*thread_self)        (gpointer              thread);
+  gboolean  (*thread_equal)       (gpointer              thread1,
+				   gpointer              thread2);
+};
+
+GLIB_VAR GThreadFunctions       g_thread_functions_for_glib_use;
+GLIB_VAR gboolean               g_thread_use_default_impl;
+GLIB_VAR gboolean               g_threads_got_initialized;
+
+/* initializes the mutex/cond/private implementation for glib, might
+ * only be called once, and must not be called directly or indirectly
+ * from another glib-function, e.g. as a callback.
+ */
+void    g_thread_init   (GThreadFunctions       *vtable);
+
+/* Errorcheck mutexes. If you define G_ERRORCHECK_MUTEXES, then all
+ * mutexes will check for re-locking and re-unlocking */
+
+/* Initialize thread system with errorcheck mutexes. vtable must be
+ * NULL. Do not call directly. Use #define G_ERRORCHECK_MUTEXES
+ * instead.
+ */
+void    g_thread_init_with_errorcheck_mutexes (GThreadFunctions* vtable);
+
+/* A random number to recognize debug calls to g_mutex_... */
+#define G_MUTEX_DEBUG_MAGIC 0xf8e18ad7
+
+#ifdef G_ERRORCHECK_MUTEXES
+#define g_thread_init(vtable) g_thread_init_with_errorcheck_mutexes (vtable)
+#endif
+
+/* internal function for fallback static mutex implementation */
+GMutex* g_static_mutex_get_mutex_impl   (GMutex **mutex);
+
+#define g_static_mutex_get_mutex_impl_shortcut(mutex) \
+  (g_atomic_pointer_get ((gpointer*)mutex) ? *(mutex) : \
+   g_static_mutex_get_mutex_impl (mutex))
+
+/* shorthands for conditional and unconditional function calls */
+
+#define G_THREAD_UF(op, arglist)					\
+    (*g_thread_functions_for_glib_use . op) arglist
+#define G_THREAD_CF(op, fail, arg)					\
+    (g_thread_supported () ? G_THREAD_UF (op, arg) : (fail))
+#define G_THREAD_ECF(op, fail, mutex, type)				\
+    (g_thread_supported () ? ((type(*)(GMutex*, gulong, gchar*))	\
+      (*g_thread_functions_for_glib_use . op))				\
+     (mutex, G_MUTEX_DEBUG_MAGIC, G_STRLOC) : (fail))
+
+#ifndef G_ERRORCHECK_MUTEXES
+# define g_mutex_lock(mutex)						\
+    G_THREAD_CF (mutex_lock,     (void)0, (mutex))
+# define g_mutex_trylock(mutex)						\
+    G_THREAD_CF (mutex_trylock,  TRUE,    (mutex))
+# define g_mutex_unlock(mutex)						\
+    G_THREAD_CF (mutex_unlock,   (void)0, (mutex))
+# define g_mutex_free(mutex)						\
+    G_THREAD_CF (mutex_free,     (void)0, (mutex))
+# define g_cond_wait(cond, mutex)					\
+    G_THREAD_CF (cond_wait,      (void)0, (cond, mutex))
+# define g_cond_timed_wait(cond, mutex, abs_time)			\
+    G_THREAD_CF (cond_timed_wait, TRUE,   (cond, mutex, abs_time))
+#else /* G_ERRORCHECK_MUTEXES */
+# define g_mutex_lock(mutex)						\
+    G_THREAD_ECF (mutex_lock,    (void)0, (mutex), void)
+# define g_mutex_trylock(mutex)						\
+    G_THREAD_ECF (mutex_trylock, TRUE,    (mutex), gboolean)
+# define g_mutex_unlock(mutex)						\
+    G_THREAD_ECF (mutex_unlock,  (void)0, (mutex), void)
+# define g_mutex_free(mutex)						\
+    G_THREAD_ECF (mutex_free,    (void)0, (mutex), void)
+# define g_cond_wait(cond, mutex)					\
+    (g_thread_supported () ? ((void(*)(GCond*, GMutex*, gulong, gchar*))\
+      g_thread_functions_for_glib_use.cond_wait)			\
+        (cond, mutex, G_MUTEX_DEBUG_MAGIC, G_STRLOC) : (void) 0)
+# define g_cond_timed_wait(cond, mutex, abs_time)			\
+    (g_thread_supported () ?						\
+      ((gboolean(*)(GCond*, GMutex*, GTimeVal*, gulong, gchar*))	\
+        g_thread_functions_for_glib_use.cond_timed_wait)		\
+          (cond, mutex, abs_time, G_MUTEX_DEBUG_MAGIC, G_STRLOC) : TRUE)
+#endif /* G_ERRORCHECK_MUTEXES */
+
+#define g_thread_supported()    (g_threads_got_initialized)
+#define g_mutex_new()            G_THREAD_UF (mutex_new,      ())
+#define g_cond_new()             G_THREAD_UF (cond_new,       ())
+#define g_cond_signal(cond)      G_THREAD_CF (cond_signal,    (void)0, (cond))
+#define g_cond_broadcast(cond)   G_THREAD_CF (cond_broadcast, (void)0, (cond))
+#define g_cond_free(cond)        G_THREAD_CF (cond_free,      (void)0, (cond))
+#define g_private_new(destructor) G_THREAD_UF (private_new, (destructor))
+#define g_private_get(private_key) G_THREAD_CF (private_get, \
+                                                ((gpointer)private_key), \
+                                                (private_key))
+#define g_private_set(private_key, value) G_THREAD_CF (private_set, \
+                                                       (void) (private_key = \
+                                                        (GPrivate*) (value)), \
+                                                       (private_key, value))
+#define g_thread_yield()              G_THREAD_CF (thread_yield, (void)0, ())
+
+#define g_thread_create(func, data, joinable, error)			\
+  (g_thread_create_full (func, data, 0, joinable, FALSE, 		\
+                         G_THREAD_PRIORITY_NORMAL, error))
+
+GThread* g_thread_create_full  (GThreadFunc            func,
+                                gpointer               data,
+                                gulong                 stack_size,
+                                gboolean               joinable,
+                                gboolean               bound,
+                                GThreadPriority        priority,
+                                GError               **error);
+GThread* g_thread_self         (void);
+void     g_thread_exit         (gpointer               retval);
+gpointer g_thread_join         (GThread               *thread);
+
+void     g_thread_set_priority (GThread               *thread,
+                                GThreadPriority        priority);
+
+/* GStaticMutexes can be statically initialized with the value
+ * G_STATIC_MUTEX_INIT, and then they can directly be used, that is
+ * much easier, than having to explicitly allocate the mutex before
+ * use
+ */
+#define g_static_mutex_lock(mutex) \
+    g_mutex_lock (g_static_mutex_get_mutex (mutex))
+#define g_static_mutex_trylock(mutex) \
+    g_mutex_trylock (g_static_mutex_get_mutex (mutex))
+#define g_static_mutex_unlock(mutex) \
+    g_mutex_unlock (g_static_mutex_get_mutex (mutex))
+void g_static_mutex_init (GStaticMutex *mutex);
+void g_static_mutex_free (GStaticMutex *mutex);
+
+struct _GStaticPrivate
+{
+  /*&lt; private &gt;*/
+  guint index;
+};
+#define G_STATIC_PRIVATE_INIT { 0 }
+void     g_static_private_init           (GStaticPrivate   *private_key);
+gpointer g_static_private_get            (GStaticPrivate   *private_key);
+void     g_static_private_set            (GStaticPrivate   *private_key,
+					  gpointer          data,
+					  GDestroyNotify    notify);
+void     g_static_private_free           (GStaticPrivate   *private_key);
+
+typedef struct _GStaticRecMutex GStaticRecMutex;
+struct _GStaticRecMutex
+{
+  /*&lt; private &gt;*/
+  GStaticMutex mutex;
+  guint depth;
+  GSystemThread owner;
+};
+
+#define G_STATIC_REC_MUTEX_INIT { G_STATIC_MUTEX_INIT }
+void     g_static_rec_mutex_init        (GStaticRecMutex *mutex);
+void     g_static_rec_mutex_lock        (GStaticRecMutex *mutex);
+gboolean g_static_rec_mutex_trylock     (GStaticRecMutex *mutex);
+void     g_static_rec_mutex_unlock      (GStaticRecMutex *mutex);
+void     g_static_rec_mutex_lock_full   (GStaticRecMutex *mutex,
+                                         guint            depth);
+guint    g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
+void     g_static_rec_mutex_free        (GStaticRecMutex *mutex);
+
+typedef struct _GStaticRWLock GStaticRWLock;
+struct _GStaticRWLock
+{
+  /*&lt; private &gt;*/
+  GStaticMutex mutex;
+  GCond *read_cond;
+  GCond *write_cond;
+  guint read_counter;
+  gboolean have_writer;
+  guint want_to_read;
+  guint want_to_write;
+};
+
+#define G_STATIC_RW_LOCK_INIT { G_STATIC_MUTEX_INIT, NULL, NULL, 0, FALSE, 0, 0 }
+
+void      g_static_rw_lock_init           (GStaticRWLock* lock);
+void      g_static_rw_lock_reader_lock    (GStaticRWLock* lock);
+gboolean  g_static_rw_lock_reader_trylock (GStaticRWLock* lock);
+void      g_static_rw_lock_reader_unlock  (GStaticRWLock* lock);
+void      g_static_rw_lock_writer_lock    (GStaticRWLock* lock);
+gboolean  g_static_rw_lock_writer_trylock (GStaticRWLock* lock);
+void      g_static_rw_lock_writer_unlock  (GStaticRWLock* lock);
+void      g_static_rw_lock_free           (GStaticRWLock* lock);
+
+typedef enum
+{
+  G_ONCE_STATUS_NOTCALLED,
+  G_ONCE_STATUS_PROGRESS,
+  G_ONCE_STATUS_READY  
+} GOnceStatus;
+
+typedef struct _GOnce GOnce;
+struct _GOnce
+{
+  volatile GOnceStatus status;
+  volatile gpointer retval;
+};
+
+#define G_ONCE_INIT { G_ONCE_STATUS_NOTCALLED, NULL }
+
+gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
+
+#ifdef G_ATOMIC_OP_MEMORY_BARRIER_NEEDED
+# define g_once(once, func, arg) g_once_impl ((once), (func), (arg))
+#else /* !G_ATOMIC_OP_MEMORY_BARRIER_NEEDED*/
+# define g_once(once, func, arg) \
+  (((once)-&gt;status == G_ONCE_STATUS_READY) ? \
+   (once)-&gt;retval : \
+   g_once_impl ((once), (func), (arg)))
+#endif /* G_ATOMIC_OP_MEMORY_BARRIER_NEEDED */
+    
+/* these are some convenience macros that expand to nothing if GLib
+ * was configured with --disable-threads. for using StaticMutexes,
+ * you define them with G_LOCK_DEFINE_STATIC (name) or G_LOCK_DEFINE (name)
+ * if you need to export the mutex. With G_LOCK_EXTERN (name) you can
+ * declare such an globally defined lock. name is a unique identifier
+ * for the protected varibale or code portion. locking, testing and
+ * unlocking of such mutexes can be done with G_LOCK(), G_UNLOCK() and
+ * G_TRYLOCK() respectively.
+ */
+extern void glib_dummy_decl (void);
+#define G_LOCK_NAME(name)               g__ ## name ## _lock
+#ifdef  G_THREADS_ENABLED
+#  define G_LOCK_DEFINE_STATIC(name)    static G_LOCK_DEFINE (name)
+#  define G_LOCK_DEFINE(name)           \
+    GStaticMutex G_LOCK_NAME (name) = G_STATIC_MUTEX_INIT
+#  define G_LOCK_EXTERN(name)           extern GStaticMutex G_LOCK_NAME (name)
+
+#  ifdef G_DEBUG_LOCKS
+#    define G_LOCK(name)                G_STMT_START{             \
+        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                   \
+               &quot;file %s: line %d (%s): locking: %s &quot;,             \
+               __FILE__,        __LINE__, G_GNUC_PRETTY_FUNCTION, \
+               #name);                                            \
+        g_static_mutex_lock (&amp;G_LOCK_NAME (name));                \
+     }G_STMT_END
+#    define G_UNLOCK(name)              G_STMT_START{             \
+        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                   \
+               &quot;file %s: line %d (%s): unlocking: %s &quot;,           \
+               __FILE__,        __LINE__, G_GNUC_PRETTY_FUNCTION, \
+               #name);                                            \
+       g_static_mutex_unlock (&amp;G_LOCK_NAME (name));               \
+     }G_STMT_END
+#    define G_TRYLOCK(name)                                       \
+        (g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                  \
+               &quot;file %s: line %d (%s): try locking: %s &quot;,         \
+               __FILE__,        __LINE__, G_GNUC_PRETTY_FUNCTION, \
+               #name), g_static_mutex_trylock (&amp;G_LOCK_NAME (name)))
+#  else  /* !G_DEBUG_LOCKS */
+#    define G_LOCK(name) g_static_mutex_lock       (&amp;G_LOCK_NAME (name))
+#    define G_UNLOCK(name) g_static_mutex_unlock   (&amp;G_LOCK_NAME (name))
+#    define G_TRYLOCK(name) g_static_mutex_trylock (&amp;G_LOCK_NAME (name))
+#  endif /* !G_DEBUG_LOCKS */
+#else   /* !G_THREADS_ENABLED */
+#  define G_LOCK_DEFINE_STATIC(name)    extern void glib_dummy_decl (void)
+#  define G_LOCK_DEFINE(name)           extern void glib_dummy_decl (void)
+#  define G_LOCK_EXTERN(name)           extern void glib_dummy_decl (void)
+#  define G_LOCK(name)
+#  define G_UNLOCK(name)
+#  define G_TRYLOCK(name)               (TRUE)
+#endif  /* !G_THREADS_ENABLED */
+
+G_END_DECLS
+
+#endif /* __G_THREAD_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthreadpool.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthreadpool.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gthreadpool.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,102 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_THREADPOOL_H__
+#define __G_THREADPOOL_H__
+
+#include &lt;glib/gthread.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GThreadPool     GThreadPool;
+
+/* Thread Pools
+ */
+
+/* The real GThreadPool is bigger, so you may only create a thread
+ * pool with the constructor function */
+struct _GThreadPool
+{
+  GFunc func;
+  gpointer user_data;
+  gboolean exclusive;
+};
+
+/* Get a thread pool with the function func, at most max_threads may
+ * run at a time (max_threads == -1 means no limit), exclusive == TRUE
+ * means, that the threads shouldn't be shared and that they will be
+ * prestarted (otherwise they are started as needed) user_data is the
+ * 2nd argument to the func */
+GThreadPool*    g_thread_pool_new             (GFunc            func,
+                                               gpointer         user_data,
+                                               gint             max_threads,
+                                               gboolean         exclusive,
+                                               GError         **error);
+
+/* Push new data into the thread pool. This task is assigned to a thread later
+ * (when the maximal number of threads is reached for that pool) or now
+ * (otherwise). If necessary a new thread will be started. The function
+ * returns immediatly */
+void            g_thread_pool_push            (GThreadPool     *pool,
+                                               gpointer         data,
+                                               GError         **error);
+
+/* Set the number of threads, which can run concurrently for that pool, -1
+ * means no limit. 0 means has the effect, that the pool won't process
+ * requests until the limit is set higher again */
+void            g_thread_pool_set_max_threads (GThreadPool     *pool,
+                                               gint             max_threads,
+                                               GError         **error);
+gint            g_thread_pool_get_max_threads (GThreadPool     *pool);
+
+/* Get the number of threads assigned to that pool. This number doesn't
+ * necessarily represent the number of working threads in that pool */
+guint           g_thread_pool_get_num_threads (GThreadPool     *pool);
+
+/* Get the number of unprocessed items in the pool */
+guint           g_thread_pool_unprocessed     (GThreadPool     *pool);
+
+/* Free the pool, immediate means, that all unprocessed items in the queue
+ * wont be processed, wait means, that the function doesn't return immediatly,
+ * but after all threads in the pool are ready processing items. immediate
+ * does however not mean, that threads are killed. */
+void            g_thread_pool_free            (GThreadPool     *pool,
+                                               gboolean         immediate,
+                                               gboolean         wait);
+
+/* Set the maximal number of unused threads before threads will be stopped by
+ * GLib, -1 means no limit */
+void            g_thread_pool_set_max_unused_threads (gint      max_threads);
+gint            g_thread_pool_get_max_unused_threads (void);
+guint           g_thread_pool_get_num_unused_threads (void);
+
+/* Stop all currently unused threads, but leave the limit untouched */
+void            g_thread_pool_stop_unused_threads    (void);
+
+G_END_DECLS
+
+#endif /* __G_THREADPOOL_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtimer.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtimer.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtimer.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,58 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_TIMER_H__
+#define __G_TIMER_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+/* Timer
+ */
+
+/* microseconds per second */
+typedef struct _GTimer		GTimer;
+
+#define G_USEC_PER_SEC 1000000
+
+GTimer* g_timer_new	(void);
+void	g_timer_destroy (GTimer	  *timer);
+void	g_timer_start	(GTimer	  *timer);
+void	g_timer_stop	(GTimer	  *timer);
+void	g_timer_reset	(GTimer	  *timer);
+void	g_timer_continue	(GTimer   *timer);
+gdouble g_timer_elapsed (GTimer	  *timer,
+			 gulong	  *microseconds);
+
+void    g_usleep        (gulong    microseconds);
+
+void    g_time_val_add  (GTimeVal *time_, 
+                         glong     microseconds);
+
+G_END_DECLS
+
+#endif /* __G_TIMER_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtree.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtree.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtree.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,88 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_TREE_H__
+#define __G_TREE_H__
+
+#include &lt;glib/gnode.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GTree  GTree;
+
+typedef gboolean (*GTraverseFunc) (gpointer  key,
+                                   gpointer  value,
+                                   gpointer  data);
+
+/* Balanced binary trees
+ */
+GTree*   g_tree_new             (GCompareFunc      key_compare_func);
+GTree*   g_tree_new_with_data   (GCompareDataFunc  key_compare_func,
+                                 gpointer          key_compare_data);
+GTree*   g_tree_new_full        (GCompareDataFunc  key_compare_func,
+                                 gpointer          key_compare_data,
+                                 GDestroyNotify    key_destroy_func,
+                                 GDestroyNotify    value_destroy_func);
+void     g_tree_destroy         (GTree            *tree);
+void     g_tree_insert          (GTree            *tree,
+                                 gpointer          key,
+                                 gpointer          value);
+void     g_tree_replace         (GTree            *tree,
+                                 gpointer          key,
+                                 gpointer          value);
+void     g_tree_remove          (GTree            *tree,
+                                 gconstpointer     key);
+void     g_tree_steal           (GTree            *tree,
+                                 gconstpointer     key);
+gpointer g_tree_lookup          (GTree            *tree,
+                                 gconstpointer     key);
+gboolean g_tree_lookup_extended (GTree            *tree,
+                                 gconstpointer     lookup_key,
+                                 gpointer         *orig_key,
+                                 gpointer         *value);
+void     g_tree_foreach         (GTree            *tree,
+                                 GTraverseFunc	   func,
+                                 gpointer	   user_data);
+
+#ifndef G_DISABLE_DEPRECATED
+void     g_tree_traverse        (GTree            *tree,
+                                 GTraverseFunc     traverse_func,
+                                 GTraverseType     traverse_type,
+                                 gpointer          user_data);
+#endif /* G_DISABLE_DEPRECATED */
+
+gpointer g_tree_search          (GTree            *tree,
+                                 GCompareFunc      search_func,
+                                 gconstpointer     user_data);
+gint     g_tree_height          (GTree            *tree);
+gint     g_tree_nnodes          (GTree            *tree);
+
+
+
+G_END_DECLS
+
+#endif /* __G_TREE_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtypes.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtypes.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gtypes.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,419 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_TYPES_H__
+#define __G_TYPES_H__
+
+#include &lt;glibconfig.h&gt;
+
+G_BEGIN_DECLS
+
+/* Provide type definitions for commonly used types.
+ *  These are useful because a &quot;gint8&quot; can be adjusted
+ *  to be 1 byte (8 bits) on all platforms. Similarly and
+ *  more importantly, &quot;gint32&quot; can be adjusted to be
+ *  4 bytes (32 bits) on all platforms.
+ */
+
+typedef char   gchar;
+typedef short  gshort;
+typedef long   glong;
+typedef int    gint;
+typedef gint   gboolean;
+
+typedef unsigned char   guchar;
+typedef unsigned short  gushort;
+typedef unsigned long   gulong;
+typedef unsigned int    guint;
+
+typedef float   gfloat;
+typedef double  gdouble;
+
+/* Define min and max constants for the fixed size numerical types */
+#define G_MININT8	((gint8)  0x80)
+#define G_MAXINT8	((gint8)  0x7f)
+#define G_MAXUINT8	((guint8) 0xff)
+
+#define G_MININT16	((gint16)  0x8000)
+#define G_MAXINT16	((gint16)  0x7fff)
+#define G_MAXUINT16	((guint16) 0xffff)
+
+#define G_MININT32	((gint32)  0x80000000)
+#define G_MAXINT32	((gint32)  0x7fffffff)
+#define G_MAXUINT32	((guint32) 0xffffffff)
+
+#define G_MININT64	G_GINT64_CONSTANT(0x8000000000000000)
+#define G_MAXINT64	G_GINT64_CONSTANT(0x7fffffffffffffff)
+#define G_MAXUINT64	G_GINT64_CONSTANT(0xffffffffffffffffU)
+
+typedef void* gpointer;
+typedef const void *gconstpointer;
+
+typedef gint            (*GCompareFunc)         (gconstpointer  a,
+                                                 gconstpointer  b);
+typedef gint            (*GCompareDataFunc)     (gconstpointer  a,
+                                                 gconstpointer  b,
+						 gpointer       user_data);
+typedef gboolean        (*GEqualFunc)           (gconstpointer  a,
+                                                 gconstpointer  b);
+typedef void            (*GDestroyNotify)       (gpointer       data);
+typedef void            (*GFunc)                (gpointer       data,
+                                                 gpointer       user_data);
+typedef guint           (*GHashFunc)            (gconstpointer  key);
+typedef void            (*GHFunc)               (gpointer       key,
+                                                 gpointer       value,
+                                                 gpointer       user_data);
+typedef void            (*GFreeFunc)            (gpointer       data);
+
+/* Define some mathematical constants that aren't available
+ * symbolically in some strict ISO C implementations.
+ */
+#define G_E     2.7182818284590452354E0
+#define G_LN2   6.9314718055994530942E-1
+#define G_LN10  2.3025850929940456840E0
+#define G_PI    3.14159265358979323846E0
+#define G_PI_2  1.57079632679489661923E0
+#define G_PI_4  0.78539816339744830962E0
+#define G_SQRT2 1.4142135623730950488E0
+
+/* Portable endian checks and conversions
+ *
+ * glibconfig.h defines G_BYTE_ORDER which expands to one of
+ * the below macros.
+ */
+#define G_LITTLE_ENDIAN 1234
+#define G_BIG_ENDIAN    4321
+#define G_PDP_ENDIAN    3412		/* unused, need specific PDP check */	
+
+
+/* Basic bit swapping functions
+ */
+#define GUINT16_SWAP_LE_BE_CONSTANT(val)	((guint16) ( \
+    (guint16) ((guint16) (val) &gt;&gt; 8) |	\
+    (guint16) ((guint16) (val) &lt;&lt; 8)))
+
+#define GUINT32_SWAP_LE_BE_CONSTANT(val)	((guint32) ( \
+    (((guint32) (val) &amp; (guint32) 0x000000ffU) &lt;&lt; 24) | \
+    (((guint32) (val) &amp; (guint32) 0x0000ff00U) &lt;&lt;  8) | \
+    (((guint32) (val) &amp; (guint32) 0x00ff0000U) &gt;&gt;  8) | \
+    (((guint32) (val) &amp; (guint32) 0xff000000U) &gt;&gt; 24)))
+
+#define GUINT64_SWAP_LE_BE_CONSTANT(val)	((guint64) ( \
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x00000000000000ffU)) &lt;&lt; 56) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x000000000000ff00U)) &lt;&lt; 40) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x0000000000ff0000U)) &lt;&lt; 24) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x00000000ff000000U)) &lt;&lt;  8) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x000000ff00000000U)) &gt;&gt;  8) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x0000ff0000000000U)) &gt;&gt; 24) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0x00ff000000000000U)) &gt;&gt; 40) |	\
+      (((guint64) (val) &amp;						\
+	(guint64) G_GINT64_CONSTANT (0xff00000000000000U)) &gt;&gt; 56)))
+
+/* Arch specific stuff for speed
+ */
+#if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
+#  if defined (__i386__)
+#    define GUINT16_SWAP_LE_BE_IA32(val) \
+       (__extension__						\
+	({ register guint16 __v, __x = ((guint16) (val));	\
+	   if (__builtin_constant_p (__x))			\
+	     __v = GUINT16_SWAP_LE_BE_CONSTANT (__x);		\
+	   else							\
+	     __asm__ (&quot;rorw $8, %w0&quot;				\
+		      : &quot;=r&quot; (__v)				\
+		      : &quot;0&quot; (__x)				\
+		      : &quot;cc&quot;);					\
+	    __v; }))
+#    if !defined (__i486__) &amp;&amp; !defined (__i586__) \
+	&amp;&amp; !defined (__pentium__) &amp;&amp; !defined (__i686__) \
+	&amp;&amp; !defined (__pentiumpro__) &amp;&amp; !defined (__pentium4__)
+#       define GUINT32_SWAP_LE_BE_IA32(val) \
+	  (__extension__					\
+	   ({ register guint32 __v, __x = ((guint32) (val));	\
+	      if (__builtin_constant_p (__x))			\
+		__v = GUINT32_SWAP_LE_BE_CONSTANT (__x);	\
+	      else						\
+		__asm__ (&quot;rorw $8, %w0\n\t&quot;			\
+			 &quot;rorl $16, %0\n\t&quot;			\
+			 &quot;rorw $8, %w0&quot;				\
+			 : &quot;=r&quot; (__v)				\
+			 : &quot;0&quot; (__x)				\
+			 : &quot;cc&quot;);				\
+	      __v; }))
+#    else /* 486 and higher has bswap */
+#       define GUINT32_SWAP_LE_BE_IA32(val) \
+	  (__extension__					\
+	   ({ register guint32 __v, __x = ((guint32) (val));	\
+	      if (__builtin_constant_p (__x))			\
+		__v = GUINT32_SWAP_LE_BE_CONSTANT (__x);	\
+	      else						\
+		__asm__ (&quot;bswap %0&quot;				\
+			 : &quot;=r&quot; (__v)				\
+			 : &quot;0&quot; (__x));				\
+	      __v; }))
+#    endif /* processor specific 32-bit stuff */
+#    define GUINT64_SWAP_LE_BE_IA32(val) \
+       (__extension__							\
+	({ union { guint64 __ll;					\
+		   guint32 __l[2]; } __w, __r;				\
+	   __w.__ll = ((guint64) (val));				\
+	   if (__builtin_constant_p (__w.__ll))				\
+	     __r.__ll = GUINT64_SWAP_LE_BE_CONSTANT (__w.__ll);		\
+	   else								\
+	     {								\
+	       __r.__l[0] = GUINT32_SWAP_LE_BE (__w.__l[1]);		\
+	       __r.__l[1] = GUINT32_SWAP_LE_BE (__w.__l[0]);		\
+	     }								\
+	   __r.__ll; }))
+     /* Possibly just use the constant version and let gcc figure it out? */
+#    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_IA32 (val))
+#    define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_IA32 (val))
+#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_IA32 (val))
+#  elif defined (__ia64__)
+#    define GUINT16_SWAP_LE_BE_IA64(val) \
+       (__extension__						\
+	({ register guint16 __v, __x = ((guint16) (val));	\
+	   if (__builtin_constant_p (__x))			\
+	     __v = GUINT16_SWAP_LE_BE_CONSTANT (__x);		\
+	   else							\
+	     __asm__ __volatile__ (&quot;shl %0 = %1, 48 ;;&quot;		\
+				   &quot;mux1 %0 = %0, @rev ;;&quot;	\
+				    : &quot;=r&quot; (__v)		\
+				    : &quot;r&quot; (__x));		\
+	    __v; }))
+#    define GUINT32_SWAP_LE_BE_IA64(val) \
+       (__extension__						\
+	 ({ register guint32 __v, __x = ((guint32) (val));	\
+	    if (__builtin_constant_p (__x))			\
+	      __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);		\
+	    else						\
+	     __asm__ __volatile__ (&quot;shl %0 = %1, 32 ;;&quot;		\
+				   &quot;mux1 %0 = %0, @rev ;;&quot;	\
+				    : &quot;=r&quot; (__v)		\
+				    : &quot;r&quot; (__x));		\
+	    __v; }))
+#    define GUINT64_SWAP_LE_BE_IA64(val) \
+       (__extension__						\
+	({ register guint64 __v, __x = ((guint64) (val));	\
+	   if (__builtin_constant_p (__x))			\
+	     __v = GUINT64_SWAP_LE_BE_CONSTANT (__x);		\
+	   else							\
+	     __asm__ __volatile__ (&quot;mux1 %0 = %1, @rev ;;&quot;	\
+				   : &quot;=r&quot; (__v)			\
+				   : &quot;r&quot; (__x));		\
+	   __v; }))
+#    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_IA64 (val))
+#    define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_IA64 (val))
+#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_IA64 (val))
+#  elif defined (__x86_64__)
+#    define GUINT32_SWAP_LE_BE_X86_64(val) \
+       (__extension__						\
+	 ({ register guint32 __v, __x = ((guint32) (val));	\
+	    if (__builtin_constant_p (__x))			\
+	      __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);		\
+	    else						\
+	     __asm__ (&quot;bswapl %0&quot;				\
+		      : &quot;=r&quot; (__v)				\
+		      : &quot;0&quot; (__x));				\
+	    __v; }))
+#    define GUINT64_SWAP_LE_BE_X86_64(val) \
+       (__extension__						\
+	({ register guint64 __v, __x = ((guint64) (val));	\
+	   if (__builtin_constant_p (__x))			\
+	     __v = GUINT64_SWAP_LE_BE_CONSTANT (__x);		\
+	   else							\
+	     __asm__ (&quot;bswapq %0&quot;				\
+		      : &quot;=r&quot; (__v)				\
+		      : &quot;0&quot; (__x));				\
+	   __v; }))
+     /* gcc seems to figure out optimal code for this on its own */
+#    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
+#    define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_X86_64 (val))
+#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_X86_64 (val))
+#  else /* generic gcc */
+#    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
+#    define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))
+#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT (val))
+#  endif
+#else /* generic */
+#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
+#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))
+#  define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT (val))
+#endif /* generic */
+
+#define GUINT16_SWAP_LE_PDP(val)	((guint16) (val))
+#define GUINT16_SWAP_BE_PDP(val)	(GUINT16_SWAP_LE_BE (val))
+#define GUINT32_SWAP_LE_PDP(val)	((guint32) ( \
+    (((guint32) (val) &amp; (guint32) 0x0000ffffU) &lt;&lt; 16) | \
+    (((guint32) (val) &amp; (guint32) 0xffff0000U) &gt;&gt; 16)))
+#define GUINT32_SWAP_BE_PDP(val)	((guint32) ( \
+    (((guint32) (val) &amp; (guint32) 0x00ff00ffU) &lt;&lt; 8) | \
+    (((guint32) (val) &amp; (guint32) 0xff00ff00U) &gt;&gt; 8)))
+
+/* The G*_TO_?E() macros are defined in glibconfig.h.
+ * The transformation is symmetric, so the FROM just maps to the TO.
+ */
+#define GINT16_FROM_LE(val)	(GINT16_TO_LE (val))
+#define GUINT16_FROM_LE(val)	(GUINT16_TO_LE (val))
+#define GINT16_FROM_BE(val)	(GINT16_TO_BE (val))
+#define GUINT16_FROM_BE(val)	(GUINT16_TO_BE (val))
+#define GINT32_FROM_LE(val)	(GINT32_TO_LE (val))
+#define GUINT32_FROM_LE(val)	(GUINT32_TO_LE (val))
+#define GINT32_FROM_BE(val)	(GINT32_TO_BE (val))
+#define GUINT32_FROM_BE(val)	(GUINT32_TO_BE (val))
+
+#define GINT64_FROM_LE(val)	(GINT64_TO_LE (val))
+#define GUINT64_FROM_LE(val)	(GUINT64_TO_LE (val))
+#define GINT64_FROM_BE(val)	(GINT64_TO_BE (val))
+#define GUINT64_FROM_BE(val)	(GUINT64_TO_BE (val))
+
+#define GLONG_FROM_LE(val)	(GLONG_TO_LE (val))
+#define GULONG_FROM_LE(val)	(GULONG_TO_LE (val))
+#define GLONG_FROM_BE(val)	(GLONG_TO_BE (val))
+#define GULONG_FROM_BE(val)	(GULONG_TO_BE (val))
+
+#define GINT_FROM_LE(val)	(GINT_TO_LE (val))
+#define GUINT_FROM_LE(val)	(GUINT_TO_LE (val))
+#define GINT_FROM_BE(val)	(GINT_TO_BE (val))
+#define GUINT_FROM_BE(val)	(GUINT_TO_BE (val))
+
+
+/* Portable versions of host-network order stuff
+ */
+#define g_ntohl(val) (GUINT32_FROM_BE (val))
+#define g_ntohs(val) (GUINT16_FROM_BE (val))
+#define g_htonl(val) (GUINT32_TO_BE (val))
+#define g_htons(val) (GUINT16_TO_BE (val))
+
+/* IEEE Standard 754 Single Precision Storage Format (gfloat):
+ *
+ *        31 30           23 22            0
+ * +--------+---------------+---------------+
+ * | s 1bit | e[30:23] 8bit | f[22:0] 23bit |
+ * +--------+---------------+---------------+
+ * B0-------------------&gt;B1-------&gt;B2--&gt;B3--&gt;
+ *
+ * IEEE Standard 754 Double Precision Storage Format (gdouble):
+ *
+ *        63 62            52 51            32   31            0
+ * +--------+----------------+----------------+ +---------------+
+ * | s 1bit | e[62:52] 11bit | f[51:32] 20bit | | f[31:0] 32bit |
+ * +--------+----------------+----------------+ +---------------+
+ * B0---------------&gt;B1----------&gt;B2---&gt;B3----&gt;  B4-&gt;B5-&gt;B6-&gt;B7-&gt;
+ */
+/* subtract from biased_exponent to form base2 exponent (normal numbers) */
+typedef union  _GDoubleIEEE754	GDoubleIEEE754;
+typedef union  _GFloatIEEE754	GFloatIEEE754;
+#define G_IEEE754_FLOAT_BIAS	(127)
+#define G_IEEE754_DOUBLE_BIAS	(1023)
+/* multiply with base2 exponent to get base10 exponent (normal numbers) */
+#define G_LOG_2_BASE_10		(0.30102999566398119521)
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+union _GFloatIEEE754
+{
+  gfloat v_float;
+  struct {
+    guint mantissa : 23;
+    guint biased_exponent : 8;
+    guint sign : 1;
+  } mpn;
+};
+union _GDoubleIEEE754
+{
+  gdouble v_double;
+  struct {
+    guint mantissa_low : 32;
+    guint mantissa_high : 20;
+    guint biased_exponent : 11;
+    guint sign : 1;
+  } mpn;
+};
+#elif G_BYTE_ORDER == G_BIG_ENDIAN
+union _GFloatIEEE754
+{
+  gfloat v_float;
+  struct {
+    guint sign : 1;
+    guint biased_exponent : 8;
+    guint mantissa : 23;
+  } mpn;
+};
+union _GDoubleIEEE754
+{
+  gdouble v_double;
+  struct {
+    guint sign : 1;
+    guint biased_exponent : 11;
+    guint mantissa_high : 20;
+    guint mantissa_low : 32;
+  } mpn;
+};
+#else /* !G_LITTLE_ENDIAN &amp;&amp; !G_BIG_ENDIAN */
+#error unknown ENDIAN type
+#endif /* !G_LITTLE_ENDIAN &amp;&amp; !G_BIG_ENDIAN */
+
+typedef struct _GTimeVal                GTimeVal;
+
+struct _GTimeVal
+{
+  glong tv_sec;
+  glong tv_usec;
+};
+
+G_END_DECLS
+
+/* We prefix variable declarations so they can
+ * properly get exported in windows dlls.
+ */
+#ifndef GLIB_VAR
+#  ifdef G_PLATFORM_WIN32
+#    ifdef GLIB_STATIC_COMPILATION
+#      define GLIB_VAR extern
+#    else /* !GLIB_STATIC_COMPILATION */
+#      ifdef GLIB_COMPILATION
+#        ifdef DLL_EXPORT
+#          define GLIB_VAR __declspec(dllexport)
+#        else /* !DLL_EXPORT */
+#          define GLIB_VAR extern
+#        endif /* !DLL_EXPORT */
+#      else /* !GLIB_COMPILATION */
+#        define GLIB_VAR extern __declspec(dllimport)
+#      endif /* !GLIB_COMPILATION */
+#    endif /* !GLIB_STATIC_COMPILATION */
+#  else /* !G_PLATFORM_WIN32 */
+#    define GLIB_VAR extern
+#  endif /* !G_PLATFORM_WIN32 */
+#endif /* GLIB_VAR */
+
+#endif /* __G_TYPES_H__ */
+

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gunicode.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gunicode.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gunicode.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,287 @@
+/* gunicode.h - Unicode manipulation functions
+ *
+ *  Copyright (C) 1999, 2000 Tom Tromey
+ *  Copyright 2000 Red Hat, Inc.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *   Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_UNICODE_H__
+#define __G_UNICODE_H__
+
+#include &lt;glib/gerror.h&gt;
+#include &lt;glib/gtypes.h&gt;
+
+G_BEGIN_DECLS
+
+typedef guint32 gunichar;
+typedef guint16 gunichar2;
+
+/* These are the possible character classifications.
+ * See <A HREF="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">http://www.unicode.org/Public/UNIDATA/UnicodeData.html</A>
+ */
+typedef enum
+{
+  G_UNICODE_CONTROL,
+  G_UNICODE_FORMAT,
+  G_UNICODE_UNASSIGNED,
+  G_UNICODE_PRIVATE_USE,
+  G_UNICODE_SURROGATE,
+  G_UNICODE_LOWERCASE_LETTER,
+  G_UNICODE_MODIFIER_LETTER,
+  G_UNICODE_OTHER_LETTER,
+  G_UNICODE_TITLECASE_LETTER,
+  G_UNICODE_UPPERCASE_LETTER,
+  G_UNICODE_COMBINING_MARK,
+  G_UNICODE_ENCLOSING_MARK,
+  G_UNICODE_NON_SPACING_MARK,
+  G_UNICODE_DECIMAL_NUMBER,
+  G_UNICODE_LETTER_NUMBER,
+  G_UNICODE_OTHER_NUMBER,
+  G_UNICODE_CONNECT_PUNCTUATION,
+  G_UNICODE_DASH_PUNCTUATION,
+  G_UNICODE_CLOSE_PUNCTUATION,
+  G_UNICODE_FINAL_PUNCTUATION,
+  G_UNICODE_INITIAL_PUNCTUATION,
+  G_UNICODE_OTHER_PUNCTUATION,
+  G_UNICODE_OPEN_PUNCTUATION,
+  G_UNICODE_CURRENCY_SYMBOL,
+  G_UNICODE_MODIFIER_SYMBOL,
+  G_UNICODE_MATH_SYMBOL,
+  G_UNICODE_OTHER_SYMBOL,
+  G_UNICODE_LINE_SEPARATOR,
+  G_UNICODE_PARAGRAPH_SEPARATOR,
+  G_UNICODE_SPACE_SEPARATOR
+} GUnicodeType;
+
+/* These are the possible line break classifications.
+ * See <A HREF="http://www.unicode.org/unicode/reports/tr14/">http://www.unicode.org/unicode/reports/tr14/</A>
+ */
+typedef enum
+{
+  G_UNICODE_BREAK_MANDATORY,
+  G_UNICODE_BREAK_CARRIAGE_RETURN,
+  G_UNICODE_BREAK_LINE_FEED,
+  G_UNICODE_BREAK_COMBINING_MARK,
+  G_UNICODE_BREAK_SURROGATE,
+  G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
+  G_UNICODE_BREAK_INSEPARABLE,
+  G_UNICODE_BREAK_NON_BREAKING_GLUE,
+  G_UNICODE_BREAK_CONTINGENT,
+  G_UNICODE_BREAK_SPACE,
+  G_UNICODE_BREAK_AFTER,
+  G_UNICODE_BREAK_BEFORE,
+  G_UNICODE_BREAK_BEFORE_AND_AFTER,
+  G_UNICODE_BREAK_HYPHEN,
+  G_UNICODE_BREAK_NON_STARTER,
+  G_UNICODE_BREAK_OPEN_PUNCTUATION,
+  G_UNICODE_BREAK_CLOSE_PUNCTUATION,
+  G_UNICODE_BREAK_QUOTATION,
+  G_UNICODE_BREAK_EXCLAMATION,
+  G_UNICODE_BREAK_IDEOGRAPHIC,
+  G_UNICODE_BREAK_NUMERIC,
+  G_UNICODE_BREAK_INFIX_SEPARATOR,
+  G_UNICODE_BREAK_SYMBOL,
+  G_UNICODE_BREAK_ALPHABETIC,
+  G_UNICODE_BREAK_PREFIX,
+  G_UNICODE_BREAK_POSTFIX,
+  G_UNICODE_BREAK_COMPLEX_CONTEXT,
+  G_UNICODE_BREAK_AMBIGUOUS,
+  G_UNICODE_BREAK_UNKNOWN,
+  G_UNICODE_BREAK_NEXT_LINE,
+  G_UNICODE_BREAK_WORD_JOINER
+} GUnicodeBreakType;
+
+/* Returns TRUE if current locale uses UTF-8 charset.  If CHARSET is
+ * not null, sets *CHARSET to the name of the current locale's
+ * charset.  This value is statically allocated, and should be copied
+ * in case the locale's charset will be changed later using setlocale()
+ * or in some other way.
+ */
+gboolean g_get_charset (G_CONST_RETURN char **charset);
+
+/* These are all analogs of the &lt;ctype.h&gt; functions.
+ */
+gboolean g_unichar_isalnum   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isalpha   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_iscntrl   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isdigit   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isgraph   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_islower   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isprint   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_ispunct   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isspace   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isupper   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isxdigit  (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_istitle   (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_isdefined (gunichar c) G_GNUC_CONST;
+gboolean g_unichar_iswide    (gunichar c) G_GNUC_CONST;
+
+/* More &lt;ctype.h&gt; functions.  These convert between the three cases.
+ * See the Unicode book to understand title case.  */
+gunichar g_unichar_toupper (gunichar c) G_GNUC_CONST;
+gunichar g_unichar_tolower (gunichar c) G_GNUC_CONST;
+gunichar g_unichar_totitle (gunichar c) G_GNUC_CONST;
+
+/* If C is a digit (according to `g_unichar_isdigit'), then return its
+   numeric value.  Otherwise return -1.  */
+gint g_unichar_digit_value (gunichar c) G_GNUC_CONST;
+
+gint g_unichar_xdigit_value (gunichar c) G_GNUC_CONST;
+
+/* Return the Unicode character type of a given character.  */
+GUnicodeType g_unichar_type (gunichar c) G_GNUC_CONST;
+
+/* Return the line break property for a given character */
+GUnicodeBreakType g_unichar_break_type (gunichar c) G_GNUC_CONST;
+
+
+/* Compute canonical ordering of a string in-place.  This rearranges
+   decomposed characters in the string according to their combining
+   classes.  See the Unicode manual for more information.  */
+void g_unicode_canonical_ordering (gunichar *string,
+				   gsize     len);
+
+/* Compute canonical decomposition of a character.  Returns g_malloc()d
+   string of Unicode characters.  RESULT_LEN is set to the resulting
+   length of the string.  */
+gunichar *g_unicode_canonical_decomposition (gunichar  ch,
+					     gsize    *result_len);
+
+/* Array of skip-bytes-per-initial character.
+ */
+GLIB_VAR const gchar * const g_utf8_skip;
+
+#define g_utf8_next_char(p) (char *)((p) + g_utf8_skip[*(guchar *)(p)])
+
+gunichar g_utf8_get_char           (const gchar  *p);
+gunichar g_utf8_get_char_validated (const  gchar *p,
+				    gssize        max_len);
+
+gchar*   g_utf8_offset_to_pointer (const gchar *str,
+                                   glong        offset);  
+glong    g_utf8_pointer_to_offset (const gchar *str,      
+				   const gchar *pos);
+gchar*   g_utf8_prev_char         (const gchar *p);
+gchar*   g_utf8_find_next_char    (const gchar *p,
+				   const gchar *end);
+gchar*   g_utf8_find_prev_char    (const gchar *str,
+				   const gchar *p);
+
+glong g_utf8_strlen (const gchar *p,  
+		     gssize       max);        
+
+/* Copies n characters from src to dest */
+gchar* g_utf8_strncpy (gchar       *dest,
+		       const gchar *src,
+		       gsize        n);
+
+/* Find the UTF-8 character corresponding to ch, in string p. These
+   functions are equivalants to strchr and strrchr */
+gchar* g_utf8_strchr  (const gchar *p,
+		       gssize       len,
+		       gunichar     c);
+gchar* g_utf8_strrchr (const gchar *p,
+		       gssize       len,
+		       gunichar     c);
+gchar* g_utf8_strreverse (const gchar *str,
+			  gssize len);
+
+gunichar2 *g_utf8_to_utf16     (const gchar      *str,
+				glong             len,            
+				glong            *items_read,     
+				glong            *items_written,  
+				GError          **error);
+gunichar * g_utf8_to_ucs4      (const gchar      *str,
+				glong             len,            
+				glong            *items_read,     
+				glong            *items_written,  
+				GError          **error);
+gunichar * g_utf8_to_ucs4_fast (const gchar      *str,
+				glong             len,            
+				glong            *items_written); 
+gunichar * g_utf16_to_ucs4     (const gunichar2  *str,
+				glong             len,            
+				glong            *items_read,     
+				glong            *items_written,  
+				GError          **error);
+gchar*     g_utf16_to_utf8     (const gunichar2  *str,
+				glong             len,            
+				glong            *items_read,     
+				glong            *items_written,  
+				GError          **error);
+gunichar2 *g_ucs4_to_utf16     (const gunichar   *str,
+				glong             len,            
+				glong            *items_read,     
+				glong            *items_written,  
+				GError          **error);
+gchar*     g_ucs4_to_utf8      (const gunichar   *str,
+				glong             len,            
+				glong            *items_read,     
+				glong            *items_written,  
+				GError          **error);
+
+/* Convert a single character into UTF-8. outbuf must have at
+ * least 6 bytes of space. Returns the number of bytes in the
+ * result.
+ */
+gint      g_unichar_to_utf8 (gunichar    c,
+			     gchar      *outbuf);
+
+/* Validate a UTF8 string, return TRUE if valid, put pointer to
+ * first invalid char in **end
+ */
+
+gboolean g_utf8_validate (const gchar  *str,
+                          gssize        max_len,  
+                          const gchar **end);
+
+/* Validate a Unicode character */
+gboolean g_unichar_validate (gunichar ch);
+
+gchar *g_utf8_strup   (const gchar *str,
+		       gssize       len);
+gchar *g_utf8_strdown (const gchar *str,
+		       gssize       len);
+gchar *g_utf8_casefold (const gchar *str,
+			gssize       len);
+
+typedef enum {
+  G_NORMALIZE_DEFAULT,
+  G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
+  G_NORMALIZE_DEFAULT_COMPOSE,
+  G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
+  G_NORMALIZE_ALL,
+  G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
+  G_NORMALIZE_ALL_COMPOSE,
+  G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
+} GNormalizeMode;
+
+gchar *g_utf8_normalize (const gchar   *str,
+			 gssize         len,
+			 GNormalizeMode mode);
+
+gint   g_utf8_collate     (const gchar *str1,
+			   const gchar *str2);
+gchar *g_utf8_collate_key (const gchar *str,
+			   gssize       len);
+
+gboolean g_unichar_get_mirror_char (gunichar ch,
+                                    gunichar *mirrored_ch);
+
+G_END_DECLS
+
+#endif /* __G_UNICODE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gutils.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gutils.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gutils.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,371 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_UTILS_H__
+#define __G_UTILS_H__
+
+#include &lt;glib/gtypes.h&gt;
+#include &lt;stdarg.h&gt;
+
+G_BEGIN_DECLS
+
+#ifdef G_OS_WIN32
+
+/* On native Win32, directory separator is the backslash, and search path
+ * separator is the semicolon.
+ */
+#define G_DIR_SEPARATOR '\\'
+#define G_DIR_SEPARATOR_S &quot;\\&quot;
+#define G_SEARCHPATH_SEPARATOR ';'
+#define G_SEARCHPATH_SEPARATOR_S &quot;;&quot;
+
+#else  /* !G_OS_WIN32 */
+
+/* Unix */
+
+#define G_DIR_SEPARATOR '/'
+#define G_DIR_SEPARATOR_S &quot;/&quot;
+#define G_SEARCHPATH_SEPARATOR ':'
+#define G_SEARCHPATH_SEPARATOR_S &quot;:&quot;
+
+#endif /* !G_OS_WIN32 */
+
+/* Define G_VA_COPY() to do the right thing for copying va_list variables.
+ * glibconfig.h may have already defined G_VA_COPY as va_copy or __va_copy.
+ */
+#if !defined (G_VA_COPY)
+#  if defined (__GNUC__) &amp;&amp; defined (__PPC__) &amp;&amp; (defined (_CALL_SYSV) || defined (_WIN32))
+#    define G_VA_COPY(ap1, ap2)	  (*(ap1) = *(ap2))
+#  elif defined (G_VA_COPY_AS_ARRAY)
+#    define G_VA_COPY(ap1, ap2)	  g_memmove ((ap1), (ap2), sizeof (va_list))
+#  else /* va_list is a pointer */
+#    define G_VA_COPY(ap1, ap2)	  ((ap1) = (ap2))
+#  endif /* va_list is a pointer */
+#endif /* !G_VA_COPY */
+
+/* inlining hassle. for compilers that don't allow the `inline' keyword,
+ * mostly because of strict ANSI C compliance or dumbness, we try to fall
+ * back to either `__inline__' or `__inline'.
+ * we define G_CAN_INLINE, if the compiler seems to be actually
+ * *capable* to do function inlining, in which case inline function bodys
+ * do make sense. we also define G_INLINE_FUNC to properly export the
+ * function prototypes if no inlining can be performed.
+ * inline function bodies have to be special cased with G_CAN_INLINE and a
+ * .c file specific macro to allow one compiled instance with extern linkage
+ * of the functions by defining G_IMPLEMENT_INLINES and the .c file macro.
+ */
+#ifdef G_IMPLEMENT_INLINES
+#  define G_INLINE_FUNC extern
+#  undef  G_CAN_INLINE
+#endif
+#ifndef G_INLINE_FUNC
+#  define G_CAN_INLINE 1
+#endif
+#if defined (G_HAVE_INLINE) &amp;&amp; defined (__GNUC__) &amp;&amp; defined (__STRICT_ANSI__)
+#  undef inline
+#  define inline __inline__
+#elif !defined (G_HAVE_INLINE)
+#  undef inline
+#  if defined (G_HAVE___INLINE__)
+#    define inline __inline__
+#  elif defined (G_HAVE___INLINE)
+#    define inline __inline
+#  else /* !inline &amp;&amp; !__inline__ &amp;&amp; !__inline */
+#    define inline  /* don't inline, then */
+#    ifndef G_INLINE_FUNC
+#      undef G_CAN_INLINE
+#    endif
+#  endif
+#endif
+#ifndef G_INLINE_FUNC
+#  if defined (__GNUC__) &amp;&amp; defined (__OPTIMIZE__)
+#    define G_INLINE_FUNC extern inline
+#  elif defined (G_CAN_INLINE) &amp;&amp; !defined (__GNUC__)
+#    define G_INLINE_FUNC static inline
+#  else /* can't inline */
+#    define G_INLINE_FUNC extern
+#    undef G_CAN_INLINE
+#  endif
+#endif /* !G_INLINE_FUNC */
+
+/* Retrive static string info
+ */
+G_CONST_RETURN gchar* g_get_user_name        (void);
+G_CONST_RETURN gchar* g_get_real_name        (void);
+G_CONST_RETURN gchar* g_get_home_dir         (void);
+G_CONST_RETURN gchar* g_get_tmp_dir          (void);
+gchar*                g_get_prgname          (void);
+void                  g_set_prgname          (const gchar *prgname);
+G_CONST_RETURN gchar* g_get_application_name (void);
+void                  g_set_application_name (const gchar *application_name);
+
+
+typedef struct _GDebugKey	GDebugKey;
+struct _GDebugKey
+{
+  gchar *key;
+  guint	 value;
+};
+
+/* Miscellaneous utility functions
+ */
+guint                 g_parse_debug_string (const gchar     *string,
+					    const GDebugKey *keys,
+					    guint            nkeys);
+
+gint                  g_snprintf           (gchar       *string,
+					    gulong       n,
+					    gchar const *format,
+					    ...) G_GNUC_PRINTF (3, 4);
+gint                  g_vsnprintf          (gchar       *string,
+					    gulong       n,
+					    gchar const *format,
+					    va_list      args);
+
+/* Check if a file name is an absolute path */
+gboolean              g_path_is_absolute   (const gchar *file_name);
+
+/* In case of absolute paths, skip the root part */
+G_CONST_RETURN gchar* g_path_skip_root     (const gchar *file_name);
+
+#ifndef G_DISABLE_DEPRECATED
+
+/* These two functions are deprecated and will be removed in the next
+ * major release of GLib. Use g_path_get_dirname/g_path_get_basename
+ * instead. Whatch out! The string returned by g_path_get_basename
+ * must be g_freed, while the string returned by g_basename must not.*/
+G_CONST_RETURN gchar* g_basename           (const gchar *file_name);
+#define g_dirname g_path_get_dirname
+
+#endif /* G_DISABLE_DEPRECATED */
+
+/* The returned strings are newly allocated with g_malloc() */
+gchar*                g_get_current_dir    (void);
+gchar*                g_path_get_basename  (const gchar *file_name);
+gchar*                g_path_get_dirname   (const gchar *file_name);
+
+
+/* Set the pointer at the specified location to NULL */
+void                  g_nullify_pointer    (gpointer    *nullify_location);
+
+/* return the environment string for the variable. The returned memory
+ * must not be freed. */
+G_CONST_RETURN gchar* g_getenv             (const gchar *variable);
+gboolean              g_setenv             (const gchar *variable,
+					    const gchar *value,
+					    gboolean     overwrite);
+void                  g_unsetenv           (const gchar *variable);
+
+
+/* we try to provide a usefull equivalent for ATEXIT if it is
+ * not defined, but use is actually abandoned. people should
+ * use g_atexit() instead.
+ */
+typedef	void		(*GVoidFunc)		(void);
+#ifndef ATEXIT
+# define ATEXIT(proc)	g_ATEXIT(proc)
+#else
+# define G_NATIVE_ATEXIT
+#endif /* ATEXIT */
+/* we use a GLib function as a replacement for ATEXIT, so
+ * the programmer is not required to check the return value
+ * (if there is any in the implementation) and doesn't encounter
+ * missing include files.
+ */
+void	g_atexit		(GVoidFunc    func);
+
+/* Look for an executable in PATH, following execvp() rules */
+gchar*  g_find_program_in_path  (const gchar *program);
+
+/* Bit tests
+ */
+G_INLINE_FUNC gint	g_bit_nth_lsf (gulong  mask,
+				       gint    nth_bit);
+G_INLINE_FUNC gint	g_bit_nth_msf (gulong  mask,
+				       gint    nth_bit);
+G_INLINE_FUNC guint	g_bit_storage (gulong  number);
+
+/* Trash Stacks
+ * elements need to be &gt;= sizeof (gpointer)
+ */
+typedef struct _GTrashStack     GTrashStack;
+struct _GTrashStack
+{
+  GTrashStack *next;
+};
+
+G_INLINE_FUNC void	g_trash_stack_push	(GTrashStack **stack_p,
+						 gpointer      data_p);
+G_INLINE_FUNC gpointer	g_trash_stack_pop	(GTrashStack **stack_p);
+G_INLINE_FUNC gpointer	g_trash_stack_peek	(GTrashStack **stack_p);
+G_INLINE_FUNC guint	g_trash_stack_height	(GTrashStack **stack_p);
+
+/* inline function implementations
+ */
+#if defined (G_CAN_INLINE) || defined (__G_UTILS_C__)
+G_INLINE_FUNC gint
+g_bit_nth_lsf (gulong mask,
+	       gint   nth_bit)
+{
+  do
+    {
+      nth_bit++;
+      if (mask &amp; (1UL &lt;&lt; nth_bit))
+	return nth_bit;
+    }
+  while (nth_bit &lt; ((GLIB_SIZEOF_LONG * 8) - 1));
+  return -1;
+}
+G_INLINE_FUNC gint
+g_bit_nth_msf (gulong mask,
+	       gint   nth_bit)
+{
+  if (nth_bit &lt; 0)
+    nth_bit = GLIB_SIZEOF_LONG * 8;
+  do
+    {
+      nth_bit--;
+      if (mask &amp; (1UL &lt;&lt; nth_bit))
+	return nth_bit;
+    }
+  while (nth_bit &gt; 0);
+  return -1;
+}
+G_INLINE_FUNC guint
+g_bit_storage (gulong number)
+{
+  register guint n_bits = 0;
+  
+  do
+    {
+      n_bits++;
+      number &gt;&gt;= 1;
+    }
+  while (number);
+  return n_bits;
+}
+G_INLINE_FUNC void
+g_trash_stack_push (GTrashStack **stack_p,
+		    gpointer      data_p)
+{
+  GTrashStack *data = (GTrashStack *) data_p;
+
+  data-&gt;next = *stack_p;
+  *stack_p = data;
+}
+G_INLINE_FUNC gpointer
+g_trash_stack_pop (GTrashStack **stack_p)
+{
+  GTrashStack *data;
+
+  data = *stack_p;
+  if (data)
+    {
+      *stack_p = data-&gt;next;
+      /* NULLify private pointer here, most platforms store NULL as
+       * subsequent 0 bytes
+       */
+      data-&gt;next = NULL;
+    }
+
+  return data;
+}
+G_INLINE_FUNC gpointer
+g_trash_stack_peek (GTrashStack **stack_p)
+{
+  GTrashStack *data;
+
+  data = *stack_p;
+
+  return data;
+}
+G_INLINE_FUNC guint
+g_trash_stack_height (GTrashStack **stack_p)
+{
+  GTrashStack *data;
+  guint i = 0;
+
+  for (data = *stack_p; data; data = data-&gt;next)
+    i++;
+
+  return i;
+}
+#endif  /* G_CAN_INLINE || __G_UTILS_C__ */
+
+/* Glib version.
+ * we prefix variable declarations so they can
+ * properly get exported in windows dlls.
+ */
+GLIB_VAR const guint glib_major_version;
+GLIB_VAR const guint glib_minor_version;
+GLIB_VAR const guint glib_micro_version;
+GLIB_VAR const guint glib_interface_age;
+GLIB_VAR const guint glib_binary_age;
+
+#define GLIB_CHECK_VERSION(major,minor,micro)    \
+    (GLIB_MAJOR_VERSION &gt; (major) || \
+     (GLIB_MAJOR_VERSION == (major) &amp;&amp; GLIB_MINOR_VERSION &gt; (minor)) || \
+     (GLIB_MAJOR_VERSION == (major) &amp;&amp; GLIB_MINOR_VERSION == (minor) &amp;&amp; \
+      GLIB_MICRO_VERSION &gt;= (micro)))
+
+G_END_DECLS
+
+/*
+ * On Windows, this macro defines a DllMain function that stores the
+ * actual DLL name that the code being compiled will be included in.
+ * STATIC should be empty or 'static'. DLL_NAME is the name of the
+ * (pointer to the) char array where the DLL name will be stored. If
+ * this is used, you must also include &lt;windows.h&gt;. If you need a more complex
+ * DLL entry point function, you cannot use this.
+ *
+ * On non-Windows platforms, expands to nothing.
+ */
+
+#ifndef G_PLATFORM_WIN32
+# define G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name)
+#else
+# define G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name)			   \
+static char *dll_name;							   \
+									   \
+BOOL WINAPI								   \
+DllMain (HINSTANCE hinstDLL,						   \
+	 DWORD     fdwReason,						   \
+	 LPVOID    lpvReserved)						   \
+{									   \
+  char bfr[1000];							   \
+  switch (fdwReason)							   \
+    {									   \
+    case DLL_PROCESS_ATTACH:						   \
+      GetModuleFileName ((HMODULE) hinstDLL, bfr, sizeof (bfr));	   \
+      dll_name = g_path_get_basename (bfr);				   \
+      break;								   \
+    }									   \
+									   \
+  return TRUE;								   \
+}
+#endif /* G_PLATFORM_WIN32 */
+
+#endif /* __G_UTILS_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gwin32.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gwin32.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib/gwin32.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,100 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_WIN32_H__
+#define __G_WIN32_H__
+
+#include &lt;glib/gtypes.h&gt;
+
+#ifdef G_PLATFORM_WIN32
+
+/* Windows emulation stubs for common Unix functions
+ */
+
+G_BEGIN_DECLS
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+#ifdef _MSC_VER
+typedef int pid_t;
+#endif
+
+#ifdef G_OS_WIN32
+
+/*
+ * To get prototypes for the following POSIXish functions, you have to
+ * include the indicated non-POSIX headers. The functions are defined
+ * in OLDNAMES.LIB (MSVC) or -lmoldname-msvc (mingw32).
+ *
+ * getcwd: &lt;direct.h&gt; (MSVC), &lt;io.h&gt; (mingw32)
+ * getpid: &lt;process.h&gt;
+ * access: &lt;io.h&gt;
+ * unlink: &lt;stdio.h&gt; or &lt;io.h&gt;
+ * open, read, write, lseek, close: &lt;io.h&gt;
+ * rmdir: &lt;io.h&gt;
+ * pipe: &lt;io.h&gt;
+ */
+
+/* pipe is not in OLDNAMES.LIB or -lmoldname-msvc. */
+#define pipe(phandles)	_pipe (phandles, 4096, _O_BINARY)
+
+/* For some POSIX functions that are not provided by the MS runtime,
+ * we provide emulators in glib, which are prefixed with g_win32_.
+ */
+#    define ftruncate(fd, size)	g_win32_ftruncate (fd, size)
+
+gint		g_win32_ftruncate	(gint		 f,
+					 guint		 size);
+#endif /* G_OS_WIN32 */
+
+/* The MS setlocale uses locale names of the form &quot;English_United
+ * States.1252&quot; etc. We want the Unixish standard form &quot;en&quot;, &quot;zh_TW&quot;
+ * etc. This function gets the current thread locale from Windows and
+ * returns it as a string of the above form for use in forming file
+ * names etc. The returned string should be deallocated with g_free().
+ */
+gchar* 		g_win32_getlocale  (void);
+
+/* Translate a Win32 error code (as returned by GetLastError()) into
+ * the corresponding message. The returned string should be deallocated
+ * with g_free().
+ */
+gchar*          g_win32_error_message (gint error);
+
+gchar*          g_win32_get_package_installation_directory (gchar *package,
+							    gchar *dll_name);
+
+gchar*          g_win32_get_package_installation_subdirectory (gchar *package,
+							       gchar *dll_name,
+							       gchar *subdir);
+
+G_END_DECLS
+
+#endif	 /* G_PLATFORM_WIN32 */
+
+#endif /* __G_WIN32_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib-object.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib-object.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib-object.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,41 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998, 1999, 2000 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __GLIB_GOBJECT_H__
+#define __GLIB_GOBJECT_H__
+
+#define __GLIB_GOBJECT_H_INSIDE__
+
+/* topmost include file for GObject header files */
+#include	&lt;gobject/gboxed.h&gt;
+#include	&lt;gobject/genums.h&gt;
+#include	&lt;gobject/gobject.h&gt;
+#include	&lt;gobject/gparam.h&gt;
+#include	&lt;gobject/gparamspecs.h&gt;
+#include	&lt;gobject/gsignal.h&gt;
+#include	&lt;gobject/gsourceclosure.h&gt;
+#include	&lt;gobject/gtype.h&gt;
+#include	&lt;gobject/gtypemodule.h&gt;
+#include	&lt;gobject/gtypeplugin.h&gt;
+#include	&lt;gobject/gvalue.h&gt;
+#include	&lt;gobject/gvaluearray.h&gt;
+#include	&lt;gobject/gvaluetypes.h&gt;
+
+#undef __GLIB_GOBJECT_H_INSIDE__
+
+#endif /* __GLIB_GOBJECT_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glib.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,77 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __G_LIB_H__
+#define __G_LIB_H__
+
+#include &lt;glib/galloca.h&gt;
+#include &lt;glib/garray.h&gt;
+#include &lt;glib/gasyncqueue.h&gt;
+#include &lt;glib/gatomic.h&gt;
+#include &lt;glib/gbacktrace.h&gt;
+#include &lt;glib/gcache.h&gt;
+#include &lt;glib/gcompletion.h&gt;
+#include &lt;glib/gconvert.h&gt;
+#include &lt;glib/gdataset.h&gt;
+#include &lt;glib/gdate.h&gt;
+#include &lt;glib/gdir.h&gt;
+#include &lt;glib/gerror.h&gt;
+#include &lt;glib/gfileutils.h&gt;
+#include &lt;glib/ghash.h&gt;
+#include &lt;glib/ghook.h&gt;
+#include &lt;glib/giochannel.h&gt;
+#include &lt;glib/glist.h&gt;
+#include &lt;glib/gmacros.h&gt;
+#include &lt;glib/gmain.h&gt;
+#include &lt;glib/gmarkup.h&gt;
+#include &lt;glib/gmem.h&gt;
+#include &lt;glib/gmessages.h&gt;
+#include &lt;glib/gnode.h&gt;
+#include &lt;glib/gpattern.h&gt;
+#include &lt;glib/gprimes.h&gt;
+#include &lt;glib/gqsort.h&gt;
+#include &lt;glib/gquark.h&gt;
+#include &lt;glib/gqueue.h&gt;
+#include &lt;glib/grand.h&gt;
+#include &lt;glib/grel.h&gt;
+#include &lt;glib/gscanner.h&gt;
+#include &lt;glib/gshell.h&gt;
+#include &lt;glib/gslist.h&gt;
+#include &lt;glib/gspawn.h&gt;
+#include &lt;glib/gstrfuncs.h&gt;
+#include &lt;glib/gstring.h&gt;
+#include &lt;glib/gthread.h&gt;
+#include &lt;glib/gthreadpool.h&gt;
+#include &lt;glib/gtimer.h&gt;
+#include &lt;glib/gtree.h&gt;
+#include &lt;glib/gtypes.h&gt;
+#include &lt;glib/gunicode.h&gt;
+#include &lt;glib/gutils.h&gt;
+#ifdef G_PLATFORM_WIN32
+#include &lt;glib/gwin32.h&gt;
+#endif
+
+#endif /* __G_LIB_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glibconfig.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glibconfig.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/glibconfig.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,188 @@
+/* glibconfig.h.win32.in Merged from two versions generated by configure for gcc and MSVC.  */
+/* glibconfig.h
+ *
+ * This is a generated file.  Please modify 'configure.in'
+ */
+
+#ifndef __G_LIBCONFIG_H__
+#define __G_LIBCONFIG_H__
+
+#include &lt;glib/gmacros.h&gt;
+
+#include &lt;limits.h&gt;
+#include &lt;float.h&gt;
+
+G_BEGIN_DECLS
+
+#define G_MINFLOAT	FLT_MIN
+#define G_MAXFLOAT	FLT_MAX
+#define G_MINDOUBLE	DBL_MIN
+#define G_MAXDOUBLE	DBL_MAX
+#define G_MINSHORT	SHRT_MIN
+#define G_MAXSHORT	SHRT_MAX
+#define G_MAXUSHORT	USHRT_MAX
+#define G_MININT	INT_MIN
+#define G_MAXINT	INT_MAX
+#define G_MAXUINT	UINT_MAX
+#define G_MINLONG	LONG_MIN
+#define G_MAXLONG	LONG_MAX
+#define G_MAXULONG	ULONG_MAX
+
+typedef signed char gint8;
+typedef unsigned char guint8;
+typedef signed short gint16;
+typedef unsigned short guint16;
+#define G_GINT16_MODIFIER &quot;h&quot;
+#define G_GINT16_FORMAT &quot;hi&quot;
+#define G_GUINT16_FORMAT &quot;hu&quot;
+typedef signed int gint32;
+typedef unsigned int guint32;
+#define G_GINT32_MODIFIER &quot;&quot;
+#define G_GINT32_FORMAT &quot;i&quot;
+#define G_GUINT32_FORMAT &quot;u&quot;
+#define G_HAVE_GINT64 1          /* deprecated, always true */
+
+#ifndef _MSC_VER
+G_GNUC_EXTENSION typedef signed long long gint64;
+G_GNUC_EXTENSION typedef unsigned long long guint64;
+#else /* _MSC_VER */
+typedef signed __int64 gint64;
+typedef unsigned __int64 guint64;
+#endif /* _MSC_VER */
+
+#ifndef _MSC_VER
+#define G_GINT64_CONSTANT(val)	(G_GNUC_EXTENSION (val##LL))
+#else /* _MSC_VER */
+#define G_GINT64_CONSTANT(val)	(val##i64)
+#endif /* _MSC_VER */
+#define G_GINT64_MODIFIER &quot;I64&quot;
+#define G_GINT64_FORMAT &quot;I64i&quot;
+#define G_GUINT64_FORMAT &quot;I64u&quot;
+
+#define GLIB_SIZEOF_VOID_P 4
+#define GLIB_SIZEOF_LONG   4
+#define GLIB_SIZEOF_SIZE_T 4
+
+typedef signed int gssize;
+typedef unsigned int gsize;
+#define G_GSIZE_MODIFIER &quot;&quot;
+#define G_GSSIZE_FORMAT &quot;i&quot;
+#define G_GSIZE_FORMAT &quot;u&quot;
+
+#define G_MAXSIZE	G_MAXUINT
+
+#define GPOINTER_TO_INT(p)	((gint)   (p))
+#define GPOINTER_TO_UINT(p)	((guint)  (p))
+
+#define GINT_TO_POINTER(i)	((gpointer)  (i))
+#define GUINT_TO_POINTER(u)	((gpointer)  (u))
+
+#ifdef NeXT /* @#%@! NeXTStep */
+# define g_ATEXIT(proc)	(!atexit (proc))
+#else
+# define g_ATEXIT(proc)	(atexit (proc))
+#endif
+
+#define g_memmove(d,s,n) G_STMT_START { memmove ((d), (s), (n)); } G_STMT_END
+
+#define GLIB_MAJOR_VERSION 2
+#define GLIB_MINOR_VERSION 4
+#define GLIB_MICRO_VERSION 5
+
+#define G_OS_WIN32
+#define G_PLATFORM_WIN32
+
+#ifndef _MSC_VER
+#define G_VA_COPY	va_copy
+#endif /* not _MSC_VER */
+
+#ifdef	__cplusplus
+#define	G_HAVE_INLINE	1
+#else	/* !__cplusplus */
+#ifndef _MSC_VER
+#define G_HAVE_INLINE 1
+#else /* _MSC_VER */
+
+#endif /* _MSC_VER */
+#define G_HAVE___INLINE 1
+#ifndef _MSC_VER
+#define G_HAVE___INLINE__ 1
+#endif /* not _MSC_VER */
+#endif	/* !__cplusplus */
+
+#ifndef _MSC_VER
+#ifndef __cplusplus
+# define G_HAVE_ISO_VARARGS 1
+#endif
+#ifdef __cplusplus
+# define G_HAVE_ISO_VARARGS 1
+#endif
+
+/* gcc-2.95.x supports both gnu style and ISO varargs, but if -ansi
+ * is passed ISO vararg support is turned off, and there is no work
+ * around to turn it on, so we unconditionally turn it off.
+ */
+#if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ == 95
+#  undef G_HAVE_ISO_VARARGS
+#endif
+
+#define G_HAVE_GNUC_VARARGS 1
+#endif /* not _MSC_VER */
+#define G_HAVE_GROWING_STACK 0
+
+
+#define G_THREADS_ENABLED
+#define G_THREADS_IMPL_WIN32
+typedef struct _GMutex* GStaticMutex;
+#define G_STATIC_MUTEX_INIT NULL
+#define g_static_mutex_get_mutex(mutex) \
+  (g_static_mutex_get_mutex_impl_shortcut (mutex))
+/* This represents a system thread as used by the implementation. An
+ * alien implementaion, as loaded by g_thread_init can only count on
+ * &quot;sizeof (gpointer)&quot; bytes to store their info. We however need more
+ * for some of our native implementations. */
+typedef union _GSystemThread GSystemThread;
+union _GSystemThread
+{
+  char   data[4];
+  double dummy_double;
+  void  *dummy_pointer;
+  long   dummy_long;
+};
+
+#define GINT16_TO_LE(val)	((gint16) (val))
+#define GUINT16_TO_LE(val)	((guint16) (val))
+#define GINT16_TO_BE(val)	((gint16) GUINT16_SWAP_LE_BE (val))
+#define GUINT16_TO_BE(val)	(GUINT16_SWAP_LE_BE (val))
+#define GINT32_TO_LE(val)	((gint32) (val))
+#define GUINT32_TO_LE(val)	((guint32) (val))
+#define GINT32_TO_BE(val)	((gint32) GUINT32_SWAP_LE_BE (val))
+#define GUINT32_TO_BE(val)	(GUINT32_SWAP_LE_BE (val))
+#define GINT64_TO_LE(val)	((gint64) (val))
+#define GUINT64_TO_LE(val)	((guint64) (val))
+#define GINT64_TO_BE(val)	((gint64) GUINT64_SWAP_LE_BE (val))
+#define GUINT64_TO_BE(val)	(GUINT64_SWAP_LE_BE (val))
+#define GLONG_TO_LE(val)	((glong) GINT32_TO_LE (val))
+#define GULONG_TO_LE(val)	((gulong) GUINT32_TO_LE (val))
+#define GLONG_TO_BE(val)	((glong) GINT32_TO_BE (val))
+#define GULONG_TO_BE(val)	((gulong) GUINT32_TO_BE (val))
+#define GINT_TO_LE(val)		((gint) GINT32_TO_LE (val))
+#define GUINT_TO_LE(val)	((guint) GUINT32_TO_LE (val))
+#define GINT_TO_BE(val)		((gint) GINT32_TO_BE (val))
+#define GUINT_TO_BE(val)	((guint) GUINT32_TO_BE (val))
+#define G_BYTE_ORDER G_LITTLE_ENDIAN
+
+#define GLIB_SYSDEF_POLLIN =1
+#define GLIB_SYSDEF_POLLOUT =4
+#define GLIB_SYSDEF_POLLPRI =2
+#define GLIB_SYSDEF_POLLHUP =16
+#define GLIB_SYSDEF_POLLERR =8
+#define GLIB_SYSDEF_POLLNVAL =32
+
+#define G_MODULE_SUFFIX &quot;dll&quot;
+
+typedef void * GPid;
+
+G_END_DECLS
+
+#endif /* GLIBCONFIG_H */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gmodule.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gmodule.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gmodule.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,96 @@
+/* GMODULE - GLIB wrapper code for dynamic module loading
+ * Copyright (C) 1998 Tim Janik
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at <A HREF="ftp://ftp.gtk.org/pub/gtk/.">ftp://ftp.gtk.org/pub/gtk/.</A> 
+ */
+
+#ifndef __GMODULE_H__
+#define __GMODULE_H__
+
+#include &lt;glib.h&gt;
+
+G_BEGIN_DECLS
+
+/* exporting and importing functions, this is special cased
+ * to feature Windows dll stubs.
+ */
+#define	G_MODULE_IMPORT		extern
+#ifdef G_PLATFORM_WIN32
+#  define	G_MODULE_EXPORT		__declspec(dllexport)
+#else /* !G_PLATFORM_WIN32 */
+#  define	G_MODULE_EXPORT
+#endif /* !G_PLATFORM_WIN32 */
+
+typedef enum
+{
+  G_MODULE_BIND_LAZY	= 1 &lt;&lt; 0,
+  G_MODULE_BIND_LOCAL	= 1 &lt;&lt; 1,
+  G_MODULE_BIND_MASK	= 0x03
+} GModuleFlags;
+
+typedef	struct _GModule			 GModule;
+typedef const gchar* (*GModuleCheckInit) (GModule	*module);
+typedef void	     (*GModuleUnload)	 (GModule	*module);
+
+/* return TRUE if dynamic module loading is supported */
+gboolean	g_module_supported	   (void) G_GNUC_CONST;
+
+/* open a module `file_name' and return handle, which is NULL on error */
+GModule*              g_module_open          (const gchar  *file_name,
+					      GModuleFlags  flags);
+
+/* close a previously opened module, returns TRUE on success */
+gboolean              g_module_close         (GModule      *module);
+
+/* make a module resident so g_module_close on it will be ignored */
+void                  g_module_make_resident (GModule      *module);
+
+/* query the last module error as a string */
+G_CONST_RETURN gchar* g_module_error         (void);
+
+/* retrieve a symbol pointer from `module', returns TRUE on success */
+gboolean              g_module_symbol        (GModule      *module,
+					      const gchar  *symbol_name,
+					      gpointer     *symbol);
+
+/* retrieve the file name from an existing module */
+G_CONST_RETURN gchar* g_module_name          (GModule      *module);
+
+/* Build the actual file name containing a module. `directory' is the
+ * directory where the module file is supposed to be, or NULL or empty
+ * in which case it should either be in the current directory or, on
+ * some operating systems, in some standard place, for instance on the
+ * PATH. Hence, to be absoultely sure to get the correct module,
+ * always pass in a directory. The file name consists of the directory,
+ * if supplied, and `module_name' suitably decorated accoring to
+ * the operating system's conventions (for instance lib*.so or *.dll).
+ *
+ * No checks are made that the file exists, or is of correct type.
+ */
+gchar*                g_module_build_path    (const gchar  *directory,
+					      const gchar  *module_name);
+
+
+G_END_DECLS
+
+#endif /* __GMODULE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gboxed.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gboxed.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gboxed.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,83 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2000-2001 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_BOXED_H__
+#define __G_BOXED_H__
+
+#include        &lt;gobject/gtype.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define G_TYPE_IS_BOXED(type)	   (G_TYPE_FUNDAMENTAL (type) == G_TYPE_BOXED)
+#define G_VALUE_HOLDS_BOXED(value) (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_BOXED))
+
+
+/* --- typedefs --- */
+typedef gpointer (*GBoxedCopyFunc)	(gpointer	 boxed);
+typedef void     (*GBoxedFreeFunc)	(gpointer	 boxed);
+
+
+/* --- prototypes --- */
+gpointer	g_boxed_copy			(GType		 boxed_type,
+						 gconstpointer	 src_boxed);
+void		g_boxed_free			(GType		 boxed_type,
+						 gpointer	 boxed);
+void		g_value_set_boxed		(GValue		*value,
+						 gconstpointer	 v_boxed);
+void		g_value_set_static_boxed	(GValue		*value,
+						 gconstpointer	 v_boxed);
+gpointer	g_value_get_boxed		(const GValue	*value);
+gpointer	g_value_dup_boxed		(const GValue	*value);
+
+
+/* --- convenience --- */
+GType	g_boxed_type_register_static		(const gchar	*name,
+						 GBoxedCopyFunc	 boxed_copy,
+						 GBoxedFreeFunc	 boxed_free);
+
+
+/* --- GLib boxed types --- */
+#define	G_TYPE_CLOSURE		(g_closure_get_type ())
+#define	G_TYPE_VALUE		(g_value_get_type ())
+#define	G_TYPE_VALUE_ARRAY	(g_value_array_get_type ())
+#define	G_TYPE_STRV	        (g_strv_get_type ())
+#define	G_TYPE_GSTRING		(g_gstring_get_type ())
+
+
+void    g_value_take_boxed      (GValue		*value,
+				 gconstpointer	 v_boxed);
+#ifndef G_DISABLE_DEPRECATED
+void	g_value_set_boxed_take_ownership	(GValue		*value,
+						 gconstpointer	 v_boxed);
+#endif
+GType	g_closure_get_type	(void)	G_GNUC_CONST;
+GType	g_value_get_type	(void)	G_GNUC_CONST;
+GType	g_value_array_get_type	(void)	G_GNUC_CONST;
+GType	g_strv_get_type	        (void)	G_GNUC_CONST;
+GType	g_gstring_get_type      (void)	G_GNUC_CONST;
+
+typedef gchar** GStrv;
+     
+G_END_DECLS
+
+#endif	/* __G_BOXED_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gclosure.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gclosure.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gclosure.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,162 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2000-2001 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_CLOSURE_H__
+#define __G_CLOSURE_H__
+
+#include        &lt;gobject/gtype.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- defines --- */
+#define	G_CLOSURE_NEEDS_MARSHAL(closure) (((GClosure*) (closure))-&gt;marshal == NULL)
+#define	G_CLOSURE_N_NOTIFIERS(cl)	 ((cl)-&gt;meta_marshal + ((cl)-&gt;n_guards &lt;&lt; 1L) + \
+                                          (cl)-&gt;n_fnotifiers + (cl)-&gt;n_inotifiers)
+#define	G_CCLOSURE_SWAP_DATA(cclosure)	 (((GClosure*) (closure))-&gt;derivative_flag)
+#define	G_CALLBACK(f)			 ((GCallback) (f))
+
+
+/* -- typedefs --- */
+typedef struct _GClosure		 GClosure;
+typedef struct _GClosureNotifyData	 GClosureNotifyData;
+typedef void  (*GCallback)              (void);
+typedef void  (*GClosureNotify)		(gpointer	 data,
+					 GClosure	*closure);
+typedef void  (*GClosureMarshal)	(GClosure	*closure,
+					 GValue         *return_value,
+					 guint           n_param_values,
+					 const GValue   *param_values,
+					 gpointer        invocation_hint,
+					 gpointer	 marshal_data);
+typedef struct _GCClosure		 GCClosure;
+
+
+/* --- structures --- */
+struct _GClosureNotifyData
+{
+  gpointer       data;
+  GClosureNotify notify;
+};
+struct _GClosure
+{
+  /*&lt; private &gt;*/	guint	 ref_count : 15;
+  /*&lt; private &gt;*/	guint	 meta_marshal : 1;
+  /*&lt; private &gt;*/	guint	 n_guards : 1;
+  /*&lt; private &gt;*/	guint	 n_fnotifiers : 2;	/* finalization notifiers */
+  /*&lt; private &gt;*/	guint	 n_inotifiers : 8;	/* invalidation notifiers */
+  /*&lt; private &gt;*/	guint	 in_inotify : 1;
+  /*&lt; private &gt;*/	guint	 floating : 1;
+  /*&lt; protected &gt;*/	guint	 derivative_flag : 1;
+  /*&lt; public &gt;*/	guint	 in_marshal : 1;
+  /*&lt; public &gt;*/	guint	 is_invalid : 1;
+
+  /*&lt; private &gt;*/	void   (*marshal)  (GClosure       *closure,
+					    GValue /*out*/ *return_value,
+					    guint           n_param_values,
+					    const GValue   *param_values,
+					    gpointer        invocation_hint,
+					    gpointer	    marshal_data);
+  /*&lt; protected &gt;*/	gpointer data;
+
+  /*&lt; private &gt;*/	GClosureNotifyData *notifiers;
+
+  /* invariants/constrains:
+   * - -&gt;marshal and -&gt;data are _invalid_ as soon as -&gt;is_invalid==TRUE
+   * - invocation of all inotifiers occours prior to fnotifiers
+   * - order of inotifiers is random
+   *   inotifiers may _not_ free/invalidate parameter values (e.g. -&gt;data)
+   * - order of fnotifiers is random
+   * - each notifier may only be removed before or during its invocation
+   * - reference counting may only happen prior to fnotify invocation
+   *   (in that sense, fnotifiers are really finalization handlers)
+   */
+};
+/* closure for C function calls, callback() is the user function
+ */
+struct _GCClosure
+{
+  GClosure	closure;
+  gpointer	callback;
+};
+
+
+/* --- prototypes --- */
+GClosure* g_cclosure_new			(GCallback	callback_func,
+						 gpointer	user_data,
+						 GClosureNotify destroy_data);
+GClosure* g_cclosure_new_swap			(GCallback	callback_func,
+						 gpointer	user_data,
+						 GClosureNotify destroy_data);
+GClosure* g_signal_type_cclosure_new		(GType          itype,
+						 guint          struct_offset);
+
+
+/* --- prototypes --- */
+GClosure* g_closure_ref				(GClosure	*closure);
+void	  g_closure_sink			(GClosure	*closure);
+void	  g_closure_unref			(GClosure	*closure);
+/* intimidating */
+GClosure* g_closure_new_simple			(guint		 sizeof_closure,
+						 gpointer	 data);
+void	  g_closure_add_finalize_notifier	(GClosure       *closure,
+						 gpointer	 notify_data,
+						 GClosureNotify	 notify_func);
+void	  g_closure_remove_finalize_notifier	(GClosure       *closure,
+						 gpointer	 notify_data,
+						 GClosureNotify	 notify_func);
+void	  g_closure_add_invalidate_notifier	(GClosure       *closure,
+						 gpointer	 notify_data,
+						 GClosureNotify	 notify_func);
+void	  g_closure_remove_invalidate_notifier	(GClosure       *closure,
+						 gpointer	 notify_data,
+						 GClosureNotify	 notify_func);
+void	  g_closure_add_marshal_guards		(GClosure	*closure,
+						 gpointer        pre_marshal_data,
+						 GClosureNotify	 pre_marshal_notify,
+						 gpointer        post_marshal_data,
+						 GClosureNotify	 post_marshal_notify);
+void	  g_closure_set_marshal			(GClosure	*closure,
+						 GClosureMarshal marshal);
+void	  g_closure_set_meta_marshal		(GClosure       *closure,
+						 gpointer	 marshal_data,
+						 GClosureMarshal meta_marshal);
+void	  g_closure_invalidate			(GClosure	*closure);
+void	  g_closure_invoke			(GClosure 	*closure,
+						 GValue	/*out*/	*return_value,
+						 guint		 n_param_values,
+						 const GValue	*param_values,
+						 gpointer	 invocation_hint);
+
+/* FIXME:
+   OK:  data_object::destroy		-&gt; closure_invalidate();
+   MIS:	closure_invalidate()		-&gt; disconnect(closure);
+   MIS:	disconnect(closure)		-&gt; (unlink) closure_unref();
+   OK:	closure_finalize()		-&gt; g_free (data_string);
+
+   random remarks:
+   - need marshaller repo with decent aliasing to base types
+   - provide marshaller collection, virtually covering anything out there
+*/
+
+G_END_DECLS
+
+#endif /* __G_CLOSURE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/genums.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/genums.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/genums.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,125 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_ENUMS_H__
+#define __G_ENUMS_H__
+
+#include &lt;gobject/gtype.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define G_TYPE_IS_ENUM(type)	       (G_TYPE_FUNDAMENTAL (type) == G_TYPE_ENUM)
+#define G_ENUM_CLASS(class)	       (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_ENUM, GEnumClass))
+#define G_IS_ENUM_CLASS(class)	       (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_ENUM))
+#define G_ENUM_CLASS_TYPE(class)       (G_TYPE_FROM_CLASS (class))
+#define G_ENUM_CLASS_TYPE_NAME(class)  (g_type_name (G_ENUM_CLASS_TYPE (class)))
+#define G_TYPE_IS_FLAGS(type)	       (G_TYPE_FUNDAMENTAL (type) == G_TYPE_FLAGS)
+#define G_FLAGS_CLASS(class)	       (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_FLAGS, GFlagsClass))
+#define G_IS_FLAGS_CLASS(class)        (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_FLAGS))
+#define G_FLAGS_CLASS_TYPE(class)      (G_TYPE_FROM_CLASS (class))
+#define G_FLAGS_CLASS_TYPE_NAME(class) (g_type_name (G_FLAGS_TYPE (class)))
+#define G_VALUE_HOLDS_ENUM(value)      (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_ENUM))
+#define G_VALUE_HOLDS_FLAGS(value)     (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_FLAGS))
+
+
+/* --- enum/flag values &amp; classes --- */
+typedef struct _GEnumClass  GEnumClass;
+typedef struct _GFlagsClass GFlagsClass;
+typedef struct _GEnumValue  GEnumValue;
+typedef struct _GFlagsValue GFlagsValue;
+struct	_GEnumClass
+{
+  GTypeClass  g_type_class;
+
+  /*&lt; public &gt;*/  
+  gint	      minimum;
+  gint	      maximum;
+  guint	      n_values;
+  GEnumValue *values;
+};
+struct	_GFlagsClass
+{
+  GTypeClass   g_type_class;
+  
+  /*&lt; public &gt;*/  
+  guint	       mask;
+  guint	       n_values;
+  GFlagsValue *values;
+};
+struct _GEnumValue
+{
+  gint	 value;
+  gchar *value_name;
+  gchar *value_nick;
+};
+struct _GFlagsValue
+{
+  guint	 value;
+  gchar *value_name;
+  gchar *value_nick;
+};
+
+
+/* --- prototypes --- */
+GEnumValue*	g_enum_get_value		(GEnumClass	*enum_class,
+						 gint		 value);
+GEnumValue*	g_enum_get_value_by_name	(GEnumClass	*enum_class,
+						 const gchar	*name);
+GEnumValue*	g_enum_get_value_by_nick	(GEnumClass	*enum_class,
+						 const gchar	*nick);
+GFlagsValue*	g_flags_get_first_value		(GFlagsClass	*flags_class,
+						 guint		 value);
+GFlagsValue*	g_flags_get_value_by_name	(GFlagsClass	*flags_class,
+						 const gchar	*name);
+GFlagsValue*	g_flags_get_value_by_nick	(GFlagsClass	*flags_class,
+						 const gchar	*nick);
+void            g_value_set_enum        	(GValue         *value,
+						 gint            v_enum);
+gint            g_value_get_enum        	(const GValue   *value);
+void            g_value_set_flags       	(GValue         *value,
+						 guint           v_flags);
+guint           g_value_get_flags       	(const GValue   *value);
+
+
+
+/* --- registration functions --- */
+/* const_static_values is a NULL terminated array of enum/flags
+ * values that is taken over!
+ */
+GType	g_enum_register_static	   (const gchar	      *name,
+				    const GEnumValue  *const_static_values);
+GType	g_flags_register_static	   (const gchar	      *name,
+				    const GFlagsValue *const_static_values);
+/* functions to complete the type information
+ * for enums/flags implemented by plugins
+ */
+void	g_enum_complete_type_info  (GType	       g_enum_type,
+				    GTypeInfo	      *info,
+				    const GEnumValue  *const_values);
+void	g_flags_complete_type_info (GType	       g_flags_type,
+				    GTypeInfo	      *info,
+				    const GFlagsValue *const_values);
+
+G_END_DECLS
+
+#endif /* __G_ENUMS_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gmarshal.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gmarshal.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gmarshal.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,169 @@
+#ifndef __G_MARSHAL_H__
+#define __G_MARSHAL_H__
+
+G_BEGIN_DECLS
+
+/* VOID:VOID (./gmarshal.list:26) */
+extern void g_cclosure_marshal_VOID__VOID (GClosure     *closure,
+                                           GValue       *return_value,
+                                           guint         n_param_values,
+                                           const GValue *param_values,
+                                           gpointer      invocation_hint,
+                                           gpointer      marshal_data);
+
+/* VOID:BOOLEAN (./gmarshal.list:27) */
+extern void g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
+                                              GValue       *return_value,
+                                              guint         n_param_values,
+                                              const GValue *param_values,
+                                              gpointer      invocation_hint,
+                                              gpointer      marshal_data);
+
+/* VOID:CHAR (./gmarshal.list:28) */
+extern void g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
+                                           GValue       *return_value,
+                                           guint         n_param_values,
+                                           const GValue *param_values,
+                                           gpointer      invocation_hint,
+                                           gpointer      marshal_data);
+
+/* VOID:UCHAR (./gmarshal.list:29) */
+extern void g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
+                                            GValue       *return_value,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint,
+                                            gpointer      marshal_data);
+
+/* VOID:INT (./gmarshal.list:30) */
+extern void g_cclosure_marshal_VOID__INT (GClosure     *closure,
+                                          GValue       *return_value,
+                                          guint         n_param_values,
+                                          const GValue *param_values,
+                                          gpointer      invocation_hint,
+                                          gpointer      marshal_data);
+
+/* VOID:UINT (./gmarshal.list:31) */
+extern void g_cclosure_marshal_VOID__UINT (GClosure     *closure,
+                                           GValue       *return_value,
+                                           guint         n_param_values,
+                                           const GValue *param_values,
+                                           gpointer      invocation_hint,
+                                           gpointer      marshal_data);
+
+/* VOID:LONG (./gmarshal.list:32) */
+extern void g_cclosure_marshal_VOID__LONG (GClosure     *closure,
+                                           GValue       *return_value,
+                                           guint         n_param_values,
+                                           const GValue *param_values,
+                                           gpointer      invocation_hint,
+                                           gpointer      marshal_data);
+
+/* VOID:ULONG (./gmarshal.list:33) */
+extern void g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
+                                            GValue       *return_value,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint,
+                                            gpointer      marshal_data);
+
+/* VOID:ENUM (./gmarshal.list:34) */
+extern void g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
+                                           GValue       *return_value,
+                                           guint         n_param_values,
+                                           const GValue *param_values,
+                                           gpointer      invocation_hint,
+                                           gpointer      marshal_data);
+
+/* VOID:FLAGS (./gmarshal.list:35) */
+extern void g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
+                                            GValue       *return_value,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint,
+                                            gpointer      marshal_data);
+
+/* VOID:FLOAT (./gmarshal.list:36) */
+extern void g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
+                                            GValue       *return_value,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint,
+                                            gpointer      marshal_data);
+
+/* VOID:DOUBLE (./gmarshal.list:37) */
+extern void g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
+                                             GValue       *return_value,
+                                             guint         n_param_values,
+                                             const GValue *param_values,
+                                             gpointer      invocation_hint,
+                                             gpointer      marshal_data);
+
+/* VOID:STRING (./gmarshal.list:38) */
+extern void g_cclosure_marshal_VOID__STRING (GClosure     *closure,
+                                             GValue       *return_value,
+                                             guint         n_param_values,
+                                             const GValue *param_values,
+                                             gpointer      invocation_hint,
+                                             gpointer      marshal_data);
+
+/* VOID:PARAM (./gmarshal.list:39) */
+extern void g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
+                                            GValue       *return_value,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint,
+                                            gpointer      marshal_data);
+
+/* VOID:BOXED (./gmarshal.list:40) */
+extern void g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
+                                            GValue       *return_value,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint,
+                                            gpointer      marshal_data);
+
+/* VOID:POINTER (./gmarshal.list:41) */
+extern void g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
+                                              GValue       *return_value,
+                                              guint         n_param_values,
+                                              const GValue *param_values,
+                                              gpointer      invocation_hint,
+                                              gpointer      marshal_data);
+
+/* VOID:OBJECT (./gmarshal.list:42) */
+extern void g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
+                                             GValue       *return_value,
+                                             guint         n_param_values,
+                                             const GValue *param_values,
+                                             gpointer      invocation_hint,
+                                             gpointer      marshal_data);
+
+/* VOID:UINT,POINTER (./gmarshal.list:45) */
+extern void g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
+                                                   GValue       *return_value,
+                                                   guint         n_param_values,
+                                                   const GValue *param_values,
+                                                   gpointer      invocation_hint,
+                                                   gpointer      marshal_data);
+
+/* BOOL:FLAGS (./gmarshal.list:46) */
+extern void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
+                                               GValue       *return_value,
+                                               guint         n_param_values,
+                                               const GValue *param_values,
+                                               gpointer      invocation_hint,
+                                               gpointer      marshal_data);
+#define g_cclosure_marshal_BOOL__FLAGS	g_cclosure_marshal_BOOLEAN__FLAGS
+
+/* STRING:OBJECT,POINTER (./gmarshal.list:47) */
+extern void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
+                                                       GValue       *return_value,
+                                                       guint         n_param_values,
+                                                       const GValue *param_values,
+                                                       gpointer      invocation_hint,
+                                                       gpointer      marshal_data);
+
+G_END_DECLS
+
+#endif /* __G_MARSHAL_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobject.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobject.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobject.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,252 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_OBJECT_H__
+#define __G_OBJECT_H__
+
+#include        &lt;gobject/gtype.h&gt;
+#include        &lt;gobject/gvalue.h&gt;
+#include        &lt;gobject/gparam.h&gt;
+#include        &lt;gobject/gclosure.h&gt;
+#include        &lt;gobject/gsignal.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define G_TYPE_IS_OBJECT(type)      (G_TYPE_FUNDAMENTAL (type) == G_TYPE_OBJECT)
+#define G_OBJECT(object)            (G_TYPE_CHECK_INSTANCE_CAST ((object), G_TYPE_OBJECT, GObject))
+#define G_OBJECT_CLASS(class)       (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_OBJECT, GObjectClass))
+#define G_IS_OBJECT(object)         (G_TYPE_CHECK_INSTANCE_TYPE ((object), G_TYPE_OBJECT))
+#define G_IS_OBJECT_CLASS(class)    (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_OBJECT))
+#define G_OBJECT_GET_CLASS(object)  (G_TYPE_INSTANCE_GET_CLASS ((object), G_TYPE_OBJECT, GObjectClass))
+#define G_OBJECT_TYPE(object)       (G_TYPE_FROM_INSTANCE (object))
+#define G_OBJECT_TYPE_NAME(object)  (g_type_name (G_OBJECT_TYPE (object)))
+#define G_OBJECT_CLASS_TYPE(class)  (G_TYPE_FROM_CLASS (class))
+#define G_OBJECT_CLASS_NAME(class)  (g_type_name (G_OBJECT_CLASS_TYPE (class)))
+#define G_VALUE_HOLDS_OBJECT(value) (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_OBJECT))
+
+
+/* --- typedefs &amp; structures --- */
+typedef struct _GObject                  GObject;
+typedef struct _GObjectClass             GObjectClass;
+typedef struct _GObjectConstructParam    GObjectConstructParam;
+typedef void (*GObjectGetPropertyFunc)  (GObject      *object,
+                                         guint         property_id,
+                                         GValue       *value,
+                                         GParamSpec   *pspec);
+typedef void (*GObjectSetPropertyFunc)  (GObject      *object,
+                                         guint         property_id,
+                                         const GValue *value,
+                                         GParamSpec   *pspec);
+typedef void (*GObjectFinalizeFunc)     (GObject      *object);
+typedef void (*GWeakNotify)		(gpointer      data,
+					 GObject      *where_the_object_was);
+struct  _GObject
+{
+  GTypeInstance g_type_instance;
+  
+  /*&lt; private &gt;*/
+  guint         ref_count;
+  GData        *qdata;
+};
+struct  _GObjectClass
+{
+  GTypeClass   g_type_class;
+
+  /*&lt; private &gt;*/
+  GSList      *construct_properties;
+
+  /*&lt; public &gt;*/
+  /* overridable methods */
+  GObject*   (*constructor)     (GType                  type,
+                                 guint                  n_construct_properties,
+                                 GObjectConstructParam *construct_properties);
+  void       (*set_property)		(GObject        *object,
+                                         guint           property_id,
+                                         const GValue   *value,
+                                         GParamSpec     *pspec);
+  void       (*get_property)		(GObject        *object,
+                                         guint           property_id,
+                                         GValue         *value,
+                                         GParamSpec     *pspec);
+  void       (*dispose)			(GObject        *object);
+  void       (*finalize)		(GObject        *object);
+  
+  /* seldomly overidden */
+  void       (*dispatch_properties_changed) (GObject      *object,
+					     guint	   n_pspecs,
+					     GParamSpec  **pspecs);
+
+  /* signals */
+  void	     (*notify)			(GObject	*object,
+					 GParamSpec	*pspec);
+  /*&lt; private &gt;*/
+  /* padding */
+  gpointer	pdummy[8];
+};
+struct _GObjectConstructParam
+{
+  GParamSpec *pspec;
+  GValue     *value;
+};
+
+
+/* --- prototypes --- */
+void        g_object_class_install_property   (GObjectClass   *oclass,
+					       guint           property_id,
+					       GParamSpec     *pspec);
+GParamSpec* g_object_class_find_property      (GObjectClass   *oclass,
+					       const gchar    *property_name);
+GParamSpec**g_object_class_list_properties    (GObjectClass   *oclass,
+					       guint	      *n_properties);
+void        g_object_class_override_property  (GObjectClass   *oclass,
+					       guint           property_id,
+					       const gchar    *name);
+
+void        g_object_interface_install_property (gpointer     g_iface,
+						 GParamSpec  *pspec);
+GParamSpec* g_object_interface_find_property    (gpointer     g_iface,
+						 const gchar *property_name);
+GParamSpec**g_object_interface_list_properties  (gpointer     g_iface,
+						 guint       *n_properties_p);
+
+gpointer    g_object_new                      (GType           object_type,
+					       const gchar    *first_property_name,
+					       ...);
+gpointer    g_object_newv		      (GType           object_type,
+					       guint	       n_parameters,
+					       GParameter     *parameters);
+GObject*    g_object_new_valist               (GType           object_type,
+					       const gchar    *first_property_name,
+					       va_list         var_args);
+void	    g_object_set                      (gpointer	       object,
+					       const gchar    *first_property_name,
+					       ...);
+void        g_object_get                      (gpointer        object,
+					       const gchar    *first_property_name,
+					       ...);
+gpointer    g_object_connect                  (gpointer	       object,
+					       const gchar    *signal_spec,
+					       ...);
+void	    g_object_disconnect               (gpointer	       object,
+					       const gchar    *signal_spec,
+					       ...);
+void        g_object_set_valist               (GObject        *object,
+					       const gchar    *first_property_name,
+					       va_list         var_args);
+void        g_object_get_valist               (GObject        *object,
+					       const gchar    *first_property_name,
+					       va_list         var_args);
+void        g_object_set_property             (GObject        *object,
+					       const gchar    *property_name,
+					       const GValue   *value);
+void        g_object_get_property             (GObject        *object,
+					       const gchar    *property_name,
+					       GValue         *value);
+void        g_object_freeze_notify            (GObject        *object);
+void        g_object_notify                   (GObject        *object,
+					       const gchar    *property_name);
+void        g_object_thaw_notify              (GObject        *object);
+gpointer    g_object_ref                      (gpointer        object);
+void        g_object_unref                    (gpointer        object);
+void	    g_object_weak_ref		      (GObject	      *object,
+					       GWeakNotify     notify,
+					       gpointer	       data);
+void	    g_object_weak_unref		      (GObject	      *object,
+					       GWeakNotify     notify,
+					       gpointer	       data);
+void        g_object_add_weak_pointer         (GObject        *object, 
+                                               gpointer       *weak_pointer_location);
+void        g_object_remove_weak_pointer      (GObject        *object, 
+                                               gpointer       *weak_pointer_location);
+gpointer    g_object_get_qdata                (GObject        *object,
+					       GQuark          quark);
+void        g_object_set_qdata                (GObject        *object,
+					       GQuark          quark,
+					       gpointer        data);
+void        g_object_set_qdata_full           (GObject        *object,
+					       GQuark          quark,
+					       gpointer        data,
+					       GDestroyNotify  destroy);
+gpointer    g_object_steal_qdata              (GObject        *object,
+					       GQuark          quark);
+gpointer    g_object_get_data                 (GObject        *object,
+					       const gchar    *key);
+void        g_object_set_data                 (GObject        *object,
+					       const gchar    *key,
+					       gpointer        data);
+void        g_object_set_data_full            (GObject        *object,
+					       const gchar    *key,
+					       gpointer        data,
+					       GDestroyNotify  destroy);
+gpointer    g_object_steal_data               (GObject        *object,
+					       const gchar    *key);
+void        g_object_watch_closure            (GObject        *object,
+					       GClosure       *closure);
+GClosure*   g_cclosure_new_object             (GCallback       callback_func,
+					       GObject	      *object);
+GClosure*   g_cclosure_new_object_swap        (GCallback       callback_func,
+					       GObject	      *object);
+GClosure*   g_closure_new_object              (guint           sizeof_closure,
+					       GObject        *object);
+void        g_value_set_object                (GValue         *value,
+					       gpointer        v_object);
+gpointer    g_value_get_object                (const GValue   *value);
+GObject*    g_value_dup_object                (const GValue   *value);
+gulong	    g_signal_connect_object           (gpointer	       instance,
+					       const gchar    *detailed_signal,
+					       GCallback       c_handler,
+					       gpointer	       gobject,
+					       GConnectFlags   connect_flags);
+
+
+/*&lt; protected &gt;*/
+void        g_object_run_dispose	      (GObject	      *object);
+
+
+void        g_value_take_object               (GValue         *value,
+					       gpointer        v_object);
+#ifndef G_DISABLE_DEPRECATED
+void        g_value_set_object_take_ownership (GValue         *value,
+					       gpointer        v_object);
+#endif
+
+/* --- implementation macros --- */
+#define G_OBJECT_WARN_INVALID_PSPEC(object, pname, property_id, pspec) \
+G_STMT_START { \
+  GObject *_object = (GObject*) (object); \
+  GParamSpec *_pspec = (GParamSpec*) (pspec); \
+  guint _property_id = (property_id); \
+  g_warning (&quot;%s: invalid %s id %u for \&quot;%s\&quot; of type `%s' in `%s'&quot;, \
+             G_STRLOC, \
+             (pname), \
+             _property_id, \
+             _pspec-&gt;name, \
+             g_type_name (G_PARAM_SPEC_TYPE (_pspec)), \
+             G_OBJECT_TYPE_NAME (_object)); \
+} G_STMT_END
+#define G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec) \
+    G_OBJECT_WARN_INVALID_PSPEC ((object), &quot;property&quot;, (property_id), (pspec))
+
+G_END_DECLS
+
+#endif /* __G_OBJECT_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobjectnotifyqueue.c
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobjectnotifyqueue.c	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gobjectnotifyqueue.c	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,169 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_NOTIFY_H__
+#define __G_NOTIFY_H__
+
+#include        &lt;string.h&gt; /* memset */
+#include        &lt;glib-object.h&gt;
+
+G_BEGIN_DECLS
+
+
+/* --- typedefs --- */
+typedef struct _GObjectNotifyContext          GObjectNotifyContext;
+typedef struct _GObjectNotifyQueue            GObjectNotifyQueue;
+typedef void (*GObjectNotifyQueueDispatcher) (GObject     *object,
+					      guint        n_pspecs,
+					      GParamSpec **pspecs);
+
+
+/* --- structures --- */
+struct _GObjectNotifyContext
+{
+  GQuark                       quark_notify_queue;
+  GObjectNotifyQueueDispatcher dispatcher;
+  GTrashStack                 *_nqueue_trash; /* unused */
+};
+struct _GObjectNotifyQueue
+{
+  GObjectNotifyContext *context;
+  GSList               *pspecs;
+  guint16               n_pspecs;
+  guint16               freeze_count;
+  /* currently, this structure abuses the GList allocation chain and thus
+   * must be &lt;= sizeof (GList)
+   */
+};
+
+
+/* --- functions --- */
+static void
+g_object_notify_queue_free (gpointer data)
+{
+  GObjectNotifyQueue *nqueue = data;
+
+  g_slist_free (nqueue-&gt;pspecs);
+  g_list_free_1 ((void*) nqueue);
+}
+
+static inline GObjectNotifyQueue*
+g_object_notify_queue_freeze (GObject		   *object,
+			      GObjectNotifyContext *context)
+{
+  GObjectNotifyQueue *nqueue;
+
+  nqueue = g_datalist_id_get_data (&amp;object-&gt;qdata, context-&gt;quark_notify_queue);
+  if (!nqueue)
+    {
+      nqueue = (void*) g_list_alloc ();
+      memset (nqueue, 0, sizeof (*nqueue));
+      nqueue-&gt;context = context;
+      g_datalist_id_set_data_full (&amp;object-&gt;qdata, context-&gt;quark_notify_queue,
+				   nqueue, g_object_notify_queue_free);
+    }
+
+  g_return_val_if_fail (nqueue-&gt;freeze_count &lt; 65535, nqueue);
+  nqueue-&gt;freeze_count++;
+
+  return nqueue;
+}
+
+static inline void
+g_object_notify_queue_thaw (GObject            *object,
+			    GObjectNotifyQueue *nqueue)
+{
+  GObjectNotifyContext *context = nqueue-&gt;context;
+  GParamSpec *pspecs_mem[16], **pspecs, **free_me = NULL;
+  GSList *slist;
+  guint n_pspecs = 0;
+
+  g_return_if_fail (nqueue-&gt;freeze_count &gt; 0);
+
+  nqueue-&gt;freeze_count--;
+  if (nqueue-&gt;freeze_count)
+    return;
+  g_return_if_fail (object-&gt;ref_count &gt; 0);
+
+  pspecs = nqueue-&gt;n_pspecs &gt; 16 ? free_me = g_new (GParamSpec*, nqueue-&gt;n_pspecs) : pspecs_mem;
+  /* set first entry to NULL since it's checked unconditionally */
+  pspecs[0] = NULL;
+  for (slist = nqueue-&gt;pspecs; slist; slist = slist-&gt;next)
+    {
+      GParamSpec *pspec = slist-&gt;data;
+      gint i = 0;
+
+      /* dedup, make pspecs in the list unique */
+    redo_dedup_check:
+      if (pspecs[i] == pspec)
+	continue;
+      if (++i &lt; n_pspecs)
+	goto redo_dedup_check;
+
+      pspecs[n_pspecs++] = pspec;
+    }
+  g_datalist_id_set_data (&amp;object-&gt;qdata, context-&gt;quark_notify_queue, NULL);
+
+  if (n_pspecs)
+    context-&gt;dispatcher (object, n_pspecs, pspecs);
+  g_free (free_me);
+}
+
+static inline void
+g_object_notify_queue_clear (GObject            *object,
+			     GObjectNotifyQueue *nqueue)
+{
+  g_return_if_fail (nqueue-&gt;freeze_count &gt; 0);
+
+  g_slist_free (nqueue-&gt;pspecs);
+  nqueue-&gt;pspecs = NULL;
+  nqueue-&gt;n_pspecs = 0;
+}
+
+static inline void
+g_object_notify_queue_add (GObject            *object,
+			   GObjectNotifyQueue *nqueue,
+			   GParamSpec	      *pspec)
+{
+  if (pspec-&gt;flags &amp; G_PARAM_READABLE)
+    {
+      GParamSpec *redirect;
+
+      g_return_if_fail (nqueue-&gt;n_pspecs &lt; 65535);
+
+      redirect = g_param_spec_get_redirect_target (pspec);
+      if (redirect)
+	pspec = redirect;
+	    
+      /* we do the deduping in _thaw */
+      nqueue-&gt;pspecs = g_slist_prepend (nqueue-&gt;pspecs, pspec);
+      nqueue-&gt;n_pspecs++;
+    }
+}
+
+static inline GObjectNotifyQueue*
+g_object_notify_queue_from_object (GObject              *object,
+				   GObjectNotifyContext *context)
+{
+  return g_datalist_id_get_data (&amp;object-&gt;qdata, context-&gt;quark_notify_queue);
+}
+
+
+G_END_DECLS
+
+#endif /* __G_OBJECT_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparam.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparam.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparam.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,228 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * gparam.h: GParamSpec base class implementation
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_PARAM_H__
+#define __G_PARAM_H__
+
+#include	&lt;gobject/gvalue.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- standard type macros --- */
+#define G_TYPE_IS_PARAM(type)		(G_TYPE_FUNDAMENTAL (type) == G_TYPE_PARAM)
+#define G_PARAM_SPEC(pspec)		(G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM, GParamSpec))
+#define G_IS_PARAM_SPEC(pspec)		(G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM))
+#define G_PARAM_SPEC_CLASS(pclass)      (G_TYPE_CHECK_CLASS_CAST ((pclass), G_TYPE_PARAM, GParamSpecClass))
+#define G_IS_PARAM_SPEC_CLASS(pclass)   (G_TYPE_CHECK_CLASS_TYPE ((pclass), G_TYPE_PARAM))
+#define G_PARAM_SPEC_GET_CLASS(pspec)	(G_TYPE_INSTANCE_GET_CLASS ((pspec), G_TYPE_PARAM, GParamSpecClass))
+
+
+/* --- convenience macros --- */
+#define G_PARAM_SPEC_TYPE(pspec)	(G_TYPE_FROM_INSTANCE (pspec))
+#define G_PARAM_SPEC_TYPE_NAME(pspec)	(g_type_name (G_PARAM_SPEC_TYPE (pspec)))
+#define	G_PARAM_SPEC_VALUE_TYPE(pspec)	(G_PARAM_SPEC (pspec)-&gt;value_type)
+#define G_VALUE_HOLDS_PARAM(value)	(G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_PARAM))
+       
+
+/* --- flags --- */
+typedef enum
+{
+  G_PARAM_READABLE            = 1 &lt;&lt; 0,
+  G_PARAM_WRITABLE            = 1 &lt;&lt; 1,
+  G_PARAM_CONSTRUCT	      = 1 &lt;&lt; 2,
+  G_PARAM_CONSTRUCT_ONLY      = 1 &lt;&lt; 3,
+  G_PARAM_LAX_VALIDATION      = 1 &lt;&lt; 4,
+  G_PARAM_PRIVATE	      = 1 &lt;&lt; 5
+} GParamFlags;
+#define	G_PARAM_READWRITE	(G_PARAM_READABLE | G_PARAM_WRITABLE)
+#define	G_PARAM_MASK		(0x000000ff)
+/* bits in the range 0xffffff00 are reserved for 3rd party usage */
+#define	G_PARAM_USER_SHIFT	(8)
+
+
+/* --- typedefs &amp; structures --- */
+typedef struct _GParamSpec      GParamSpec;
+typedef struct _GParamSpecClass GParamSpecClass;
+typedef struct _GParameter	GParameter;
+typedef struct _GParamSpecPool  GParamSpecPool;
+struct _GParamSpec
+{
+  GTypeInstance  g_type_instance;
+
+  gchar         *name;
+  GParamFlags    flags;
+  GType		 value_type;
+  GType		 owner_type;	/* class or interface using this property */
+
+  /*&lt; private &gt;*/
+  gchar         *_nick;
+  gchar         *_blurb;
+  GData		*qdata;
+  guint          ref_count;
+  guint		 param_id;	/* sort-criteria */
+};
+struct _GParamSpecClass
+{
+  GTypeClass      g_type_class;
+
+  GType		  value_type;
+
+  void	        (*finalize)		(GParamSpec   *pspec);
+
+  /* GParam methods */
+  void          (*value_set_default)    (GParamSpec   *pspec,
+					 GValue       *value);
+  gboolean      (*value_validate)       (GParamSpec   *pspec,
+					 GValue       *value);
+  gint          (*values_cmp)           (GParamSpec   *pspec,
+					 const GValue *value1,
+					 const GValue *value2);
+  /*&lt; private &gt;*/
+  gpointer	  dummy[4];
+};
+struct _GParameter /* auxillary structure for _setv() variants */
+{
+  const gchar *name;
+  GValue       value;
+};
+
+
+/* --- prototypes --- */
+GParamSpec*	g_param_spec_ref		(GParamSpec    *pspec);
+void		g_param_spec_unref		(GParamSpec    *pspec);
+void		g_param_spec_sink		(GParamSpec    *pspec);
+gpointer        g_param_spec_get_qdata		(GParamSpec    *pspec,
+						 GQuark         quark);
+void            g_param_spec_set_qdata		(GParamSpec    *pspec,
+						 GQuark         quark,
+						 gpointer       data);
+void            g_param_spec_set_qdata_full	(GParamSpec    *pspec,
+						 GQuark         quark,
+						 gpointer       data,
+						 GDestroyNotify destroy);
+gpointer        g_param_spec_steal_qdata	(GParamSpec    *pspec,
+						 GQuark         quark);
+GParamSpec*     g_param_spec_get_redirect_target (GParamSpec   *pspec);
+
+void		g_param_value_set_default	(GParamSpec    *pspec,
+						 GValue	       *value);
+gboolean	g_param_value_defaults		(GParamSpec    *pspec,
+						 GValue	       *value);
+gboolean	g_param_value_validate		(GParamSpec    *pspec,
+						 GValue	       *value);
+gboolean	g_param_value_convert		(GParamSpec    *pspec,
+						 const GValue  *src_value,
+						 GValue	       *dest_value,
+						 gboolean	strict_validation);
+gint		g_param_values_cmp		(GParamSpec    *pspec,
+						 const GValue  *value1,
+						 const GValue  *value2);
+G_CONST_RETURN gchar*	g_param_spec_get_name	(GParamSpec    *pspec);
+G_CONST_RETURN gchar*	g_param_spec_get_nick	(GParamSpec    *pspec);
+G_CONST_RETURN gchar*	g_param_spec_get_blurb	(GParamSpec    *pspec);
+void            g_value_set_param               (GValue	       *value,
+						 GParamSpec    *param);
+GParamSpec*     g_value_get_param               (const GValue  *value);
+GParamSpec*     g_value_dup_param               (const GValue  *value);
+
+
+void           g_value_take_param               (GValue        *value,
+					         GParamSpec    *param);
+#ifndef G_DISABLE_DEPRECATED
+void           g_value_set_param_take_ownership (GValue        *value,
+					         GParamSpec    *param);
+#endif
+
+/* --- convenience functions --- */
+typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
+struct _GParamSpecTypeInfo
+{
+  /* type system portion */
+  guint16         instance_size;                               /* obligatory */
+  guint16         n_preallocs;                                 /* optional */
+  void		(*instance_init)	(GParamSpec   *pspec); /* optional */
+
+  /* class portion */
+  GType           value_type;				       /* obligatory */
+  void          (*finalize)             (GParamSpec   *pspec); /* optional */
+  void          (*value_set_default)    (GParamSpec   *pspec,  /* recommended */
+					 GValue       *value);
+  gboolean      (*value_validate)       (GParamSpec   *pspec,  /* optional */
+					 GValue       *value);
+  gint          (*values_cmp)           (GParamSpec   *pspec,  /* recommended */
+					 const GValue *value1,
+					 const GValue *value2);
+};
+GType	g_param_type_register_static	(const gchar		  *name,
+					 const GParamSpecTypeInfo *pspec_info);
+
+/* For registering builting types */
+GType  _g_param_type_register_static_constant (const gchar              *name,
+					       const GParamSpecTypeInfo *pspec_info,
+					       GType                     opt_type);
+
+
+/* --- protected --- */
+gpointer	g_param_spec_internal		(GType	        param_type,
+						 const gchar   *name,
+						 const gchar   *nick,
+						 const gchar   *blurb,
+						 GParamFlags    flags);
+GParamSpecPool* g_param_spec_pool_new		(gboolean	type_prefixing);
+void		g_param_spec_pool_insert	(GParamSpecPool	*pool,
+						 GParamSpec	*pspec,
+						 GType		 owner_type);
+void		g_param_spec_pool_remove	(GParamSpecPool	*pool,
+						 GParamSpec	*pspec);
+GParamSpec*	g_param_spec_pool_lookup	(GParamSpecPool	*pool,
+						 const gchar	*param_name,
+						 GType		 owner_type,
+						 gboolean	 walk_ancestors);
+GList*		g_param_spec_pool_list_owned	(GParamSpecPool	*pool,
+						 GType		 owner_type);
+GParamSpec**	g_param_spec_pool_list		(GParamSpecPool	*pool,
+						 GType		 owner_type,
+						 guint		*n_pspecs_p);
+
+
+
+/* contracts:
+ *
+ * gboolean value_validate (GParamSpec *pspec,
+ *                          GValue     *value):
+ *	modify value contents in the least destructive way, so
+ *	that it complies with pspec's requirements (i.e.
+ *	according to minimum/maximum ranges etc...). return
+ *	whether modification was necessary.
+ *
+ * gint values_cmp (GParamSpec   *pspec,
+ *                  const GValue *value1,
+ *                  const GValue *value2):
+ *	return value1 - value2, i.e. (-1) if value1 &lt; value2,
+ *	(+1) if value1 &gt; value2, and (0) otherwise (equality)
+ */
+
+G_END_DECLS
+
+#endif /* __G_PARAM_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparamspecs.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparamspecs.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gparamspecs.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,426 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * gparamspecs.h: GLib default param specs
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_PARAMSPECS_H__
+#define __G_PARAMSPECS_H__
+
+#include        &lt;gobject/gvalue.h&gt;
+#include        &lt;gobject/genums.h&gt;
+#include        &lt;gobject/gboxed.h&gt;
+#include        &lt;gobject/gobject.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define	G_TYPE_PARAM_CHAR		   (g_param_spec_types[0])
+#define G_IS_PARAM_SPEC_CHAR(pspec)        (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_CHAR))
+#define G_PARAM_SPEC_CHAR(pspec)           (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_CHAR, GParamSpecChar))
+#define	G_TYPE_PARAM_UCHAR		   (g_param_spec_types[1])
+#define G_IS_PARAM_SPEC_UCHAR(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_UCHAR))
+#define G_PARAM_SPEC_UCHAR(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_UCHAR, GParamSpecUChar))
+#define	G_TYPE_PARAM_BOOLEAN		   (g_param_spec_types[2])
+#define G_IS_PARAM_SPEC_BOOLEAN(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_BOOLEAN))
+#define G_PARAM_SPEC_BOOLEAN(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_BOOLEAN, GParamSpecBoolean))
+#define	G_TYPE_PARAM_INT		   (g_param_spec_types[3])
+#define G_IS_PARAM_SPEC_INT(pspec)         (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_INT))
+#define G_PARAM_SPEC_INT(pspec)            (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_INT, GParamSpecInt))
+#define	G_TYPE_PARAM_UINT		   (g_param_spec_types[4])
+#define G_IS_PARAM_SPEC_UINT(pspec)        (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_UINT))
+#define G_PARAM_SPEC_UINT(pspec)           (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_UINT, GParamSpecUInt))
+#define	G_TYPE_PARAM_LONG		   (g_param_spec_types[5])
+#define G_IS_PARAM_SPEC_LONG(pspec)        (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_LONG))
+#define G_PARAM_SPEC_LONG(pspec)           (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_LONG, GParamSpecLong))
+#define	G_TYPE_PARAM_ULONG		   (g_param_spec_types[6])
+#define G_IS_PARAM_SPEC_ULONG(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_ULONG))
+#define G_PARAM_SPEC_ULONG(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_ULONG, GParamSpecULong))
+#define	G_TYPE_PARAM_INT64		   (g_param_spec_types[7])
+#define G_IS_PARAM_SPEC_INT64(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_INT64))
+#define G_PARAM_SPEC_INT64(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_INT64, GParamSpecInt64))
+#define	G_TYPE_PARAM_UINT64		   (g_param_spec_types[8])
+#define G_IS_PARAM_SPEC_UINT64(pspec)      (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_UINT64))
+#define G_PARAM_SPEC_UINT64(pspec)         (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_UINT64, GParamSpecUInt64))
+#define	G_TYPE_PARAM_UNICHAR		   (g_param_spec_types[9])
+#define G_PARAM_SPEC_UNICHAR(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_UNICHAR, GParamSpecUnichar))
+#define G_IS_PARAM_SPEC_UNICHAR(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_UNICHAR))
+#define	G_TYPE_PARAM_ENUM		   (g_param_spec_types[10])
+#define G_IS_PARAM_SPEC_ENUM(pspec)        (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_ENUM))
+#define G_PARAM_SPEC_ENUM(pspec)           (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_ENUM, GParamSpecEnum))
+#define	G_TYPE_PARAM_FLAGS		   (g_param_spec_types[11])
+#define G_IS_PARAM_SPEC_FLAGS(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_FLAGS))
+#define G_PARAM_SPEC_FLAGS(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_FLAGS, GParamSpecFlags))
+#define	G_TYPE_PARAM_FLOAT		   (g_param_spec_types[12])
+#define G_IS_PARAM_SPEC_FLOAT(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_FLOAT))
+#define G_PARAM_SPEC_FLOAT(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_FLOAT, GParamSpecFloat))
+#define	G_TYPE_PARAM_DOUBLE		   (g_param_spec_types[13])
+#define G_IS_PARAM_SPEC_DOUBLE(pspec)      (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_DOUBLE))
+#define G_PARAM_SPEC_DOUBLE(pspec)         (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_DOUBLE, GParamSpecDouble))
+#define	G_TYPE_PARAM_STRING		   (g_param_spec_types[14])
+#define G_IS_PARAM_SPEC_STRING(pspec)      (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_STRING))
+#define G_PARAM_SPEC_STRING(pspec)         (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_STRING, GParamSpecString))
+#define	G_TYPE_PARAM_PARAM		   (g_param_spec_types[15])
+#define G_IS_PARAM_SPEC_PARAM(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_PARAM))
+#define G_PARAM_SPEC_PARAM(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_PARAM, GParamSpecParam))
+#define	G_TYPE_PARAM_BOXED		   (g_param_spec_types[16])
+#define G_IS_PARAM_SPEC_BOXED(pspec)       (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_BOXED))
+#define G_PARAM_SPEC_BOXED(pspec)          (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_BOXED, GParamSpecBoxed))
+#define	G_TYPE_PARAM_POINTER		   (g_param_spec_types[17])
+#define G_IS_PARAM_SPEC_POINTER(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_POINTER))
+#define G_PARAM_SPEC_POINTER(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_POINTER, GParamSpecPointer))
+#define	G_TYPE_PARAM_VALUE_ARRAY	   (g_param_spec_types[18])
+#define G_IS_PARAM_SPEC_VALUE_ARRAY(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_VALUE_ARRAY))
+#define G_PARAM_SPEC_VALUE_ARRAY(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_VALUE_ARRAY, GParamSpecValueArray))
+#define	G_TYPE_PARAM_OBJECT		   (g_param_spec_types[19])
+#define G_IS_PARAM_SPEC_OBJECT(pspec)      (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_OBJECT))
+#define G_PARAM_SPEC_OBJECT(pspec)         (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_OBJECT, GParamSpecObject))
+#define	G_TYPE_PARAM_OVERRIDE		   (g_param_spec_types[20])
+#define G_IS_PARAM_SPEC_OVERRIDE(pspec)    (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_OVERRIDE))
+#define G_PARAM_SPEC_OVERRIDE(pspec)       (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_OVERRIDE, GParamSpecOverride))
+
+
+/* --- typedefs &amp; structures --- */
+typedef struct _GParamSpecChar       GParamSpecChar;
+typedef struct _GParamSpecUChar      GParamSpecUChar;
+typedef struct _GParamSpecBoolean    GParamSpecBoolean;
+typedef struct _GParamSpecInt        GParamSpecInt;
+typedef struct _GParamSpecUInt       GParamSpecUInt;
+typedef struct _GParamSpecLong       GParamSpecLong;
+typedef struct _GParamSpecULong      GParamSpecULong;
+typedef struct _GParamSpecInt64      GParamSpecInt64;
+typedef struct _GParamSpecUInt64     GParamSpecUInt64;
+typedef struct _GParamSpecUnichar    GParamSpecUnichar;
+typedef struct _GParamSpecEnum       GParamSpecEnum;
+typedef struct _GParamSpecFlags      GParamSpecFlags;
+typedef struct _GParamSpecFloat      GParamSpecFloat;
+typedef struct _GParamSpecDouble     GParamSpecDouble;
+typedef struct _GParamSpecString     GParamSpecString;
+typedef struct _GParamSpecParam      GParamSpecParam;
+typedef struct _GParamSpecBoxed      GParamSpecBoxed;
+typedef struct _GParamSpecPointer    GParamSpecPointer;
+typedef struct _GParamSpecValueArray GParamSpecValueArray;
+typedef struct _GParamSpecObject     GParamSpecObject;
+typedef struct _GParamSpecOverride   GParamSpecOverride;
+
+struct _GParamSpecChar
+{
+  GParamSpec    parent_instance;
+  
+  gint8         minimum;
+  gint8         maximum;
+  gint8         default_value;
+};
+struct _GParamSpecUChar
+{
+  GParamSpec    parent_instance;
+  
+  guint8        minimum;
+  guint8        maximum;
+  guint8        default_value;
+};
+struct _GParamSpecBoolean
+{
+  GParamSpec    parent_instance;
+  
+  gboolean      default_value;
+};
+struct _GParamSpecInt
+{
+  GParamSpec    parent_instance;
+  
+  gint          minimum;
+  gint          maximum;
+  gint          default_value;
+};
+struct _GParamSpecUInt
+{
+  GParamSpec    parent_instance;
+  
+  guint         minimum;
+  guint         maximum;
+  guint         default_value;
+};
+struct _GParamSpecLong
+{
+  GParamSpec    parent_instance;
+  
+  glong         minimum;
+  glong         maximum;
+  glong         default_value;
+};
+struct _GParamSpecULong
+{
+  GParamSpec    parent_instance;
+  
+  gulong        minimum;
+  gulong        maximum;
+  gulong        default_value;
+};
+struct _GParamSpecInt64
+{
+  GParamSpec    parent_instance;
+  
+  gint64        minimum;
+  gint64        maximum;
+  gint64        default_value;
+};
+struct _GParamSpecUInt64
+{
+  GParamSpec    parent_instance;
+  
+  guint64       minimum;
+  guint64       maximum;
+  guint64       default_value;
+};
+struct _GParamSpecUnichar
+{
+  GParamSpec    parent_instance;
+  
+  gunichar      default_value;
+};
+struct _GParamSpecEnum
+{
+  GParamSpec    parent_instance;
+  
+  GEnumClass   *enum_class;
+  gint          default_value;
+};
+struct _GParamSpecFlags
+{
+  GParamSpec    parent_instance;
+  
+  GFlagsClass  *flags_class;
+  guint         default_value;
+};
+struct _GParamSpecFloat
+{
+  GParamSpec    parent_instance;
+  
+  gfloat        minimum;
+  gfloat        maximum;
+  gfloat        default_value;
+  gfloat        epsilon;
+};
+struct _GParamSpecDouble
+{
+  GParamSpec    parent_instance;
+  
+  gdouble       minimum;
+  gdouble       maximum;
+  gdouble       default_value;
+  gdouble       epsilon;
+};
+struct _GParamSpecString
+{
+  GParamSpec    parent_instance;
+  
+  gchar        *default_value;
+  gchar        *cset_first;
+  gchar        *cset_nth;
+  gchar         substitutor;
+  guint         null_fold_if_empty : 1;
+  guint         ensure_non_null : 1;
+};
+struct _GParamSpecParam
+{
+  GParamSpec    parent_instance;
+};
+struct _GParamSpecBoxed
+{
+  GParamSpec    parent_instance;
+};
+struct _GParamSpecPointer
+{
+  GParamSpec    parent_instance;
+};
+struct _GParamSpecValueArray
+{
+  GParamSpec    parent_instance;
+  GParamSpec   *element_spec;
+  guint		fixed_n_elements;
+};
+struct _GParamSpecObject
+{
+  GParamSpec    parent_instance;
+};
+struct _GParamSpecOverride
+{
+  /*&lt; private &gt;*/
+  GParamSpec    parent_instance;
+  GParamSpec   *overridden;
+};
+
+/* --- GParamSpec prototypes --- */
+GParamSpec*	g_param_spec_char	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gint8		  minimum,
+					  gint8		  maximum,
+					  gint8		  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_uchar	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  guint8	  minimum,
+					  guint8	  maximum,
+					  guint8	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_boolean	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gboolean	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_int	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gint		  minimum,
+					  gint		  maximum,
+					  gint		  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_uint	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  guint		  minimum,
+					  guint		  maximum,
+					  guint		  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_long	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  glong		  minimum,
+					  glong		  maximum,
+					  glong		  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_ulong	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gulong	  minimum,
+					  gulong	  maximum,
+					  gulong	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_int64	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gint64       	  minimum,
+					  gint64       	  maximum,
+					  gint64       	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_uint64	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  guint64	  minimum,
+					  guint64	  maximum,
+					  guint64	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*    g_param_spec_unichar      (const gchar    *name,
+				          const gchar    *nick,
+				          const gchar    *blurb,
+				          gunichar	  default_value,
+				          GParamFlags     flags);
+GParamSpec*	g_param_spec_enum	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GType		  enum_type,
+					  gint		  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_flags	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GType		  flags_type,
+					  guint		  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_float	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gfloat	  minimum,
+					  gfloat	  maximum,
+					  gfloat	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_double	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  gdouble	  minimum,
+					  gdouble	  maximum,
+					  gdouble	  default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_string	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  const gchar	 *default_value,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_param	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GType		  param_type,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_boxed	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GType		  boxed_type,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_pointer	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_value_array (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GParamSpec	 *element_spec,
+					  GParamFlags	  flags);
+GParamSpec*	g_param_spec_object	 (const gchar	 *name,
+					  const gchar	 *nick,
+					  const gchar	 *blurb,
+					  GType		  object_type,
+					  GParamFlags	  flags);
+
+GParamSpec*     g_param_spec_override    (const gchar    *name,
+					  GParamSpec     *overridden);
+
+/* --- internal --- */
+/* We prefix variable declarations so they can
+ * properly get exported in windows dlls.
+ */
+#ifndef GOBJECT_VAR
+#  ifdef G_PLATFORM_WIN32
+#    ifdef GOBJECT_STATIC_COMPILATION
+#      define GOBJECT_VAR extern
+#    else /* !GOBJECT_STATIC_COMPILATION */
+#      ifdef GOBJECT_COMPILATION
+#        ifdef DLL_EXPORT
+#          define GOBJECT_VAR __declspec(dllexport)
+#        else /* !DLL_EXPORT */
+#          define GOBJECT_VAR extern
+#        endif /* !DLL_EXPORT */
+#      else /* !GOBJECT_COMPILATION */
+#        define GOBJECT_VAR extern __declspec(dllimport)
+#      endif /* !GOBJECT_COMPILATION */
+#    endif /* !GOBJECT_STATIC_COMPILATION */
+#  else /* !G_PLATFORM_WIN32 */
+#    define GOBJECT_VAR extern
+#  endif /* !G_PLATFORM_WIN32 */
+#endif /* GOBJECT_VAR */
+
+GOBJECT_VAR GType *g_param_spec_types;
+
+G_END_DECLS
+
+#endif /* __G_PARAMSPECS_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsignal.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsignal.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsignal.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,270 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2000-2001 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_SIGNAL_H__
+#define __G_SIGNAL_H__
+
+#include	&lt;gobject/gclosure.h&gt;
+#include	&lt;gobject/gvalue.h&gt;
+#include	&lt;gobject/gparam.h&gt;
+#include	&lt;gobject/gmarshal.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- typedefs --- */
+typedef struct _GSignalQuery		 GSignalQuery;
+typedef struct _GSignalInvocationHint	 GSignalInvocationHint;
+typedef GClosureMarshal			 GSignalCMarshaller;
+typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
+					 guint			n_param_values,
+					 const GValue	       *param_values,
+					 gpointer		data);
+typedef gboolean (*GSignalAccumulator)	(GSignalInvocationHint *ihint,
+					 GValue		       *return_accu,
+					 const GValue	       *handler_return,
+					 gpointer               data);
+
+
+/* --- run, match and connect types --- */
+typedef enum
+{
+  G_SIGNAL_RUN_FIRST	= 1 &lt;&lt; 0,
+  G_SIGNAL_RUN_LAST	= 1 &lt;&lt; 1,
+  G_SIGNAL_RUN_CLEANUP	= 1 &lt;&lt; 2,
+  G_SIGNAL_NO_RECURSE	= 1 &lt;&lt; 3,
+  G_SIGNAL_DETAILED	= 1 &lt;&lt; 4,
+  G_SIGNAL_ACTION	= 1 &lt;&lt; 5,
+  G_SIGNAL_NO_HOOKS	= 1 &lt;&lt; 6
+} GSignalFlags;
+#define G_SIGNAL_FLAGS_MASK  0x7f
+typedef enum
+{
+  G_CONNECT_AFTER	= 1 &lt;&lt; 0,
+  G_CONNECT_SWAPPED	= 1 &lt;&lt; 1
+} GConnectFlags;
+typedef enum
+{
+  G_SIGNAL_MATCH_ID	   = 1 &lt;&lt; 0,
+  G_SIGNAL_MATCH_DETAIL	   = 1 &lt;&lt; 1,
+  G_SIGNAL_MATCH_CLOSURE   = 1 &lt;&lt; 2,
+  G_SIGNAL_MATCH_FUNC	   = 1 &lt;&lt; 3,
+  G_SIGNAL_MATCH_DATA	   = 1 &lt;&lt; 4,
+  G_SIGNAL_MATCH_UNBLOCKED = 1 &lt;&lt; 5
+} GSignalMatchType;
+#define G_SIGNAL_MATCH_MASK  0x3f
+#define	G_SIGNAL_TYPE_STATIC_SCOPE (G_TYPE_FLAG_RESERVED_ID_BIT)
+
+
+/* --- signal information --- */
+struct _GSignalInvocationHint
+{
+  guint		signal_id;
+  GQuark	detail;
+  GSignalFlags	run_type;
+};
+struct _GSignalQuery
+{
+  guint		signal_id;
+  const gchar  *signal_name;
+  GType		itype;
+  GSignalFlags	signal_flags;
+  GType		return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
+  guint		n_params;
+  const GType  *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
+};
+
+
+/* --- signals --- */
+guint                 g_signal_newv         (const gchar        *signal_name,
+					     GType               itype,
+					     GSignalFlags        signal_flags,
+					     GClosure           *class_closure,
+					     GSignalAccumulator	 accumulator,
+					     gpointer		 accu_data,
+					     GSignalCMarshaller  c_marshaller,
+					     GType               return_type,
+					     guint               n_params,
+					     GType              *param_types);
+guint                 g_signal_new_valist   (const gchar        *signal_name,
+					     GType               itype,
+					     GSignalFlags        signal_flags,
+					     GClosure           *class_closure,
+					     GSignalAccumulator	 accumulator,
+					     gpointer		 accu_data,
+					     GSignalCMarshaller  c_marshaller,
+					     GType               return_type,
+					     guint               n_params,
+					     va_list             args);
+guint                 g_signal_new          (const gchar        *signal_name,
+					     GType               itype,
+					     GSignalFlags        signal_flags,
+					     guint               class_offset,
+					     GSignalAccumulator	 accumulator,
+					     gpointer		 accu_data,
+					     GSignalCMarshaller  c_marshaller,
+					     GType               return_type,
+					     guint               n_params,
+					     ...);
+void                  g_signal_emitv        (const GValue       *instance_and_params,
+					     guint               signal_id,
+					     GQuark              detail,
+					     GValue             *return_value);
+void                  g_signal_emit_valist  (gpointer            instance,
+					     guint               signal_id,
+					     GQuark              detail,
+					     va_list             var_args);
+void                  g_signal_emit         (gpointer            instance,
+					     guint               signal_id,
+					     GQuark              detail,
+					     ...);
+void                  g_signal_emit_by_name (gpointer            instance,
+					     const gchar        *detailed_signal,
+					     ...);
+guint                 g_signal_lookup       (const gchar        *name,
+					     GType               itype);
+G_CONST_RETURN gchar* g_signal_name         (guint               signal_id);
+void                  g_signal_query        (guint               signal_id,
+					     GSignalQuery       *query);
+guint*                g_signal_list_ids     (GType               itype,
+					     guint              *n_ids);
+gboolean	      g_signal_parse_name   (const gchar	*detailed_signal,
+					     GType		 itype,
+					     guint		*signal_id_p,
+					     GQuark		*detail_p,
+					     gboolean		 force_detail_quark);
+GSignalInvocationHint* g_signal_get_invocation_hint (gpointer    instance);
+
+
+/* --- signal emissions --- */
+void	g_signal_stop_emission		    (gpointer		  instance,
+					     guint		  signal_id,
+					     GQuark		  detail);
+void	g_signal_stop_emission_by_name	    (gpointer		  instance,
+					     const gchar	 *detailed_signal);
+gulong	g_signal_add_emission_hook	    (guint		  signal_id,
+					     GQuark		  detail,
+					     GSignalEmissionHook  hook_func,
+					     gpointer	       	  hook_data,
+					     GDestroyNotify	  data_destroy);
+void	g_signal_remove_emission_hook	    (guint		  signal_id,
+					     gulong		  hook_id);
+
+
+/* --- signal handlers --- */
+gboolean g_signal_has_handler_pending	      (gpointer		  instance,
+					       guint		  signal_id,
+					       GQuark		  detail,
+					       gboolean		  may_be_blocked);
+gulong	 g_signal_connect_closure_by_id	      (gpointer		  instance,
+					       guint		  signal_id,
+					       GQuark		  detail,
+					       GClosure		 *closure,
+					       gboolean		  after);
+gulong	 g_signal_connect_closure	      (gpointer		  instance,
+					       const gchar       *detailed_signal,
+					       GClosure		 *closure,
+					       gboolean		  after);
+gulong	 g_signal_connect_data		      (gpointer		  instance,
+					       const gchar	 *detailed_signal,
+					       GCallback	  c_handler,
+					       gpointer		  data,
+					       GClosureNotify	  destroy_data,
+					       GConnectFlags	  connect_flags);
+void	 g_signal_handler_block		      (gpointer		  instance,
+					       gulong		  handler_id);
+void	 g_signal_handler_unblock	      (gpointer		  instance,
+					       gulong		  handler_id);
+void	 g_signal_handler_disconnect	      (gpointer		  instance,
+					       gulong		  handler_id);
+gboolean g_signal_handler_is_connected	      (gpointer		  instance,
+					       gulong		  handler_id);
+gulong	 g_signal_handler_find		      (gpointer		  instance,
+					       GSignalMatchType	  mask,
+					       guint		  signal_id,
+					       GQuark		  detail,
+					       GClosure		 *closure,
+					       gpointer		  func,
+					       gpointer		  data);
+guint	 g_signal_handlers_block_matched      (gpointer		  instance,
+					       GSignalMatchType	  mask,
+					       guint		  signal_id,
+					       GQuark		  detail,
+					       GClosure		 *closure,
+					       gpointer		  func,
+					       gpointer		  data);
+guint	 g_signal_handlers_unblock_matched    (gpointer		  instance,
+					       GSignalMatchType	  mask,
+					       guint		  signal_id,
+					       GQuark		  detail,
+					       GClosure		 *closure,
+					       gpointer		  func,
+					       gpointer		  data);
+guint	 g_signal_handlers_disconnect_matched (gpointer		  instance,
+					       GSignalMatchType	  mask,
+					       guint		  signal_id,
+					       GQuark		  detail,
+					       GClosure		 *closure,
+					       gpointer		  func,
+					       gpointer		  data);
+
+
+/* --- chaining for language bindings --- */
+void	g_signal_override_class_closure	      (guint		  signal_id,
+					       GType		  instance_type,
+					       GClosure		 *class_closure);
+void	g_signal_chain_from_overridden	      (const GValue      *instance_and_params,
+					       GValue            *return_value);
+
+
+/* --- convenience --- */
+#define g_signal_connect(instance, detailed_signal, c_handler, data) \
+    g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, (GConnectFlags) 0)
+#define g_signal_connect_after(instance, detailed_signal, c_handler, data) \
+    g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, G_CONNECT_AFTER)
+#define g_signal_connect_swapped(instance, detailed_signal, c_handler, data) \
+    g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, G_CONNECT_SWAPPED)
+#define	g_signal_handlers_disconnect_by_func(instance, func, data)						\
+    g_signal_handlers_disconnect_matched ((instance),								\
+					  (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),	\
+					  0, 0, NULL, (func), (data))
+#define	g_signal_handlers_block_by_func(instance, func, data)							\
+    g_signal_handlers_block_matched      ((instance),								\
+				          (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),	\
+				          0, 0, NULL, (func), (data))
+#define	g_signal_handlers_unblock_by_func(instance, func, data)							\
+    g_signal_handlers_unblock_matched    ((instance),								\
+				          (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),	\
+				          0, 0, NULL, (func), (data))
+
+
+gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
+					    GValue                *return_accu,
+					    const GValue          *handler_return,
+					    gpointer               dummy);
+
+/*&lt; private &gt;*/
+void	 g_signal_handlers_destroy	      (gpointer		  instance);
+void	 _g_signals_destroy		      (GType		  itype);
+
+G_END_DECLS
+
+#endif /* __G_SIGNAL_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsourceclosure.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsourceclosure.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gsourceclosure.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,41 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_SOURCECLOSURE_H__
+#define __G_SOURCECLOSURE_H__
+
+#include &lt;gobject/gclosure.h&gt;
+
+G_BEGIN_DECLS
+
+void g_source_set_closure (GSource  *source,
+			   GClosure *closure);
+
+GType g_io_channel_get_type   (void);
+GType g_io_condition_get_type (void);
+
+#define G_TYPE_IO_CHANNEL (g_io_channel_get_type ())
+#define G_TYPE_IO_CONDITION (g_io_condition_get_type ())
+
+G_END_DECLS
+
+#endif /* __G_SOURCECLOSURE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtype.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtype.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtype.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,479 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_TYPE_H__
+#define __G_TYPE_H__
+
+#include        &lt;glib.h&gt;
+
+G_BEGIN_DECLS
+
+/* Basic Type Macros
+ */
+#define G_TYPE_FUNDAMENTAL(type)	(g_type_fundamental (type))
+#define	G_TYPE_FUNDAMENTAL_MAX		(255 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT)
+
+/* Constant fundamental types,
+ * introduced by g_type_init().
+ */
+#define G_TYPE_INVALID			G_TYPE_MAKE_FUNDAMENTAL (0)
+#define G_TYPE_NONE			G_TYPE_MAKE_FUNDAMENTAL (1)
+#define G_TYPE_INTERFACE		G_TYPE_MAKE_FUNDAMENTAL (2)
+#define G_TYPE_CHAR			G_TYPE_MAKE_FUNDAMENTAL (3)
+#define G_TYPE_UCHAR			G_TYPE_MAKE_FUNDAMENTAL (4)
+#define G_TYPE_BOOLEAN			G_TYPE_MAKE_FUNDAMENTAL (5)
+#define G_TYPE_INT			G_TYPE_MAKE_FUNDAMENTAL (6)
+#define G_TYPE_UINT			G_TYPE_MAKE_FUNDAMENTAL (7)
+#define G_TYPE_LONG			G_TYPE_MAKE_FUNDAMENTAL (8)
+#define G_TYPE_ULONG			G_TYPE_MAKE_FUNDAMENTAL (9)
+#define G_TYPE_INT64			G_TYPE_MAKE_FUNDAMENTAL (10)
+#define G_TYPE_UINT64			G_TYPE_MAKE_FUNDAMENTAL (11)
+#define G_TYPE_ENUM			G_TYPE_MAKE_FUNDAMENTAL (12)
+#define G_TYPE_FLAGS			G_TYPE_MAKE_FUNDAMENTAL (13)
+#define G_TYPE_FLOAT			G_TYPE_MAKE_FUNDAMENTAL (14)
+#define G_TYPE_DOUBLE			G_TYPE_MAKE_FUNDAMENTAL (15)
+#define G_TYPE_STRING			G_TYPE_MAKE_FUNDAMENTAL (16)
+#define G_TYPE_POINTER			G_TYPE_MAKE_FUNDAMENTAL (17)
+#define G_TYPE_BOXED			G_TYPE_MAKE_FUNDAMENTAL (18)
+#define G_TYPE_PARAM			G_TYPE_MAKE_FUNDAMENTAL (19)
+#define G_TYPE_OBJECT			G_TYPE_MAKE_FUNDAMENTAL (20)
+
+
+/* Reserved fundamental type numbers to create new fundamental
+ * type IDs with G_TYPE_MAKE_FUNDAMENTAL().
+ * Send email to <A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">gtk-devel-list at redhat.com</A> for reservations.
+ */
+#define	G_TYPE_FUNDAMENTAL_SHIFT	(2)
+#define	G_TYPE_MAKE_FUNDAMENTAL(x)	((GType) ((x) &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT))
+#define G_TYPE_RESERVED_GLIB_FIRST	(21)
+#define G_TYPE_RESERVED_GLIB_LAST	(31)
+#define G_TYPE_RESERVED_BSE_FIRST	(32)
+#define G_TYPE_RESERVED_BSE_LAST	(48)
+#define G_TYPE_RESERVED_USER_FIRST	(49)
+
+
+/* Type Checking Macros
+ */
+#define G_TYPE_IS_FUNDAMENTAL(type)             ((type) &lt;= G_TYPE_FUNDAMENTAL_MAX)
+#define G_TYPE_IS_DERIVED(type)                 ((type) &gt; G_TYPE_FUNDAMENTAL_MAX)
+#define G_TYPE_IS_INTERFACE(type)               (G_TYPE_FUNDAMENTAL (type) == G_TYPE_INTERFACE)
+#define G_TYPE_IS_CLASSED(type)                 (g_type_test_flags ((type), G_TYPE_FLAG_CLASSED))
+#define G_TYPE_IS_INSTANTIATABLE(type)          (g_type_test_flags ((type), G_TYPE_FLAG_INSTANTIATABLE))
+#define G_TYPE_IS_DERIVABLE(type)               (g_type_test_flags ((type), G_TYPE_FLAG_DERIVABLE))
+#define G_TYPE_IS_DEEP_DERIVABLE(type)          (g_type_test_flags ((type), G_TYPE_FLAG_DEEP_DERIVABLE))
+#define G_TYPE_IS_ABSTRACT(type)                (g_type_test_flags ((type), G_TYPE_FLAG_ABSTRACT))
+#define G_TYPE_IS_VALUE_ABSTRACT(type)          (g_type_test_flags ((type), G_TYPE_FLAG_VALUE_ABSTRACT))
+#define G_TYPE_IS_VALUE_TYPE(type)              (g_type_check_is_value_type (type))
+#define G_TYPE_HAS_VALUE_TABLE(type)            (g_type_value_table_peek (type) != NULL)
+
+
+/* Typedefs
+ */
+#if	GLIB_SIZEOF_LONG == GLIB_SIZEOF_SIZE_T
+typedef gulong                          GType;
+#else	/* hm, shouldn't happen? */
+typedef gsize                           GType;
+#endif
+typedef struct _GValue                  GValue;
+typedef union  _GTypeCValue             GTypeCValue;
+typedef struct _GTypePlugin             GTypePlugin;
+typedef struct _GTypeClass              GTypeClass;
+typedef struct _GTypeInterface          GTypeInterface;
+typedef struct _GTypeInstance           GTypeInstance;
+typedef struct _GTypeInfo               GTypeInfo;
+typedef struct _GTypeFundamentalInfo    GTypeFundamentalInfo;
+typedef struct _GInterfaceInfo          GInterfaceInfo;
+typedef struct _GTypeValueTable         GTypeValueTable;
+typedef struct _GTypeQuery		GTypeQuery;
+
+
+/* Basic Type Structures
+ */
+struct _GTypeClass
+{
+  /*&lt; private &gt;*/
+  GType g_type;
+};
+struct _GTypeInstance
+{
+  /*&lt; private &gt;*/
+  GTypeClass *g_class;
+};
+struct _GTypeInterface
+{
+  /*&lt; private &gt;*/
+  GType g_type;         /* iface type */
+  GType g_instance_type;
+};
+struct _GTypeQuery
+{
+  GType		type;
+  const gchar  *type_name;
+  guint		class_size;
+  guint		instance_size;
+};
+
+
+/* Casts, checks and accessors for structured types
+ * usage of these macros is reserved to type implementations only
+ */
+/*&lt; protected &gt;*/
+#define G_TYPE_CHECK_INSTANCE(instance)				(_G_TYPE_CHI ((GTypeInstance*) (instance)))
+#define G_TYPE_CHECK_INSTANCE_CAST(instance, g_type, c_type)    (_G_TYPE_CIC ((instance), (g_type), c_type))
+#define G_TYPE_CHECK_INSTANCE_TYPE(instance, g_type)            (_G_TYPE_CIT ((instance), (g_type)))
+#define G_TYPE_INSTANCE_GET_CLASS(instance, g_type, c_type)     (_G_TYPE_IGC ((instance), (g_type), c_type))
+#define G_TYPE_INSTANCE_GET_INTERFACE(instance, g_type, c_type) (_G_TYPE_IGI ((instance), (g_type), c_type))
+#define G_TYPE_CHECK_CLASS_CAST(g_class, g_type, c_type)        (_G_TYPE_CCC ((g_class), (g_type), c_type))
+#define G_TYPE_CHECK_CLASS_TYPE(g_class, g_type)                (_G_TYPE_CCT ((g_class), (g_type)))
+#define G_TYPE_CHECK_VALUE(value)				(_G_TYPE_CHV ((value)))
+#define G_TYPE_CHECK_VALUE_TYPE(value, g_type)			(_G_TYPE_CVH ((value), (g_type)))
+#define G_TYPE_FROM_INSTANCE(instance)                          (G_TYPE_FROM_CLASS (((GTypeInstance*) (instance))-&gt;g_class))
+#define G_TYPE_FROM_CLASS(g_class)                              (((GTypeClass*) (g_class))-&gt;g_type)
+#define G_TYPE_FROM_INTERFACE(g_iface)                          (((GTypeInterface*) (g_iface))-&gt;g_type)
+
+#define G_TYPE_INSTANCE_GET_PRIVATE(instance, g_type, c_type)   ((c_type*) g_type_instance_get_private ((GTypeInstance*) (instance), (g_type)))
+
+
+/* debug flags for g_type_init_with_debug_flags() */
+typedef enum	/*&lt; skip &gt;*/
+{
+  G_TYPE_DEBUG_NONE	= 0,
+  G_TYPE_DEBUG_OBJECTS	= 1 &lt;&lt; 0,
+  G_TYPE_DEBUG_SIGNALS	= 1 &lt;&lt; 1,
+  G_TYPE_DEBUG_MASK	= 0x03
+} GTypeDebugFlags;
+
+
+/* --- prototypes --- */
+void                  g_type_init                    (void);
+void                  g_type_init_with_debug_flags   (GTypeDebugFlags  debug_flags);
+G_CONST_RETURN gchar* g_type_name                    (GType            type);
+GQuark                g_type_qname                   (GType            type);
+GType                 g_type_from_name               (const gchar     *name);
+GType                 g_type_parent                  (GType            type);
+guint                 g_type_depth                   (GType            type);
+GType                 g_type_next_base               (GType            leaf_type,
+						      GType            root_type);
+gboolean              g_type_is_a                    (GType            type,
+						      GType            is_a_type);
+gpointer              g_type_class_ref               (GType            type);
+gpointer              g_type_class_peek              (GType            type);
+gpointer              g_type_class_peek_static       (GType            type);
+void                  g_type_class_unref             (gpointer         g_class);
+gpointer              g_type_class_peek_parent       (gpointer         g_class);
+gpointer              g_type_interface_peek          (gpointer         instance_class,
+						      GType            iface_type);
+gpointer              g_type_interface_peek_parent   (gpointer         g_iface);
+
+gpointer              g_type_default_interface_ref   (GType            g_type);
+gpointer              g_type_default_interface_peek  (GType            g_type);
+void                  g_type_default_interface_unref (gpointer         g_iface);
+
+/* g_free() the returned arrays */
+GType*                g_type_children                (GType            type,
+						      guint           *n_children);
+GType*                g_type_interfaces              (GType            type,
+						      guint           *n_interfaces);
+
+/* per-type _static_ data */
+void                  g_type_set_qdata               (GType            type,
+						      GQuark           quark,
+						      gpointer         data);
+gpointer              g_type_get_qdata               (GType            type,
+						      GQuark           quark);
+void		      g_type_query		     (GType	       type,
+						      GTypeQuery      *query);
+
+
+/* --- type registration --- */
+typedef void   (*GBaseInitFunc)              (gpointer         g_class);
+typedef void   (*GBaseFinalizeFunc)          (gpointer         g_class);
+typedef void   (*GClassInitFunc)             (gpointer         g_class,
+					      gpointer         class_data);
+typedef void   (*GClassFinalizeFunc)         (gpointer         g_class,
+					      gpointer         class_data);
+typedef void   (*GInstanceInitFunc)          (GTypeInstance   *instance,
+					      gpointer         g_class);
+typedef void   (*GInterfaceInitFunc)         (gpointer         g_iface,
+					      gpointer         iface_data);
+typedef void   (*GInterfaceFinalizeFunc)     (gpointer         g_iface,
+					      gpointer         iface_data);
+typedef gboolean (*GTypeClassCacheFunc)	     (gpointer	       cache_data,
+					      GTypeClass      *g_class);
+typedef void     (*GTypeInterfaceCheckFunc)  (gpointer	       func_data,
+					      gpointer         g_iface);
+typedef enum    /*&lt; skip &gt;*/
+{
+  G_TYPE_FLAG_CLASSED           = (1 &lt;&lt; 0),
+  G_TYPE_FLAG_INSTANTIATABLE    = (1 &lt;&lt; 1),
+  G_TYPE_FLAG_DERIVABLE         = (1 &lt;&lt; 2),
+  G_TYPE_FLAG_DEEP_DERIVABLE    = (1 &lt;&lt; 3)
+} GTypeFundamentalFlags;
+typedef enum    /*&lt; skip &gt;*/
+{
+  G_TYPE_FLAG_ABSTRACT		= (1 &lt;&lt; 4),
+  G_TYPE_FLAG_VALUE_ABSTRACT	= (1 &lt;&lt; 5)
+} GTypeFlags;
+struct _GTypeInfo
+{
+  /* interface types, classed types, instantiated types */
+  guint16                class_size;
+  
+  GBaseInitFunc          base_init;
+  GBaseFinalizeFunc      base_finalize;
+  
+  /* interface types, classed types, instantiated types */
+  GClassInitFunc         class_init;
+  GClassFinalizeFunc     class_finalize;
+  gconstpointer          class_data;
+  
+  /* instantiated types */
+  guint16                instance_size;
+  guint16                n_preallocs;
+  GInstanceInitFunc      instance_init;
+  
+  /* value handling */
+  const GTypeValueTable	*value_table;
+};
+struct _GTypeFundamentalInfo
+{
+  GTypeFundamentalFlags  type_flags;
+};
+struct _GInterfaceInfo
+{
+  GInterfaceInitFunc     interface_init;
+  GInterfaceFinalizeFunc interface_finalize;
+  gpointer               interface_data;
+};
+struct _GTypeValueTable
+{
+  void     (*value_init)         (GValue       *value);
+  void     (*value_free)         (GValue       *value);
+  void     (*value_copy)         (const GValue *src_value,
+				  GValue       *dest_value);
+  /* varargs functionality (optional) */
+  gpointer (*value_peek_pointer) (const GValue *value);
+  gchar	    *collect_format;
+  gchar*   (*collect_value)      (GValue       *value,
+				  guint         n_collect_values,
+				  GTypeCValue  *collect_values,
+				  guint		collect_flags);
+  gchar	    *lcopy_format;
+  gchar*   (*lcopy_value)        (const GValue *value,
+				  guint         n_collect_values,
+				  GTypeCValue  *collect_values,
+				  guint		collect_flags);
+};
+GType g_type_register_static		(GType			     parent_type,
+					 const gchar		    *type_name,
+					 const GTypeInfo	    *info,
+					 GTypeFlags		     flags);
+GType g_type_register_dynamic		(GType			     parent_type,
+					 const gchar		    *type_name,
+					 GTypePlugin		    *plugin,
+					 GTypeFlags		     flags);
+GType g_type_register_fundamental	(GType			     type_id,
+					 const gchar		    *type_name,
+					 const GTypeInfo	    *info,
+					 const GTypeFundamentalInfo *finfo,
+					 GTypeFlags		     flags);
+void  g_type_add_interface_static	(GType			     instance_type,
+					 GType			     interface_type,
+					 const GInterfaceInfo	    *info);
+void  g_type_add_interface_dynamic	(GType			     instance_type,
+					 GType			     interface_type,
+					 GTypePlugin		    *plugin);
+void  g_type_interface_add_prerequisite (GType			     interface_type,
+					 GType			     prerequisite_type);
+GType*g_type_interface_prerequisites    (GType                       interface_type,
+					 guint                      *n_prerequisites);
+void     g_type_class_add_private       (gpointer                    g_class,
+                                         gsize                       private_size);
+gpointer g_type_instance_get_private    (GTypeInstance              *instance,
+                                         GType                       private_type);
+
+
+/* --- GType boilerplate --- */
+/* convenience macros for type implementations, which for a type GtkGadget will:
+ * - prototype: static void     gtk_gadget_class_init (GtkGadgetClass *klass);
+ * - prototype: static void     gtk_gadget_init       (GtkGadget      *self);
+ * - define:    static gpointer gtk_gadget_parent_class = NULL;
+ *   gtk_gadget_parent_class is initialized prior to calling gtk_gadget_class_init()
+ * - implement: GType           gtk_gadget_get_type (void) { ... }
+ * - support custom code in gtk_gadget_get_type() after the type is registered.
+ *
+ * macro arguments: TypeName, type_name, TYPE_PARENT, CODE
+ * example: G_DEFINE_TYPE_WITH_CODE (GtkGadget, gtk_gadget, GTK_TYPE_WIDGET,
+ *                                   g_print (&quot;GtkGadget-id: %lu\n&quot;, g_define_type_id));
+ */
+#define G_DEFINE_TYPE(TN, t_n, T_P)                         G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, {})
+#define G_DEFINE_TYPE_WITH_CODE(TN, t_n, T_P, _C_)          G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, _C_)
+#define G_DEFINE_ABSTRACT_TYPE(TN, t_n, T_P)                G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, {})
+#define G_DEFINE_ABSTRACT_TYPE_WITH_CODE(TN, t_n, T_P, _C_) G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, _C_)
+
+/* convenience macro to ease interface addition in the CODE
+ * section of G_DEFINE_TYPE_WITH_CODE() (this macro relies on
+ * the g_define_type_id present within G_DEFINE_TYPE_WITH_CODE()).
+ * usage example:
+ * G_DEFINE_TYPE_WITH_CODE (GtkTreeStore, gtk_tree_store, G_TYPE_OBJECT,
+ *                          G_IMPLEMENT_INTERFACE (GTK_TYPE_TREE_MODEL,
+ *                                                 gtk_tree_store_tree_model_init));
+ */
+#define G_IMPLEMENT_INTERFACE(TYPE_IFACE, iface_init)       { \
+  static const GInterfaceInfo g_implement_interface_info = { \
+    (GInterfaceInitFunc) iface_init \
+  }; \
+  g_type_add_interface_static (g_define_type_id, TYPE_IFACE, &amp;g_implement_interface_info); \
+}
+
+#define G_DEFINE_TYPE_EXTENDED(TypeName, type_name, TYPE_PARENT, flags, CODE) \
+\
+static void     type_name##_init              (TypeName        *self); \
+static void     type_name##_class_init        (TypeName##Class *klass); \
+static gpointer type_name##_parent_class = NULL; \
+static void     type_name##_class_intern_init (gpointer klass) \
+{ \
+  type_name##_parent_class = g_type_class_peek_parent (klass); \
+  type_name##_class_init ((TypeName##Class*) klass); \
+} \
+\
+GType \
+type_name##_get_type (void) \
+{ \
+  static GType g_define_type_id = 0; \
+  if (G_UNLIKELY (g_define_type_id == 0)) \
+    { \
+      static const GTypeInfo g_define_type_info = { \
+        sizeof (TypeName##Class), \
+        (GBaseInitFunc) NULL, \
+        (GBaseFinalizeFunc) NULL, \
+        (GClassInitFunc) type_name##_class_intern_init, \
+        (GClassFinalizeFunc) NULL, \
+        NULL,   /* class_data */ \
+        sizeof (TypeName), \
+        0,      /* n_preallocs */ \
+        (GInstanceInitFunc) type_name##_init, \
+        NULL    /* value_table */ \
+      }; \
+      g_define_type_id = g_type_register_static (TYPE_PARENT, #TypeName, &amp;g_define_type_info, (GTypeFlags) flags); \
+      { CODE ; } \
+    } \
+  return g_define_type_id; \
+}
+
+
+/* --- protected (for fundamental type implementations) --- */
+GTypePlugin*	 g_type_get_plugin		(GType		     type);
+GTypePlugin*	 g_type_interface_get_plugin	(GType		     instance_type,
+						 GType               interface_type);
+GType		 g_type_fundamental_next	(void);
+GType		 g_type_fundamental		(GType		     type_id);
+GTypeInstance*   g_type_create_instance         (GType               type);
+void             g_type_free_instance           (GTypeInstance      *instance);
+
+void		 g_type_add_class_cache_func    (gpointer	     cache_data,
+						 GTypeClassCacheFunc cache_func);
+void		 g_type_remove_class_cache_func (gpointer	     cache_data,
+						 GTypeClassCacheFunc cache_func);
+void             g_type_class_unref_uncached    (gpointer            g_class);
+
+void             g_type_add_interface_check     (gpointer	         check_data,
+						 GTypeInterfaceCheckFunc check_func);
+void             g_type_remove_interface_check  (gpointer	         check_data,
+						 GTypeInterfaceCheckFunc chec_func);
+
+GTypeValueTable* g_type_value_table_peek        (GType		     type);
+
+
+/*&lt; private &gt;*/
+gboolean	 g_type_check_instance          (GTypeInstance      *instance);
+GTypeInstance*   g_type_check_instance_cast     (GTypeInstance      *instance,
+						 GType               iface_type);
+gboolean         g_type_check_instance_is_a	(GTypeInstance      *instance,
+						 GType               iface_type);
+GTypeClass*      g_type_check_class_cast        (GTypeClass         *g_class,
+						 GType               is_a_type);
+gboolean         g_type_check_class_is_a        (GTypeClass         *g_class,
+						 GType               is_a_type);
+gboolean	 g_type_check_is_value_type     (GType		     type);
+gboolean	 g_type_check_value             (GValue		    *value);
+gboolean	 g_type_check_value_holds	(GValue		    *value,
+						 GType		     type);
+gboolean         g_type_test_flags              (GType               type,
+						 guint               flags);
+
+
+/* --- debugging functions --- */
+G_CONST_RETURN gchar* g_type_name_from_instance	(GTypeInstance	*instance);
+G_CONST_RETURN gchar* g_type_name_from_class	(GTypeClass	*g_class);
+
+
+/* --- implementation bits --- */
+#ifndef G_DISABLE_CAST_CHECKS
+#  define _G_TYPE_CIC(ip, gt, ct) \
+    ((ct*) g_type_check_instance_cast ((GTypeInstance*) ip, gt))
+#  define _G_TYPE_CCC(cp, gt, ct) \
+    ((ct*) g_type_check_class_cast ((GTypeClass*) cp, gt))
+#else /* G_DISABLE_CAST_CHECKS */
+#  define _G_TYPE_CIC(ip, gt, ct)       ((ct*) ip)
+#  define _G_TYPE_CCC(cp, gt, ct)       ((ct*) cp)
+#endif /* G_DISABLE_CAST_CHECKS */
+#define _G_TYPE_CHI(ip)			(g_type_check_instance ((GTypeInstance*) ip))
+#define _G_TYPE_CHV(vl)			(g_type_check_value ((GValue*) vl))
+#define _G_TYPE_IGC(ip, gt, ct)         ((ct*) (((GTypeInstance*) ip)-&gt;g_class))
+#define _G_TYPE_IGI(ip, gt, ct)         ((ct*) g_type_interface_peek (((GTypeInstance*) ip)-&gt;g_class, gt))
+#ifdef	__GNUC__
+#  define _G_TYPE_CIT(ip, gt)             (G_GNUC_EXTENSION ({ \
+  GTypeInstance *__inst = (GTypeInstance*) ip; GType __t = gt; gboolean __r; \
+  if (__inst &amp;&amp; __inst-&gt;g_class &amp;&amp; __inst-&gt;g_class-&gt;g_type == __t) \
+    __r = TRUE; \
+  else \
+    __r = g_type_check_instance_is_a (__inst, __t); \
+  __r; \
+}))
+#  define _G_TYPE_CCT(cp, gt)             (G_GNUC_EXTENSION ({ \
+  GTypeClass *__class = (GTypeClass*) cp; GType __t = gt; gboolean __r; \
+  if (__class &amp;&amp; __class-&gt;g_type == __t) \
+    __r = TRUE; \
+  else \
+    __r = g_type_check_class_is_a (__class, __t); \
+  __r; \
+}))
+#  define _G_TYPE_CVH(vl, gt)             (G_GNUC_EXTENSION ({ \
+  GValue *__val = (GValue*) vl; GType __t = gt; gboolean __r; \
+  if (__val &amp;&amp; __val-&gt;g_type == __t) \
+    __r = TRUE; \
+  else \
+    __r = g_type_check_value_holds (__val, __t); \
+  __r; \
+}))
+#else  /* !__GNUC__ */
+#  define _G_TYPE_CIT(ip, gt)             (g_type_check_instance_is_a ((GTypeInstance*) ip, gt))
+#  define _G_TYPE_CCT(cp, gt)             (g_type_check_class_is_a ((GTypeClass*) cp, gt))
+#  define _G_TYPE_CVH(vl, gt)             (g_type_check_value_holds ((GValue*) vl, gt))
+#endif /* !__GNUC__ */
+#define	G_TYPE_FLAG_RESERVED_ID_BIT	((GType) (1 &lt;&lt; 0))
+extern GTypeDebugFlags			_g_type_debug_flags;
+
+G_END_DECLS
+
+#endif /* __G_TYPE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypemodule.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypemodule.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypemodule.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,85 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2000 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_TYPE_MODULE_H__
+#define __G_TYPE_MODULE_H__
+
+#include &lt;gobject/gobject.h&gt;
+
+G_BEGIN_DECLS
+
+typedef struct _GTypeModule      GTypeModule;
+typedef struct _GTypeModuleClass GTypeModuleClass;
+
+#define G_TYPE_TYPE_MODULE              (g_type_module_get_type ())
+#define G_TYPE_MODULE(module)           (G_TYPE_CHECK_INSTANCE_CAST ((module), G_TYPE_TYPE_MODULE, GTypeModule))
+#define G_TYPE_MODULE_CLASS(class)      (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_TYPE_MODULE, GTypeModuleClass))
+#define G_IS_TYPE_MODULE(module)        (G_TYPE_CHECK_INSTANCE_TYPE ((module), G_TYPE_TYPE_MODULE))
+#define G_IS_TYPE_MODULE_CLASS(class)   (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_TYPE_MODULE))
+#define G_TYPE_MODULE_GET_CLASS(module) (G_TYPE_INSTANCE_GET_CLASS ((module), G_TYPE_TYPE_MODULE, GTypeModuleClass))
+
+struct _GTypeModule 
+{
+  GObject parent_instance;
+
+  guint use_count;
+  GSList *type_infos;
+  GSList *interface_infos;
+
+  /*&lt; public &gt;*/
+  gchar *name;
+};
+
+struct _GTypeModuleClass
+{
+  GObjectClass parent_class;
+
+  /*&lt; public &gt;*/
+  gboolean (* load)   (GTypeModule *module);
+  void     (* unload) (GTypeModule *module);
+
+  /*&lt; private &gt;*/
+  /* Padding for future expansion */
+  void (*reserved1) (void);
+  void (*reserved2) (void);
+  void (*reserved3) (void);
+  void (*reserved4) (void);
+};
+
+GType    g_type_module_get_type      (void);
+gboolean g_type_module_use           (GTypeModule     *module);
+void     g_type_module_unuse         (GTypeModule     *module);
+void     g_type_module_set_name      (GTypeModule     *module,
+				      const gchar     *name);
+GType    g_type_module_register_type (GTypeModule     *module,
+				      GType            parent_type,
+				      const gchar     *type_name,
+				      const GTypeInfo *type_info,
+				      GTypeFlags       flags);
+void     g_type_module_add_interface (GTypeModule           *module,
+				      GType                  instance_type,
+				      GType                  interface_type,
+				      const GInterfaceInfo  *interface_info);
+
+G_END_DECLS
+
+#endif /* __G_TYPE_MODULE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypeplugin.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypeplugin.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gtypeplugin.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,79 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2000 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_TYPE_PLUGIN_H__
+#define __G_TYPE_PLUGIN_H__
+
+#include	&lt;gobject/gtype.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define G_TYPE_TYPE_PLUGIN		(g_type_plugin_get_type ())
+#define G_TYPE_PLUGIN(inst)		(G_TYPE_CHECK_INSTANCE_CAST ((inst), G_TYPE_TYPE_PLUGIN, GTypePlugin))
+#define G_TYPE_PLUGIN_CLASS(vtable)	(G_TYPE_CHECK_CLASS_CAST ((vtable), G_TYPE_TYPE_PLUGIN, GTypePluginClass))
+#define G_IS_TYPE_PLUGIN(inst)		(G_TYPE_CHECK_INSTANCE_TYPE ((inst), G_TYPE_TYPE_PLUGIN))
+#define G_IS_TYPE_PLUGIN_CLASS(vtable)	(G_TYPE_CHECK_CLASS_TYPE ((vtable), G_TYPE_TYPE_PLUGIN))
+#define G_TYPE_PLUGIN_GET_CLASS(inst)	(G_TYPE_INSTANCE_GET_INTERFACE ((inst), G_TYPE_TYPE_PLUGIN, GTypePluginClass))
+
+
+/* --- typedefs &amp; structures --- */
+typedef struct _GTypePluginClass		   GTypePluginClass;
+typedef void  (*GTypePluginUse)			  (GTypePlugin     *plugin);
+typedef void  (*GTypePluginUnuse)		  (GTypePlugin     *plugin);
+typedef void  (*GTypePluginCompleteTypeInfo)	  (GTypePlugin     *plugin,
+						   GType            g_type,
+						   GTypeInfo       *info,
+						   GTypeValueTable *value_table);
+typedef void  (*GTypePluginCompleteInterfaceInfo) (GTypePlugin     *plugin,
+						   GType            instance_type,
+						   GType            interface_type,
+						   GInterfaceInfo  *info);
+struct _GTypePluginClass
+{
+  /*&lt; private &gt;*/
+  GTypeInterface		   base_iface;
+  
+  /*&lt; public &gt;*/
+  GTypePluginUse		   use_plugin;
+  GTypePluginUnuse		   unuse_plugin;
+  GTypePluginCompleteTypeInfo	   complete_type_info;
+  GTypePluginCompleteInterfaceInfo complete_interface_info;
+};
+
+
+/* --- prototypes --- */
+GType	g_type_plugin_get_type			(void)	G_GNUC_CONST;
+void	g_type_plugin_use			(GTypePlugin	 *plugin);
+void	g_type_plugin_unuse			(GTypePlugin	 *plugin);
+void	g_type_plugin_complete_type_info	(GTypePlugin     *plugin,
+						 GType            g_type,
+						 GTypeInfo       *info,
+						 GTypeValueTable *value_table);
+void	g_type_plugin_complete_interface_info	(GTypePlugin     *plugin,
+						 GType            instance_type,
+						 GType            interface_type,
+						 GInterfaceInfo  *info);
+
+G_END_DECLS
+
+#endif /* __G_TYPE_PLUGIN_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvalue.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvalue.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvalue.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,94 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * gvalue.h: generic GValue functions
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_VALUE_H__
+#define __G_VALUE_H__
+
+#include	&lt;gobject/gtype.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define	G_TYPE_IS_VALUE(type)		(g_type_check_is_value_type (type))
+#define	G_IS_VALUE(value)		(G_TYPE_CHECK_VALUE (value))
+#define	G_VALUE_TYPE(value)		(((GValue*) (value))-&gt;g_type)
+#define	G_VALUE_TYPE_NAME(value)	(g_type_name (G_VALUE_TYPE (value)))
+#define G_VALUE_HOLDS(value,type)	(G_TYPE_CHECK_VALUE_TYPE ((value), (type)))
+
+
+/* --- typedefs &amp; structures --- */
+typedef void (*GValueTransform) (const GValue *src_value,
+				 GValue       *dest_value);
+struct _GValue
+{
+  /*&lt; private &gt;*/
+  GType		g_type;
+
+  /* public for GTypeValueTable methods */
+  union {
+    gint	v_int;
+    guint	v_uint;
+    glong	v_long;
+    gulong	v_ulong;
+    gint64      v_int64;
+    guint64     v_uint64;
+    gfloat	v_float;
+    gdouble	v_double;
+    gpointer	v_pointer;
+  } data[2];
+};
+
+
+/* --- prototypes --- */
+GValue*         g_value_init	   	(GValue       *value,
+					 GType         g_type);
+void            g_value_copy    	(const GValue *src_value,
+					 GValue       *dest_value);
+GValue*         g_value_reset   	(GValue       *value);
+void            g_value_unset   	(GValue       *value);
+void		g_value_set_instance	(GValue	      *value,
+					 gpointer      instance);
+
+
+/* --- private --- */
+gboolean	g_value_fits_pointer	(const GValue *value);
+gpointer	g_value_peek_pointer	(const GValue *value);
+
+
+/* --- implementation details --- */
+gboolean g_value_type_compatible	(GType		 src_type,
+					 GType		 dest_type);
+gboolean g_value_type_transformable	(GType           src_type,
+					 GType           dest_type);
+gboolean g_value_transform		(const GValue   *src_value,
+					 GValue         *dest_value);
+void	g_value_register_transform_func	(GType		 src_type,
+					 GType		 dest_type,
+					 GValueTransform transform_func);
+#define G_VALUE_NOCOPY_CONTENTS		(1 &lt;&lt; 27)
+
+
+G_END_DECLS
+
+#endif /* __G_VALUE_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluearray.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluearray.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluearray.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,75 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * gvaluearray.h: GLib array type holding GValues
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_VALUE_ARRAY_H__
+#define __G_VALUE_ARRAY_H__
+
+#include	&lt;gobject/gvalue.h&gt;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif /* __cplusplus */
+
+
+/* --- typedefs &amp; structs --- */
+typedef struct _GValueArray GValueArray;
+struct _GValueArray
+{
+  guint   n_values;
+  GValue *values;
+
+  /*&lt; private &gt;*/
+  guint   n_prealloced;
+};
+
+
+/* --- prototypes --- */
+GValue*		g_value_array_get_nth	     (GValueArray	*value_array,
+					      guint		 index_);
+GValueArray*	g_value_array_new	     (guint		 n_prealloced);
+void		g_value_array_free	     (GValueArray	*value_array);
+GValueArray*	g_value_array_copy	     (const GValueArray *value_array);
+GValueArray*	g_value_array_prepend	     (GValueArray	*value_array,
+					      const GValue	*value);
+GValueArray*	g_value_array_append	     (GValueArray	*value_array,
+					      const GValue	*value);
+GValueArray*	g_value_array_insert	     (GValueArray	*value_array,
+					      guint		 index_,
+					      const GValue	*value);
+GValueArray*	g_value_array_remove	     (GValueArray	*value_array,
+					      guint		 index_);
+GValueArray*	g_value_array_sort	     (GValueArray	*value_array,
+					      GCompareFunc	 compare_func);
+GValueArray*	g_value_array_sort_with_data (GValueArray	*value_array,
+					      GCompareDataFunc	 compare_func,
+					      gpointer		 user_data);
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __G_VALUE_ARRAY_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluecollector.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluecollector.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluecollector.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,160 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * gvaluecollector.h: GValue varargs stubs
+ */
+#ifndef __G_VALUE_COLLECTOR_H__
+#define __G_VALUE_COLLECTOR_H__
+
+#include &lt;glib-object.h&gt;
+
+G_BEGIN_DECLS
+
+/* we may want to add aggregate types here some day, if requested
+ * by users. the basic C types are covered already, everything
+ * smaller than an int is promoted to an integer and floats are
+ * always promoted to doubles for varargs call constructions.
+ */
+enum	/*&lt; skip &gt;*/
+{
+  G_VALUE_COLLECT_INT		= 'i',
+  G_VALUE_COLLECT_LONG		= 'l',
+  G_VALUE_COLLECT_INT64         = 'q',
+  G_VALUE_COLLECT_DOUBLE	= 'd',
+  G_VALUE_COLLECT_POINTER	= 'p'
+};
+
+
+/* vararg union holding actuall values collected
+ */
+union _GTypeCValue
+{
+  gint     v_int;
+  glong    v_long;
+  gint64   v_int64;
+  gdouble  v_double;
+  gpointer v_pointer;
+};
+
+
+/* G_VALUE_COLLECT() collects a variable argument value
+ * from a va_list. we have to implement the varargs collection as a
+ * macro, because on some systems va_list variables cannot be passed
+ * by reference.
+ * value is supposed to be initialized according to the value
+ * type to be collected.
+ * var_args is the va_list variable and may be evaluated multiple times.
+ * __error is a gchar** variable that will be modified to hold a g_new()
+ * allocated error messages if something fails.
+ */
+#define G_VALUE_COLLECT(value, var_args, flags, __error)				\
+G_STMT_START {										\
+  GValue *_value = (value);								\
+  guint _flags = (flags);								\
+  GType _value_type = G_VALUE_TYPE (_value);						\
+  GTypeValueTable *_vtable = g_type_value_table_peek (_value_type);			\
+  gchar *_collect_format = _vtable-&gt;collect_format;					\
+  GTypeCValue _cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };		\
+  guint _n_values = 0;									\
+                                                                                        \
+  if (_vtable-&gt;value_free)								\
+    _vtable-&gt;value_free (_value);							\
+  _value-&gt;g_type = _value_type;		/* value_meminit() from gvalue.c */		\
+  memset (_value-&gt;data, 0, sizeof (_value-&gt;data));					\
+  while (*_collect_format)								\
+    {											\
+      GTypeCValue *_cvalue = _cvalues + _n_values++;					\
+                                                                                        \
+      switch (*_collect_format++)							\
+	{										\
+	case G_VALUE_COLLECT_INT:							\
+	  _cvalue-&gt;v_int = va_arg ((var_args), gint);					\
+	  break;									\
+	case G_VALUE_COLLECT_LONG:							\
+	  _cvalue-&gt;v_long = va_arg ((var_args), glong);					\
+	  break;									\
+	case G_VALUE_COLLECT_INT64:							\
+	  _cvalue-&gt;v_int64 = va_arg ((var_args), gint64);				\
+	  break;									\
+	case G_VALUE_COLLECT_DOUBLE:							\
+	  _cvalue-&gt;v_double = va_arg ((var_args), gdouble);				\
+	  break;									\
+	case G_VALUE_COLLECT_POINTER:							\
+	  _cvalue-&gt;v_pointer = va_arg ((var_args), gpointer);				\
+	  break;									\
+	default:									\
+	  g_assert_not_reached ();							\
+	}										\
+    }											\
+  *(__error) = _vtable-&gt;collect_value (_value,						\
+				       _n_values,					\
+				       _cvalues,					\
+				       _flags);						\
+} G_STMT_END
+
+
+/* G_VALUE_LCOPY() collects a value's variable argument
+ * locations from a va_list. usage is analogous to G_VALUE_COLLECT().
+ */
+#define G_VALUE_LCOPY(value, var_args, flags, __error)					\
+G_STMT_START {										\
+  const GValue *_value = (value);							\
+  guint _flags = (flags);								\
+  GType _value_type = G_VALUE_TYPE (_value);						\
+  GTypeValueTable *_vtable = g_type_value_table_peek (_value_type);			\
+  gchar *_lcopy_format = _vtable-&gt;lcopy_format;						\
+  GTypeCValue _cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };		\
+  guint _n_values = 0;									\
+                                                                                        \
+  while (*_lcopy_format)								\
+    {											\
+      GTypeCValue *_cvalue = _cvalues + _n_values++;					\
+                                                                                        \
+      switch (*_lcopy_format++)								\
+	{										\
+	case G_VALUE_COLLECT_INT:							\
+	  _cvalue-&gt;v_int = va_arg ((var_args), gint);					\
+	  break;									\
+	case G_VALUE_COLLECT_LONG:							\
+	  _cvalue-&gt;v_long = va_arg ((var_args), glong);					\
+	  break;									\
+	case G_VALUE_COLLECT_INT64:							\
+	  _cvalue-&gt;v_int64 = va_arg ((var_args), gint64);				\
+	  break;									\
+	case G_VALUE_COLLECT_DOUBLE:							\
+	  _cvalue-&gt;v_double = va_arg ((var_args), gdouble);				\
+	  break;									\
+	case G_VALUE_COLLECT_POINTER:							\
+	  _cvalue-&gt;v_pointer = va_arg ((var_args), gpointer);				\
+	  break;									\
+	default:									\
+	  g_assert_not_reached ();							\
+	}										\
+    }											\
+  *(__error) = _vtable-&gt;lcopy_value (_value,						\
+				     _n_values,						\
+				     _cvalues,						\
+				     _flags);						\
+} G_STMT_END
+
+
+#define	G_VALUE_COLLECT_FORMAT_MAX_LENGTH	(8)
+
+G_END_DECLS
+
+#endif /* __G_VALUE_COLLECTOR_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluetypes.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluetypes.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/glib-dev-2.4.5/include/glib-2.0/gobject/gvaluetypes.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,114 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * gvaluetypes.h: GLib default values
+ */
+#if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
+#error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
+#endif
+
+#ifndef __G_VALUETYPES_H__
+#define __G_VALUETYPES_H__
+
+#include	&lt;gobject/gvalue.h&gt;
+
+G_BEGIN_DECLS
+
+/* --- type macros --- */
+#define G_VALUE_HOLDS_CHAR(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_CHAR))
+#define G_VALUE_HOLDS_UCHAR(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_UCHAR))
+#define G_VALUE_HOLDS_BOOLEAN(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_BOOLEAN))
+#define G_VALUE_HOLDS_INT(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_INT))
+#define G_VALUE_HOLDS_UINT(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_UINT))
+#define G_VALUE_HOLDS_LONG(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_LONG))
+#define G_VALUE_HOLDS_ULONG(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_ULONG))
+#define G_VALUE_HOLDS_INT64(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_INT64))
+#define G_VALUE_HOLDS_UINT64(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_UINT64))
+#define G_VALUE_HOLDS_FLOAT(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_FLOAT))
+#define G_VALUE_HOLDS_DOUBLE(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_DOUBLE))
+#define G_VALUE_HOLDS_STRING(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_STRING))
+#define G_VALUE_HOLDS_POINTER(value)	 (G_TYPE_CHECK_VALUE_TYPE ((value), G_TYPE_POINTER))
+
+
+/* --- prototypes --- */
+void		      g_value_set_char		(GValue	      *value,
+						 gchar	       v_char);
+gchar		      g_value_get_char		(const GValue *value);
+void		      g_value_set_uchar		(GValue	      *value,
+						 guchar	       v_uchar);
+guchar		      g_value_get_uchar		(const GValue *value);
+void		      g_value_set_boolean	(GValue	      *value,
+						 gboolean      v_boolean);
+gboolean	      g_value_get_boolean	(const GValue *value);
+void		      g_value_set_int		(GValue	      *value,
+						 gint	       v_int);
+gint		      g_value_get_int		(const GValue *value);
+void		      g_value_set_uint		(GValue	      *value,
+						 guint	       v_uint);
+guint		      g_value_get_uint		(const GValue *value);
+void		      g_value_set_long		(GValue	      *value,
+						 glong	       v_long);
+glong		      g_value_get_long		(const GValue *value);
+void		      g_value_set_ulong		(GValue	      *value,
+						 gulong	       v_ulong);
+gulong		      g_value_get_ulong		(const GValue *value);
+void		      g_value_set_int64		(GValue	      *value,
+						 gint64	       v_int64);
+gint64		      g_value_get_int64		(const GValue *value);
+void		      g_value_set_uint64	(GValue	      *value,
+						 guint64      v_uint64);
+guint64		      g_value_get_uint64	(const GValue *value);
+void		      g_value_set_float		(GValue	      *value,
+						 gfloat	       v_float);
+gfloat		      g_value_get_float		(const GValue *value);
+void		      g_value_set_double	(GValue	      *value,
+						 gdouble       v_double);
+gdouble		      g_value_get_double	(const GValue *value);
+void		      g_value_set_string	(GValue	      *value,
+						 const gchar  *v_string);
+void		      g_value_set_static_string (GValue	      *value,
+						 const gchar  *v_string);
+G_CONST_RETURN gchar* g_value_get_string	(const GValue *value);
+gchar*		      g_value_dup_string	(const GValue *value);
+void		      g_value_set_pointer	(GValue	      *value,
+						 gpointer      v_pointer);
+gpointer	      g_value_get_pointer	(const GValue *value);
+
+
+/* Convenience for registering new pointer types */
+GType                 g_pointer_type_register_static (const gchar *name);
+
+/* debugging aid, describe value contents as string */
+gchar*                g_strdup_value_contents   (const GValue *value);
+
+
+void g_value_take_string		        (GValue		   *value,
+						 gchar		   *v_string);
+#ifndef G_DISABLE_DEPRECATED
+void g_value_set_string_take_ownership		(GValue		   *value,
+						 gchar		   *v_string);
+#endif
+
+
+/* humpf, need a C representable type name for G_TYPE_STRING */
+typedef gchar* gchararray;
+
+
+G_END_DECLS
+
+#endif /* __G_VALUETYPES_H__ */

Added: upwatch/trunk/mswindows/MonitorService/glib.lib
===================================================================
(Binary files differ)


Property changes on: upwatch/trunk/mswindows/MonitorService/glib.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: upwatch/trunk/mswindows/MonitorService/libpcre.lib
===================================================================
(Binary files differ)


Property changes on: upwatch/trunk/mswindows/MonitorService/libpcre.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: upwatch/trunk/mswindows/MonitorService/log.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorService/log.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/log.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,172 @@
+#include &lt;cstdio&gt;
+#include &lt;ctime&gt;
+#include &lt;process.h&gt;
+#include &lt;winsock.h&gt;
+
+extern &quot;C&quot; {
+#include &quot;.\snprintf.h&quot;
+}
+
+#ifdef DMALLOC 
+#include &quot;dmalloc.h&quot;
+#endif
+
+// publicly accessible vars
+char *progname;
+int _log2stderr;
+int _log2syslog;
+char *_logfilename;
+
+/****************************
+ logging utility function
+ Mar 31 22:17:53 ts probe[20492]: main.c(63): startup ron
+ ***************************/
+
+#ifdef WITH_THREADS
+pthread_mutex_t _logmutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+char *_logsrce;
+int _logline;
+char *_logfile;
+static void _ll_lograw(int level, const char *msg);
+
+void _LOGRAW(int level, char *buffer)
+{
+  char *p, *file;
+  char msg[2500];
+  unsigned now = (unsigned) time(NULL);
+static char prvmsg[512];
+static int rpt;
+static unsigned prv;
+
+  if ((p = strrchr(_logsrce, '/')) != NULL) {
+    file = ++p;
+  } else {
+    file = _logsrce;
+  }
+  sprintf(msg, &quot;%s[%lu] %s(%d): &quot;, progname, (unsigned long)getpid(), file, _logline);
+  strncat(msg, buffer, sizeof(msg) - 80); // it's assumed that progname+getpid+file+line &lt; 80
+
+  //fprintf(stderr, &quot;compare: rpt=%u, msg=%s, prv=%s\n&quot;, rpt, msg, prvmsg);
+  // test if the same error happens again and again
+  if (strncmp(prvmsg, msg, sizeof(prvmsg)) == 0) { 
+    //fprintf(stderr, &quot;they are the same\n&quot;);
+    if (now - prv &lt; 300) { // but not more then 5 minutes ago
+      //fprintf(stderr, &quot;and not longer than 5 min ago\n&quot;);
+      rpt++;
+      return;
+    }
+  }
+  // at this point it either isn't the same message, or 5 minutes have passed
+  if (rpt) {
+    char buf[256];
+
+    sprintf(buf, &quot;%s[%lu] last message repeated %u times&quot;, progname, (unsigned long)getpid(), rpt);
+    _ll_lograw(level, buf);
+    rpt = 0;
+  }
+  prv = now;
+  strncpy(prvmsg, msg, sizeof(prvmsg));
+  _ll_lograw(level, msg);
+}
+
+static void _ll_lograw(int level, const char *msg)
+{
+	static int debug = 3;
+  struct tm *tms;
+  time_t now;
+  char timebuf[30];
+  char hostname[256];
+  char *p;
+
+  time(&amp;now);
+  tms = gmtime(&amp;now);
+  strftime(timebuf, sizeof(timebuf), &quot;%b %e %H:%M:%S&quot;, tms);
+ 
+  gethostname(hostname, sizeof(hostname));
+  p = strchr(hostname, '.');
+  if (p) *p = 0;
+
+  if (_log2stderr &amp;&amp; (level-debug &lt; 5)) {
+    fprintf(stderr, &quot;%s %s %s\n&quot;, timebuf, hostname, msg);
+  }
+  if (_logfilename &amp;&amp; (level-debug &lt; 5)) {
+    FILE *out;
+
+    out = fopen(_logfilename, &quot;a&quot;);
+    if (out) {
+      fprintf(out, &quot;%s %s %s\n&quot;, timebuf, hostname, msg);
+      fclose(out);
+    } else {
+      _log2syslog = 1;
+    }
+  }
+  /*if (_log2syslog) {
+    syslog(level, msg);
+  }*/
+#ifdef WITH_THREADS
+  pthread_mutex_unlock(&amp;_logmutex);
+#endif
+}
+
+void _LOG(int level, char *fmt, ...)
+{
+  char buffer[2048]; // this is as long as we need errors to be
+  char newfmt[256];
+  char *p, *q;
+  va_list arg;
+
+static int firsttime = 1;
+static int snprintf_does_errno;  // set to true if snprintf does %m conversions
+
+  if (firsttime) {
+    char tmp[256];
+
+    firsttime = 0;
+    snprintf(tmp, sizeof(tmp), &quot;%m&quot;);
+    if (strcmp(tmp, strerror(errno))) {
+      snprintf_does_errno = 0;
+    } else {
+      snprintf_does_errno = 1;
+    }
+  }
+
+  if (fmt == NULL) fmt = &quot;(null)&quot;;
+
+  // expand %m if needed
+  if (!snprintf_does_errno) {
+    for (p = fmt, q = &amp;newfmt[0]; *p &amp;&amp; q &lt; (newfmt + sizeof(newfmt) -1);) {
+      switch(*p) {
+      case '\\': 
+        *q++ = *p++; 
+        if (*p) *q++ = *p++; /* escape a character */
+        break; 
+      case '%':   
+        if (*(p+1) == 'm') {
+          strcpy(q, strerror(errno));
+          p += 2;
+          q += strlen(strerror(errno));
+          break;
+        }
+      default:
+        *q++ = *p++;
+        break;
+      }
+    }
+    *q = 0;
+    fmt = newfmt;
+  }
+
+  va_start(arg, fmt);
+  vsnprintf(buffer, sizeof(buffer)-256 /* extra space for %m expansions */, fmt, arg);
+  va_end(arg);
+
+      
+  // kill trailing blanks (xml errors have this a lot)
+  for (p = &amp;buffer[(unsigned char)(strlen(buffer) - 1)]; isspace(*p); p--) {
+    *p = 0;
+  }
+
+  _LOGRAW(level, buffer);
+}
+

Added: upwatch/trunk/mswindows/MonitorService/log.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/log.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/log.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,18 @@
+//#include &lt;syslog.h&gt;
+#ifdef WITH_THREADS
+#define LOG pthread_mutex_lock(&amp;_logmutex),_logsrce=__FILE__,_logline=__LINE__,_LOG
+#define LOGRAW pthread_mutex_lock(&amp;_logmutex),_logsrce=__FILE__,_logline=__LINE__,_LOGRAW
+extern pthread_mutex_t _logmutex;
+#else
+#define LOG _logsrce=__FILE__,_logline=__LINE__,_LOG
+#define LOGRAW _logsrce=__FILE__,_logline=__LINE__,_LOGRAW
+#endif
+void _LOG(int level, char *fmt, ...);
+void _LOGRAW(int level, char *fmt);
+extern char *_logsrce;
+extern char *progname;
+extern int _logline;
+extern int _log2stderr;
+extern int _log2syslog;
+extern char *_logfilename;
+

Added: upwatch/trunk/mswindows/MonitorService/logregex.cpp
===================================================================
--- upwatch/trunk/mswindows/MonitorService/logregex.cpp	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/logregex.cpp	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,628 @@
+#include &lt;cstdio&gt;
+#include &lt;string&gt;
+#include &lt;sys/stat.h&gt;
+#include &quot;.\glib.h&quot;
+#include &quot;.\log.h&quot;
+#include &quot;.\logregex.h&quot;
+#include &quot;.\errorlog.h&quot;
+
+#define MACROS &quot;macros.txt&quot;
+#define RMACROS &quot;rmacros.txt&quot;
+
+struct regexspec {
+  char *file;   // basefilename this regex is originating from
+  char *regex;  // regular expression
+  regex_t preg; // compiled version
+  unsigned match; // number of times this regex matched
+};
+
+struct macrodef {
+  char *key;
+  int keylen;
+  char *value;
+};
+
+struct typespec {
+  char *name;
+  int runs;                 // total amount of matching runs
+  int pondered;             // total amount of regexes pondered
+  GPtrArray *macros;        // points to list of macrodefs
+  GPtrArray *rmacros;       // points to list of macrodefs
+  GPtrArray *green;         // points to list of regexspec structures
+  int gmatch;               // how many times is the green matching done so far
+  GPtrArray *yellow;        // same here
+  GPtrArray *red;           // same here
+};
+
+static GHashTable *files; // table of all files and the modification date
+static GHashTable *types; // table of all logfile type. point to struct typespecs
+
+static guint *guintdup(guint val)
+{
+  guint *iptr = (guint*)g_malloc(sizeof(guint));
+  *iptr = val;
+  return(iptr);
+}
+
+// return TRUE if the given file was modified since
+// we last read it.
+static int logregex_file_newer(char *fullname)
+{
+  struct stat st;
+  time_t *previous;
+
+  if (files == NULL) {
+    files = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+  }
+  if (stat(fullname, &amp;st)) {
+    LOG(LOG_WARNING, &quot;%s: %m&quot;, fullname);
+    return 0;                  // problem accessing file
+  }
+  previous = (time_t *)g_hash_table_lookup(files, fullname);
+  if (!previous) { // not yet in table: insert it
+    g_hash_table_insert(files, strdup(fullname), guintdup((guint)st.st_mtime));
+    return 1;
+  }
+  if (st.st_mtime &gt; *previous) { // current file newer?
+    *previous = st.st_mtime;
+    return 1;
+  } 
+  return 0;
+}
+
+// (re)read macro-definitions if necessary
+//
+static void logregex_read_macros(GPtrArray *macs, char *filename)
+{
+  FILE *in;
+  char buffer[4096];
+
+  //printf(&quot;read macros %s\n&quot;, filename);
+  in = fopen(filename, &quot;r&quot;);
+  if (in == NULL) {
+    LOG(LOG_WARNING, &quot;%s: %m&quot;, filename);
+    return;
+  }
+
+  while (fgets(buffer, sizeof(buffer), in)) {
+    char *p;
+    struct macrodef *macro;
+
+    if (buffer[0] == 0) continue;
+    if (buffer[0] == '\n') continue;
+    if (buffer[0] == ' ') continue;
+    if (buffer[0] == '#') continue;
+    if (buffer[0] == ';') continue;
+
+    buffer[strlen(buffer)-1] = 0;
+    for (p=buffer; *p; p++) {
+      if (*p == ' ' || *p == '\t') break;
+    }
+    if (!*p) continue;
+    for (*p++ = 0; *p; p++) {
+      if (*p != ' ' &amp;&amp; *p != '\t') {
+        break;
+      }
+    }
+    macro = (macrodef*)malloc(sizeof(struct macrodef));
+    macro-&gt;key = strdup(buffer);
+    macro-&gt;keylen = (int)strlen(buffer);
+    macro-&gt;value = strdup(p);
+    g_ptr_array_add(macs, macro);
+  }
+  fclose(in);
+}
+
+static void logregex_refresh_macros(struct typespec *ts, char *path)
+{
+  char filename[PATH_MAX];
+
+  sprintf(filename, &quot;%s/%s&quot;, path, MACROS);
+  if (!logregex_file_newer(filename)) return;
+  LOG(LOG_INFO, &quot;reloading %s&quot;, filename);
+  if (ts-&gt;macros) {
+    while (ts-&gt;macros-&gt;len) {
+      struct macrodef *macro;
+
+      macro = (macrodef*)g_ptr_array_remove_index_fast(ts-&gt;macros, 0);
+      free(macro-&gt;key);
+      free(macro-&gt;value);
+      free(macro);
+    }
+    g_ptr_array_free(ts-&gt;macros, 0);
+  }
+  ts-&gt;macros = g_ptr_array_new();
+  logregex_read_macros(ts-&gt;macros, filename);
+}
+
+static char *logregex_macro_find(GPtrArray *macros, char *key)
+{
+  int i;
+
+  for (i=0; i &lt; (int)macros-&gt;len; i++) {
+    struct macrodef *macro;
+
+    macro =  (macrodef*)g_ptr_array_index(macros, i);
+    if (strcmp(macro-&gt;key, key) == 0) {
+      return(macro-&gt;value);
+    }
+  }
+  return NULL;
+}
+
+static int logregex_is_macro(GPtrArray *macros, char *key)
+{
+  int i;
+
+  for (i=0; i &lt; (int)macros-&gt;len; i++) {
+    struct macrodef *macro;
+
+    macro = (macrodef*)g_ptr_array_index(macros, i);
+    if (strncmp(key, macro-&gt;key, macro-&gt;keylen) == 0) {
+      return(macro-&gt;keylen);
+    }
+  }
+  return 0;
+}
+
+static void logregex_replace_macros(GPtrArray *macros, char *in, char *out)
+{
+  char *p;
+
+  for (p = in; *p; p++) {
+    if (*p == '[') {
+      char *head, *tail;
+      char *replace;
+      char var[4096];
+
+      for (head = p+1, tail = var; *head;) {
+        if (*head == ']') {
+          *tail = 0;
+          break;
+        }
+        *tail++ = *head++;
+      }
+      if (!*head) continue;
+      replace = logregex_macro_find(macros, var);
+      if (replace) {
+        strcpy(out, replace);
+        out += strlen(replace);
+        p = head;
+        continue;
+      }
+    }
+    *out++ = *p;
+  }
+  *out = 0;
+}
+
+static void logregex_refresh_rmacros(struct typespec *ts, char *path)
+{
+  char filename[PATH_MAX];
+
+  sprintf(filename, &quot;%s/%s&quot;, path, RMACROS);
+  if (!logregex_file_newer(filename)) return;
+  LOG(LOG_INFO, &quot;reloading %s&quot;, filename);
+  if (ts-&gt;rmacros) {
+    while (ts-&gt;rmacros-&gt;len) {
+      struct macrodef *macro;
+
+      macro = (macrodef*)g_ptr_array_remove_index_fast(ts-&gt;rmacros, 0);
+      free(macro-&gt;key);
+      free(macro-&gt;value);
+      free(macro);
+    }
+    g_ptr_array_free(ts-&gt;rmacros, 0);
+  }
+  ts-&gt;rmacros = g_ptr_array_new();
+  logregex_read_macros(ts-&gt;rmacros, filename);
+}
+
+static void free_regexspec(gpointer data)
+{
+  struct regexspec *rs = (struct regexspec *) data;
+
+  free(rs-&gt;file);
+  free(rs-&gt;regex);
+  regfree(&amp;rs-&gt;preg);
+  free(rs);
+}
+
+static void logregex_remove_file(struct typespec *ts, char *file)
+{
+  int i;
+
+  //printf(&quot;remove %s:%s\n&quot;, ts-&gt;name, file);
+  if (ts-&gt;green) {
+    for (i=0; i &lt; (int)ts-&gt;green-&gt;len; i++) {
+      struct regexspec *rs = (regexspec*)g_ptr_array_index(ts-&gt;green, i);
+      if (strcmp(file, rs-&gt;file) == 0) {
+        g_ptr_array_remove_index(ts-&gt;green, i);
+        free_regexspec(rs);
+        i--;
+      }
+    }
+  }
+  if (ts-&gt;yellow) {
+    for (i=0; i &lt; (int)ts-&gt;yellow-&gt;len; i++) {
+      struct regexspec *rs = (regexspec*)g_ptr_array_index(ts-&gt;yellow, i);
+      if (strcmp(file, rs-&gt;file) == 0) {
+        g_ptr_array_remove_index(ts-&gt;yellow, i);
+        free_regexspec(rs);
+        i--;
+      }
+    }
+  }
+  if (ts-&gt;red) {
+    for (i=0; i &lt; (int)ts-&gt;red-&gt;len; i++) {
+      struct regexspec *rs = (regexspec*)g_ptr_array_index(ts-&gt;red, i);
+      if (strcmp(file, rs-&gt;file) == 0) {
+        g_ptr_array_remove_index(ts-&gt;red, i);
+        free_regexspec(rs);
+        i--;
+      }
+    }
+  }
+}
+
+static void free_typespec(gpointer data)
+{
+  struct typespec *ts = (struct typespec *) data;
+
+  g_free(ts-&gt;name);
+  g_ptr_array_free(ts-&gt;macros, TRUE);
+  g_ptr_array_free(ts-&gt;green, TRUE);
+  g_ptr_array_free(ts-&gt;yellow, TRUE);
+  g_ptr_array_free(ts-&gt;red, TRUE);
+  g_free(ts);
+}
+
+// add the regular expressions in a file to our internal database
+// 
+static void logregex_add_file(char *fullname, struct typespec *ts, char *file)
+{
+  FILE *in;
+  char buffer[4096];
+  char buffer2[8192];
+  int line = 0;
+
+  //printf(&quot;add %s as %s:%s\n&quot;, fullname, ts-&gt;name, file);
+
+  LOG(LOG_INFO, &quot;loading %s&quot;, fullname);
+  in = fopen(fullname, &quot;r&quot;);
+  if (in == NULL) {
+    LOG(LOG_WARNING, &quot;%s: %m&quot;, fullname);
+    return;
+  }
+  while (fgets(buffer, sizeof(buffer), in)) {
+    char *p;
+    int err;
+    struct regexspec *spec = NULL;
+
+    line++;
+    if (buffer[0] == 0) continue;
+    if (buffer[0] == '\n') continue;
+    if (buffer[0] == '\t') continue;
+    if (buffer[0] == ' ') continue;
+    if (buffer[0] == '#') continue;
+    if (buffer[0] == ';') continue;
+    if (buffer[0] == '/') continue;
+
+    buffer[strlen(buffer)-1] = 0;          // strip trailing \n
+    for (p=buffer; *p; p++) {
+      if (*p == ' ' || *p == '\t') break;  // find the end of the first word (probably red or green)
+    }
+    if (!*p) continue;
+    for (*p++ = 0; *p; p++) {
+      if (*p != ' ' &amp;&amp; *p != '\t') { // skip to the beginning of next word
+        break;
+      }
+    }
+    if (!*p) continue;
+    logregex_replace_macros(ts-&gt;macros, p, buffer2);
+    //strcpy(buffer2, p);
+
+    if (!spec) {
+      spec = (regexspec*)malloc(sizeof(struct regexspec));
+    }
+    memset(&amp;spec-&gt;preg, 0, sizeof(spec-&gt;preg));
+    err = regcomp(&amp;spec-&gt;preg, buffer2, REG_EXTENDED|REG_ICASE);
+    if (err) {
+      char buffer[256];
+
+      regerror(err, &amp;spec-&gt;preg, buffer, sizeof(buffer));
+      LOG(LOG_ERR, &quot;%s(%u): %s: %s&quot;, fullname, line, buffer2, buffer);
+      fprintf(stderr, &quot;%s(%u): %s: %s\n&quot;, fullname, line, buffer2, buffer);
+      continue;
+    }
+    spec-&gt;file = strdup(file);
+    spec-&gt;regex = strdup(buffer2);
+    if (strncmp(&quot;green&quot;, buffer, 6) == 0) {
+      g_ptr_array_add(ts-&gt;green, spec);
+    }
+    if (strncmp(&quot;yellow&quot;, buffer, 6) == 0) {
+      g_ptr_array_add(ts-&gt;yellow, spec);
+    }
+    if (strncmp(&quot;red&quot;, buffer, 3) == 0) {
+      g_ptr_array_add(ts-&gt;red, spec);
+    }
+    spec = NULL;
+  }
+  fclose(in);
+}
+
+// refresh the data for a specific filetype (for example syslog)
+// 
+static void logregex_refresh_type(char *path, char *type)
+{
+  struct typespec *ts;
+  GDir *dir;
+  GError *error=NULL;
+  G_CONST_RETURN gchar *filename;
+
+  if (types == NULL) {
+    types = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, free_typespec);
+  }
+  ts = (typespec*)g_hash_table_lookup(types, type);
+  if (!ts) {
+    ts = (typespec*)g_malloc0(sizeof(struct typespec));
+    ts-&gt;name = strdup(type);
+    ts-&gt;green = g_ptr_array_new();
+    ts-&gt;yellow = g_ptr_array_new();
+    ts-&gt;red = g_ptr_array_new();
+    g_hash_table_insert(types, strdup(type), ts);
+  }
+
+  logregex_refresh_macros(ts, path); // refresh the macros first
+  logregex_refresh_rmacros(ts, path); // and the reverse macros
+  dir = g_dir_open (path, 0, &amp;error);
+  if (dir == NULL) {
+    perror(path);
+    return; 
+  }
+  while ((filename = g_dir_read_name(dir)) != NULL) {
+    char buffer[PATH_MAX];
+
+    if (filename[0] == '.') continue;  // skip '.', '..' and hidden files
+    if (strcmp(filename, MACROS) == 0) continue; // skip macrofiles
+    if (strcmp(filename, RMACROS) == 0) continue; // .. and this one too
+    sprintf(buffer, &quot;%s/%s&quot;, path, filename);
+    if (!g_file_test(buffer, G_FILE_TEST_IS_REGULAR)) {
+      fprintf(stderr, &quot;%s: not a regular file\n&quot;, buffer);
+      continue;
+    }
+    if (logregex_file_newer(buffer)) {
+      logregex_remove_file(ts, (char *)filename);
+      logregex_add_file(buffer, ts, (char *)filename);
+    }
+  }
+  g_dir_close(dir);
+}
+
+static void logregex_print_1stat(gpointer key, gpointer value, gpointer user_data)
+{
+  char *type = (char *)user_data;
+  char *name = (char *)key;
+  struct typespec *ts = (struct typespec *) value;
+  if (type &amp;&amp; strcmp((char*)key, type)) return;
+
+  printf(&quot;%s: runs %u, avg pondered/run %u\n&quot;, name, ts-&gt;runs, ts-&gt;pondered/(ts-&gt;runs?ts-&gt;runs:1));
+}
+
+// print stats for all 
+// 
+void logregex_print_stats(char *type)
+{
+  if (types == NULL) return;
+  g_hash_table_foreach(types, logregex_print_1stat, type);
+}
+
+void logregex_expand_macros(char *type, char *in, char *out)
+{
+  struct typespec *ts;
+
+  if (!types) {
+    strcpy(out, in);
+    return;
+  }
+  ts = (typespec*)g_hash_table_lookup(types, type);
+  if (ts == NULL) {
+    strcpy(out, in);
+    return;
+  }
+  logregex_replace_macros(ts-&gt;macros, in, out);
+}
+
+// read all directories in the path
+// the name of these directories denote the filetype
+// for each filetype read regular expressions and macros
+int logregex_refresh(char *path)
+{
+  GDir *dir;
+  GError *error=NULL;
+  G_CONST_RETURN gchar *filename;
+
+  dir = g_dir_open (path, 0, &amp;error);
+  if (dir == NULL) {
+    perror(path);
+    return 0;
+  }
+  while ((filename = g_dir_read_name(dir)) != NULL) {
+    char buffer[PATH_MAX];
+
+    if (filename[0] == '.') continue;  // skip '.', '..' and hidden files
+    sprintf(buffer, &quot;%s\\%s&quot;, path, filename);
+    if (!g_file_test(buffer, G_FILE_TEST_IS_DIR)) {
+      fprintf(stderr, &quot;%s: not a regular file\n&quot;, buffer);
+      continue;
+    }
+    logregex_refresh_type(buffer, (char *)filename);
+  }
+  g_dir_close(dir);
+  return 1;
+}
+
+int logregex_rmatchline(char *type, char *line)
+{
+  struct typespec *ts;
+  regmatch_t mt;
+  regex_t spec;
+  int i, j;
+  int replaced = 0;
+  char buffer[4096];
+  char *out = buffer;
+
+  ts = (typespec*)g_hash_table_lookup(types, type);
+  if (!ts) return 0;
+
+  for (j=0; j &lt; (int)ts-&gt;rmacros-&gt;len; j++) {
+    struct macrodef *macro;
+    int err;
+    int matching = 1;
+
+    macro = (macrodef*)g_ptr_array_index(ts-&gt;rmacros, j);
+
+    memset(&amp;spec, 0, sizeof(spec));
+    err = regcomp(&amp;spec, macro-&gt;value, REG_EXTENDED);
+    if (err) {
+      char buffer[256];
+
+      regerror(err, &amp;spec, buffer, sizeof(buffer));
+      LOG(LOG_ERR, buffer);
+      continue;
+    }
+    while (matching) {
+      matching = 0;
+      if (regexec(&amp;spec,  line, 1, &amp;mt, 0) == 0) {
+        char buffer[4096];
+        char *out = buffer;
+        int i;
+
+        for (i=0; line[i];) {
+          if (i == mt.rm_so) {
+            matching = 1;
+            *out ++ = '[';
+            strcpy(out, macro-&gt;key);
+            out += strlen(macro-&gt;key);
+            *out++ = ']';
+            i = mt.rm_eo;
+          } else {
+            *out++ = line[i++];
+          }
+        }
+        *out = 0;
+        strcpy(line, buffer);
+        replaced = 1;
+      }
+    }
+    regfree(&amp;spec);
+  }
+
+  // change '[[' to '\[['
+  // change ']]' to ']\]'
+  // escape '?', '*', '(' and ')'
+  for (i=0; line[i];) {
+    int c = line[i];
+
+    if (c == '[') {
+      int len;
+
+      len = logregex_is_macro(ts-&gt;rmacros, &amp;line[i+1]);
+      if (len &amp;&amp; line[i+len+1] == ']') { // and ends with ']'
+        // this is start of macro, don't escape it but just copy it
+        *out++ = line[i++];  // copy the starting '[' 
+        while (len--) { 
+          *out++ = line[i++]; // copy the macroname
+        }
+      } else {
+        *out++ = '\\'; // just escape it
+      }
+    } else if (c == ']') {
+      *out++ = '\\';
+    } else // other metacharacter?   {}()^$.|*+\?  
+      if (c == '{' || c == '}' || c == '(' || c == ')' || c == '^' || c == '$' ||
+          c == '.' || c == '|' || c == '*' || c == '+' || c == '?' || c == '\\') {
+      *out++ = '\\';
+    }
+    *out++ = line[i++];  
+  }
+  *out = 0;
+  strcpy(line, buffer);
+  return replaced;
+}
+
+// This function should return a negative integer if the first value 
+// comes before the second, 0 if they are equal, or a positive integer
+// if the first value comes after the second. 
+static gint regexspec_compare_func(gconstpointer a, gconstpointer b)
+{
+  struct regexspec *rs1 = *(struct regexspec **) a;
+  struct regexspec *rs2 = *(struct regexspec **) b;
+
+  return(rs2-&gt;match - rs1-&gt;match);
+}
+
+int logregex_matchline(char *type, char *buffer, int *color)
+{
+  int i;
+  int match = 0;
+  struct typespec *ts;
+  ts = (typespec*)g_hash_table_lookup(types, type);
+  if (!ts) return 0;
+
+  //printf(&quot;matching: %s\n&quot;, buffer);
+
+  ts-&gt;runs++;
+  if (ts-&gt;red) {
+    for (i=0; i &lt; (int)ts-&gt;red-&gt;len; i++) {
+      struct regexspec *rs = (regexspec*)g_ptr_array_index(ts-&gt;red, i);
+
+      //printf(&quot;red %s\n&quot;, rs-&gt;regex);
+      ts-&gt;pondered++;
+      if (rs &amp;&amp; regexec(&amp;rs-&gt;preg,  buffer, 0, 0, 0) == 0) {
+        rs-&gt;match++;
+        *color = STAT_RED;
+        return TRUE;
+      }
+    }
+  }
+
+  if (ts-&gt;yellow) {
+    for (i=0; i &lt; (int)ts-&gt;yellow-&gt;len; i++) {
+      struct regexspec *rs = (regexspec*)g_ptr_array_index(ts-&gt;yellow, i);
+
+      //printf(&quot;yellow %s\n&quot;, rs-&gt;regex);
+      ts-&gt;pondered++;
+      if (rs &amp;&amp; regexec(&amp;rs-&gt;preg,  buffer, 0, 0, 0) == 0) {
+        rs-&gt;match++;
+        *color = STAT_YELLOW;
+        return TRUE;
+      }
+    }
+  }
+
+  if (ts-&gt;green) {
+    ts-&gt;gmatch++;
+    if (ts-&gt;gmatch == 100 || ts-&gt;gmatch == 1000 || ts-&gt;gmatch == 10000 || ts-&gt;gmatch == 100000) {
+      g_ptr_array_sort(ts-&gt;green, regexspec_compare_func);
+    }
+    for (i=0; i &lt; (int)ts-&gt;green-&gt;len; i++) {
+      struct regexspec *rs = (regexspec*)g_ptr_array_index(ts-&gt;green, i);
+
+      ts-&gt;pondered++;
+      if (rs &amp;&amp; regexec(&amp;rs-&gt;preg,  buffer, 0, 0, 0) == 0) {
+        match = 1;
+        rs-&gt;match++;
+        break;
+        //printf(&quot;MATCH green%s\n&quot;, rs-&gt;regex);
+      } 
+    }
+  }
+  if (!match) { 
+    *color = STAT_YELLOW;
+    return TRUE;
+  }
+  *color = STAT_GREEN;
+  return FALSE;
+}
+

Added: upwatch/trunk/mswindows/MonitorService/logregex.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/logregex.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/logregex.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,13 @@
+#ifndef __LOGREGEX_H
+#define __LOGREGEX_H
+
+#include &quot;pcreposix.h&quot;
+
+int logregex_matchline(char *type, char *buffer, int *color);
+int logregex_rmatchline(char *type, char *line);
+int logregex_refresh(char *path);
+void logregex_print_stats(char *type);
+void logregex_expand_macros(char *type, char *in, char *out);
+
+#endif /* __LOGREGEX_H */
+

Added: upwatch/trunk/mswindows/MonitorService/pcre.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/pcre.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/pcre.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,186 @@
+/*************************************************
+*       Perl-Compatible Regular Expressions      *
+*************************************************/
+
+/* Copyright (c) 1997-2003 University of Cambridge */
+
+#ifndef _PCRE_H
+#define _PCRE_H
+
+/* The file pcre.h is build by &quot;configure&quot;. Do not edit it; instead
+make changes to pcre.in. */
+
+#define PCRE_MAJOR          4
+#define PCRE_MINOR          4
+#define PCRE_DATE           21-August-2003
+
+/* Win32 uses DLL by default */
+
+#ifdef _WIN32
+#  ifdef PCRE_DEFINITION
+#    ifdef DLL_EXPORT
+#      define PCRE_DATA_SCOPE __declspec(dllexport)
+#    endif
+#  else
+#    ifndef PCRE_STATIC
+#      define PCRE_DATA_SCOPE extern __declspec(dllimport)
+#    endif
+#  endif
+#endif
+#ifndef PCRE_DATA_SCOPE
+#  define PCRE_DATA_SCOPE     extern
+#endif
+
+/* Have to include stdlib.h in order to ensure that size_t is defined;
+it is needed here for malloc. */
+
+#include &lt;stdlib.h&gt;
+
+/* Allow for C++ users */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Options */
+
+#define PCRE_CASELESS           0x0001
+#define PCRE_MULTILINE          0x0002
+#define PCRE_DOTALL             0x0004
+#define PCRE_EXTENDED           0x0008
+#define PCRE_ANCHORED           0x0010
+#define PCRE_DOLLAR_ENDONLY     0x0020
+#define PCRE_EXTRA              0x0040
+#define PCRE_NOTBOL             0x0080
+#define PCRE_NOTEOL             0x0100
+#define PCRE_UNGREEDY           0x0200
+#define PCRE_NOTEMPTY           0x0400
+#define PCRE_UTF8               0x0800
+#define PCRE_NO_AUTO_CAPTURE    0x1000
+#define PCRE_NO_UTF8_CHECK      0x2000
+
+/* Exec-time and get/set-time error codes */
+
+#define PCRE_ERROR_NOMATCH        (-1)
+#define PCRE_ERROR_NULL           (-2)
+#define PCRE_ERROR_BADOPTION      (-3)
+#define PCRE_ERROR_BADMAGIC       (-4)
+#define PCRE_ERROR_UNKNOWN_NODE   (-5)
+#define PCRE_ERROR_NOMEMORY       (-6)
+#define PCRE_ERROR_NOSUBSTRING    (-7)
+#define PCRE_ERROR_MATCHLIMIT     (-8)
+#define PCRE_ERROR_CALLOUT        (-9)  /* Never used by PCRE itself */
+#define PCRE_ERROR_BADUTF8       (-10)
+
+/* Request types for pcre_fullinfo() */
+
+#define PCRE_INFO_OPTIONS            0
+#define PCRE_INFO_SIZE               1
+#define PCRE_INFO_CAPTURECOUNT       2
+#define PCRE_INFO_BACKREFMAX         3
+#define PCRE_INFO_FIRSTBYTE          4
+#define PCRE_INFO_FIRSTCHAR          4  /* For backwards compatibility */
+#define PCRE_INFO_FIRSTTABLE         5
+#define PCRE_INFO_LASTLITERAL        6
+#define PCRE_INFO_NAMEENTRYSIZE      7
+#define PCRE_INFO_NAMECOUNT          8
+#define PCRE_INFO_NAMETABLE          9
+#define PCRE_INFO_STUDYSIZE         10
+
+/* Request types for pcre_config() */
+
+#define PCRE_CONFIG_UTF8                    0
+#define PCRE_CONFIG_NEWLINE                 1
+#define PCRE_CONFIG_LINK_SIZE               2
+#define PCRE_CONFIG_POSIX_MALLOC_THRESHOLD  3
+#define PCRE_CONFIG_MATCH_LIMIT             4
+
+/* Bit flags for the pcre_extra structure */
+
+#define PCRE_EXTRA_STUDY_DATA          0x0001
+#define PCRE_EXTRA_MATCH_LIMIT         0x0002
+#define PCRE_EXTRA_CALLOUT_DATA        0x0004
+
+/* Types */
+
+struct real_pcre;                 /* declaration; the definition is private  */
+typedef struct real_pcre pcre;
+
+/* The structure for passing additional data to pcre_exec(). This is defined in
+such as way as to be extensible. */
+
+typedef struct pcre_extra {
+  unsigned long int flags;        /* Bits for which fields are set */
+  void *study_data;               /* Opaque data from pcre_study() */
+  unsigned long int match_limit;  /* Maximum number of calls to match() */
+  void *callout_data;             /* Data passed back in callouts */
+} pcre_extra;
+
+/* The structure for passing out data via the pcre_callout_function. We use a
+structure so that new fields can be added on the end in future versions,
+without changing the API of the function, thereby allowing old clients to work
+without modification. */
+
+typedef struct pcre_callout_block {
+  int          version;           /* Identifies version of block */
+  /* ------------------------ Version 0 ------------------------------- */
+  int          callout_number;    /* Number compiled into pattern */
+  int         *offset_vector;     /* The offset vector */
+  const char  *subject;           /* The subject being matched */
+  int          subject_length;    /* The length of the subject */
+  int          start_match;       /* Offset to start of this match attempt */
+  int          current_position;  /* Where we currently are */
+  int          capture_top;       /* Max current capture */
+  int          capture_last;      /* Most recently closed capture */
+  void        *callout_data;      /* Data passed in with the call */
+  /* ------------------------------------------------------------------ */
+} pcre_callout_block;
+
+/* Indirection for store get and free functions. These can be set to
+alternative malloc/free functions if required. There is also an optional
+callout function that is triggered by the (?) regex item. Some magic is
+required for Win32 DLL; it is null on other OS. For Virtual Pascal, these
+have to be different again. */
+
+#ifndef VPCOMPAT
+PCRE_DATA_SCOPE void *(*pcre_malloc)(size_t);
+PCRE_DATA_SCOPE void  (*pcre_free)(void *);
+PCRE_DATA_SCOPE int   (*pcre_callout)(pcre_callout_block *);
+#else   /* VPCOMPAT */
+extern void *pcre_malloc(size_t);
+extern void  pcre_free(void *);
+extern int   pcre_callout(pcre_callout_block *);
+#endif  /* VPCOMPAT */
+
+/* Exported PCRE functions */
+
+extern pcre *pcre_compile(const char *, int, const char **,
+              int *, const unsigned char *);
+extern int  pcre_config(int, void *);
+extern int  pcre_copy_named_substring(const pcre *, const char *,
+              int *, int, const char *, char *, int);
+extern int  pcre_copy_substring(const char *, int *, int, int,
+              char *, int);
+extern int  pcre_exec(const pcre *, const pcre_extra *,
+              const char *, int, int, int, int *, int);
+extern void pcre_free_substring(const char *);
+extern void pcre_free_substring_list(const char **);
+extern int  pcre_fullinfo(const pcre *, const pcre_extra *, int,
+              void *);
+extern int  pcre_get_named_substring(const pcre *, const char *,
+              int *, int,  const char *, const char **);
+extern int  pcre_get_stringnumber(const pcre *, const char *);
+extern int  pcre_get_substring(const char *, int *, int, int,
+              const char **);
+extern int  pcre_get_substring_list(const char *, int *, int,
+              const char ***);
+extern int  pcre_info(const pcre *, int *, int *);
+extern const unsigned char *pcre_maketables(void);
+extern pcre_extra *pcre_study(const pcre *, int, const char **);
+extern const char *pcre_version(void);
+
+#ifdef __cplusplus
+}  /* extern &quot;C&quot; */
+#endif
+
+#endif /* End of pcre.h */

Added: upwatch/trunk/mswindows/MonitorService/pcreposix.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/pcreposix.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/pcreposix.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,88 @@
+/*************************************************
+*       Perl-Compatible Regular Expressions      *
+*************************************************/
+
+/* Copyright (c) 1997-2003 University of Cambridge */
+
+#ifndef _PCREPOSIX_H
+#define _PCREPOSIX_H
+
+/* This is the header for the POSIX wrapper interface to the PCRE Perl-
+Compatible Regular Expression library. It defines the things POSIX says should
+be there. I hope. */
+
+/* Have to include stdlib.h in order to ensure that size_t is defined. */
+
+#include &lt;stdlib.h&gt;
+
+/* Allow for C++ users */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Options defined by POSIX. */
+
+#define REG_ICASE     0x01
+#define REG_NEWLINE   0x02
+#define REG_NOTBOL    0x04
+#define REG_NOTEOL    0x08
+
+/* These are not used by PCRE, but by defining them we make it easier
+to slot PCRE into existing programs that make POSIX calls. */
+
+#define REG_EXTENDED  0
+#define REG_NOSUB     0
+
+/* Error values. Not all these are relevant or used by the wrapper. */
+
+enum {
+  REG_ASSERT = 1,  /* internal error ? */
+  REG_BADBR,       /* invalid repeat counts in {} */
+  REG_BADPAT,      /* pattern error */
+  REG_BADRPT,      /* ? * + invalid */
+  REG_EBRACE,      /* unbalanced {} */
+  REG_EBRACK,      /* unbalanced [] */
+  REG_ECOLLATE,    /* collation error - not relevant */
+  REG_ECTYPE,      /* bad class */
+  REG_EESCAPE,     /* bad escape sequence */
+  REG_EMPTY,       /* empty expression */
+  REG_EPAREN,      /* unbalanced () */
+  REG_ERANGE,      /* bad range inside [] */
+  REG_ESIZE,       /* expression too big */
+  REG_ESPACE,      /* failed to get memory */
+  REG_ESUBREG,     /* bad back reference */
+  REG_INVARG,      /* bad argument */
+  REG_NOMATCH      /* match failed */
+};
+
+
+/* The structure representing a compiled regular expression. */
+
+typedef struct {
+  void *re_pcre;
+  size_t re_nsub;
+  size_t re_erroffset;
+} regex_t;
+
+/* The structure in which a captured offset is returned. */
+
+typedef int regoff_t;
+
+typedef struct {
+  regoff_t rm_so;
+  regoff_t rm_eo;
+} regmatch_t;
+
+/* The functions */
+
+extern int regcomp(regex_t *, const char *, int);
+extern int regexec(const regex_t *, const char *, size_t, regmatch_t *, int);
+extern size_t regerror(int, const regex_t *, char *, size_t);
+extern void regfree(regex_t *);
+
+#ifdef __cplusplus
+}   /* extern &quot;C&quot; */
+#endif
+
+#endif /* End of pcreposix.h */

Added: upwatch/trunk/mswindows/MonitorService/snprintf.c
===================================================================
--- upwatch/trunk/mswindows/MonitorService/snprintf.c	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/snprintf.c	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,1025 @@
+/*
+ * snprintf.c - a portable implementation of snprintf
+ *
+ * AUTHOR
+ *   Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;, April 1999.
+ *
+ *   Copyright 1999, Mark Martinec. All rights reserved.
+ *
+ * TERMS AND CONDITIONS
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the &quot;Frontier Artistic License&quot; which comes
+ *   with this Kit.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty
+ *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *   See the Frontier Artistic License for more details.
+ *
+ *   You should have received a copy of the Frontier Artistic License
+ *   with this Kit in the file named LICENSE.txt .
+ *   If not, I'll be glad to provide one.
+ *
+ * FEATURES
+ * - careful adherence to specs regarding flags, field width and precision;
+ * - good performance for large string handling (large format, large
+ *   argument or large paddings). Performance is similar to system's sprintf
+ *   and in several cases significantly better (make sure you compile with
+ *   optimizations turned on, tell the compiler the code is strict ANSI
+ *   if necessary to give it more freedom for optimizations);
+ * - return value semantics per ISO/IEC 9899:1999 (&quot;ISO C99&quot;);
+ * - written in standard ISO/ANSI C - requires an ANSI C compiler.
+ *
+ * SUPPORTED CONVERSION SPECIFIERS AND DATA TYPES
+ *
+ * This snprintf only supports the following conversion specifiers:
+ * s, c, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)
+ * with flags: '-', '+', ' ', '0' and '#'.
+ * An asterisk is supported for field width as well as precision.
+ *
+ * Length modifiers 'h' (short int), 'l' (long int),
+ * and 'll' (long long int) are supported.
+ * NOTE:
+ *   If macro SNPRINTF_LONGLONG_SUPPORT is not defined (default) the
+ *   length modifier 'll' is recognized but treated the same as 'l',
+ *   which may cause argument value truncation! Defining
+ *   SNPRINTF_LONGLONG_SUPPORT requires that your system's sprintf also
+ *   handles length modifier 'll'.  long long int is a language extension
+ *   which may not be portable.
+ *
+ * Conversion of numeric data (conversion specifiers d, u, o, x, X, p)
+ * with length modifiers (none or h, l, ll) is left to the system routine
+ * sprintf, but all handling of flags, field width and precision as well as
+ * c and s conversions is done very carefully by this portable routine.
+ * If a string precision (truncation) is specified (e.g. %.8s) it is
+ * guaranteed the string beyond the specified precision will not be referenced.
+ *
+ * Length modifiers h, l and ll are ignored for c and s conversions (data
+ * types wint_t and wchar_t are not supported).
+ *
+ * The following common synonyms for conversion characters are supported:
+ *   - i is a synonym for d
+ *   - D is a synonym for ld, explicit length modifiers are ignored
+ *   - U is a synonym for lu, explicit length modifiers are ignored
+ *   - O is a synonym for lo, explicit length modifiers are ignored
+ * The D, O and U conversion characters are nonstandard, they are supported
+ * for backward compatibility only, and should not be used for new code.
+ *
+ * The following is specifically NOT supported:
+ *   - flag ' (thousands' grouping character) is recognized but ignored
+ *   - numeric conversion specifiers: f, e, E, g, G and synonym F,
+ *     as well as the new a and A conversion specifiers
+ *   - length modifier 'L' (long double) and 'q' (quad - use 'll' instead)
+ *   - wide character/string conversions: lc, ls, and nonstandard
+ *     synonyms C and S
+ *   - writeback of converted string length: conversion character n
+ *   - the n$ specification for direct reference to n-th argument
+ *   - locales
+ *
+ * It is permitted for str_m to be zero, and it is permitted to specify NULL
+ * pointer for resulting string argument if str_m is zero (as per ISO C99).
+ *
+ * The return value is the number of characters which would be generated
+ * for the given input, excluding the trailing null. If this value
+ * is greater or equal to str_m, not all characters from the result
+ * have been stored in str, output bytes beyond the (str_m-1) -th character
+ * are discarded. If str_m is greater than zero it is guaranteed
+ * the resulting string will be null-terminated.
+ *
+ * NOTE that this matches the ISO C99, OpenBSD, and GNU C library 2.1,
+ * but is different from some older and vendor implementations,
+ * and is also different from XPG, XSH5, SUSv2 specifications.
+ * For historical discussion on changes in the semantics and standards
+ * of snprintf see printf(3) man page in the Linux programmers manual.
+ *
+ * Routines asprintf and vasprintf return a pointer (in the ptr argument)
+ * to a buffer sufficiently large to hold the resulting string. This pointer
+ * should be passed to free(3) to release the allocated storage when it is
+ * no longer needed. If sufficient space cannot be allocated, these functions
+ * will return -1 and set ptr to be a NULL pointer. These two routines are a
+ * GNU C library extensions (glibc).
+ *
+ * Routines asnprintf and vasnprintf are similar to asprintf and vasprintf,
+ * yet, like snprintf and vsnprintf counterparts, will write at most str_m-1
+ * characters into the allocated output string, the last character in the
+ * allocated buffer then gets the terminating null. If the formatted string
+ * length (the return value) is greater than or equal to the str_m argument,
+ * the resulting string was truncated and some of the formatted characters
+ * were discarded. These routines present a handy way to limit the amount
+ * of allocated memory to some sane value.
+ *
+ * AVAILABILITY
+ *   <A HREF="http://www.ijs.si/software/snprintf/">http://www.ijs.si/software/snprintf/</A>
+ *
+ * REVISION HISTORY
+ * 1999-04	V0.9  Mark Martinec
+ *		- initial version, some modifications after comparing printf
+ *		  man pages for Digital Unix 4.0, Solaris 2.6 and HPUX 10,
+ *		  and checking how Perl handles sprintf (differently!);
+ * 1999-04-09	V1.0  Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- added main test program, fixed remaining inconsistencies,
+ *		  added optional (long long int) support;
+ * 1999-04-12	V1.1  Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- support the 'p' conversion (pointer to void);
+ *		- if a string precision is specified
+ *		  make sure the string beyond the specified precision
+ *		  will not be referenced (e.g. by strlen);
+ * 1999-04-13	V1.2  Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- support synonyms %D=%ld, %U=%lu, %O=%lo;
+ *		- speed up the case of long format string with few conversions;
+ * 1999-06-30	V1.3  Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- fixed runaway loop (eventually crashing when str_l wraps
+ *		  beyond 2^31) while copying format string without
+ *		  conversion specifiers to a buffer that is too short
+ *		  (thanks to Edwin Young &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">edwiny at autonomy.com</A>&gt; for
+ *		  spotting the problem);
+ *		- added macros PORTABLE_SNPRINTF_VERSION_(MAJOR|MINOR)
+ *		  to snprintf.h
+ * 2000-02-14	V2.0 (never released) Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- relaxed license terms: The Artistic License now applies.
+ *		  You may still apply the GNU GENERAL PUBLIC LICENSE
+ *		  as was distributed with previous versions, if you prefer;
+ *		- changed REVISION HISTORY dates to use ISO 8601 date format;
+ *		- added vsnprintf (patch also independently proposed by
+ *		  Caolan McNamara 2000-05-04, and Keith M Willenson 2000-06-01)
+ * 2000-06-27	V2.1  Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- removed POSIX check for str_m&lt;1; value 0 for str_m is
+ *		  allowed by ISO C99 (and GNU C library 2.1) - (pointed out
+ *		  on 2000-05-04 by Caolan McNamara, caolan@ csn dot ul dot ie).
+ *		  Besides relaxed license this change in standards adherence
+ *		  is the main reason to bump up the major version number;
+ *		- added nonstandard routines asnprintf, vasnprintf, asprintf,
+ *		  vasprintf that dynamically allocate storage for the
+ *		  resulting string; these routines are not compiled by default,
+ *		  see comments where NEED_V?ASN?PRINTF macros are defined;
+ *		- autoconf contributed by Caolan McNamara
+ * 2000-10-06	V2.2  Mark Martinec &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;
+ *		- BUG FIX: the %c conversion used a temporary variable
+ *		  that was no longer in scope when referenced,
+ *		  possibly causing incorrect resulting character;
+ *		- BUG FIX: make precision and minimal field width unsigned
+ *		  to handle huge values (2^31 &lt;= n &lt; 2^32) correctly;
+ *		  also be more careful in the use of signed/unsigned/size_t
+ *		  internal variables - probably more careful than many
+ *		  vendor implementations, but there may still be a case
+ *		  where huge values of str_m, precision or minimal field
+ *		  could cause incorrect behaviour;
+ *		- use separate variables for signed/unsigned arguments,
+ *		  and for short/int, long, and long long argument lengths
+ *		  to avoid possible incompatibilities on certain
+ *		  computer architectures. Also use separate variable
+ *		  arg_sign to hold sign of a numeric argument,
+ *		  to make code more transparent;
+ *		- some fiddling with zero padding and &quot;0x&quot; to make it
+ *		  Linux compatible;
+ *		- systematically use macros fast_memcpy and fast_memset
+ *		  instead of case-by-case hand optimization; determine some
+ *		  breakeven string lengths for different architectures;
+ *		- terminology change: 'format' -&gt; 'conversion specifier',
+ *		  'C9x' -&gt; 'ISO/IEC 9899:1999 (&quot;ISO C99&quot;)',
+ *		  'alternative form' -&gt; 'alternate form',
+ *		  'data type modifier' -&gt; 'length modifier';
+ *		- several comments rephrased and new ones added;
+ *		- make compiler not complain about 'credits' defined but
+ *		  not used;
+ */
+
+
+/* Define HAVE_SNPRINTF if your system already has snprintf and vsnprintf.
+ *
+ * If HAVE_SNPRINTF is defined this module will not produce code for
+ * snprintf and vsnprintf, unless PREFER_PORTABLE_SNPRINTF is defined as well,
+ * causing this portable version of snprintf to be called portable_snprintf
+ * (and portable_vsnprintf).
+ */
+/* #define HAVE_SNPRINTF */
+
+/* Define PREFER_PORTABLE_SNPRINTF if your system does have snprintf and
+ * vsnprintf but you would prefer to use the portable routine(s) instead.
+ * In this case the portable routine is declared as portable_snprintf
+ * (and portable_vsnprintf) and a macro 'snprintf' (and 'vsnprintf')
+ * is defined to expand to 'portable_v?snprintf' - see file snprintf.h .
+ * Defining this macro is only useful if HAVE_SNPRINTF is also defined,
+ * but does does no harm if defined nevertheless.
+ */
+/* #define PREFER_PORTABLE_SNPRINTF */
+
+/* Define SNPRINTF_LONGLONG_SUPPORT if you want to support
+ * data type (long long int) and length modifier 'll' (e.g. %lld).
+ * If undefined, 'll' is recognized but treated as a single 'l'.
+ *
+ * If the system's sprintf does not handle 'll'
+ * the SNPRINTF_LONGLONG_SUPPORT must not be defined!
+ *
+ * This is off by default as (long long int) is a language extension.
+ */
+/* #define SNPRINTF_LONGLONG_SUPPORT */
+
+/* Define NEED_SNPRINTF_ONLY if you only need snprintf, and not vsnprintf.
+ * If NEED_SNPRINTF_ONLY is defined, the snprintf will be defined directly,
+ * otherwise both snprintf and vsnprintf routines will be defined
+ * and snprintf will be a simple wrapper around vsnprintf, at the expense
+ * of an extra procedure call.
+ */
+/* #define NEED_SNPRINTF_ONLY */
+
+/* Define NEED_V?ASN?PRINTF macros if you need library extension
+ * routines asprintf, vasprintf, asnprintf, vasnprintf respectively,
+ * and your system library does not provide them. They are all small
+ * wrapper routines around portable_vsnprintf. Defining any of the four
+ * NEED_V?ASN?PRINTF macros automatically turns off NEED_SNPRINTF_ONLY
+ * and turns on PREFER_PORTABLE_SNPRINTF.
+ *
+ * Watch for name conflicts with the system library if these routines
+ * are already present there.
+ *
+ * NOTE: vasprintf and vasnprintf routines need va_copy() from stdarg.h, as
+ * specified by C99, to be able to traverse the same list of arguments twice.
+ * I don't know of any other standard and portable way of achieving the same.
+ * With some versions of gcc you may use __va_copy(). You might even get away
+ * with &quot;ap2 = ap&quot;, in this case you must not call va_end(ap2) !
+ *   #define va_copy(ap2,ap) ap2 = ap
+ */
+/* #define NEED_ASPRINTF   */
+/* #define NEED_ASNPRINTF  */
+/* #define NEED_VASPRINTF  */
+/* #define NEED_VASNPRINTF */
+
+
+/* Define the following macros if desired:
+ *   SOLARIS_COMPATIBLE, SOLARIS_BUG_COMPATIBLE,
+ *   HPUX_COMPATIBLE, HPUX_BUG_COMPATIBLE, LINUX_COMPATIBLE,
+ *   DIGITAL_UNIX_COMPATIBLE, DIGITAL_UNIX_BUG_COMPATIBLE,
+ *   PERL_COMPATIBLE, PERL_BUG_COMPATIBLE,
+ *
+ * - For portable applications it is best not to rely on peculiarities
+ *   of a given implementation so it may be best not to define any
+ *   of the macros that select compatibility and to avoid features
+ *   that vary among the systems.
+ *
+ * - Selecting compatibility with more than one operating system
+ *   is not strictly forbidden but is not recommended.
+ *
+ * - 'x'_BUG_COMPATIBLE implies 'x'_COMPATIBLE .
+ *
+ * - 'x'_COMPATIBLE refers to (and enables) a behaviour that is
+ *   documented in a sprintf man page on a given operating system
+ *   and actually adhered to by the system's sprintf (but not on
+ *   most other operating systems). It may also refer to and enable
+ *   a behaviour that is declared 'undefined' or 'implementation specific'
+ *   in the man page but a given implementation behaves predictably
+ *   in a certain way.
+ *
+ * - 'x'_BUG_COMPATIBLE refers to (and enables) a behaviour of system's sprintf
+ *   that contradicts the sprintf man page on the same operating system.
+ *
+ * - I do not claim that the 'x'_COMPATIBLE and 'x'_BUG_COMPATIBLE
+ *   conditionals take into account all idiosyncrasies of a particular
+ *   implementation, there may be other incompatibilities.
+ */
+
+
+
+/* ============================================= */
+/* NO USER SERVICABLE PARTS FOLLOWING THIS POINT */
+/* ============================================= */
+
+#define PORTABLE_SNPRINTF_VERSION_MAJOR 2
+#define PORTABLE_SNPRINTF_VERSION_MINOR 2
+
+#if defined(NEED_ASPRINTF) || defined(NEED_ASNPRINTF) || defined(NEED_VASPRINTF) || defined(NEED_VASNPRINTF)
+# if defined(NEED_SNPRINTF_ONLY)
+# undef NEED_SNPRINTF_ONLY
+# endif
+# if !defined(PREFER_PORTABLE_SNPRINTF)
+# define PREFER_PORTABLE_SNPRINTF
+# endif
+#endif
+
+#if defined(SOLARIS_BUG_COMPATIBLE) &amp;&amp; !defined(SOLARIS_COMPATIBLE)
+#define SOLARIS_COMPATIBLE
+#endif
+
+#if defined(HPUX_BUG_COMPATIBLE) &amp;&amp; !defined(HPUX_COMPATIBLE)
+#define HPUX_COMPATIBLE
+#endif
+
+#if defined(DIGITAL_UNIX_BUG_COMPATIBLE) &amp;&amp; !defined(DIGITAL_UNIX_COMPATIBLE)
+#define DIGITAL_UNIX_COMPATIBLE
+#endif
+
+#if defined(PERL_BUG_COMPATIBLE) &amp;&amp; !defined(PERL_COMPATIBLE)
+#define PERL_COMPATIBLE
+#endif
+
+#if defined(LINUX_BUG_COMPATIBLE) &amp;&amp; !defined(LINUX_COMPATIBLE)
+#define LINUX_COMPATIBLE
+#endif
+
+#include &lt;sys/types.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;errno.h&gt;
+
+#ifdef isdigit
+#undef isdigit
+#endif
+#define isdigit(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
+
+/* For copying strings longer or equal to 'breakeven_point'
+ * it is more efficient to call memcpy() than to do it inline.
+ * The value depends mostly on the processor architecture,
+ * but also on the compiler and its optimization capabilities.
+ * The value is not critical, some small value greater than zero
+ * will be just fine if you don't care to squeeze every drop
+ * of performance out of the code.
+ *
+ * Small values favor memcpy, large values favor inline code.
+ */
+#if defined(__alpha__) || defined(__alpha)
+#  define breakeven_point   2	/* AXP (DEC Alpha)     - gcc or cc or egcs */
+#endif
+#if defined(__i386__)  || defined(__i386)
+#  define breakeven_point  12	/* Intel Pentium/Linux - gcc 2.96 */
+#endif
+#if defined(__hppa)
+#  define breakeven_point  10	/* HP-PA               - gcc */
+#endif
+#if defined(__sparc__) || defined(__sparc)
+#  define breakeven_point  33	/* Sun Sparc 5         - gcc 2.8.1 */
+#endif
+
+/* some other values of possible interest: */
+/* #define breakeven_point  8 */  /* VAX 4000          - vaxc */
+/* #define breakeven_point 19 */  /* VAX 4000          - gcc 2.7.0 */
+
+#ifndef breakeven_point
+#  define breakeven_point   6	/* some reasonable one-size-fits-all value */
+#endif
+
+#define fast_memcpy(d,s,n) \
+  { register size_t nn = (size_t)(n); \
+    if (nn &gt;= breakeven_point) memcpy((d), (s), nn); \
+    else if (nn &gt; 0) { /* proc call overhead is worth only for large strings*/\
+      register char *dd; register const char *ss; \
+      for (ss=(s), dd=(d); nn&gt;0; nn--) *dd++ = *ss++; } }
+
+#define fast_memset(d,c,n) \
+  { register size_t nn = (size_t)(n); \
+    if (nn &gt;= breakeven_point) memset((d), (int)(c), nn); \
+    else if (nn &gt; 0) { /* proc call overhead is worth only for large strings*/\
+      register char *dd; register const int cc=(int)(c); \
+      for (dd=(d); nn&gt;0; nn--) *dd++ = cc; } }
+
+/* prototypes */
+
+#if defined(NEED_ASPRINTF)
+int asprintf   (char **ptr, const char *fmt, /*args*/ ...);
+#endif
+#if defined(NEED_VASPRINTF)
+int vasprintf  (char **ptr, const char *fmt, va_list ap);
+#endif
+#if defined(NEED_ASNPRINTF)
+int asnprintf  (char **ptr, size_t str_m, const char *fmt, /*args*/ ...);
+#endif
+#if defined(NEED_VASNPRINTF)
+int vasnprintf (char **ptr, size_t str_m, const char *fmt, va_list ap);
+#endif
+
+#if defined(HAVE_SNPRINTF)
+/* declare our portable snprintf  routine under name portable_snprintf  */
+/* declare our portable vsnprintf routine under name portable_vsnprintf */
+#else
+/* declare our portable routines under names snprintf and vsnprintf */
+#define portable_snprintf snprintf
+#if !defined(NEED_SNPRINTF_ONLY)
+#define portable_vsnprintf vsnprintf
+#endif
+#endif
+
+#if !defined(HAVE_SNPRINTF) || defined(PREFER_PORTABLE_SNPRINTF)
+int portable_snprintf(char *str, size_t str_m, const char *fmt, /*args*/ ...);
+#if !defined(NEED_SNPRINTF_ONLY)
+int portable_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap);
+#endif
+#endif
+
+/* declarations */
+
+static char credits[] = &quot;\n\
+@(#)snprintf.c, v2.2: Mark Martinec, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mark.martinec at ijs.si</A>&gt;\n\
+@(#)snprintf.c, v2.2: Copyright 1999, Mark Martinec. Frontier Artistic License applies.\n\
+@(#)snprintf.c, v2.2: <A HREF="http://www.ijs.si/software/snprintf/\n">http://www.ijs.si/software/snprintf/\n</A>&quot;;
+
+#if defined(NEED_ASPRINTF)
+int asprintf(char **ptr, const char *fmt, /*args*/ ...) {
+  va_list ap;
+  size_t str_m;
+  int str_l;
+
+  *ptr = NULL;
+  va_start(ap, fmt);                            /* measure the required size */
+  str_l = portable_vsnprintf(NULL, (size_t)0, fmt, ap);
+  va_end(ap);
+  assert(str_l &gt;= 0);        /* possible integer overflow if str_m &gt; INT_MAX */
+  *ptr = (char *) malloc(str_m = (size_t)str_l + 1);
+  if (*ptr == NULL) { errno = ENOMEM; str_l = -1; }
+  else {
+    int str_l2;
+    va_start(ap, fmt);
+    str_l2 = portable_vsnprintf(*ptr, str_m, fmt, ap);
+    va_end(ap);
+    assert(str_l2 == str_l);
+  }
+  return str_l;
+}
+#endif
+
+#if defined(NEED_VASPRINTF)
+int vasprintf(char **ptr, const char *fmt, va_list ap) {
+  size_t str_m;
+  int str_l;
+
+  *ptr = NULL;
+  { va_list ap2;
+    va_copy(ap2, ap);  /* don't consume the original ap, we'll need it again */
+    str_l = portable_vsnprintf(NULL, (size_t)0, fmt, ap2);/*get required size*/
+    va_end(ap2);
+  }
+  assert(str_l &gt;= 0);        /* possible integer overflow if str_m &gt; INT_MAX */
+  *ptr = (char *) malloc(str_m = (size_t)str_l + 1);
+  if (*ptr == NULL) { errno = ENOMEM; str_l = -1; }
+  else {
+    int str_l2 = portable_vsnprintf(*ptr, str_m, fmt, ap);
+    assert(str_l2 == str_l);
+  }
+  return str_l;
+}
+#endif
+
+#if defined(NEED_ASNPRINTF)
+int asnprintf (char **ptr, size_t str_m, const char *fmt, /*args*/ ...) {
+  va_list ap;
+  int str_l;
+
+  *ptr = NULL;
+  va_start(ap, fmt);                            /* measure the required size */
+  str_l = portable_vsnprintf(NULL, (size_t)0, fmt, ap);
+  va_end(ap);
+  assert(str_l &gt;= 0);        /* possible integer overflow if str_m &gt; INT_MAX */
+  if ((size_t)str_l + 1 &lt; str_m) str_m = (size_t)str_l + 1;      /* truncate */
+  /* if str_m is 0, no buffer is allocated, just set *ptr to NULL */
+  if (str_m == 0) {  /* not interested in resulting string, just return size */
+  } else {
+    *ptr = (char *) malloc(str_m);
+    if (*ptr == NULL) { errno = ENOMEM; str_l = -1; }
+    else {
+      int str_l2;
+      va_start(ap, fmt);
+      str_l2 = portable_vsnprintf(*ptr, str_m, fmt, ap);
+      va_end(ap);
+      assert(str_l2 == str_l);
+    }
+  }
+  return str_l;
+}
+#endif
+
+#if defined(NEED_VASNPRINTF)
+int vasnprintf (char **ptr, size_t str_m, const char *fmt, va_list ap) {
+  int str_l;
+
+  *ptr = NULL;
+  { va_list ap2;
+    va_copy(ap2, ap);  /* don't consume the original ap, we'll need it again */
+    str_l = portable_vsnprintf(NULL, (size_t)0, fmt, ap2);/*get required size*/
+    va_end(ap2);
+  }
+  assert(str_l &gt;= 0);        /* possible integer overflow if str_m &gt; INT_MAX */
+  if ((size_t)str_l + 1 &lt; str_m) str_m = (size_t)str_l + 1;      /* truncate */
+  /* if str_m is 0, no buffer is allocated, just set *ptr to NULL */
+  if (str_m == 0) {  /* not interested in resulting string, just return size */
+  } else {
+    *ptr = (char *) malloc(str_m);
+    if (*ptr == NULL) { errno = ENOMEM; str_l = -1; }
+    else {
+      int str_l2 = portable_vsnprintf(*ptr, str_m, fmt, ap);
+      assert(str_l2 == str_l);
+    }
+  }
+  return str_l;
+}
+#endif
+
+/*
+ * If the system does have snprintf and the portable routine is not
+ * specifically required, this module produces no code for snprintf/vsnprintf.
+ */
+#if !defined(HAVE_SNPRINTF) || defined(PREFER_PORTABLE_SNPRINTF)
+
+#if !defined(NEED_SNPRINTF_ONLY)
+int portable_snprintf(char *str, size_t str_m, const char *fmt, /*args*/ ...) {
+  va_list ap;
+  int str_l;
+
+  va_start(ap, fmt);
+  str_l = portable_vsnprintf(str, str_m, fmt, ap);
+  va_end(ap);
+  return str_l;
+}
+#endif
+
+#if defined(NEED_SNPRINTF_ONLY)
+int portable_snprintf(char *str, size_t str_m, const char *fmt, /*args*/ ...) {
+#else
+int portable_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap) {
+#endif
+
+#if defined(NEED_SNPRINTF_ONLY)
+  va_list ap;
+#endif
+  size_t str_l = 0;
+  const char *p = fmt;
+
+/* In contrast with POSIX, the ISO C99 now says
+ * that str can be NULL and str_m can be 0.
+ * This is more useful than the old:  if (str_m &lt; 1) return -1; */
+
+#if defined(NEED_SNPRINTF_ONLY)
+  va_start(ap, fmt);
+#endif
+  if (!p) p = &quot;&quot;;
+  while (*p) {
+    if (*p != '%') {
+   /* if (str_l &lt; str_m) str[str_l++] = *p++;    -- this would be sufficient */
+   /* but the following code achieves better performance for cases
+    * where format string is long and contains few conversions */
+      const char *q = strchr(p+1,'%');
+      size_t n = !q ? strlen(p) : (q-p);
+      if (str_l &lt; str_m) {
+        size_t avail = str_m-str_l;
+        fast_memcpy(str+str_l, p, (n&gt;avail?avail:n));
+      }
+      p += n; str_l += n;
+    } else {
+      const char *starting_p;
+      size_t min_field_width = 0, precision = 0;
+      int zero_padding = 0, precision_specified = 0, justify_left = 0;
+      int alternate_form = 0, force_sign = 0;
+      int space_for_positive = 1; /* If both the ' ' and '+' flags appear,
+                                     the ' ' flag should be ignored. */
+      char length_modifier = '\0';            /* allowed values: \0, h, l, L */
+      char tmp[32];/* temporary buffer for simple numeric-&gt;string conversion */
+
+      const char *str_arg;      /* string address in case of string argument */
+      size_t str_arg_l;         /* natural field width of arg without padding
+                                   and sign */
+      unsigned char uchar_arg;
+        /* unsigned char argument value - only defined for c conversion.
+           N.B. standard explicitly states the char argument for
+           the c conversion is unsigned */
+
+      size_t number_of_zeros_to_pad = 0;
+        /* number of zeros to be inserted for numeric conversions
+           as required by the precision or minimal field width */
+
+      size_t zero_padding_insertion_ind = 0;
+        /* index into tmp where zero padding is to be inserted */
+
+      char fmt_spec = '\0';
+        /* current conversion specifier character */
+
+      str_arg = credits;/* just to make compiler happy (defined but not used)*/
+      str_arg = NULL;
+      starting_p = p; p++;  /* skip '%' */
+   /* parse flags */
+      while (*p == '0' || *p == '-' || *p == '+' ||
+             *p == ' ' || *p == '#' || *p == '\'') {
+        switch (*p) {
+        case '0': zero_padding = 1; break;
+        case '-': justify_left = 1; break;
+        case '+': force_sign = 1; space_for_positive = 0; break;
+        case ' ': force_sign = 1;
+     /* If both the ' ' and '+' flags appear, the ' ' flag should be ignored */
+#ifdef PERL_COMPATIBLE
+     /* ... but in Perl the last of ' ' and '+' applies */
+                  space_for_positive = 1;
+#endif
+                  break;
+        case '#': alternate_form = 1; break;
+        case '\'': break;
+        }
+        p++;
+      }
+   /* If the '0' and '-' flags both appear, the '0' flag should be ignored. */
+
+   /* parse field width */
+      if (*p == '*') {
+        int j;
+        p++; j = va_arg(ap, int);
+        if (j &gt;= 0) min_field_width = j;
+        else { min_field_width = -j; justify_left = 1; }
+      } else if (isdigit((int)(*p))) {
+        /* size_t could be wider than unsigned int;
+           make sure we treat argument like common implementations do */
+        unsigned int uj = *p++ - '0';
+        while (isdigit((int)(*p))) uj = 10*uj + (unsigned int)(*p++ - '0');
+        min_field_width = uj;
+      }
+   /* parse precision */
+      if (*p == '.') {
+        p++; precision_specified = 1;
+        if (*p == '*') {
+          int j = va_arg(ap, int);
+          p++;
+          if (j &gt;= 0) precision = j;
+          else {
+            precision_specified = 0; precision = 0;
+         /* NOTE:
+          *   Solaris 2.6 man page claims that in this case the precision
+          *   should be set to 0.  Digital Unix 4.0, HPUX 10 and BSD man page
+          *   claim that this case should be treated as unspecified precision,
+          *   which is what we do here.
+          */
+          }
+        } else if (isdigit((int)(*p))) {
+          /* size_t could be wider than unsigned int;
+             make sure we treat argument like common implementations do */
+          unsigned int uj = *p++ - '0';
+          while (isdigit((int)(*p))) uj = 10*uj + (unsigned int)(*p++ - '0');
+          precision = uj;
+        }
+      }
+   /* parse 'h', 'l' and 'll' length modifiers */
+      if (*p == 'h' || *p == 'l') {
+        length_modifier = *p; p++;
+        if (length_modifier == 'l' &amp;&amp; *p == 'l') {   /* double l = long long */
+#ifdef SNPRINTF_LONGLONG_SUPPORT
+          length_modifier = '2';                  /* double l encoded as '2' */
+#else
+          length_modifier = 'l';                 /* treat it as a single 'l' */
+#endif
+          p++;
+        }
+      }
+      fmt_spec = *p;
+   /* common synonyms: */
+      switch (fmt_spec) {
+      case 'i': fmt_spec = 'd'; break;
+      case 'D': fmt_spec = 'd'; length_modifier = 'l'; break;
+      case 'U': fmt_spec = 'u'; length_modifier = 'l'; break;
+      case 'O': fmt_spec = 'o'; length_modifier = 'l'; break;
+      default: break;
+      }
+   /* get parameter value, do initial processing */
+      switch (fmt_spec) {
+      case '%': /* % behaves similar to 's' regarding flags and field widths */
+      case 'c': /* c behaves similar to 's' regarding flags and field widths */
+      case 's':
+        length_modifier = '\0';          /* wint_t and wchar_t not supported */
+     /* the result of zero padding flag with non-numeric conversion specifier*/
+     /* is undefined. Solaris and HPUX 10 does zero padding in this case,    */
+     /* Digital Unix and Linux does not. */
+#if !defined(SOLARIS_COMPATIBLE) &amp;&amp; !defined(HPUX_COMPATIBLE)
+        zero_padding = 0;    /* turn zero padding off for string conversions */
+#endif
+        str_arg_l = 1;
+        switch (fmt_spec) {
+        case '%':
+          str_arg = p; break;
+        case 'c': {
+          int j = va_arg(ap, int);
+          uchar_arg = (unsigned char) j;   /* standard demands unsigned char */
+          str_arg = (const char *) &amp;uchar_arg;
+          break;
+        }
+        case 's':
+          str_arg = va_arg(ap, const char *);
+          if (!str_arg) str_arg_l = 0;
+       /* make sure not to address string beyond the specified precision !!! */
+          else if (!precision_specified) str_arg_l = strlen(str_arg);
+       /* truncate string if necessary as requested by precision */
+          else if (precision == 0) str_arg_l = 0;
+          else {
+       /* memchr on HP does not like n &gt; 2^31  !!! */
+            const char *q = memchr(str_arg, '\0',
+                             precision &lt;= 0x7fffffff ? precision : 0x7fffffff);
+            str_arg_l = !q ? precision : (q-str_arg);
+          }
+          break;
+        default: break;
+        }
+        break;
+      case 'd': case 'u': case 'o': case 'x': case 'X': case 'p': {
+        /* NOTE: the u, o, x, X and p conversion specifiers imply
+                 the value is unsigned;  d implies a signed value */
+
+        int arg_sign = 0;
+          /* 0 if numeric argument is zero (or if pointer is NULL for 'p'),
+            +1 if greater than zero (or nonzero for unsigned arguments),
+            -1 if negative (unsigned argument is never negative) */
+
+        int int_arg = 0;  unsigned int uint_arg = 0;
+          /* only defined for length modifier h, or for no length modifiers */
+
+        long int long_arg = 0;  unsigned long int ulong_arg = 0;
+          /* only defined for length modifier l */
+
+        void *ptr_arg = NULL;
+          /* pointer argument value -only defined for p conversion */
+
+#ifdef SNPRINTF_LONGLONG_SUPPORT
+        long long int long_long_arg = 0;
+        unsigned long long int ulong_long_arg = 0;
+          /* only defined for length modifier ll */
+#endif
+        if (fmt_spec == 'p') {
+        /* HPUX 10: An l, h, ll or L before any other conversion character
+         *   (other than d, i, u, o, x, or X) is ignored.
+         * Digital Unix:
+         *   not specified, but seems to behave as HPUX does.
+         * Solaris: If an h, l, or L appears before any other conversion
+         *   specifier (other than d, i, u, o, x, or X), the behavior
+         *   is undefined. (Actually %hp converts only 16-bits of address
+         *   and %llp treats address as 64-bit data which is incompatible
+         *   with (void *) argument on a 32-bit system).
+         */
+#ifdef SOLARIS_COMPATIBLE
+#  ifdef SOLARIS_BUG_COMPATIBLE
+          /* keep length modifiers even if it represents 'll' */
+#  else
+          if (length_modifier == '2') length_modifier = '\0';
+#  endif
+#else
+          length_modifier = '\0';
+#endif
+          ptr_arg = va_arg(ap, void *);
+          if (ptr_arg != NULL) arg_sign = 1;
+        } else if (fmt_spec == 'd') {  /* signed */
+          switch (length_modifier) {
+          case '\0':
+          case 'h':
+         /* It is non-portable to specify a second argument of char or short
+          * to va_arg, because arguments seen by the called function
+          * are not char or short.  C converts char and short arguments
+          * to int before passing them to a function.
+          */
+            int_arg = va_arg(ap, int);
+            if      (int_arg &gt; 0) arg_sign =  1;
+            else if (int_arg &lt; 0) arg_sign = -1;
+            break;
+          case 'l':
+            long_arg = va_arg(ap, long int);
+            if      (long_arg &gt; 0) arg_sign =  1;
+            else if (long_arg &lt; 0) arg_sign = -1;
+            break;
+#ifdef SNPRINTF_LONGLONG_SUPPORT
+          case '2':
+            long_long_arg = va_arg(ap, long long int);
+            if      (long_long_arg &gt; 0) arg_sign =  1;
+            else if (long_long_arg &lt; 0) arg_sign = -1;
+            break;
+#endif
+          }
+        } else {  /* unsigned */
+          switch (length_modifier) {
+          case '\0':
+          case 'h':
+            uint_arg = va_arg(ap, unsigned int);
+            if (uint_arg) arg_sign = 1;
+            break;
+          case 'l':
+            ulong_arg = va_arg(ap, unsigned long int);
+            if (ulong_arg) arg_sign = 1;
+            break;
+#ifdef SNPRINTF_LONGLONG_SUPPORT
+          case '2':
+            ulong_long_arg = va_arg(ap, unsigned long long int);
+            if (ulong_long_arg) arg_sign = 1;
+            break;
+#endif
+          }
+        }
+        str_arg = tmp; str_arg_l = 0;
+     /* NOTE:
+      *   For d, i, u, o, x, and X conversions, if precision is specified,
+      *   the '0' flag should be ignored. This is so with Solaris 2.6,
+      *   Digital UNIX 4.0, HPUX 10, Linux, FreeBSD, NetBSD; but not with Perl.
+      */
+#ifndef PERL_COMPATIBLE
+        if (precision_specified) zero_padding = 0;
+#endif
+        if (fmt_spec == 'd') {
+          if (force_sign &amp;&amp; arg_sign &gt;= 0)
+            tmp[str_arg_l++] = space_for_positive ? ' ' : '+';
+         /* leave negative numbers for sprintf to handle,
+            to avoid handling tricky cases like (short int)(-32768) */
+#ifdef LINUX_COMPATIBLE
+        } else if (fmt_spec == 'p' &amp;&amp; force_sign &amp;&amp; arg_sign &gt; 0) {
+          tmp[str_arg_l++] = space_for_positive ? ' ' : '+';
+#endif
+        } else if (alternate_form) {
+          if (arg_sign != 0 &amp;&amp; (fmt_spec == 'x' || fmt_spec == 'X') )
+            { tmp[str_arg_l++] = '0'; tmp[str_arg_l++] = fmt_spec; }
+         /* alternate form should have no effect for p conversion, but ... */
+#ifdef HPUX_COMPATIBLE
+          else if (fmt_spec == 'p'
+         /* HPUX 10: for an alternate form of p conversion,
+          *          a nonzero result is prefixed by 0x. */
+#ifndef HPUX_BUG_COMPATIBLE
+         /* Actually it uses 0x prefix even for a zero value. */
+                   &amp;&amp; arg_sign != 0
+#endif
+                  ) { tmp[str_arg_l++] = '0'; tmp[str_arg_l++] = 'x'; }
+#endif
+        }
+        zero_padding_insertion_ind = str_arg_l;
+        if (!precision_specified) precision = 1;   /* default precision is 1 */
+        if (precision == 0 &amp;&amp; arg_sign == 0
+#if defined(HPUX_BUG_COMPATIBLE) || defined(LINUX_COMPATIBLE)
+            &amp;&amp; fmt_spec != 'p'
+         /* HPUX 10 man page claims: With conversion character p the result of
+          * converting a zero value with a precision of zero is a null string.
+          * Actually HP returns all zeroes, and Linux returns &quot;(nil)&quot;. */
+#endif
+        ) {
+         /* converted to null string */
+         /* When zero value is formatted with an explicit precision 0,
+            the resulting formatted string is empty (d, i, u, o, x, X, p).   */
+        } else {
+          char f[5]; int f_l = 0;
+          f[f_l++] = '%';    /* construct a simple format string for sprintf */
+          if (!length_modifier) { }
+          else if (length_modifier=='2') { f[f_l++] = 'l'; f[f_l++] = 'l'; }
+          else f[f_l++] = length_modifier;
+          f[f_l++] = fmt_spec; f[f_l++] = '\0';
+          if (fmt_spec == 'p') str_arg_l += sprintf(tmp+str_arg_l, f, ptr_arg);
+          else if (fmt_spec == 'd') {  /* signed */
+            switch (length_modifier) {
+            case '\0':
+            case 'h': str_arg_l+=sprintf(tmp+str_arg_l, f, int_arg);  break;
+            case 'l': str_arg_l+=sprintf(tmp+str_arg_l, f, long_arg); break;
+#ifdef SNPRINTF_LONGLONG_SUPPORT
+            case '2': str_arg_l+=sprintf(tmp+str_arg_l,f,long_long_arg); break;
+#endif
+            }
+          } else {  /* unsigned */
+            switch (length_modifier) {
+            case '\0':
+            case 'h': str_arg_l+=sprintf(tmp+str_arg_l, f, uint_arg);  break;
+            case 'l': str_arg_l+=sprintf(tmp+str_arg_l, f, ulong_arg); break;
+#ifdef SNPRINTF_LONGLONG_SUPPORT
+            case '2': str_arg_l+=sprintf(tmp+str_arg_l,f,ulong_long_arg);break;
+#endif
+            }
+          }
+         /* include the optional minus sign and possible &quot;0x&quot;
+            in the region before the zero padding insertion point */
+          if (zero_padding_insertion_ind &lt; str_arg_l &amp;&amp;
+              tmp[zero_padding_insertion_ind] == '-') {
+            zero_padding_insertion_ind++;
+          }
+          if (zero_padding_insertion_ind+1 &lt; str_arg_l &amp;&amp;
+              tmp[zero_padding_insertion_ind]   == '0' &amp;&amp;
+             (tmp[zero_padding_insertion_ind+1] == 'x' ||
+              tmp[zero_padding_insertion_ind+1] == 'X') ) {
+            zero_padding_insertion_ind += 2;
+          }
+        }
+        { size_t num_of_digits = str_arg_l - zero_padding_insertion_ind;
+          if (alternate_form &amp;&amp; fmt_spec == 'o'
+#ifdef HPUX_COMPATIBLE                                  /* (&quot;%#.o&quot;,0) -&gt; &quot;&quot;  */
+              &amp;&amp; (str_arg_l &gt; 0)
+#endif
+#ifdef DIGITAL_UNIX_BUG_COMPATIBLE                      /* (&quot;%#o&quot;,0) -&gt; &quot;00&quot; */
+#else
+              /* unless zero is already the first character */
+              &amp;&amp; !(zero_padding_insertion_ind &lt; str_arg_l
+                   &amp;&amp; tmp[zero_padding_insertion_ind] == '0')
+#endif
+          ) {        /* assure leading zero for alternate-form octal numbers */
+            if (!precision_specified || precision &lt; num_of_digits+1) {
+             /* precision is increased to force the first character to be zero,
+                except if a zero value is formatted with an explicit precision
+                of zero */
+              precision = num_of_digits+1; precision_specified = 1;
+            }
+          }
+       /* zero padding to specified precision? */
+          if (num_of_digits &lt; precision) 
+            number_of_zeros_to_pad = precision - num_of_digits;
+        }
+     /* zero padding to specified minimal field width? */
+        if (!justify_left &amp;&amp; zero_padding) {
+          int n = min_field_width - (str_arg_l+number_of_zeros_to_pad);
+          if (n &gt; 0) number_of_zeros_to_pad += n;
+        }
+        break;
+      }
+      default: /* unrecognized conversion specifier, keep format string as-is*/
+        zero_padding = 0;  /* turn zero padding off for non-numeric convers. */
+#ifndef DIGITAL_UNIX_COMPATIBLE
+        justify_left = 1; min_field_width = 0;                /* reset flags */
+#endif
+#if defined(PERL_COMPATIBLE) || defined(LINUX_COMPATIBLE)
+     /* keep the entire format string unchanged */
+        str_arg = starting_p; str_arg_l = p - starting_p;
+     /* well, not exactly so for Linux, which does something inbetween,
+      * and I don't feel an urge to imitate it: &quot;%+++++hy&quot; -&gt; &quot;%+y&quot;  */
+#else
+     /* discard the unrecognized conversion, just keep *
+      * the unrecognized conversion character          */
+        str_arg = p; str_arg_l = 0;
+#endif
+        if (*p) str_arg_l++;  /* include invalid conversion specifier unchanged
+                                 if not at end-of-string */
+        break;
+      }
+      if (*p) p++;      /* step over the just processed conversion specifier */
+   /* insert padding to the left as requested by min_field_width;
+      this does not include the zero padding in case of numerical conversions*/
+      if (!justify_left) {                /* left padding with blank or zero */
+        int n = min_field_width - (str_arg_l+number_of_zeros_to_pad);
+        if (n &gt; 0) {
+          if (str_l &lt; str_m) {
+            size_t avail = str_m-str_l;
+            fast_memset(str+str_l, (zero_padding?'0':' '), (n&gt;avail?avail:n));
+          }
+          str_l += n;
+        }
+      }
+   /* zero padding as requested by the precision or by the minimal field width
+    * for numeric conversions required? */
+      if (number_of_zeros_to_pad &lt;= 0) {
+     /* will not copy first part of numeric right now, *
+      * force it to be copied later in its entirety    */
+        zero_padding_insertion_ind = 0;
+      } else {
+     /* insert first part of numerics (sign or '0x') before zero padding */
+        int n = zero_padding_insertion_ind;
+        if (n &gt; 0) {
+          if (str_l &lt; str_m) {
+            size_t avail = str_m-str_l;
+            fast_memcpy(str+str_l, str_arg, (n&gt;avail?avail:n));
+          }
+          str_l += n;
+        }
+     /* insert zero padding as requested by the precision or min field width */
+        n = number_of_zeros_to_pad;
+        if (n &gt; 0) {
+          if (str_l &lt; str_m) {
+            size_t avail = str_m-str_l;
+            fast_memset(str+str_l, '0', (n&gt;avail?avail:n));
+          }
+          str_l += n;
+        }
+      }
+   /* insert formatted string
+    * (or as-is conversion specifier for unknown conversions) */
+      { int n = str_arg_l - zero_padding_insertion_ind;
+        if (n &gt; 0) {
+          if (str_l &lt; str_m) {
+            size_t avail = str_m-str_l;
+            fast_memcpy(str+str_l, str_arg+zero_padding_insertion_ind,
+                        (n&gt;avail?avail:n));
+          }
+          str_l += n;
+        }
+      }
+   /* insert right padding */
+      if (justify_left) {          /* right blank padding to the field width */
+        int n = min_field_width - (str_arg_l+number_of_zeros_to_pad);
+        if (n &gt; 0) {
+          if (str_l &lt; str_m) {
+            size_t avail = str_m-str_l;
+            fast_memset(str+str_l, ' ', (n&gt;avail?avail:n));
+          }
+          str_l += n;
+        }
+      }
+    }
+  }
+#if defined(NEED_SNPRINTF_ONLY)
+  va_end(ap);
+#endif
+  if (str_m &gt; 0) { /* make sure the string is null-terminated
+                      even at the expense of overwriting the last character
+                      (shouldn't happen, but just in case) */
+    str[str_l &lt;= str_m-1 ? str_l : str_m-1] = '\0';
+  }
+  /* Return the number of characters formatted (excluding trailing null
+   * character), that is, the number of characters that would have been
+   * written to the buffer if it were large enough.
+   *
+   * The value of str_l should be returned, but str_l is of unsigned type
+   * size_t, and snprintf is int, possibly leading to an undetected
+   * integer overflow, resulting in a negative return value, which is illegal.
+   * Both XSH5 and ISO C99 (at least the draft) are silent on this issue.
+   * Should errno be set to EOVERFLOW and EOF returned in this case???
+   */
+  return (int) str_l;
+}
+#endif

Added: upwatch/trunk/mswindows/MonitorService/snprintf.h
===================================================================
--- upwatch/trunk/mswindows/MonitorService/snprintf.h	2005-03-07 13:13:22 UTC (rev 478)
+++ upwatch/trunk/mswindows/MonitorService/snprintf.h	2005-03-25 20:56:55 UTC (rev 479)
@@ -0,0 +1,26 @@
+#ifndef _PORTABLE_SNPRINTF_H_
+#define _PORTABLE_SNPRINTF_H_
+
+#define PORTABLE_SNPRINTF_VERSION_MAJOR 2
+#define PORTABLE_SNPRINTF_VERSION_MINOR 2
+
+#ifdef HAVE_SNPRINTF
+#include &lt;stdio.h&gt;
+#else
+extern int snprintf(char *, size_t, const char *, /*args*/ ...);
+extern int vsnprintf(char *, size_t, const char *, va_list);
+#endif
+
+#if defined(HAVE_SNPRINTF) &amp;&amp; defined(PREFER_PORTABLE_SNPRINTF)
+extern int portable_snprintf(char *str, size_t str_m, const char *fmt, /*args*/ ...);
+extern int portable_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap);
+#define snprintf  portable_snprintf
+#define vsnprintf portable_vsnprintf
+#endif
+
+extern int asprintf  (char **ptr, const char *fmt, /*args*/ ...);
+extern int vasprintf (char **ptr, const char *fmt, va_list ap);
+extern int asnprintf (char **ptr, size_t str_m, const char *fmt, /*args*/ ...);
+extern int vasnprintf(char **ptr, size_t str_m, const char *fmt, va_list ap);
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000008.html">[Upwatch-commits] r478 - upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/upwatch-commits">More information about the Upwatch-commits
mailing list</a><br>
</body></html>
