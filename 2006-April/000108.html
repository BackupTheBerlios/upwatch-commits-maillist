<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Upwatch-commits] r576 - in upwatch/trunk: . cfg common compat doc patches
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/upwatch-commits/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:upwatch-commits%40lists.berlios.de?Subject=Re%3A%20%5BUpwatch-commits%5D%20r576%20-%20in%20upwatch/trunk%3A%20.%20cfg%20common%20compat%20doc%20patches&In-Reply-To=%3C200604132050.k3DKotUS021579%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000106.html">
   <LINK REL="Next"  HREF="000107.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Upwatch-commits] r576 - in upwatch/trunk: . cfg common compat doc patches</H1>
    <B>wijnand at BerliOS</B> 
    <A HREF="mailto:upwatch-commits%40lists.berlios.de?Subject=Re%3A%20%5BUpwatch-commits%5D%20r576%20-%20in%20upwatch/trunk%3A%20.%20cfg%20common%20compat%20doc%20patches&In-Reply-To=%3C200604132050.k3DKotUS021579%40sheep.berlios.de%3E"
       TITLE="[Upwatch-commits] r576 - in upwatch/trunk: . cfg common compat doc patches">wijnand at berlios.de
       </A><BR>
    <I>Thu Apr 13 22:50:55 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000106.html">[Upwatch-commits] r575 - upwatch/trunk
</A></li>
        <LI>Next message: <A HREF="000107.html">[Upwatch-commits] r577 - upwatch/trunk/uw_send
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#108">[ date ]</a>
              <a href="thread.html#108">[ thread ]</a>
              <a href="subject.html#108">[ subject ]</a>
              <a href="author.html#108">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: wijnand
Date: 2006-04-13 22:50:54 +0200 (Thu, 13 Apr 2006)
New Revision: 576

Removed:
   upwatch/trunk/cfg/cvs2cl.pl
   upwatch/trunk/common/license_proprietary.def
   upwatch/trunk/compat/sometests/
   upwatch/trunk/patches/libstatgrab-openbsd.patch
   upwatch/trunk/patches/xmbmon203.patch
   upwatch/trunk/upwatch-spec.spec
   upwatch/trunk/uw_investigate/
Modified:
   upwatch/trunk/Makefile.am
   upwatch/trunk/common/Makefile.am
   upwatch/trunk/compat/Makefile.am
   upwatch/trunk/configure.ac
   upwatch/trunk/doc/howitallworks.xml
   upwatch/trunk/patches/README
Log:
Remove unused cruft and make sure it is not referenced anymore.
Working with a cleaner tree is much better.

Not sure if uw_setip is still used/usefull so that one remains.


Modified: upwatch/trunk/Makefile.am
===================================================================
--- upwatch/trunk/Makefile.am	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/Makefile.am	2006-04-13 20:50:54 UTC (rev 576)
@@ -1,9 +1,5 @@
 include $(top_srcdir)/Makefile.am.path
 
-#if HAVE_LIBNET
-#USE_LIBNET = uw_investigate
-#endif
-
 if HAVE_LIBPCAP
 UW_IPTRAF = uw_iptraf
 endif
@@ -83,7 +79,7 @@
   upwatch-spec.def upwatch-spec.tpl upwatch.spec templates \
   patches/libpcap-linux-timeout.patch mswindows \
   ${SERVER_DIST} \
-  install-sh config.sub mkinstalldirs depcomp cfg/cvs2cl.pl
+  install-sh config.sub mkinstalldirs depcomp
 
 
 upwatch.spec: force upwatch-spec.def upwatch-spec.tpl common/spec.tpl \

Deleted: upwatch/trunk/cfg/cvs2cl.pl
===================================================================
--- upwatch/trunk/cfg/cvs2cl.pl	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/cfg/cvs2cl.pl	2006-04-13 20:50:54 UTC (rev 576)
@@ -1,1995 +0,0 @@
-#!/usr/bin/perl -w
-# -*- mode: perl; perl-indent-level: 2; -*-
-
-eval 'exec perl -w -x $0 ${1+&quot;$@&quot;}'
-  if 0; # not running under some shell
-
-##############################################################
-###                                                        ###
-### cvs2cl.pl: produce ChangeLog(s) from `cvs log` output. ###
-###                                                        ###
-##############################################################
-
-## $Revision: 1.1 $
-## $Date: 2002/12/27 10:12:15 $
-## $Author: raarts $
-##
-##   (C) 2001,2002 Martyn J. Pearce &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">fluffy at cpan.org</A>&gt;
-##   (C) 1999 Karl Fogel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">kfogel at red-bean.com</A>&gt;, under the GNU GPL.
-##
-##   (Extensively hacked on by Melissa O'Neill &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">oneill at cs.sfu.ca</A>&gt;.)
-##
-## cvs2cl.pl is free software; you can redistribute it and/or modify
-## it under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 2, or (at your option)
-## any later version.
-##
-## cvs2cl.pl is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You may have received a copy of the GNU General Public License
-## along with cvs2cl.pl; see the file COPYING.  If not, write to the
-## Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-## Boston, MA 02111-1307, USA.
-
-
-
-use strict;
-use Text::Wrap;
-use Time::Local;
-use File::Basename;
-
-
-# The Plan:
-#
-# Read in the logs for multiple files, spit out a nice ChangeLog that
-# mirrors the information entered during `cvs commit'.
-#
-# The problem presents some challenges. In an ideal world, we could
-# detect files with the same author, log message, and checkin time --
-# each &lt;filelist, author, time, logmessage&gt; would be a changelog entry.
-# We'd sort them; and spit them out.  Unfortunately, CVS is *not atomic*
-# so checkins can span a range of times.  Also, the directory structure
-# could be hierarchical.
-#
-# Another question is whether we really want to have the ChangeLog
-# exactly reflect commits. An author could issue two related commits,
-# with different log entries, reflecting a single logical change to the
-# source. GNU style ChangeLogs group these under a single author/date.
-# We try to do the same.
-#
-# So, we parse the output of `cvs log', storing log messages in a
-# multilevel hash that stores the mapping:
-#   directory =&gt; author =&gt; time =&gt; message =&gt; filelist
-# As we go, we notice &quot;nearby&quot; commit times and store them together
-# (i.e., under the same timestamp), so they appear in the same log
-# entry.
-#
-# When we've read all the logs, we twist this mapping into
-# a time =&gt; author =&gt; message =&gt; filelist mapping for each directory.
-#
-# If we're not using the `--distributed' flag, the directory is always
-# considered to be `./', even as descend into subdirectories.
-
-
-############### Globals ################
-
-
-# What we run to generate it:
-my $Log_Source_Command = &quot;cvs log&quot;;
-
-# In case we have to print it out:
-my $VERSION = '$Revision: 1.1 $';
-$VERSION =~ s/\S+\s+(\S+)\s+\S+/$1/;
-
-## Vars set by options:
-
-# Print debugging messages?
-my $Debug = 0;
-
-# Just show version and exit?
-my $Print_Version = 0;
-
-# Just print usage message and exit?
-my $Print_Usage = 0;
-
-# Single top-level ChangeLog, or one per subdirectory?
-my $Distributed = 0;
-
-# What file should we generate (defaults to &quot;ChangeLog&quot;)?
-my $Log_File_Name = &quot;ChangeLog&quot;;
-
-# Grab most recent entry date from existing ChangeLog file, just add
-# to that ChangeLog.
-my $Cumulative = 0;
-
-# Expand usernames to email addresses based on a map file?
-my $User_Map_File = &quot;&quot;;
-
-# Output to a file or to stdout?
-my $Output_To_Stdout = 0;
-
-# Eliminate empty log messages?
-my $Prune_Empty_Msgs = 0;
-
-# Tags of which not to output
-my @ignore_tags;
-
-# Don't call Text::Wrap on the body of the message
-my $No_Wrap = 0;
-
-# Separates header from log message.  Code assumes it is either &quot; &quot; or
-# &quot;\n\n&quot;, so if there's ever an option to set it to something else,
-# make sure to go through all conditionals that use this var.
-my $After_Header = &quot; &quot;;
-
-# XML Encoding
-my $XML_Encoding = '';
-
-# Format more for programs than for humans.
-my $XML_Output = 0;
-
-# Do some special tweaks for log data that was written in FSF
-# ChangeLog style.
-my $FSF_Style = 0;
-
-# Show times in UTC instead of local time
-my $UTC_Times = 0;
-
-# Show day of week in output?
-my $Show_Day_Of_Week = 0;
-
-# Show revision numbers in output?
-my $Show_Revisions = 0;
-
-# Show tags (symbolic names) in output?
-my $Show_Tags = 0;
-
-# Show tags separately in output?
-my $Show_Tag_Dates = 0;
-
-# Show branches by symbolic name in output?
-my $Show_Branches = 0;
-
-# Show only revisions on these branches or their ancestors.
-my @Follow_Branches;
-
-# Don't bother with files matching this regexp.
-my @Ignore_Files;
-
-# How exactly we match entries.  We definitely want &quot;o&quot;,
-# and user might add &quot;i&quot; by using --case-insensitive option.
-my $Case_Insensitive = 0;
-
-# Maybe only show log messages matching a certain regular expression.
-my $Regexp_Gate = &quot;&quot;;
-
-# Pass this global option string along to cvs, to the left of `log':
-my $Global_Opts = &quot;&quot;;
-
-# Pass this option string along to the cvs log subcommand:
-my $Command_Opts = &quot;&quot;;
-
-# Read log output from stdin instead of invoking cvs log?
-my $Input_From_Stdin = 0;
-
-# Don't show filenames in output.
-my $Hide_Filenames = 0;
-
-# Max checkin duration. CVS checkin is not atomic, so we may have checkin
-# times that span a range of time. We assume that checkins will last no
-# longer than $Max_Checkin_Duration seconds, and that similarly, no
-# checkins will happen from the same users with the same message less
-# than $Max_Checkin_Duration seconds apart.
-my $Max_Checkin_Duration = 180;
-
-# What to put at the front of [each] ChangeLog.
-my $ChangeLog_Header = &quot;&quot;;
-
-# Whether to enable 'delta' mode, and for what start/end tags.
-my $Delta_Mode = 0;
-my $Delta_From = &quot;&quot;;
-my $Delta_To = &quot;&quot;;
-
-## end vars set by options.
-
-# latest observed times for the start/end tags in delta mode
-my $Delta_StartTime = 0;
-my $Delta_EndTime = 0;
-
-# In 'cvs log' output, one long unbroken line of equal signs separates
-# files:
-my $file_separator = &quot;=======================================&quot;
-                   . &quot;======================================&quot;;
-
-# In 'cvs log' output, a shorter line of dashes separates log messages
-# within a file:
-my $logmsg_separator = &quot;----------------------------&quot;;
-
-
-############### End globals ############
-
-
-
-
-&amp;parse_options ();
-&amp;derive_change_log ();
-
-
-
-### Everything below is subroutine definitions. ###
-
-# If accumulating, grab the boundary date from pre-existing ChangeLog.
-sub maybe_grab_accumulation_date ()
-{
-  if (! $Cumulative) {
-    return &quot;&quot;;
-  }
-
-  # else
-
-  open (LOG, &quot;$Log_File_Name&quot;)
-      or die (&quot;trouble opening $Log_File_Name for reading ($!)&quot;);
-
-  my $boundary_date;
-  while (&lt;LOG&gt;)
-  {
-    if (/^(\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d)/)
-    {
-      $boundary_date = &quot;$1&quot;;
-      last;
-    }
-  }
-
-  close (LOG);
-  return $boundary_date;
-}
-
-
-# Fills up a ChangeLog structure in the current directory.
-sub derive_change_log ()
-{
-  # See &quot;The Plan&quot; above for a full explanation.
-
-  my %grand_poobah;
-
-  my $file_full_path;
-  my $time;
-  my $revision;
-  my $author;
-  my $msg_txt;
-  my $detected_file_separator;
-
-  my %tag_date_printed;
-
-  # Might be adding to an existing ChangeLog
-  my $accumulation_date = &amp;maybe_grab_accumulation_date ();
-  if ($accumulation_date) {
-    # Insert -d immediately after 'cvs log'
-    my $Log_Date_Command = &quot;-d\'&gt;${accumulation_date}\'&quot;;
-    $Log_Source_Command =~ s/(^.*log\S*)/$1 $Log_Date_Command/;
-    &amp;debug (&quot;(adding log msg starting from $accumulation_date)\n&quot;);
-  }
-
-  # We might be expanding usernames
-  my %usermap;
-
-  # In general, it's probably not very maintainable to use state
-  # variables like this to tell the loop what it's doing at any given
-  # moment, but this is only the first one, and if we never have more
-  # than a few of these, it's okay.
-  my $collecting_symbolic_names = 0;
-  my %symbolic_names;    # Where tag names get stored.
-  my %branch_names;      # We'll grab branch names while we're at it.
-  my %branch_numbers;    # Save some revisions for @Follow_Branches
-  my @branch_roots;      # For showing which files are branch ancestors.
-
-  # Bleargh.  Compensate for a deficiency of custom wrapping.
-  if (($After_Header ne &quot; &quot;) and $FSF_Style)
-  {
-    $After_Header .= &quot;\t&quot;;
-  }
-
-  if (! $Input_From_Stdin) {
-    &amp;debug (&quot;(run \&quot;${Log_Source_Command}\&quot;)\n&quot;);
-    open (LOG_SOURCE, &quot;$Log_Source_Command |&quot;)
-        or die &quot;unable to run \&quot;${Log_Source_Command}\&quot;&quot;;
-  }
-  else {
-    open (LOG_SOURCE, &quot;-&quot;) or die &quot;unable to open stdin for reading&quot;;
-  }
-
-  binmode LOG_SOURCE;
-
-  %usermap = &amp;maybe_read_user_map_file ();
-
-  while (&lt;LOG_SOURCE&gt;)
-  {
-    # If on a new file and don't see filename, skip until we find it, and
-    # when we find it, grab it.
-    if ((! (defined $file_full_path)) and /^Working file: (.*)/)
-    {
-      $file_full_path = $1;
-      if (@Ignore_Files)
-      {
-        my $base;
-        ($base, undef, undef) = fileparse ($file_full_path);
-        # Ouch, I wish trailing operators in regexps could be
-        # evaluated on the fly!
-        if ($Case_Insensitive) {
-          if (grep ($file_full_path =~ m|$_|i, @Ignore_Files)) {
-            undef $file_full_path;
-          }
-        }
-        elsif (grep ($file_full_path =~ m|$_|, @Ignore_Files)) {
-          undef $file_full_path;
-        }
-      }
-      next;
-    }
-
-    # Just spin wheels if no file defined yet.
-    next if (! $file_full_path);
-
-    # Collect tag names in case we're asked to print them in the output.
-    if (/^symbolic names:$/) {
-      $collecting_symbolic_names = 1;
-      next;  # There's no more info on this line, so skip to next
-    }
-    if ($collecting_symbolic_names)
-    {
-      # All tag names are listed with whitespace in front in cvs log
-      # output; so if see non-whitespace, then we're done collecting.
-      if (/^\S/) {
-        $collecting_symbolic_names = 0;
-      }
-      else    # we're looking at a tag name, so parse &amp; store it
-      {
-        # According to the Cederqvist manual, in node &quot;Tags&quot;, tag
-        # names must start with an uppercase or lowercase letter and
-        # can contain uppercase and lowercase letters, digits, `-',
-        # and `_'.  However, it's not our place to enforce that, so
-        # we'll allow anything CVS hands us to be a tag:
-        /^\s+([^:]+): ([\d.]+)$/;
-        my $tag_name = $1;
-        my $tag_rev  = $2;
-
-        # A branch number either has an odd number of digit sections
-        # (and hence an even number of dots), or has &quot;.0.&quot; as the
-        # second-to-last digit section.  Test for these conditions.
-        my $real_branch_rev = &quot;&quot;;
-        if (($tag_rev =~ /^(\d+\.\d+\.)+\d+$/)   # Even number of dots...
-            and (! ($tag_rev =~ /^(1\.)+1$/)))   # ...but not &quot;1.[1.]1&quot;
-        {
-          $real_branch_rev = $tag_rev;
-        }
-        elsif ($tag_rev =~ /(\d+\.(\d+\.)+)0.(\d+)/)  # Has &quot;.0.&quot;
-        {
-          $real_branch_rev = $1 . $3;
-        }
-        # If we got a branch, record its number.
-        if ($real_branch_rev)
-        {
-          $branch_names{$real_branch_rev} = $tag_name;
-          if (@Follow_Branches) {
-            if (grep ($_ eq $tag_name, @Follow_Branches)) {
-              $branch_numbers{$tag_name} = $real_branch_rev;
-            }
-          }
-        }
-        else {
-          # Else it's just a regular (non-branch) tag.
-          push (@{$symbolic_names{$tag_rev}}, $tag_name);
-        }
-      }
-    }
-    # End of code for collecting tag names.
-
-    # If have file name, but not revision, and see revision, then grab
-    # it.  (We collect unconditionally, even though we may or may not
-    # ever use it.)
-    if ((! (defined $revision)) and (/^revision (\d+\.[\d.]+)/))
-    {
-      $revision = $1;
-
-      if (@Follow_Branches)
-      {
-        foreach my $branch (@Follow_Branches)
-        {
-          # Special case for following trunk revisions
-          if (($branch =~ /^trunk$/i) and ($revision =~ /^[0-9]+\.[0-9]+$/))
-          {
-            goto dengo;
-          }
-
-          my $branch_number = $branch_numbers{$branch};
-          if ($branch_number)
-          {
-            # Are we on one of the follow branches or an ancestor of
-            # same?
-            #
-            # If this revision is a prefix of the branch number, or
-            # possibly is less in the minormost number, OR if this
-            # branch number is a prefix of the revision, then yes.
-            # Otherwise, no.
-            #
-            # So below, we determine if any of those conditions are
-            # met.
-
-            # Trivial case: is this revision on the branch?
-            # (Compare this way to avoid regexps that screw up Emacs
-            # indentation, argh.)
-            if ((substr ($revision, 0, ((length ($branch_number)) + 1)))
-                eq ($branch_number . &quot;.&quot;))
-            {
-              goto dengo;
-            }
-            # Non-trivial case: check if rev is ancestral to branch
-            elsif ((length ($branch_number)) &gt; (length ($revision)))
-            {
-              $revision =~ /^((?:\d+\.)+)(\d+)$/;
-              my $r_left = $1;          # still has the trailing &quot;.&quot;
-              my $r_end = $2;
-
-              $branch_number =~ /^((?:\d+\.)+)(\d+)\.\d+$/;
-              my $b_left = $1;  # still has trailing &quot;.&quot;
-              my $b_mid  = $2;   # has no trailing &quot;.&quot;
-
-              if (($r_left eq $b_left)
-                  &amp;&amp; ($r_end &lt;= $b_mid))
-              {
-                goto dengo;
-              }
-            }
-          }
-        }
-      }
-      else    # (! @Follow_Branches)
-      {
-        next;
-      }
-
-      # Else we are following branches, but this revision isn't on the
-      # path.  So skip it.
-      undef $revision;
-    dengo:
-      next;
-    }
-
-    # If we don't have a revision right now, we couldn't possibly
-    # be looking at anything useful.
-    if (! (defined ($revision))) {
-      $detected_file_separator = /^$file_separator$/o;
-      if ($detected_file_separator) {
-        # No revisions for this file; can happen, e.g. &quot;cvs log -d DATE&quot;
-        goto CLEAR;
-      }
-      else {
-        next;
-      }
-    }
-
-    # If have file name but not date and author, and see date or
-    # author, then grab them:
-    unless (defined $time)
-    {
-      if (/^date: .*/)
-      {
-        ($time, $author) = &amp;parse_date_and_author ($_);
-        if (defined ($usermap{$author}) and $usermap{$author}) {
-          $author = $usermap{$author};
-        }
-      }
-      else {
-        $detected_file_separator = /^$file_separator$/o;
-        if ($detected_file_separator) {
-          # No revisions for this file; can happen, e.g. &quot;cvs log -d DATE&quot;
-          goto CLEAR;
-        }
-      }
-      # If the date/time/author hasn't been found yet, we couldn't
-      # possibly care about anything we see.  So skip:
-      next;
-    }
-
-    # A &quot;branches: ...&quot; line here indicates that one or more branches
-    # are rooted at this revision.  If we're showing branches, then we
-    # want to show that fact as well, so we collect all the branches
-    # that this is the latest ancestor of and store them in
-    # @branch_roots.  Just for reference, the format of the line we're
-    # seeing at this point is:
-    #
-    #    branches:  1.5.2;  1.5.4;  ...;
-    #
-    # Okay, here goes:
-
-    if (/^branches:\s+(.*);$/)
-    {
-      if ($Show_Branches)
-      {
-        my $lst = $1;
-        $lst =~ s/(1\.)+1;|(1\.)+1$//;  # ignore the trivial branch 1.1.1
-        if ($lst) {
-          @branch_roots = split (/;\s+/, $lst);
-        }
-        else {
-          undef @branch_roots;
-        }
-        next;
-      }
-      else
-      {
-        # Ugh.  This really bothers me.  Suppose we see a log entry
-        # like this:
-        #
-        #    ----------------------------
-        #    revision 1.1
-        #    date: 1999/10/17 03:07:38;  author: jrandom;  state: Exp;
-        #    branches:  1.1.2;
-        #    Intended first line of log message begins here.
-        #    ----------------------------
-        #
-        # The question is, how we can tell the difference between that
-        # log message and a *two*-line log message whose first line is
-        #
-        #    &quot;branches:  1.1.2;&quot;
-        #
-        # See the problem?  The output of &quot;cvs log&quot; is inherently
-        # ambiguous.
-        #
-        # For now, we punt: we liberally assume that people don't
-        # write log messages like that, and just toss a &quot;branches:&quot;
-        # line if we see it but are not showing branches.  I hope no
-        # one ever loses real log data because of this.
-        next;
-      }
-    }
-
-    # If have file name, time, and author, then we're just grabbing
-    # log message texts:
-    $detected_file_separator = /^$file_separator$/o;
-    if ($detected_file_separator &amp;&amp; ! (defined $revision)) {
-      # No revisions for this file; can happen, e.g. &quot;cvs log -d DATE&quot;
-      goto CLEAR;
-    }
-    unless ($detected_file_separator || /^$logmsg_separator$/o)
-    {
-      $msg_txt .= $_;   # Normally, just accumulate the message...
-      next;
-    }
-    # ... until a msg separator is encountered:
-    # Ensure the message contains something:
-    if ((! $msg_txt)
-        || ($msg_txt =~ /^\s*\.\s*$|^\s*$/)
-        || ($msg_txt =~ /\*\*\* empty log message \*\*\*/))
-    {
-      if ($Prune_Empty_Msgs) {
-        goto CLEAR;
-      }
-      # else
-      $msg_txt = &quot;[no log message]\n&quot;;
-    }
-
-    ### Store it all in the Grand Poobah:
-    {
-      my $dir_key;        # key into %grand_poobah
-      my %qunk;           # complicated little jobbie, see below
-
-      # Each revision of a file has a little data structure (a `qunk')
-      # associated with it.  That data structure holds not only the
-      # file's name, but any additional information about the file
-      # that might be needed in the output, such as the revision
-      # number, tags, branches, etc.  The reason to have these things
-      # arranged in a data structure, instead of just appending them
-      # textually to the file's name, is that we may want to do a
-      # little rearranging later as we write the output.  For example,
-      # all the files on a given tag/branch will go together, followed
-      # by the tag in parentheses (so trunk or otherwise non-tagged
-      # files would go at the end of the file list for a given log
-      # message).  This rearrangement is a lot easier to do if we
-      # don't have to reparse the text.
-      #
-      # A qunk looks like this:
-      #
-      #   {
-      #     filename    =&gt;    &quot;hello.c&quot;,
-      #     revision    =&gt;    &quot;1.4.3.2&quot;,
-      #     time        =&gt;    a timegm() return value (moment of commit)
-      #     tags        =&gt;    [ &quot;tag1&quot;, &quot;tag2&quot;, ... ],
-      #     branch      =&gt;    &quot;branchname&quot; # There should be only one, right?
-      #     branchroots =&gt;    [ &quot;branchtag1&quot;, &quot;branchtag2&quot;, ... ]
-      #   }
-
-      if ($Distributed) {
-        # Just the basename, don't include the path.
-        ($qunk{'filename'}, $dir_key, undef) = fileparse ($file_full_path);
-      }
-      else {
-        $dir_key = &quot;./&quot;;
-        $qunk{'filename'} = $file_full_path;
-      }
-
-      # This may someday be used in a more sophisticated calculation
-      # of what other files are involved in this commit.  For now, we
-      # don't use it much except for delta mode, because the
-      # common-commit-detection algorithm is hypothesized to be
-      # &quot;good enough&quot; as it stands.
-      $qunk{'time'} = $time;
-
-      # We might be including revision numbers and/or tags and/or
-      # branch names in the output.  Most of the code from here to
-      # loop-end deals with organizing these in qunk.
-
-      $qunk{'revision'} = $revision;
-
-      # Grab the branch, even though we may or may not need it:
-      $qunk{'revision'} =~ /((?:\d+\.)+)\d+/;
-      my $branch_prefix = $1;
-      $branch_prefix =~ s/\.$//;  # strip off final dot
-      if ($branch_names{$branch_prefix}) {
-        $qunk{'branch'} = $branch_names{$branch_prefix};
-      }
-
-      # If there's anything in the @branch_roots array, then this
-      # revision is the root of at least one branch.  We'll display
-      # them as branch names instead of revision numbers, the
-      # substitution for which is done directly in the array:
-      if (@branch_roots) {
-        my @roots = map { $branch_names{$_} } @branch_roots;
-        $qunk{'branchroots'} = \@roots;
-      }
-
-      # Save tags too.
-      if (defined ($symbolic_names{$revision})) {
-        $qunk{'tags'} = $symbolic_names{$revision};
-        delete $symbolic_names{$revision};
-
-	# If we're in 'delta' mode, update the latest observed
-	# times for the beginning and ending tags, and
-	# when we get around to printing output, we will simply restrict
-	# ourselves to that timeframe...
-	
-	if ($Delta_Mode) {
-	  if (($time &gt; $Delta_StartTime) &amp;&amp;
-	      (grep { $_ eq $Delta_From } @{$qunk{'tags'}}))
-	  {
-	    $Delta_StartTime = $time;
-	  }
-	  
-	  if (($time &gt; $Delta_EndTime) &amp;&amp;
-	      (grep { $_ eq $Delta_To } @{$qunk{'tags'}}))
-	  {
-	    $Delta_EndTime = $time;
-	  }
-	}
-      }
-
-      # Add this file to the list
-      # (We use many spoonfuls of autovivication magic. Hashes and arrays
-      # will spring into existence if they aren't there already.)
-
-      &amp;debug (&quot;(pushing log msg for ${dir_key}$qunk{'filename'})\n&quot;);
-
-      # Store with the files in this commit.  Later we'll loop through
-      # again, making sure that revisions with the same log message
-      # and nearby commit times are grouped together as one commit.
-      push (@{$grand_poobah{$dir_key}{$author}{$time}{$msg_txt}}, \%qunk);
-    }
-
-  CLEAR:
-    # Make way for the next message
-    undef $msg_txt;
-    undef $time;
-    undef $revision;
-    undef $author;
-    undef @branch_roots;
-
-    # Maybe even make way for the next file:
-    if ($detected_file_separator) {
-      undef $file_full_path;
-      undef %branch_names;
-      undef %branch_numbers;
-      undef %symbolic_names;
-    }
-  }
-
-  close (LOG_SOURCE);
-
-  ### Process each ChangeLog
-
-  while (my ($dir,$authorhash) = each %grand_poobah)
-  {
-    &amp;debug (&quot;DOING DIR: $dir\n&quot;);
-
-    # Here we twist our hash around, from being
-    #   author =&gt; time =&gt; message =&gt; filelist
-    # in %$authorhash to
-    #   time =&gt; author =&gt; message =&gt; filelist
-    # in %changelog.
-    #
-    # This is also where we merge entries.  The algorithm proceeds
-    # through the timeline of the changelog with a sliding window of
-    # $Max_Checkin_Duration seconds; within that window, entries that
-    # have the same log message are merged.
-    #
-    # (To save space, we zap %$authorhash after we've copied
-    # everything out of it.)
-
-    my %changelog;
-    while (my ($author,$timehash) = each %$authorhash)
-    {
-      my $lasttime;
-      my %stamptime;
-      foreach my $time (sort {$main::a &lt;=&gt; $main::b} (keys %$timehash))
-      {
-        my $msghash = $timehash-&gt;{$time};
-        while (my ($msg,$qunklist) = each %$msghash)
-        {
- 	  my $stamptime = $stamptime{$msg};
-          if ((defined $stamptime)
-              and (($time - $stamptime) &lt; $Max_Checkin_Duration)
-              and (defined $changelog{$stamptime}{$author}{$msg}))
-          {
- 	    push(@{$changelog{$stamptime}{$author}{$msg}}, @$qunklist);
-          }
-          else {
-            $changelog{$time}{$author}{$msg} = $qunklist;
-            $stamptime{$msg} = $time;
-          }
-        }
-      }
-    }
-    undef (%$authorhash);
-
-    ### Now we can write out the ChangeLog!
-
-    my ($logfile_here, $logfile_bak, $tmpfile);
-
-    if (! $Output_To_Stdout) {
-      $logfile_here =  $dir . $Log_File_Name;
-      $logfile_here =~ s/^\.\/\//\//;   # fix any leading &quot;.//&quot; problem
-      $tmpfile      = &quot;${logfile_here}.cvs2cl$$.tmp&quot;;
-      $logfile_bak  = &quot;${logfile_here}.bak&quot;;
-
-      open (LOG_OUT, &quot;&gt;$tmpfile&quot;) or die &quot;Unable to open \&quot;$tmpfile\&quot;&quot;;
-    }
-    else {
-      open (LOG_OUT, &quot;&gt;-&quot;) or die &quot;Unable to open stdout for writing&quot;;
-    }
-
-    print LOG_OUT $ChangeLog_Header;
-
-    if ($XML_Output) {
-      my $encoding    = 
-        length $XML_Encoding ? qq'encoding=&quot;$XML_Encoding&quot;' : '';
-      my $version     = 'version=&quot;1.0&quot;';
-      my $declaration = 
-        sprintf '&lt;?xml %s?&gt;', join ' ', grep length, $version, $encoding;
-      my $root        =
-        '&lt;changelog xmlns=&quot;<A HREF="http://www.red-bean.com/xmlns/cvs2cl/">http://www.red-bean.com/xmlns/cvs2cl/</A>&quot;&gt;';
-      print LOG_OUT &quot;$declaration\n\n$root\n\n&quot;;
-    }
-
-    foreach my $time (sort {$main::b &lt;=&gt; $main::a} (keys %changelog))
-    {
-      next if ($Delta_Mode &amp;&amp;
-	       (($time &lt;= $Delta_StartTime) ||
-		($time &gt; $Delta_EndTime &amp;&amp; $Delta_EndTime)));
-
-      # Set up the date/author line.
-      # kff todo: do some more XML munging here, on the header
-      # part of the entry:
-      my ($ignore,$min,$hour,$mday,$mon,$year,$wday)
-          = $UTC_Times ? gmtime($time) : localtime($time);
-
-      # XML output includes everything else, we might as well make
-      # it always include Day Of Week too, for consistency.
-      if ($Show_Day_Of_Week or $XML_Output) {
-        $wday = (&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
-                 &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;)[$wday];
-        $wday = ($XML_Output) ? &quot;&lt;weekday&gt;${wday}&lt;/weekday&gt;\n&quot; : &quot; $wday&quot;;
-      }
-      else {
-        $wday = &quot;&quot;;
-      }
-
-      my $authorhash = $changelog{$time};
-      if ($Show_Tag_Dates) {
-        my %tags;
-        while (my ($author,$mesghash) = each %$authorhash) {
-          while (my ($msg,$qunk) = each %$mesghash) {
-            foreach my $qunkref2 (@$qunk) {
-	      if (defined ($$qunkref2{'tags'})) {
-                foreach my $tag (@{$$qunkref2{'tags'}}) {
-                  $tags{$tag} = 1;
-                }
-              }
-	    }
-          }
-        }
-        foreach my $tag (keys %tags) {
-          if (!defined $tag_date_printed{$tag}) {
-            $tag_date_printed{$tag} = $time;
-            if ($XML_Output) {
-              # NOT YET DONE
-            }
-            else {
-              printf LOG_OUT (&quot;%4u-%02u-%02u${wday} %02u:%02u  tag %s\n\n&quot;,
-                              $year+1900, $mon+1, $mday, $hour, $min, $tag);
-            }
-          }
-        }
-      }
-      while (my ($author,$mesghash) = each %$authorhash)
-      {
-        # If XML, escape in outer loop to avoid compound quoting:
-        if ($XML_Output) {
-          $author = &amp;xml_escape ($author);
-        }
-
-      FOOBIE:
-        while (my ($msg,$qunklist) = each %$mesghash)
-        {
-          ## MJP: 19.xii.01 : Exclude @ignore_tags
-          for my $ignore_tag (@ignore_tags) {
-            next FOOBIE
-              if grep $_ eq $ignore_tag, map(@{$_-&gt;{tags}},
-                                             grep(defined $_-&gt;{tags},
-                                                  @$qunklist));
-          }
-          ## MJP: 19.xii.01 : End exclude @ignore_tags
-
-          my $files               = &amp;pretty_file_list ($qunklist);
-          my $header_line;          # date and author
-          my $body;                 # see below
-          my $wholething;           # $header_line + $body
-
-          if ($XML_Output) {
-            $header_line =
-                sprintf (&quot;&lt;date&gt;%4u-%02u-%02u&lt;/date&gt;\n&quot;
-                         . &quot;${wday}&quot;
-                         . &quot;&lt;time&gt;%02u:%02u&lt;/time&gt;\n&quot;
-                         . &quot;&lt;author&gt;%s&lt;/author&gt;\n&quot;,
-                         $year+1900, $mon+1, $mday, $hour, $min, $author);
-          }
-          else {
-            $header_line =
-                sprintf (&quot;%4u-%02u-%02u${wday} %02u:%02u  %s\n\n&quot;,
-                         $year+1900, $mon+1, $mday, $hour, $min, $author);
-          }
-
-          $Text::Wrap::huge = 'overflow'
-            if $Text::Wrap::VERSION &gt;= 2001.0130;
-          # Reshape the body according to user preferences.
-          if ($XML_Output)
-          {
-            $msg = &amp;preprocess_msg_text ($msg);
-            $body = $files . $msg;
-          }
-          elsif ($No_Wrap)
-          {
-            $msg = &amp;preprocess_msg_text ($msg);
-            $files = wrap (&quot;\t&quot;, &quot;	&quot;, &quot;$files&quot;);
-            $msg =~ s/\n(.*)/\n\t$1/g;
-            unless ($After_Header eq &quot; &quot;) {
-              $msg =~ s/^(.*)/\t$1/g;
-            }
-            $body = $files . $After_Header . $msg;
-          }
-          else  # do wrapping, either FSF-style or regular
-          {
-            if ($FSF_Style)
-            {
-              $files = wrap (&quot;\t&quot;, &quot;        &quot;, &quot;$files&quot;);
-
-              my $files_last_line_len = 0;
-              if ($After_Header eq &quot; &quot;)
-              {
-                $files_last_line_len = &amp;last_line_len ($files);
-                $files_last_line_len += 1;  # for $After_Header
-              }
-
-              $msg = &amp;wrap_log_entry
-                  ($msg, &quot;\t&quot;, 69 - $files_last_line_len, 69);
-              $body = $files . $After_Header . $msg;
-            }
-            else  # not FSF-style
-            {
-              $msg = &amp;preprocess_msg_text ($msg);
-              $body = $files . $After_Header . $msg;
-              $body = wrap (&quot;\t&quot;, &quot;        &quot;, &quot;$body&quot;);
-            }
-          }
-
-          $wholething = $header_line . $body;
-
-          if ($XML_Output) {
-            $wholething = &quot;&lt;entry&gt;\n${wholething}&lt;/entry&gt;\n&quot;;
-          }
-
-          # One last check: make sure it passes the regexp test, if the
-          # user asked for that.  We have to do it here, so that the
-          # test can match against information in the header as well
-          # as in the text of the log message.
-
-          # How annoying to duplicate so much code just because I
-          # can't figure out a way to evaluate scalars on the trailing
-          # operator portion of a regular expression.  Grrr.
-          if ($Case_Insensitive) {
-            unless ($Regexp_Gate &amp;&amp; ($wholething !~ /$Regexp_Gate/oi)) {
-              print LOG_OUT &quot;${wholething}\n&quot;;
-            }
-          }
-          else {
-            unless ($Regexp_Gate &amp;&amp; ($wholething !~ /$Regexp_Gate/o)) {
-              print LOG_OUT &quot;${wholething}\n&quot;;
-            }
-          }
-        }
-      }
-    }
-
-    if ($XML_Output) {
-      print LOG_OUT &quot;&lt;/changelog&gt;\n&quot;;
-    }
-
-    close (LOG_OUT);
-
-    if (! $Output_To_Stdout)
-    {
-      # If accumulating, append old data to new before renaming.  But
-      # don't append the most recent entry, since it's already in the
-      # new log due to CVS's idiosyncratic interpretation of &quot;log -d&quot;.
-      if ($Cumulative &amp;&amp; -f $logfile_here)
-      {
-        open (NEW_LOG, &quot;&gt;&gt;$tmpfile&quot;)
-            or die &quot;trouble appending to $tmpfile ($!)&quot;;
-
-        open (OLD_LOG, &quot;&lt;$logfile_here&quot;)
-            or die &quot;trouble reading from $logfile_here ($!)&quot;;
-
-        my $started_first_entry = 0;
-        my $passed_first_entry = 0;
-        while (&lt;OLD_LOG&gt;)
-        {
-          if (! $passed_first_entry)
-          {
-            if ((! $started_first_entry)
-                &amp;&amp; /^(\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d)/) {
-              $started_first_entry = 1;
-            }
-            elsif (/^(\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d)/) {
-              $passed_first_entry = 1;
-              print NEW_LOG $_;
-            }
-          }
-          else {
-            print NEW_LOG $_;
-          }
-        }
-
-        close (NEW_LOG);
-        close (OLD_LOG);
-      }
-
-      if (-f $logfile_here) {
-        rename ($logfile_here, $logfile_bak);
-      }
-      rename ($tmpfile, $logfile_here);
-    }
-  }
-}
-
-
-sub parse_date_and_author ()
-{
-  # Parses the date/time and author out of a line like:
-  #
-  # date: 1999/02/19 23:29:05;  author: apharris;  state: Exp;
-
-  my $line = shift;
-
-  my ($year, $mon, $mday, $hours, $min, $secs, $author) = $line =~
-      m#(\d+)/(\d+)/(\d+)\s+(\d+):(\d+):(\d+);\s+author:\s+([^;]+);#
-          or  die &quot;Couldn't parse date ``$line''&quot;;
-  die &quot;Bad date or Y2K issues&quot; unless ($year &gt; 1969 and $year &lt; 2258);
-  # Kinda arbitrary, but useful as a sanity check
-  my $time = timegm($secs,$min,$hours,$mday,$mon-1,$year-1900);
-
-  return ($time, $author);
-}
-
-
-# Here we take a bunch of qunks and convert them into printed
-# summary that will include all the information the user asked for.
-sub pretty_file_list ()
-{
-  if ($Hide_Filenames and (! $XML_Output)) {
-    return &quot;&quot;;
-  }
-
-  my $qunksref = shift;
-  my @qunkrefs = @$qunksref;
-  my @filenames;
-  my $beauty = &quot;&quot;;          # The accumulating header string for this entry.
-  my %non_unanimous_tags;   # Tags found in a proper subset of qunks
-  my %unanimous_tags;       # Tags found in all qunks
-  my %all_branches;         # Branches found in any qunk
-  my $common_dir = undef;   # Dir prefix common to all files (&quot;&quot; if none)
-  my $fbegun = 0;           # Did we begin printing filenames yet?
-
-  # First, loop over the qunks gathering all the tag/branch names.
-  # We'll put them all in non_unanimous_tags, and take out the
-  # unanimous ones later.
- QUNKREF:
-  foreach my $qunkref (@qunkrefs)
-  {
-    ## MJP: 19.xii.01 : Exclude @ignore_tags
-    for my $ignore_tag (@ignore_tags) {
-      next QUNKREF
-        if grep $_ eq $ignore_tag, @{$$qunkref{'tags'}};
-    }
-    ## MJP: 19.xii.01 : End exclude @ignore_tags
-
-    # Keep track of whether all the files in this commit were in the
-    # same directory, and memorize it if so.  We can make the output a
-    # little more compact by mentioning the directory only once.
-    if ((scalar (@qunkrefs)) &gt; 1)
-    {
-      if (! (defined ($common_dir)))
-      {
-        my ($base, $dir);
-        ($base, $dir, undef) = fileparse ($$qunkref{'filename'});
-
-        if ((! (defined ($dir)))  # this first case is sheer paranoia
-            or ($dir eq &quot;&quot;)
-            or ($dir eq &quot;./&quot;)
-            or ($dir eq &quot;.\\&quot;))
-        {
-          $common_dir = &quot;&quot;;
-        }
-        else
-        {
-          $common_dir = $dir;
-        }
-      }
-      elsif ($common_dir ne &quot;&quot;)
-      {
-        # Already have a common dir prefix, so how much of it can we preserve?
-        $common_dir = &amp;common_path_prefix ($$qunkref{'filename'}, $common_dir);
-      }
-    }
-    else  # only one file in this entry anyway, so common dir not an issue
-    {
-      $common_dir = &quot;&quot;;
-    }
-
-    if (defined ($$qunkref{'branch'})) {
-      $all_branches{$$qunkref{'branch'}} = 1;
-    }
-    if (defined ($$qunkref{'tags'})) {
-      foreach my $tag (@{$$qunkref{'tags'}}) {
-        $non_unanimous_tags{$tag} = 1;
-      }
-    }
-  }
-
-  # Any tag held by all qunks will be printed specially... but only if
-  # there are multiple qunks in the first place!
-  if ((scalar (@qunkrefs)) &gt; 1) {
-    foreach my $tag (keys (%non_unanimous_tags)) {
-      my $everyone_has_this_tag = 1;
-      foreach my $qunkref (@qunkrefs) {
-        if ((! (defined ($$qunkref{'tags'})))
-            or (! (grep ($_ eq $tag, @{$$qunkref{'tags'}})))) {
-          $everyone_has_this_tag = 0;
-        }
-      }
-      if ($everyone_has_this_tag) {
-        $unanimous_tags{$tag} = 1;
-        delete $non_unanimous_tags{$tag};
-      }
-    }
-  }
-
-  if ($XML_Output)
-  {
-    # If outputting XML, then our task is pretty simple, because we
-    # don't have to detect common dir, common tags, branch prefixing,
-    # etc.  We just output exactly what we have, and don't worry about
-    # redundancy or readability.
-
-    foreach my $qunkref (@qunkrefs)
-    {
-      my $filename    = $$qunkref{'filename'};
-      my $revision    = $$qunkref{'revision'};
-      my $tags        = $$qunkref{'tags'};
-      my $branch      = $$qunkref{'branch'};
-      my $branchroots = $$qunkref{'branchroots'};
-
-      $filename = &amp;xml_escape ($filename);   # probably paranoia
-      $revision = &amp;xml_escape ($revision);   # definitely paranoia
-
-      $beauty .= &quot;&lt;file&gt;\n&quot;;
-      $beauty .= &quot;&lt;name&gt;${filename}&lt;/name&gt;\n&quot;;
-      $beauty .= &quot;&lt;revision&gt;${revision}&lt;/revision&gt;\n&quot;;
-      if ($branch) {
-        $branch   = &amp;xml_escape ($branch);     # more paranoia
-        $beauty .= &quot;&lt;branch&gt;${branch}&lt;/branch&gt;\n&quot;;
-      }
-      foreach my $tag (@$tags) {
-        $tag = &amp;xml_escape ($tag);  # by now you're used to the paranoia
-        $beauty .= &quot;&lt;tag&gt;${tag}&lt;/tag&gt;\n&quot;;
-      }
-      foreach my $root (@$branchroots) {
-        $root = &amp;xml_escape ($root);  # which is good, because it will continue
-        $beauty .= &quot;&lt;branchroot&gt;${root}&lt;/branchroot&gt;\n&quot;;
-      }
-      $beauty .= &quot;&lt;/file&gt;\n&quot;;
-    }
-
-    # Theoretically, we could go home now.  But as long as we're here,
-    # let's print out the common_dir and utags, as a convenience to
-    # the receiver (after all, earlier code calculated that stuff
-    # anyway, so we might as well take advantage of it).
-
-    if ((scalar (keys (%unanimous_tags))) &gt; 1) {
-      foreach my $utag ((keys (%unanimous_tags))) {
-        $utag = &amp;xml_escape ($utag);   # the usual paranoia
-        $beauty .= &quot;&lt;utag&gt;${utag}&lt;/utag&gt;\n&quot;;
-      }
-    }
-    if ($common_dir) {
-      $common_dir = &amp;xml_escape ($common_dir);
-      $beauty .= &quot;&lt;commondir&gt;${common_dir}&lt;/commondir&gt;\n&quot;;
-    }
-
-    # That's enough for XML, time to go home:
-    return $beauty;
-  }
-
-  # Else not XML output, so complexly compactify for chordate
-  # consumption.  At this point we have enough global information
-  # about all the qunks to organize them non-redundantly for output.
-
-  if ($common_dir) {
-    # Note that $common_dir still has its trailing slash
-    $beauty .= &quot;$common_dir: &quot;;
-  }
-
-  if ($Show_Branches)
-  {
-    # For trailing revision numbers.
-    my @brevisions;
-
-    foreach my $branch (keys (%all_branches))
-    {
-      foreach my $qunkref (@qunkrefs)
-      {
-        if ((defined ($$qunkref{'branch'}))
-            and ($$qunkref{'branch'} eq $branch))
-        {
-          if ($fbegun) {
-            # kff todo: comma-delimited in XML too?  Sure.
-            $beauty .= &quot;, &quot;;
-          }
-          else {
-            $fbegun = 1;
-          }
-          my $fname = substr ($$qunkref{'filename'}, length ($common_dir));
-          $beauty .= $fname;
-          $$qunkref{'printed'} = 1;  # Just setting a mark bit, basically
-
-          if ($Show_Tags &amp;&amp; (defined @{$$qunkref{'tags'}})) {
-            my @tags = grep ($non_unanimous_tags{$_}, @{$$qunkref{'tags'}});
-
-            if (@tags) {
-              $beauty .= &quot; (tags: &quot;;
-              $beauty .= join (', ', @tags);
-              $beauty .= &quot;)&quot;;
-            }
-          }
-
-          if ($Show_Revisions) {
-            # Collect the revision numbers' last components, but don't
-            # print them -- they'll get printed with the branch name
-            # later.
-            $$qunkref{'revision'} =~ /.+\.([\d]+)$/;
-            push (@brevisions, $1);
-
-            # todo: we're still collecting branch roots, but we're not
-            # showing them anywhere.  If we do show them, it would be
-            # nifty to just call them revision &quot;0&quot; on a the branch.
-            # Yeah, that's the ticket.
-          }
-        }
-      }
-      $beauty .= &quot; ($branch&quot;;
-      if (@brevisions) {
-        if ((scalar (@brevisions)) &gt; 1) {
-          $beauty .= &quot;.[&quot;;
-          $beauty .= (join (',', @brevisions));
-          $beauty .= &quot;]&quot;;
-        }
-        else {
-          $beauty .= &quot;.[$brevisions[0]]&quot;;
-        }
-      }
-      $beauty .= &quot;)&quot;;
-    }
-  }
-
-  # Okay; any qunks that were done according to branch are taken care
-  # of, and marked as printed.  Now print everyone else.
-
-  foreach my $qunkref (@qunkrefs)
-  {
-    next if (defined ($$qunkref{'printed'}));   # skip if already printed
-
-    if ($fbegun) {
-      $beauty .= &quot;, &quot;;
-    }
-    else {
-      $fbegun = 1;
-    }
-    $beauty .= substr ($$qunkref{'filename'}, length ($common_dir));
-    # todo: Shlomo's change was this:
-    # $beauty .= substr ($$qunkref{'filename'},
-    #              (($common_dir eq &quot;./&quot;) ? &quot;&quot; : length ($common_dir)));
-    $$qunkref{'printed'} = 1;  # Set a mark bit.
-
-    if ($Show_Revisions || $Show_Tags)
-    {
-      my $started_addendum = 0;
-
-      if ($Show_Revisions) {
-        $started_addendum = 1;
-        $beauty .= &quot; (&quot;;
-        $beauty .= &quot;$$qunkref{'revision'}&quot;;
-      }
-      if ($Show_Tags &amp;&amp; (defined $$qunkref{'tags'})) {
-        my @tags = grep ($non_unanimous_tags{$_}, @{$$qunkref{'tags'}});
-        if ((scalar (@tags)) &gt; 0) {
-          if ($started_addendum) {
-            $beauty .= &quot;, &quot;;
-          }
-          else {
-            $beauty .= &quot; (tags: &quot;;
-          }
-          $beauty .= join (', ', @tags);
-          $started_addendum = 1;
-        }
-      }
-      if ($started_addendum) {
-        $beauty .= &quot;)&quot;;
-      }
-    }
-  }
-
-  # Unanimous tags always come last.
-  if ($Show_Tags &amp;&amp; %unanimous_tags)
-  {
-    $beauty .= &quot; (utags: &quot;;
-    $beauty .= join (', ', sort keys (%unanimous_tags));
-    $beauty .= &quot;)&quot;;
-  }
-
-  # todo: still have to take care of branch_roots?
-
-  $beauty = &quot;* $beauty:&quot;;
-
-  return $beauty;
-}
-
-
-sub common_path_prefix ()
-{
-  my $path1 = shift;
-  my $path2 = shift;
-
-  my ($dir1, $dir2);
-  (undef, $dir1, undef) = fileparse ($path1);
-  (undef, $dir2, undef) = fileparse ($path2);
-
-  # Transmogrify Windows filenames to look like Unix.
-  # (It is far more likely that someone is running cvs2cl.pl under
-  # Windows than that they would genuinely have backslashes in their
-  # filenames.)
-  $dir1 =~ tr#\\#/#;
-  $dir2 =~ tr#\\#/#;
-
-  my $accum1 = &quot;&quot;;
-  my $accum2 = &quot;&quot;;
-  my $last_common_prefix = &quot;&quot;;
-
-  while ($accum1 eq $accum2)
-  {
-    $last_common_prefix = $accum1;
-    last if ($accum1 eq $dir1);
-    my ($tmp1) = split (/\//, (substr ($dir1, length ($accum1))));
-    my ($tmp2) = split (/\//, (substr ($dir2, length ($accum2))));
-    $accum1 .= &quot;$tmp1/&quot; if (defined $tmp1 and $tmp1 ne '');
-    $accum2 .= &quot;$tmp2/&quot; if (defined $tmp2 and $tmp2 ne '');
-  }
-
-  return $last_common_prefix;
-}
-
-
-sub preprocess_msg_text ()
-{
-  my $text = shift;
-
-  # Strip out carriage returns (as they probably result from DOSsy editors).
-  $text =~ s/\r\n/\n/g;
-
-  # If it *looks* like two newlines, make it *be* two newlines:
-  $text =~ s/\n\s*\n/\n\n/g;
-
-  if ($XML_Output)
-  {
-    $text = &amp;xml_escape ($text);
-    $text = &quot;&lt;msg&gt;${text}&lt;/msg&gt;\n&quot;;
-  }
-  elsif (! $No_Wrap)
-  {
-    # Strip off lone newlines, but only for lines that don't begin with
-    # whitespace or a mail-quoting character, since we want to preserve
-    # that kind of formatting.  Also don't strip newlines that follow a
-    # period; we handle those specially next.  And don't strip
-    # newlines that precede an open paren.
-    1 while ($text =~ s/(^|\n)([^&gt;\s].*[^.\n])\n([^&gt;\n])/$1$2 $3/g);
-
-    # If a newline follows a period, make sure that when we bring up the
-    # bottom sentence, it begins with two spaces.
-    1 while ($text =~ s/(^|\n)([^&gt;\s].*)\n([^&gt;\n])/$1$2  $3/g);
-  }
-
-  return $text;
-}
-
-
-sub last_line_len ()
-{
-  my $files_list = shift;
-  my @lines = split (/\n/, $files_list);
-  my $last_line = pop (@lines);
-  return length ($last_line);
-}
-
-
-# A custom wrap function, sensitive to some common constructs used in
-# log entries.
-sub wrap_log_entry ()
-{
-  my $text = shift;                  # The text to wrap.
-  my $left_pad_str = shift;          # String to pad with on the left.
-
-  # These do NOT take left_pad_str into account:
-  my $length_remaining = shift;      # Amount left on current line.
-  my $max_line_length  = shift;      # Amount left for a blank line.
-
-  my $wrapped_text = &quot;&quot;;             # The accumulating wrapped entry.
-  my $user_indent = &quot;&quot;;              # Inherited user_indent from prev line.
-
-  my $first_time = 1;                # First iteration of the loop?
-  my $suppress_line_start_match = 0; # Set to disable line start checks.
-
-  my @lines = split (/\n/, $text);
-  while (@lines)   # Don't use `foreach' here, it won't work.
-  {
-    my $this_line = shift (@lines);
-    chomp $this_line;
-
-    if ($this_line =~ /^(\s+)/) {
-      $user_indent = $1;
-    }
-    else {
-      $user_indent = &quot;&quot;;
-    }
-
-    # If it matches any of the line-start regexps, print a newline now...
-    if ($suppress_line_start_match)
-    {
-      $suppress_line_start_match = 0;
-    }
-    elsif (($this_line =~ /^(\s*)\*\s+[a-zA-Z0-9]/)
-           || ($this_line =~ /^(\s*)\* [a-zA-Z0-9_\.\/\+-]+/)
-           || ($this_line =~ /^(\s*)\([a-zA-Z0-9_\.\/\+-]+(\)|,\s*)/)
-           || ($this_line =~ /^(\s+)(\S+)/)
-           || ($this_line =~ /^(\s*)- +/)
-           || ($this_line =~ /^()\s*$/)
-           || ($this_line =~ /^(\s*)\*\) +/)
-           || ($this_line =~ /^(\s*)[a-zA-Z0-9](\)|\.|\:) +/))
-    {
-      # Make a line break immediately, unless header separator is set
-      # and this line is the first line in the entry, in which case
-      # we're getting the blank line for free already and shouldn't
-      # add an extra one.
-      unless (($After_Header ne &quot; &quot;) and ($first_time))
-      {
-        if ($this_line =~ /^()\s*$/) {
-          $suppress_line_start_match = 1;
-          $wrapped_text .= &quot;\n${left_pad_str}&quot;;
-        }
-
-        $wrapped_text .= &quot;\n${left_pad_str}&quot;;
-      }
-
-      $length_remaining = $max_line_length - (length ($user_indent));
-    }
-
-    # Now that any user_indent has been preserved, strip off leading
-    # whitespace, so up-folding has no ugly side-effects.
-    $this_line =~ s/^\s*//;
-
-    # Accumulate the line, and adjust parameters for next line.
-    my $this_len = length ($this_line);
-    if ($this_len == 0)
-    {
-      # Blank lines should cancel any user_indent level.
-      $user_indent = &quot;&quot;;
-      $length_remaining = $max_line_length;
-    }
-    elsif ($this_len &gt;= $length_remaining) # Line too long, try breaking it.
-    {
-      # Walk backwards from the end.  At first acceptable spot, break
-      # a new line.
-      my $idx = $length_remaining - 1;
-      if ($idx &lt; 0) { $idx = 0 };
-      while ($idx &gt; 0)
-      {
-        if (substr ($this_line, $idx, 1) =~ /\s/)
-        {
-          my $line_now = substr ($this_line, 0, $idx);
-          my $next_line = substr ($this_line, $idx);
-          $this_line = $line_now;
-
-          # Clean whitespace off the end.
-          chomp $this_line;
-
-          # The current line is ready to be printed.
-          $this_line .= &quot;\n${left_pad_str}&quot;;
-
-          # Make sure the next line is allowed full room.
-          $length_remaining = $max_line_length - (length ($user_indent));
-
-          # Strip next_line, but then preserve any user_indent.
-          $next_line =~ s/^\s*//;
-
-          # Sneak a peek at the user_indent of the upcoming line, so
-          # $next_line (which will now precede it) can inherit that
-          # indent level.  Otherwise, use whatever user_indent level
-          # we currently have, which might be none.
-          my $next_next_line = shift (@lines);
-          if ((defined ($next_next_line)) &amp;&amp; ($next_next_line =~ /^(\s+)/)) {
-            $next_line = $1 . $next_line if (defined ($1));
-            # $length_remaining = $max_line_length - (length ($1));
-            $next_next_line =~ s/^\s*//;
-          }
-          else {
-            $next_line = $user_indent . $next_line;
-          }
-          if (defined ($next_next_line)) {
-            unshift (@lines, $next_next_line);
-          }
-          unshift (@lines, $next_line);
-
-          # Our new next line might, coincidentally, begin with one of
-          # the line-start regexps, so we temporarily turn off
-          # sensitivity to that until we're past the line.
-          $suppress_line_start_match = 1;
-
-          last;
-        }
-        else
-        {
-          $idx--;
-        }
-      }
-
-      if ($idx == 0)
-      {
-        # We bottomed out because the line is longer than the
-        # available space.  But that could be because the space is
-        # small, or because the line is longer than even the maximum
-        # possible space.  Handle both cases below.
-
-        if ($length_remaining == ($max_line_length - (length ($user_indent))))
-        {
-          # The line is simply too long -- there is no hope of ever
-          # breaking it nicely, so just insert it verbatim, with
-          # appropriate padding.
-          $this_line = &quot;\n${left_pad_str}${this_line}&quot;;
-        }
-        else
-        {
-          # Can't break it here, but may be able to on the next round...
-          unshift (@lines, $this_line);
-          $length_remaining = $max_line_length - (length ($user_indent));
-          $this_line = &quot;\n${left_pad_str}&quot;;
-        }
-      }
-    }
-    else  # $this_len &lt; $length_remaining, so tack on what we can.
-    {
-      # Leave a note for the next iteration.
-      $length_remaining = $length_remaining - $this_len;
-
-      if ($this_line =~ /\.$/)
-      {
-        $this_line .= &quot;  &quot;;
-        $length_remaining -= 2;
-      }
-      else  # not a sentence end
-      {
-        $this_line .= &quot; &quot;;
-        $length_remaining -= 1;
-      }
-    }
-
-    # Unconditionally indicate that loop has run at least once.
-    $first_time = 0;
-
-    $wrapped_text .= &quot;${user_indent}${this_line}&quot;;
-  }
-
-  # One last bit of padding.
-  $wrapped_text .= &quot;\n&quot;;
-
-  return $wrapped_text;
-}
-
-
-sub xml_escape ()
-{
-  my $txt = shift;
-  $txt =~ s/&amp;/&amp;/g;
-  $txt =~ s/&lt;/&lt;/g;
-  $txt =~ s/&gt;/&gt;/g;
-  return $txt;
-}
-
-
-sub maybe_read_user_map_file ()
-{
-  my %expansions;
-
-  if ($User_Map_File)
-  {
-    open (MAPFILE, &quot;&lt;$User_Map_File&quot;)
-        or die (&quot;Unable to open $User_Map_File ($!)&quot;);
-
-    while (&lt;MAPFILE&gt;)
-    {
-      next if /^\s*#/;  # Skip comment lines.
-      next if not /:/;  # Skip lines without colons.
-
-      # It is now safe to split on ':'.
-      my ($username, $expansion) = split ':';
-      chomp $expansion;
-      $expansion =~ s/^'(.*)'$/$1/;
-      $expansion =~ s/^&quot;(.*)&quot;$/$1/;
-
-      # If it looks like the expansion has a real name already, then
-      # we toss the username we got from CVS log.  Otherwise, keep
-      # it to use in combination with the email address.
-
-      if ($expansion =~ /^\s*&lt;{0,1}\<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">S+ at .</A>*/) {
-        # Also, add angle brackets if none present
-        if (! ($expansion =~ /&lt;\S+@\S+&gt;/)) {
-          $expansions{$username} = &quot;$username &lt;$expansion&gt;&quot;;
-        }
-        else {
-          $expansions{$username} = &quot;$username $expansion&quot;;
-        }
-      }
-      else {
-        $expansions{$username} = $expansion;
-      }
-    }
-
-    close (MAPFILE);
-  }
-
-  return %expansions;
-}
-
-
-sub parse_options ()
-{
-  # Check this internally before setting the global variable.
-  my $output_file;
-
-  # If this gets set, we encountered unknown options and will exit at
-  # the end of this subroutine.
-  my $exit_with_admonishment = 0;
-
-  while (my $arg = shift (@ARGV))
-  {
-    if ($arg =~ /^-h$|^-help$|^--help$|^--usage$|^-?$/) {
-      $Print_Usage = 1;
-    }
-    elsif ($arg =~ /^--delta$/) {
-      my $narg = shift(@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      if ($narg =~ /^([A-Za-z][A-Za-z0-9_\-]*):([A-Za-z][A-Za-z0-9_\-]*)$/) {
-	$Delta_From = $1;
-	$Delta_To = $2;
-	$Delta_Mode = 1;
-      } else {
-	die &quot;--delta FROM_TAG:TO_TAG is what you meant to say.\n&quot;;
-      }
-    }
-    elsif ($arg =~ /^--debug$/) {        # unadvertised option, heh
-      $Debug = 1;
-    }
-    elsif ($arg =~ /^--version$/) {
-      $Print_Version = 1;
-    }
-    elsif ($arg =~ /^-g$|^--global-opts$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      # Don't assume CVS is called &quot;cvs&quot; on the user's system:
-      $Log_Source_Command =~ s/(^\S*)/$1 $narg/;
-    }
-    elsif ($arg =~ /^-l$|^--log-opts$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      $Log_Source_Command .= &quot; $narg&quot;;
-    }
-    elsif ($arg =~ /^-f$|^--file$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      $output_file = $narg;
-    }
-    elsif ($arg =~ /^--accum$/) {
-      $Cumulative = 1;
-    }
-    elsif ($arg =~ /^--fsf$/) {
-      $FSF_Style = 1;
-    }
-    elsif ($arg =~ /^-U$|^--usermap$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      $User_Map_File = $narg;
-    }
-    elsif ($arg =~ /^-W$|^--window$/) {
-      defined(my $narg = shift (@ARGV)) || die &quot;$arg needs argument.\n&quot;;
-      $Max_Checkin_Duration = $narg;
-    }
-    elsif ($arg =~ /^-I$|^--ignore$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      push (@Ignore_Files, $narg);
-    }
-    elsif ($arg =~ /^-C$|^--case-insensitive$/) {
-      $Case_Insensitive = 1;
-    }
-    elsif ($arg =~ /^-R$|^--regexp$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      $Regexp_Gate = $narg;
-    }
-    elsif ($arg =~ /^--stdout$/) {
-      $Output_To_Stdout = 1;
-    }
-    elsif ($arg =~ /^--version$/) {
-      $Print_Version = 1;
-    }
-    elsif ($arg =~ /^-d$|^--distributed$/) {
-      $Distributed = 1;
-    }
-    elsif ($arg =~ /^-P$|^--prune$/) {
-      $Prune_Empty_Msgs = 1;
-    }
-    elsif ($arg =~ /^-S$|^--separate-header$/) {
-      $After_Header = &quot;\n\n&quot;;
-    }
-    elsif ($arg =~ /^--no-wrap$/) {
-      $No_Wrap = 1;
-    }
-    elsif ($arg =~ /^--gmt$|^--utc$/) {
-      $UTC_Times = 1;
-    }
-    elsif ($arg =~ /^-w$|^--day-of-week$/) {
-      $Show_Day_Of_Week = 1;
-    }
-    elsif ($arg =~ /^-r$|^--revisions$/) {
-      $Show_Revisions = 1;
-    }
-    elsif ($arg =~ /^-t$|^--tags$/) {
-      $Show_Tags = 1;
-    }
-    elsif ($arg =~ /^-T$|^--tagdates$/) {
-      $Show_Tag_Dates = 1;
-    }
-    elsif ($arg =~ /^-b$|^--branches$/) {
-      $Show_Branches = 1;
-    }
-    elsif ($arg =~ /^-F$|^--follow$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      push (@Follow_Branches, $narg);
-    }
-    elsif ($arg =~ /^--stdin$/) {
-      $Input_From_Stdin = 1;
-    }
-    elsif ($arg =~ /^--header$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      $ChangeLog_Header = &amp;slurp_file ($narg);
-      if (! defined ($ChangeLog_Header)) {
-        $ChangeLog_Header = &quot;&quot;;
-      }
-    }
-    elsif ($arg =~ /^--xml-encoding$/) {
-      my $narg = shift (@ARGV) || die &quot;$arg needs argument.\n&quot;;
-      $XML_Encoding = $narg ;
-    }
-    elsif ($arg =~ /^--xml$/) {
-      $XML_Output = 1;
-    }
-    elsif ($arg =~ /^--hide-filenames$/) {
-      $Hide_Filenames = 1;
-      $After_Header = &quot;&quot;;
-    }
-    elsif ($arg =~ /^--ignore-tag$/ ) {
-      die &quot;$arg needs argument.\n&quot;
-        unless @ARGV;
-      push @ignore_tags, shift @ARGV;
-    }
-    else {
-      # Just add a filename as argument to the log command
-      $Log_Source_Command .= &quot; '$arg'&quot;;
-    }
-  }
-
-  ## Check for contradictions...
-
-  if ($Output_To_Stdout &amp;&amp; $Distributed) {
-    print STDERR &quot;cannot pass both --stdout and --distributed\n&quot;;
-    $exit_with_admonishment = 1;
-  }
-
-  if ($Output_To_Stdout &amp;&amp; $output_file) {
-    print STDERR &quot;cannot pass both --stdout and --file\n&quot;;
-    $exit_with_admonishment = 1;
-  }
-
-  if ($XML_Output &amp;&amp; $Cumulative) {
-    print STDERR &quot;cannot pass both --xml and --accum\n&quot;;
-    $exit_with_admonishment = 1;
-  }
-
-  # Or if any other error message has already been printed out, we
-  # just leave now:
-  if ($exit_with_admonishment) {
-    &amp;usage ();
-    exit (1);
-  }
-  elsif ($Print_Usage) {
-    &amp;usage ();
-    exit (0);
-  }
-  elsif ($Print_Version) {
-    &amp;version ();
-    exit (0);
-  }
-
-  ## Else no problems, so proceed.
-
-  if ($output_file) {
-    $Log_File_Name = $output_file;
-  }
-}
-
-
-sub slurp_file ()
-{
-  my $filename = shift || die (&quot;no filename passed to slurp_file()&quot;);
-  my $retstr;
-
-  open (SLURPEE, &quot;&lt;${filename}&quot;) or die (&quot;unable to open $filename ($!)&quot;);
-  my $saved_sep = $/;
-  undef $/;
-  $retstr = &lt;SLURPEE&gt;;
-  $/ = $saved_sep;
-  close (SLURPEE);
-  return $retstr;
-}
-
-
-sub debug ()
-{
-  if ($Debug) {
-    my $msg = shift;
-    print STDERR $msg;
-  }
-}
-
-
-sub version ()
-{
-  print &quot;cvs2cl.pl version ${VERSION}; distributed under the GNU GPL.\n&quot;;
-}
-
-
-sub usage ()
-{
-  &amp;version ();
-  print &lt;&lt;'END_OF_INFO';
-Generate GNU-style ChangeLogs in CVS working copies.
-
-Notes about the output format(s):
-
-   The default output of cvs2cl.pl is designed to be compact, formally
-   unambiguous, but still easy for humans to read.  It is largely
-   self-explanatory, I hope; the one abbreviation that might not be
-   obvious is &quot;utags&quot;.  That stands for &quot;universal tags&quot; -- a
-   universal tag is one held by all the files in a given change entry.
-
-   If you need output that's easy for a program to parse, use the
-   --xml option.  Note that with XML output, just about all available
-   information is included with each change entry, whether you asked
-   for it or not, on the theory that your parser can ignore anything
-   it's not looking for.
-
-Notes about the options and arguments (the actual options are listed
-last in this usage message):
-
-  * The -I and -F options may appear multiple times.
-
-  * To follow trunk revisions, use &quot;-F trunk&quot; (&quot;-F TRUNK&quot; also works).
-    This is okay because no would ever, ever be crazy enough to name a
-    branch &quot;trunk&quot;, right?  Right.
-
-  * For the -U option, the UFILE should be formatted like
-    CVSROOT/users. That is, each line of UFILE looks like this
-       jrandom:<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">jrandom at red-bean.com</A>
-    or maybe even like this
-       jrandom:'Jesse Q. Random &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">jrandom at red-bean.com</A>&gt;'
-    Don't forget to quote the portion after the colon if necessary.
-
-  * Many people want to filter by date.  To do so, invoke cvs2cl.pl
-    like this:
-       cvs2cl.pl -l &quot;-d'DATESPEC'&quot;
-    where DATESPEC is any date specification valid for &quot;cvs log -d&quot;.
-    (Note that CVS 1.10.7 and below requires there be no space between
-    -d and its argument).
-
-Options/Arguments:
-
-  -h, -help, --help, or -?     Show this usage and exit
-  --version                    Show version and exit
-  -r, --revisions              Show revision numbers in output
-  -b, --branches               Show branch names in revisions when possible
-  -t, --tags                   Show tags (symbolic names) in output
-  -T, --tagdates               Show tags in output on their first occurance
-  --stdin                      Read from stdin, don't run cvs log
-  --stdout                     Output to stdout not to ChangeLog
-  -d, --distributed            Put ChangeLogs in subdirs
-  -f FILE, --file FILE         Write to FILE instead of &quot;ChangeLog&quot;
-  --fsf                        Use this if log data is in FSF ChangeLog style
-  -W SECS, --window SECS       Window of time within which log entries unify
-  -U UFILE, --usermap UFILE    Expand usernames to email addresses from UFILE
-  -R REGEXP, --regexp REGEXP   Include only entries that match REGEXP
-  -I REGEXP, --ignore REGEXP   Ignore files whose names match REGEXP
-  -C, --case-insensitive       Any regexp matching is done case-insensitively
-  -F BRANCH, --follow BRANCH   Show only revisions on or ancestral to BRANCH
-  -S, --separate-header        Blank line between each header and log message
-  --no-wrap                    Don't auto-wrap log message (recommend -S also)
-  --gmt, --utc                 Show times in GMT/UTC instead of local time
-  --accum                      Add to an existing ChangeLog (incompat w/ --xml)
-  -w, --day-of-week            Show day of week
-  --header FILE                Get ChangeLog header from FILE (&quot;-&quot; means stdin)
-  --xml                        Output XML instead of ChangeLog format
-  --xml-encoding ENCODING      Insert encoding clause in XML header
-  --hide-filenames             Don't show filenames (ignored for XML output)
-  -P, --prune                  Don't show empty log messages
-  -g OPTS, --global-opts OPTS  Invoke like this &quot;cvs OPTS log ...&quot;
-  -l OPTS, --log-opts OPTS     Invoke like this &quot;cvs ... log OPTS&quot;
-  FILE1 [FILE2 ...]            Show only log information for the named FILE(s)
-
-See <A HREF="http://www.red-bean.com/cvs2cl">http://www.red-bean.com/cvs2cl</A> for maintenance and bug info.
-END_OF_INFO
-}
-
-__END__
-
-=head1 NAME
-
-cvs2cl.pl - produces GNU-style ChangeLogs in CVS working copies, by
-    running &quot;cvs log&quot; and parsing the output.  Shared log entries are
-    unified in an intuitive way.
-
-=head1 DESCRIPTION
-
-This script generates GNU-style ChangeLog files from CVS log
-information.  Basic usage: just run it inside a working copy and a
-ChangeLog will appear.  It requires repository access (i.e., 'cvs log'
-must work).  Run &quot;cvs2cl.pl --help&quot; to see more advanced options.
-
-See <A HREF="http://www.red-bean.com/cvs2cl">http://www.red-bean.com/cvs2cl</A> for updates, and for instructions
-on getting anonymous CVS access to this script.
-
-Maintainer: Karl Fogel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">kfogel at red-bean.com</A>&gt;
-Please report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">bug-cvs2cl at red-bean.com</A>&gt;.
-
-=head1 README
-
-This script generates GNU-style ChangeLog files from CVS log
-information.  Basic usage: just run it inside a working copy and a
-ChangeLog will appear.  It requires repository access (i.e., 'cvs log'
-must work).  Run &quot;cvs2cl.pl --help&quot; to see more advanced options.
-
-See <A HREF="http://www.red-bean.com/cvs2cl">http://www.red-bean.com/cvs2cl</A> for updates, and for instructions
-on getting anonymous CVS access to this script.
-
-Maintainer: Karl Fogel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">kfogel at red-bean.com</A>&gt;
-Please report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">bug-cvs2cl at red-bean.com</A>&gt;.
-
-=head1 PREREQUISITES
-
-This script requires C&lt;Text::Wrap&gt;, C&lt;Time::Local&gt;, and
-C&lt;File::Basename&gt;.
-It also seems to require C&lt;Perl 5.004_04&gt; or higher.
-
-=pod OSNAMES
-
-any
-
-=pod SCRIPT CATEGORIES
-
-Version_Control/CVS
-
-=cut
-
-
--*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*- -*-
-
-Note about a bug-slash-opportunity:
------------------------------------
-
-There's a bug in Text::Wrap, which affects cvs2cl.  This script
-reveals it:
-
-  #!/usr/bin/perl -w
-
-  use Text::Wrap;
-
-  my $test_text =
-  &quot;This script demonstrates a bug in Text::Wrap.  The very long line
-  following this paragraph will be relocated relative to the surrounding
-  text:
-
-  ====================================================================
-
-  See?  When the bug happens, we'll get the line of equal signs below
-  this paragraph, even though it should be above.&quot;;
-
-
-  # Print out the test text with no wrapping:
-  print &quot;$test_text&quot;;
-  print &quot;\n&quot;;
-  print &quot;\n&quot;;
-
-  # Now print it out wrapped, and see the bug:
-  print wrap (&quot;\t&quot;, &quot;        &quot;, &quot;$test_text&quot;);
-  print &quot;\n&quot;;
-  print &quot;\n&quot;;
-
-If the line of equal signs were one shorter, then the bug doesn't
-happen.  Interesting.
-
-Anyway, rather than fix this in Text::Wrap, we might as well write a
-new wrap() which has the following much-needed features:
-
-* initial indentation, like current Text::Wrap()
-* subsequent line indentation, like current Text::Wrap()
-* user chooses among: force-break long words, leave them alone, or die()?
-* preserve existing indentation: chopped chunks from an indented line
-  are indented by same (like this line, not counting the asterisk!)
-* optional list of things to preserve on line starts, default &quot;&gt;&quot;
-
-Note that the last two are essentially the same concept, so unify in
-implementation and give a good interface to controlling them.
-
-And how about:
-
-Optionally, when encounter a line pre-indented by same as previous
-line, then strip the newline and refill, but indent by the same.
-Yeah...

Modified: upwatch/trunk/common/Makefile.am
===================================================================
--- upwatch/trunk/common/Makefile.am	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/common/Makefile.am	2006-04-13 20:50:54 UTC (rev 576)
@@ -2,6 +2,5 @@
 
 EXTRA_DIST = db.c generic_options.def dbase_options.def \
   main.c man1.tpl spec.tpl init.tpl minimal_options.def \
-  probe.tpl probe_generic.def common.h license_proprietary.def \
-  license_gpl.def
+  probe.tpl probe_generic.def common.h license_gpl.def
 

Deleted: upwatch/trunk/common/license_proprietary.def
===================================================================
--- upwatch/trunk/common/license_proprietary.def	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/common/license_proprietary.def	2006-04-13 20:50:54 UTC (rev 576)
@@ -1,9 +0,0 @@
-copyright = {
-  date = &quot;2002-2004&quot;;
-  author=  &quot;Ron Arts&quot;;
-  owner = &quot;Upwatch BV&quot;;
-  eaddr = &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">info at upwatch.com</A>&quot;;
-  type = &quot;NOTE&quot;;
-  text = 
-'Redistribution Prohibited. Violation will be prosecuted to the maximum extent possible by applicable law.';
-};

Modified: upwatch/trunk/compat/Makefile.am
===================================================================
--- upwatch/trunk/compat/Makefile.am	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/compat/Makefile.am	2006-04-13 20:50:54 UTC (rev 576)
@@ -2,4 +2,4 @@
 SERVERONLY = bb
 endif
 
-SUBDIRS = ${SERVERONLY} sometests
+SUBDIRS = ${SERVERONLY}

Modified: upwatch/trunk/configure.ac
===================================================================
--- upwatch/trunk/configure.ac	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/configure.ac	2006-04-13 20:50:54 UTC (rev 576)
@@ -719,8 +719,6 @@
 AC_CONFIG_FILES([uw_process/Makefile])
 AC_CONFIG_FILES([uw_syncprobes/Makefile])
 AC_CONFIG_FILES([compat/Makefile])
-AC_CONFIG_FILES([compat/sometests/Makefile])
-AC_CONFIG_FILES([compat/sometests/setproctitle/Makefile])
 AC_CONFIG_FILES([compat/bb/Makefile])
 AC_CONFIG_FILES([compat/bb/bbhimport/Makefile])
 fi

Modified: upwatch/trunk/doc/howitallworks.xml
===================================================================
--- upwatch/trunk/doc/howitallworks.xml	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/doc/howitallworks.xml	2006-04-13 20:50:54 UTC (rev 576)
@@ -105,10 +105,6 @@
            &lt;varname&gt;uw_send&lt;/varname&gt; queue, which is emptied by the uw_send process which sends
            all files to a remote queue on another host (received and queued by uw_accept).
         &lt;/para&gt;
-        &lt;para&gt; &lt;varname&gt;uw_examine&lt;/varname&gt; can do some additional tests like traceroute to the target host.
-           It attaches this report
-           to the probe result, and in its turn puts everything in an &lt;varname&gt;uw_process&lt;/varname&gt; or
-           &lt;varname&gt;uw_send&lt;/varname&gt; queue.&lt;/para&gt;
        &lt;/sect2&gt;
        &lt;sect2 id=&quot;uw_process_storing_results_in_the_database&quot;&gt;
         &lt;title&gt;uw_process: storing results in the database&lt;/title&gt;

Modified: upwatch/trunk/patches/README
===================================================================
--- upwatch/trunk/patches/README	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/patches/README	2006-04-13 20:50:54 UTC (rev 576)
@@ -11,9 +11,3 @@
 Adds timeout support to the linux libpcap library.
 Don't know if that's still needed for the newest versions.
 
-
-libstatgrab-openbsd.patch
-
-Old patch to add openbsd support to libpcap
-
-

Deleted: upwatch/trunk/patches/libstatgrab-openbsd.patch
===================================================================
--- upwatch/trunk/patches/libstatgrab-openbsd.patch	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/patches/libstatgrab-openbsd.patch	2006-04-13 20:50:54 UTC (rev 576)
@@ -1,32 +0,0 @@
-diff -uNr libstatgrab-orig/configure.in libstatgrab/configure.in
---- libstatgrab-orig/configure.in	2004-05-30 21:56:28.000000000 +0200
-+++ libstatgrab/configure.in	2004-06-09 19:00:00.000000000 +0200
-@@ -40,6 +40,12 @@
-                 [],
-                 [#include &lt;sys/disk.h&gt;])
- 
-+# ds_bytes has been removed in OpenBSD
-+AC_CHECK_MEMBER(struct disk_sysctl.ds_bytes,
-+                [AC_DEFINE(HAVE_DS_BYTES, , [Removed in OpenBSD])],
-+                [],
-+                [#include &lt;sys/disk.h&gt;])
-+
- # Check for sys/loadavg.h
- AC_CHECK_HEADERS([sys/loadavg.h])
- 
-diff -uNr libstatgrab-orig/src/libstatgrab/disk_stats.c libstatgrab/src/libstatgrab/disk_stats.c
---- libstatgrab-orig/src/libstatgrab/disk_stats.c	2004-05-30 21:56:28.000000000 +0200
-+++ libstatgrab/src/libstatgrab/disk_stats.c	2004-06-09 19:01:26.000000000 +0200
-@@ -415,6 +415,12 @@
- #endif
- #else
-
-+#ifdef HAVE_DS_BYTES
-+                rbytes = wbytes = stats[i].ds_bytes;
-+#else
-+                rbytes = stats[i].ds_rbytes;
-+                wbytes = stats[i].ds_wbytes;
-+#endif
- #endif
- 
- 		/* Don't keep stats for disks that have never been used. */

Deleted: upwatch/trunk/patches/xmbmon203.patch
===================================================================
--- upwatch/trunk/patches/xmbmon203.patch	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/patches/xmbmon203.patch	2006-04-13 20:50:54 UTC (rev 576)
@@ -1,54 +0,0 @@
---- xmbmon203-orig/Makefile.in	2003-07-04 05:13:45.000000000 +0200
-+++ xmbmon203/Makefile.in	2004-05-25 16:40:11.660167592 +0200
-@@ -37,14 +37,16 @@
- RM=rm -f
- INSTALL=install
- 
--INST_DIR=/usr/local/bin
-+INST_DIR=$(DESTDIR)/usr/local/bin
- INST_XDIR=/usr/X11R6/bin
- INST_XRDIR=/usr/X11R6/lib/X11/app-defaults
-  
- .c.o:
- 	$(CC) -c $(CFLAGS) $*.c
- 
--PROGRAM = mbmon xmbmon
-+PROGRAM = mbmon xmbmon.a
-+PACKAGE = upwatch
-+VERSION = `cat ../VERSION`
- 
- TESTPROG = testpci testsmb testhwm testfan
- 
-@@ -55,6 +57,17 @@
- 
- all: $(PROGRAM)
- 
-+distdir: 
-+	mkdir -p ../$(PACKAGE)-$(VERSION)/xmbmon203/AC-TOOLS
-+	cp *.c *.h Makefile.* *.txt configure *.in *.resources ../$(PACKAGE)-$(VERSION)/xmbmon203
-+	cp AC-TOOLS/config.* AC-TOOLS/install-sh ../$(PACKAGE)-$(VERSION)/xmbmon203/AC-TOOLS
-+
-+check:
-+	echo check OK
-+
-+xmbmon.a: $(OBJS)
-+	$(AR) -r xmbmon.a *.o
-+
- mbmon: mbmon.c mbmon.h methods.h pci_pm.h smbuses.h sensors.h $(OBJS)
- 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ mbmon.c $(OBJS) $(SPLIBS)
- 
-@@ -130,8 +143,12 @@
- 	$(RM) Makefile config.cache config.log config.h config.status
- 
- install: $(PROGRAM)
--	$(INSTALL) -o root -g wheel -m 4555 -c -p mbmon $(INST_DIR)
--	$(INSTALL) -o root -g wheel -m 4555 -c -p xmbmon $(INST_XDIR)
-+	mkdir -p $(INST_DIR)
-+	if test `${ID} -u` -eq 0; then \
-+	  $(INSTALL) -o root -g wheel -m 4555 -c -p mbmon $(INST_DIR); \
-+	else \
-+	  cp mbmon $(INST_DIR); \
-+	fi
- 
- lint:
- 	$(LINT) $(INCLUDES) $(DEFS) $(FONTDEFINES) $(SRCS) -lm

Deleted: upwatch/trunk/upwatch-spec.spec
===================================================================
--- upwatch/trunk/upwatch-spec.spec	2006-04-13 15:54:32 UTC (rev 575)
+++ upwatch/trunk/upwatch-spec.spec	2006-04-13 20:50:54 UTC (rev 576)
@@ -1,176 +0,0 @@
-
-Summary: UpWatch - The Best monitoring framework
-Vendor: <A HREF="http://www.upwatch.com">http://www.upwatch.com</A>
-Name: upwatch
-Version: 0.1
-Release: 1
-Source: <A HREF="http://www.upwatch.com/%{name">http://www.upwatch.com/%{name</A>}-%{version}.tar.gz
-Packager: Ron Arts &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">raarts at upwatch.com</A>&gt;
-Copyright: Proprietary
-Group: Application/Monitoring
-BuildRoot: %{_tmppath}/%{name}-%{version}-root
-BuildRequires: gzip glib2-devel mysql-devel curl-devel autogen 
-
-%define strip_binaries 1
-%define gzip_man 1
-%define  __prefix /usr
-
-Prefix: %{__prefix} 
-
-%description
-Upwatch is a full-fledged monitoring and report engine for
-internet hosts. It boasts support for various services, long-time
-history, graphs, and notification
-
-This package contains all upwatch documentation, plus supporting files
-like the database schema.
-
-
-
-%package uw_accept
-Summary: UpWatch - Upwatch daemon for accepting reports
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl &gt;= 7.9.3 autogen &gt;= 5.3.6 libnet &gt;= 1.0.2
-
-%description uw_accept
-uw_accept listen on port 1985 for incoming upwatch reports.
-Using a POP3-like protocol it asks for a username and password
-and copies incoming files to a queue
-
-%files uw_accept
-%defattr(-,root,root)
-/usr/bin/uw_accept
-%config(noreplace) /etc/uw_accept.conf
-%config(noreplace) /etc/upwatch.d/uw_accept.conf
-/usr/share/man/man1/uw_accept.1.gz
-
-
-%package uw_httpget
-Summary: UpWatch - Upwatch parallel probe daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl &gt;= 7.9.3 autogen &gt;= 5.3.6 libnet &gt;= 1.0.2
-
-%description uw_httpget
-uw_httpget reads a list of hosts from the database, and 
-sends http GET requests to each host. This happens in parallel, 
-so uw_httpget can process thousands of hosts in a very short period.
-
-%files uw_httpget
-%defattr(-,root,root)
-/usr/bin/uw_httpget
-%config(noreplace) /etc/uw_httpget.conf
-%config(noreplace) /etc/upwatch.d/uw_httpget.conf
-/usr/share/man/man1/uw_httpget.1.gz
-
-
-%package uw_ping
-Summary: UpWatch - Upwatch parallel ping daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl &gt;= 7.9.3 autogen &gt;= 5.3.6 libnet &gt;= 1.0.2
-
-%description uw_ping
-uw_ping reads a list of hosts from the database, and sends ping 
-packets to each host.  This happens in parallel, so uw_ping can 
-process thousands of hosts in a very short period.
-
-%files uw_ping
-%defattr(-,root,root)
-/usr/bin/uw_ping
-%config(noreplace) /etc/uw_ping.conf
-%config(noreplace) /etc/upwatch.d/uw_ping.conf
-/usr/share/man/man1/uw_ping.1.gz
-
-
-%package uw_process
-Summary: UpWatch - Upwatch parallel probe daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl &gt;= 7.9.3 autogen &gt;= 5.3.6 libnet &gt;= 1.0.2
-
-%description uw_process
-uw_process sends all files in the queue to a central server using 
-the uw_process protocol. This is a very simple protocol and looks
-something like POP3.
-
-%files uw_process
-%defattr(-,root,root)
-/usr/bin/uw_process
-%config(noreplace) /etc/uw_process.conf
-%config(noreplace) /etc/upwatch.d/uw_process.conf
-/usr/share/man/man1/uw_process.1.gz
-
-
-%package uw_send
-Summary: UpWatch - Upwatch parallel probe daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl &gt;= 7.9.3 autogen &gt;= 5.3.6 libnet &gt;= 1.0.2
-
-%description uw_send
-uw_send sends all files in the queue to a central server using 
-the uw_send protocol. This is a very simple protocol and looks
-something like POP3.
-
-%files uw_send
-%defattr(-,root,root)
-/usr/bin/uw_send
-%config(noreplace) /etc/uw_send.conf
-%config(noreplace) /etc/upwatch.d/uw_send.conf
-/usr/share/man/man1/uw_send.1.gz
-
-
-%package uw_traceroute
-Summary: UpWatch - Upwatch problem investigator daemon
-Group: Application/Monitoring
-Requires: libpcap mysql glib2 curl &gt;= 7.9.3 autogen &gt;= 5.3.6 libnet &gt;= 1.0.2
-
-%description uw_traceroute
-When some probe cannot get to its destination, it hands the
-problem over to uw_traceroute, which does a traceroute (either icmp, 
-tcp or udp) to the destination, and reports on its findings.
-
-%files uw_traceroute
-%defattr(-,root,root)
-/usr/bin/uw_traceroute
-%config(noreplace) /etc/uw_traceroute.conf
-%config(noreplace) /etc/upwatch.d/uw_traceroute.conf
-/usr/share/man/man1/uw_traceroute.1.gz
-
-
-%prep
-%setup  
-
-%build 
-%configure
-make 
-make check
-
-%install
-[ &quot;$RPM_BUILD_ROOT&quot; != &quot;/&quot; ] &amp;&amp; rm -rf $RPM_BUILD_ROOT
-mkdir -p $RPM_BUILD_ROOT
-make DESTDIR=$RPM_BUILD_ROOT install
-
-mkdir -p $RPM_BUILD_ROOT/etc/upwatch.d
-install -m 644 config/upwatch.conf $RPM_BUILD_ROOT/etc/
-install -m 644 uw_accept/uw_accept.conf $RPM_BUILD_ROOT/etc/upwatch.d
-install -m 644 uw_process/uw_process.conf $RPM_BUILD_ROOT/etc/upwatch.d
-
-%if %{strip_binaries}
-{ cd $RPM_BUILD_ROOT
-  strip .%{__prefix}/bin/* || /bin/true
-}
-%endif
-%if %{gzip_man}
-{ cd $RPM_BUILD_ROOT
-  gzip .%{_mandir}/man1/*.1 
-}
-%endif
-
-%clean
-#[ &quot;$RPM_BUILD_ROOT&quot; != &quot;/&quot; ] &amp;&amp; rm -rf $RPM_BUILD_ROOT
-
-%files
-%doc AUTHORS COPYING ChangeLog NEWS README 
-
-%changelog
-* Mon Sep 2 2002 Ron Arts &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">raarts at upwatch.com</A>&gt;
-- Rel. 1: First package version
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000106.html">[Upwatch-commits] r575 - upwatch/trunk
</A></li>
	<LI>Next message: <A HREF="000107.html">[Upwatch-commits] r577 - upwatch/trunk/uw_send
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#108">[ date ]</a>
              <a href="thread.html#108">[ thread ]</a>
              <a href="subject.html#108">[ subject ]</a>
              <a href="author.html#108">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/upwatch-commits">More information about the Upwatch-commits
mailing list</a><br>
</body></html>
