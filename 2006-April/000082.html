<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Upwatch-commits] r550 - in upwatch/trunk: . st-1.6 st-1.6/docs st-1.6/examples st-1.6/extensions
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/upwatch-commits/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:upwatch-commits%40lists.berlios.de?Subject=Re%3A%20%5BUpwatch-commits%5D%20r550%20-%20in%20upwatch/trunk%3A%20.%20st-1.6%20st-1.6/docs%20st-1.6/examples%20st-1.6/extensions&In-Reply-To=%3C200604051629.k35GTLqe025873%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000080.html">
   <LINK REL="Next"  HREF="000083.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Upwatch-commits] r550 - in upwatch/trunk: . st-1.6 st-1.6/docs st-1.6/examples st-1.6/extensions</H1>
    <B>wijnand at BerliOS</B> 
    <A HREF="mailto:upwatch-commits%40lists.berlios.de?Subject=Re%3A%20%5BUpwatch-commits%5D%20r550%20-%20in%20upwatch/trunk%3A%20.%20st-1.6%20st-1.6/docs%20st-1.6/examples%20st-1.6/extensions&In-Reply-To=%3C200604051629.k35GTLqe025873%40sheep.berlios.de%3E"
       TITLE="[Upwatch-commits] r550 - in upwatch/trunk: . st-1.6 st-1.6/docs st-1.6/examples st-1.6/extensions">wijnand at berlios.de
       </A><BR>
    <I>Wed Apr  5 18:29:21 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000080.html">[Upwatch-commits] r549 - upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog
</A></li>
        <LI>Next message: <A HREF="000083.html">[Upwatch-commits] r551 - in upwatch/trunk: . cfg libstatgrab-0.13 libstatgrab-0.13/docs libstatgrab-0.13/docs/libstatgrab libstatgrab-0.13/docs/saidar libstatgrab-0.13/docs/statgrab libstatgrab-0.13/examples libstatgrab-0.13/src libstatgrab-0.13/src/libstatgrab libstatgrab-0.13/src/saidar libstatgrab-0.13/src/statgrab util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#82">[ date ]</a>
              <a href="thread.html#82">[ thread ]</a>
              <a href="subject.html#82">[ subject ]</a>
              <a href="author.html#82">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: wijnand
Date: 2006-04-05 18:29:20 +0200 (Wed, 05 Apr 2006)
New Revision: 550

Added:
   upwatch/trunk/st-1.6/
   upwatch/trunk/st-1.6/Makefile.am
   upwatch/trunk/st-1.6/README
   upwatch/trunk/st-1.6/common.h
   upwatch/trunk/st-1.6/docs/
   upwatch/trunk/st-1.6/docs/fig.gif
   upwatch/trunk/st-1.6/docs/notes.html
   upwatch/trunk/st-1.6/docs/reference.html
   upwatch/trunk/st-1.6/docs/st.html
   upwatch/trunk/st-1.6/docs/timeout_heap.txt
   upwatch/trunk/st-1.6/examples/
   upwatch/trunk/st-1.6/examples/Makefile
   upwatch/trunk/st-1.6/examples/README
   upwatch/trunk/st-1.6/examples/error.c
   upwatch/trunk/st-1.6/examples/lookupdns.c
   upwatch/trunk/st-1.6/examples/proxy.c
   upwatch/trunk/st-1.6/examples/res.c
   upwatch/trunk/st-1.6/examples/server.c
   upwatch/trunk/st-1.6/extensions/
   upwatch/trunk/st-1.6/extensions/Makefile
   upwatch/trunk/st-1.6/extensions/README
   upwatch/trunk/st-1.6/extensions/common.h
   upwatch/trunk/st-1.6/extensions/dnscache.c
   upwatch/trunk/st-1.6/extensions/dnsres.c
   upwatch/trunk/st-1.6/extensions/lrucache.c
   upwatch/trunk/st-1.6/extensions/print_stk.patch
   upwatch/trunk/st-1.6/extensions/stx.h
   upwatch/trunk/st-1.6/extensions/stx_fileio.c
   upwatch/trunk/st-1.6/extensions/stx_fileio.h
   upwatch/trunk/st-1.6/extensions/testdns.c
   upwatch/trunk/st-1.6/ia64asm.S
   upwatch/trunk/st-1.6/io.c
   upwatch/trunk/st-1.6/key.c
   upwatch/trunk/st-1.6/libst.def
   upwatch/trunk/st-1.6/md.h
   upwatch/trunk/st-1.6/osguess.sh
   upwatch/trunk/st-1.6/public.h
   upwatch/trunk/st-1.6/sched.c
   upwatch/trunk/st-1.6/st.pc.in
   upwatch/trunk/st-1.6/st.spec
   upwatch/trunk/st-1.6/stk.c
   upwatch/trunk/st-1.6/sync.c
Removed:
   upwatch/trunk/st-1.4/
Modified:
   upwatch/trunk/Makefile.am
   upwatch/trunk/Makefile.am.libs
   upwatch/trunk/configure.ac
Log:
Upgrade to st-1.6.
More supported platforms we can use that.

Nice to find raarts in the changelog ;-)


Modified: upwatch/trunk/Makefile.am
===================================================================
--- upwatch/trunk/Makefile.am	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/Makefile.am	2006-04-05 16:29:20 UTC (rev 550)
@@ -66,7 +66,7 @@
 export TOP_SRCDIR = $(top_srcdir)
 
 if ENABLE_SERVER
-SUBDIRS = upwatch st-1.4 ${XMBMON} libstatgrab ${PROGNAMES} compat util scripts config common
+SUBDIRS = upwatch st-1.6 ${XMBMON} libstatgrab ${PROGNAMES} compat util scripts config common
 else
 SUBDIRS = upwatch ${XMBMON} libstatgrab ${PROGNAMES} util scripts config common 
 endif

Modified: upwatch/trunk/Makefile.am.libs
===================================================================
--- upwatch/trunk/Makefile.am.libs	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/Makefile.am.libs	2006-04-05 16:29:20 UTC (rev 550)
@@ -3,8 +3,8 @@
 LIBUPWATCH = $(top_srcdir)/upwatch/libupwatch.a @LIBXML2_LIBS@
 LIBUPWATCHT = $(top_srcdir)/upwatch/libupwatcht.a @LIBXML2_LIBS@
 
-LIBST = $(top_srcdir)/st-1.4/libst.a
-INCL_ST = $(top_srcdir)/st-1.4
+LIBST = $(top_srcdir)/st-1.6/libst.a
+INCL_ST = $(top_srcdir)/st-1.6
 
 LIBSTATGRAB = $(top_srcdir)/libstatgrab/src/libstatgrab/.libs/libstatgrab.a
 INCL_STATGRAB = $(top_srcdir)/libstatgrab/src/libstatgrab/

Modified: upwatch/trunk/configure.ac
===================================================================
--- upwatch/trunk/configure.ac	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/configure.ac	2006-04-05 16:29:20 UTC (rev 550)
@@ -683,7 +683,7 @@
 
 if test &quot;$enable_server&quot; = &quot;yes&quot; -o &quot;$enable_monitors&quot; = &quot;yes&quot;
 then
-AC_CONFIG_FILES([st-1.4/Makefile])
+AC_CONFIG_FILES([st-1.6/Makefile])
 fi
 
 # server 

Added: upwatch/trunk/st-1.6/Makefile.am
===================================================================
--- upwatch/trunk/st-1.6/Makefile.am	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/Makefile.am	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,30 @@
+noinst_LIBRARIES = libst.a
+libst_a_SOURCES = sched.c stk.c sync.c key.c io.c st.h common.h  md.h public.h
+if LINUX
+MYCFLAGS = -DUSE_POLL -DLINUX
+endif
+if FREEBSD
+MYCFLAGS = -DFREEBSD
+endif
+if NETBSD
+MYCFLAGS = -DNETBSD
+endif
+if OPENBSD
+MYCFLAGS = -DOPENBSD
+endif
+if SOLARIS
+MYCFLAGS = -DSOLARIS
+endif
+if CYGWIN
+MYCFLAGS = -DCYGWIN
+endif
+AM_CFLAGS = ${MYCFLAGS}
+
+EXTRA_DIST = osguess.sh
+
+sched.c: st.h
+
+st.h:
+	cp public.h st.h
+	sed &quot;s/@VERSION@/1.4/g&quot; &lt; st.pc.in &gt; st.pc
+

Added: upwatch/trunk/st-1.6/README
===================================================================
--- upwatch/trunk/st-1.6/README	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/README	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,356 @@
+WELCOME!
+
+The State Threads Library is a small application library which provides
+a foundation for writing fast and highly scalable Internet applications
+(such as web servers, proxy servers, mail transfer agents, and so on,
+really any network-data-driven application) on UNIX-like platforms.  It
+combines the simplicity of the multithreaded programming paradigm, in
+which one thread supports each simultaneous connection, with the
+performance and scalability of an event-driven state machine
+architecture.  In other words, this library offers a threading API for
+structuring an Internet application as a state machine.  For more
+details, please see the library documentation in the &quot;docs&quot; directory or
+on-line at
+
+    <A HREF="http://state-threads.sourceforge.net/docs/">http://state-threads.sourceforge.net/docs/</A>
+
+The State Threads Project is an open source project for maintaining and
+enhancing the State Threads Library.  For more information about this
+project, please see
+
+    <A HREF="http://state-threads.sourceforge.net/">http://state-threads.sourceforge.net/</A>
+
+
+BUILDING
+
+To build the library by hand, use the GNU make utility.  Run the make
+command (e.g., `gmake') with no arguments to display all supported
+targets.
+
+To build more or less automatically, first set the CONFIG_GUESS_PATH
+variable in either osguess.sh or your environment then run &quot;make
+default&quot; which guesses your OS and builds.  Requires the &quot;config.guess&quot;
+utility from GNU autoconf (not included with ST).  You can use one from
+a larger &quot;main&quot; software project or just use any config.guess available
+on your system.  You can also get it directly from GNU:
+<A HREF="ftp://ftp.gnu.org/gnu/autoconf/">ftp://ftp.gnu.org/gnu/autoconf/</A>
+
+To build rpms (RedHat Linux 6.2 or later, Linux/Mandrake, Solaris with
+gnome, etc.):
+    download the latest st-x.y.tar.gz
+    # rpm -ta st-x.y.tar.gz
+The .rpms will land in /usr/src/RPMS/&lt;arch&gt;.  Install them with:
+    # rpm -i libst*.rpm
+Requires GNU automake and rpm 3.0.3 or later.
+
+Debian users:
+  If you run potato, please upgrade to woody.
+  If you run woody, &quot;apt-get install libst-dev&quot; will get you v1.3.
+  If you run testing/unstable, you will get the newest available version.
+  If you *must* have the newest libst in woody, you may follow these
+  not-recommended instructions:
+    1. Add &quot;deb-src &lt;your-favourite-debian-mirror&gt; unstable main&quot; to your
+       /etc/apt/sources.list
+    2. apt-get update
+    3. apt-get source st
+    4. cd st-1.4 (or whatever version you got)
+    5. debuild
+    6. dpkg -i ../*.deb
+
+If your application uses autoconf to search for dependencies and you
+want to search for a given version of libst, you can simply add
+        PKG_CHECK_MODULES(MYAPP, st &gt;= 1.3 mumble &gt;= 0.2.23)
+to your configure.ac/in.  This will define @MYAPP_LIBS@ and
<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">+ at MYAPP_CFLAGS</A>@ which you may then use in your Makefile.am/in files to
+link against mumble and st.
+
+
+LICENSE
+
+The State Threads library is a derivative of the Netscape Portable
+Runtime library (NSPR).  All source code in this directory is
+distributed under the terms of the Mozilla Public License (MPL) version
+1.1 or the GNU General Public License (GPL) version 2 or later.  For
+more information about these licenses please see
+<A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A> and <A HREF="http://www.gnu.org/copyleft/.">http://www.gnu.org/copyleft/.</A>
+
+All source code in the &quot;examples&quot; directory is distributed under the BSD
+style license.
+
+
+PLATFORMS
+
+Please see the &quot;docs/notes.html&quot; file for the list of currently
+supported platforms.
+
+
+DEBUGGER SUPPORT
+
+It's almost impossible to print SP and PC in a portable way.  The only
+way to see thread's stack platform-independently is to actually jump to
+the saved context.  That's what the _st_iterate_threads() function does.
+Do the following to iterate over all threads:
+
+- set the _st_iterate_threads_flag to 1 in debugger
+- set breakpoint at the _st_show_thread_stack() function
+  (which does nothing)
+- call the _st_iterate_threads() function which jumps to the
+  next thread
+- at each break you can explore thread's stack
+- continue
+- when iteration is complete, you return to the original
+  point (you can see thread id and a message as arguments of
+  the _st_show_thread_stack() function).
+
+You can call _st_iterate_threads() in three ways:
+
+- Insert it into your source code at the point you want to
+  go over threads.
+- Just run application and this function will be called at
+  the first context switch.
+- Call it directly from the debugger at any point.
+
+This works with gdb and dbx.
+
+Example using gdb:
+
+(gdb) set _st_iterate_threads_flag = 1
+(gdb) b _st_show_thread_stack
+...
+(gdb) call _st_iterate_threads()
+...
+(gdb) bt
+...
+(gdb) c
+...
+(gdb) bt
+...
+(gdb) c
+...
+and so on...
+
+_st_iterate_threads_flag will be set to 0 automatically
+after iteration is over or you can set it to 0 at any time
+to stop iteration.
+
+Sometimes gdb complains about SIGSEGV when you call a function
+directly at gdb command-line.  It can be ignored -- just call the
+same function right away again, it works just fine.  For example:
+
+(gdb) set _st_iterate_threads_flag = 1
+(gdb) b _st_show_thread_stack
+Breakpoint 1 at 0x809bbbb: file sched.c, line 856.
+(gdb) call _st_iterate_threads()
+Program received signal SIGSEGV, Segmentation fault.
+....
+(gdb) # just call the function again:
+(gdb) call _st_iterate_threads()
+Breakpoint 1, _st_show_thread_stack (thread=0x4017aee4, messg=0x80ae7a2
+&quot;Iteration started&quot;)    at sched.c:856
+856     }
+....
+
+You can use simple gdb command-line scripting to display
+all threads and their stack traces at once:
+
+(gdb) while _st_iterate_threads_flag
+ &gt;bt
+ &gt;c
+ &gt;end
+....
+
+Another script to stop at the thread with the specific thread id
+(e.g., 0x40252ee4):
+
+(gdb) # set the flag again:
+(gdb) set _st_iterate_threads_flag = 1
+(gdb) call _st_iterate_threads()
+Breakpoint 1, _st_show_thread_stack (thread=0x4017aee4, messg=0x80ae7a2
+&quot;Iteration started&quot;)    at sched.c:856
+856     }
+....
+(gdb) while thread != 0x40252ee4
+ &gt;c
+ &gt;end
+....
+....
+Breakpoint 1, _st_show_thread_stack (thread=0x40252ee4, messg=0x0) at
+sched.c:856
+856     }
+(gdb) bt
+....
+(gdb) # don't want to continue iteration, unset the flag:
+(gdb) set _st_iterate_threads_flag = 0
+(gdb) c
+Continuing.
+Breakpoint 1, _st_show_thread_stack (thread=0x0, messg=0x80ae78e &quot;Iteration
+completed&quot;)
+    at sched.c:856
+856     }
+(gdb) c
+Continuing.
+(gdb) return
+Make selected stack frame return now? (y or n) y
+#0  0x4011254e in __select ()
+   from /lib/libc.so.6
+(gdb) detach
+
+
+CHANGE LOG
+
+Changes from 1.5.2 to 1.6.
+--------------------------
+none
+
+
+Changes from 1.5.1 to 1.5.2.
+----------------------------
+o  Alfred Perlstein's context switch callback feature.
+
+o  Claus Assmann's st_recvmsg/st_sendmsg wrappers.
+
+o  Extra stack padding for platforms that need it.
+
+o  Ron Arts's timeout clarifications in the reference manual.
+
+o  Raymond Bero and Anton Berezin's AMD64 FreeBSD port.
+
+o  Claus Assmann's AMD64 SunOS 5.10 port.
+
+o  Claus Assmann's AMD64 OpenBSD port.
+
+o  Michael Abd-El-Malek's Mac OS X port.
+
+o  Michael Abd-El-Malek's stack printing patch.
+
+
+Changes from 1.5.0 to 1.5.1.
+----------------------------
+o  Andreas Gustafsson's USE_POLL fix.
+
+o  Gene's st_set_utime_function() enhancement.
+
+
+Changes from 1.4 to 1.5.0.
+--------------------------
+o  Andreas Gustafsson's performance patch.
+
+o  New extensions:  Improved DNS resolver, generic LRU cache, in-process
+   DNS cache, and a program to test the resolver and cache.
+
+o  Support for AMD Opteron 64-bit CPUs under Linux.
+
+o  Support for SPARC-64 under Solaris.
+
+o  Andreas Gustafsson's support for VAX under NetBSD.
+
+o  Changed unportable #warning directives in md.h to #error.
+
+
+Changes from 1.3 to 1.4.
+------------------------
+o  Andreas Gustafsson's NetBSD port.
+
+o  Wesley W. Terpstra's Darwin (MacOS X) port.
+
+o  Support for many CPU architectures under Linux and *BSD.
+
+o  Renamed private typedefs so they don't conflict with public ones any
+   more.
+
+o  common.h now includes public.h for strict prototyping.
+
+o  Joshua Levy's recommendation to make st_connect() and st_sendto()
+   accept const struct sockaddr pointers, as the originals do.
+
+o  Clarified the documentation regarding blocking vs. non-blocking I/O.
+
+o  Cygwin support.
+
+o  Created the extensions directory.
+
+o  Fixed warnings from ia64asm.S.
+
+
+Changes from 1.2 to 1.3.
+------------------------
+o  Added st_read_resid() and st_write_resid() to allow the caller to know
+   how much data was transferred before an error occurred.  Updated
+   documentation.
+
+o  Updated project link, copyrights, and documentation regarding
+   timeouts.  Added comment to st_connect().
+
+o  Optimized the _st_add_sleep_q() function in sched.c.  Now we walk the
+   sleep queue *backward* when inserting a thread into it.  When you
+   have lots (hundreds) of threads and several timeout values, it takes
+   a while to insert a thread at the appropriate point in the sleep
+   queue.  The idea is that often this appropriate point is closer to
+   the end of the queue rather than the beginning.  Measurements show
+   performance improves with this change.  In any case this change
+   should do no harm.
+
+o  Added a hint of when to define USE_POLL and when not to, to the
+   Makefile.
+
+o  Added debugging support (files common.h and sched.c).   See above.
+
+o  Decreased the number of reallocations of _ST_POLLFDS in sched.c.
+   Inspired by Lev Walkin.
+
+o  Fixed st_usleep(-1) and st_sleep(-1), and added a warning to the
+   documentation about too-large timeouts.
+
+o  Linux/*BSD Alpha port.
+
+o  Wesley W. Terpstra modernized the build process:
+   - properly build relocatable libraries under bsd and linux
+   - use library versioning
+   - added rpm spec file
+   - added debian/ files
+   See above for build instructions.
+
+
+Changes from 1.1 to 1.2.
+------------------------
+o  Added st_randomize_stacks().
+
+o  Added a patch contributed by Sascha Schumann.
+
+
+Changes from 1.0 to 1.1.
+------------------------
+o  Relicensed under dual MPL-GPL.
+
+o  OpenBSD port.
+
+o  Compile-time option to use poll() instead of select() for
+   event polling (see Makefile).
+   This is useful if you want to support a large number of open
+   file descriptors (larger than FD_SETSIZE) within a single
+   process.
+
+o  Linux IA-64 port.
+   Two issues make IA-64 different from other platforms:
+
+   - Besides the traditional call stack in memory, IA-64 uses the
+     general register stack.  Thus each thread needs a backing store
+     for the register stack in addition to the memory stack.
+
+   - Current implementation of setjmp()/longjmp() can not be used
+     for thread context-switching since it assumes that only one
+     register stack exists.  Using special assembly functions for
+     context-switching is unavoidable.
+    
+o  Thread stack capping on IRIX.
+   This allows some profiling tools (such as SpeedShop) to know when
+   to stop unwinding the stack.  Without this libexc, used by SpeedShop,
+   traces right off the stack and crashes.
+
+o  Miscellaneous documentation additions.
+
+
+COPYRIGHTS
+
+Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+All Rights Reserved.

Added: upwatch/trunk/st-1.6/common.h
===================================================================
--- upwatch/trunk/st-1.6/common.h	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/common.h	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,467 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#ifndef __ST_COMMON_H__
+#define __ST_COMMON_H__
+
+#include &lt;stddef.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;setjmp.h&gt;
+
+/* Enable assertions only if DEBUG is defined */
+#ifndef DEBUG
+#define NDEBUG
+#endif
+#include &lt;assert.h&gt;
+#define ST_ASSERT(expr) assert(expr)
+
+#define ST_BEGIN_MACRO  {
+#define ST_END_MACRO    }
+
+#include &quot;public.h&quot;
+#include &quot;md.h&quot;
+
+
+/*****************************************
+ * Circular linked list definitions
+ */
+
+typedef struct _st_clist {
+  struct _st_clist *next;
+  struct _st_clist *prev;
+} _st_clist_t;
+
+/* Insert element &quot;_e&quot; into the list, before &quot;_l&quot; */
+#define ST_INSERT_BEFORE(_e,_l)	 \
+    ST_BEGIN_MACRO		 \
+	(_e)-&gt;next = (_l);	 \
+	(_e)-&gt;prev = (_l)-&gt;prev; \
+	(_l)-&gt;prev-&gt;next = (_e); \
+	(_l)-&gt;prev = (_e);	 \
+    ST_END_MACRO
+
+/* Insert element &quot;_e&quot; into the list, after &quot;_l&quot; */
+#define ST_INSERT_AFTER(_e,_l)	 \
+    ST_BEGIN_MACRO		 \
+	(_e)-&gt;next = (_l)-&gt;next; \
+	(_e)-&gt;prev = (_l);	 \
+	(_l)-&gt;next-&gt;prev = (_e); \
+	(_l)-&gt;next = (_e);	 \
+    ST_END_MACRO
+
+/* Return the element following element &quot;_e&quot; */
+#define ST_NEXT_LINK(_e)  ((_e)-&gt;next)
+
+/* Append an element &quot;_e&quot; to the end of the list &quot;_l&quot; */
+#define ST_APPEND_LINK(_e,_l) ST_INSERT_BEFORE(_e,_l)
+
+/* Insert an element &quot;_e&quot; at the head of the list &quot;_l&quot; */
+#define ST_INSERT_LINK(_e,_l) ST_INSERT_AFTER(_e,_l)
+
+/* Return the head/tail of the list */
+#define ST_LIST_HEAD(_l) (_l)-&gt;next
+#define ST_LIST_TAIL(_l) (_l)-&gt;prev
+
+/* Remove the element &quot;_e&quot; from it's circular list */
+#define ST_REMOVE_LINK(_e)	       \
+    ST_BEGIN_MACRO		       \
+	(_e)-&gt;prev-&gt;next = (_e)-&gt;next; \
+	(_e)-&gt;next-&gt;prev = (_e)-&gt;prev; \
+    ST_END_MACRO
+
+/* Return non-zero if the given circular list &quot;_l&quot; is empty, */
+/* zero if the circular list is not empty */
+#define ST_CLIST_IS_EMPTY(_l) \
+    ((_l)-&gt;next == (_l))
+
+/* Initialize a circular list */
+#define ST_INIT_CLIST(_l)  \
+    ST_BEGIN_MACRO	   \
+	(_l)-&gt;next = (_l); \
+	(_l)-&gt;prev = (_l); \
+    ST_END_MACRO
+
+#define ST_INIT_STATIC_CLIST(_l) \
+    {(_l), (_l)}
+
+
+/*****************************************
+ * Basic types definitions
+ */
+
+typedef void  (*_st_destructor_t)(void *);
+
+
+typedef struct _st_stack {
+  _st_clist_t links;
+  char *vaddr;                /* Base of stack's allocated memory */
+  int  vaddr_size;            /* Size of stack's allocated memory */
+  int  stk_size;              /* Size of usable portion of the stack */
+  char *stk_bottom;           /* Lowest address of stack's usable portion */
+  char *stk_top;              /* Highest address of stack's usable portion */
+  void *sp;                   /* Stack pointer from C's point of view */
+#ifdef __ia64__
+  void *bsp;                  /* Register stack backing store pointer */
+#endif
+} _st_stack_t;
+
+
+typedef struct _st_cond {
+  _st_clist_t wait_q;	      /* Condition variable wait queue */
+} _st_cond_t;
+
+
+typedef struct _st_thread _st_thread_t;
+
+struct _st_thread {
+  int state;                  /* Thread's state */
+  int flags;                  /* Thread's flags */
+
+  void *(*start)(void *arg);  /* The start function of the thread */
+  void *arg;                  /* Argument of the start function */
+  void *retval;               /* Return value of the start function */
+
+  _st_stack_t *stack;	      /* Info about thread's stack */
+
+  _st_clist_t links;          /* For putting on run/sleep/zombie queue */
+  _st_clist_t wait_links;     /* For putting on mutex/condvar wait queue */
+#ifdef DEBUG
+  _st_clist_t tlink;          /* For putting on thread queue */
+#endif
+
+  st_utime_t due;             /* Wakeup time when thread is sleeping */
+  _st_thread_t *left;         /* For putting in timeout heap */
+  _st_thread_t *right;	      /* -- see docs/timeout_heap.txt for details */
+  int heap_index;
+
+  void **private_data;        /* Per thread private data */
+
+  _st_cond_t *term;           /* Termination condition variable for join */
+
+  jmp_buf context;            /* Thread's context */
+};
+
+
+typedef struct _st_mutex {
+  _st_thread_t *owner;        /* Current mutex owner */
+  _st_clist_t  wait_q;        /* Mutex wait queue */
+} _st_mutex_t;
+
+
+typedef struct _st_pollq {
+  _st_clist_t links;          /* For putting on io queue */
+  _st_thread_t  *thread;      /* Polling thread */
+  struct pollfd *pds;         /* Array of poll descriptors */
+  int npds;                   /* Length of the array */
+  int on_ioq;                 /* Is it on ioq? */
+} _st_pollq_t;
+
+
+typedef struct _st_vp {
+  _st_thread_t *idle_thread;  /* Idle thread for this vp */
+  st_utime_t last_clock;      /* The last time we went into vp_check_clock() */
+
+  _st_clist_t run_q;          /* run queue for this vp */
+  _st_clist_t io_q;           /* io queue for this vp */
+  _st_clist_t zombie_q;       /* zombie queue for this vp */
+#ifdef DEBUG
+  _st_clist_t thread_q;       /* all threads of this vp */
+#endif
+  int pagesize;
+
+  _st_thread_t *sleep_q;      /* sleep queue for this vp */
+  int sleepq_size;	      /* number of threads on sleep queue */
+
+#ifdef ST_SWITCH_CB
+  st_switch_cb_t switch_out_cb;	/* called when a thread is switched out */
+  st_switch_cb_t switch_in_cb;	/* called when a thread is switched in */
+#endif
+
+#ifndef USE_POLL
+  int maxfd;
+  fd_set fd_read_set, fd_write_set, fd_exception_set;
+  int fd_ref_cnts[FD_SETSIZE][3];
+#else
+  int fdcnt;
+  struct pollfd *ioq_pollfds;
+  int ioq_pollfds_size;
+#endif  /* !USE_POLL */
+} _st_vp_t;
+
+
+typedef struct _st_netfd {
+  int osfd;                   /* Underlying OS file descriptor */
+  int inuse;                  /* In-use flag */
+  void *private_data;         /* Per descriptor private data */
+  _st_destructor_t destructor; /* Private data destructor function */
+  void *aux_data;             /* Auxiliary data for internal use */
+  struct _st_netfd *next;     /* For putting on the free list */
+} _st_netfd_t;
+
+
+/*****************************************
+ * Current vp and thread
+ */
+
+extern _st_vp_t	    _st_this_vp;
+extern _st_thread_t *_st_this_thread;
+
+#define _ST_CURRENT_THREAD()            (_st_this_thread)
+#define _ST_SET_CURRENT_THREAD(_thread) (_st_this_thread = (_thread))
+
+#define _ST_LAST_CLOCK                  (_st_this_vp.last_clock)
+
+#define _ST_RUNQ                        (_st_this_vp.run_q)
+#define _ST_IOQ                         (_st_this_vp.io_q)
+#define _ST_ZOMBIEQ                     (_st_this_vp.zombie_q)
+#ifdef DEBUG
+#define _ST_THREADQ                     (_st_this_vp.thread_q)
+#endif
+
+#define _ST_PAGE_SIZE                   (_st_this_vp.pagesize)
+
+#define _ST_SLEEPQ                      (_st_this_vp.sleep_q)
+#define _ST_SLEEPQ_SIZE                 (_st_this_vp.sleepq_size)
+
+#ifndef USE_POLL
+#define _ST_MAX_OSFD                    (_st_this_vp.maxfd)
+#define _ST_FD_READ_SET                 (_st_this_vp.fd_read_set)
+#define _ST_FD_WRITE_SET                (_st_this_vp.fd_write_set)
+#define _ST_FD_EXCEPTION_SET            (_st_this_vp.fd_exception_set)
+#define _ST_FD_READ_CNT(fd)             (_st_this_vp.fd_ref_cnts[fd][0])
+#define _ST_FD_WRITE_CNT(fd)            (_st_this_vp.fd_ref_cnts[fd][1])
+#define _ST_FD_EXCEPTION_CNT(fd)        (_st_this_vp.fd_ref_cnts[fd][2])
+#else
+#define _ST_OSFD_CNT                    (_st_this_vp.fdcnt)
+#define _ST_POLLFDS                     (_st_this_vp.ioq_pollfds)
+#define _ST_POLLFDS_SIZE                (_st_this_vp.ioq_pollfds_size)
+#endif
+
+
+/*****************************************
+ * vp queues operations
+ */
+
+#define _ST_ADD_IOQ(_pq)    ST_APPEND_LINK(&amp;_pq.links, &amp;_ST_IOQ)
+#define _ST_DEL_IOQ(_pq)    ST_REMOVE_LINK(&amp;_pq.links)
+
+#define _ST_ADD_RUNQ(_thr)  ST_APPEND_LINK(&amp;(_thr)-&gt;links, &amp;_ST_RUNQ)
+#define _ST_DEL_RUNQ(_thr)  ST_REMOVE_LINK(&amp;(_thr)-&gt;links)
+
+#define _ST_ADD_SLEEPQ(_thr, _timeout)  _st_add_sleep_q(_thr, _timeout)
+#define _ST_DEL_SLEEPQ(_thr)		_st_del_sleep_q(_thr)
+
+#define _ST_ADD_ZOMBIEQ(_thr)  ST_APPEND_LINK(&amp;(_thr)-&gt;links, &amp;_ST_ZOMBIEQ)
+#define _ST_DEL_ZOMBIEQ(_thr)  ST_REMOVE_LINK(&amp;(_thr)-&gt;links)
+
+#ifdef DEBUG
+#define _ST_ADD_THREADQ(_thr)  ST_APPEND_LINK(&amp;(_thr)-&gt;tlink, &amp;_ST_THREADQ)
+#define _ST_DEL_THREADQ(_thr)  ST_REMOVE_LINK(&amp;(_thr)-&gt;tlink)
+#endif
+
+
+/*****************************************
+ * Thread states and flags
+ */
+
+#define _ST_ST_RUNNING      0 
+#define _ST_ST_RUNNABLE     1
+#define _ST_ST_IO_WAIT      2
+#define _ST_ST_LOCK_WAIT    3
+#define _ST_ST_COND_WAIT    4
+#define _ST_ST_SLEEPING     5
+#define _ST_ST_ZOMBIE       6
+#define _ST_ST_SUSPENDED    7
+
+#define _ST_FL_PRIMORDIAL   0x01
+#define _ST_FL_IDLE_THREAD  0x02
+#define _ST_FL_ON_SLEEPQ    0x04
+#define _ST_FL_INTERRUPT    0x08
+#define _ST_FL_TIMEDOUT     0x10
+
+
+/*****************************************
+ * Pointer conversion
+ */
+
+#ifndef offsetof
+#define offsetof(type, identifier) ((size_t)&amp;(((type *)0)-&gt;identifier))
+#endif
+
+#define _ST_THREAD_PTR(_qp)         \
+    ((_st_thread_t *)((char *)(_qp) - offsetof(_st_thread_t, links)))
+
+#define _ST_THREAD_WAITQ_PTR(_qp)   \
+    ((_st_thread_t *)((char *)(_qp) - offsetof(_st_thread_t, wait_links)))
+
+#define _ST_THREAD_STACK_PTR(_qp)   \
+    ((_st_stack_t *)((char*)(_qp) - offsetof(_st_stack_t, links)))
+
+#define _ST_POLLQUEUE_PTR(_qp)      \
+    ((_st_pollq_t *)((char *)(_qp) - offsetof(_st_pollq_t, links)))
+
+#ifdef DEBUG
+#define _ST_THREAD_THREADQ_PTR(_qp) \
+    ((_st_thread_t *)((char *)(_qp) - offsetof(_st_thread_t, tlink)))
+#endif
+
+
+/*****************************************
+ * Constants
+ */
+
+#define ST_UTIME_NO_TIMEOUT (-1ULL)
+#ifndef __ia64__
+#define ST_DEFAULT_STACK_SIZE (64*1024)
+#else
+#define ST_DEFAULT_STACK_SIZE (128*1024)  /* Includes register stack size */
+#endif
+
+#ifndef ST_KEYS_MAX
+#define ST_KEYS_MAX 16
+#endif
+
+#ifndef ST_MIN_POLLFDS_SIZE
+#define ST_MIN_POLLFDS_SIZE 64
+#endif
+
+
+/*****************************************
+ * Threads context switching
+ */
+
+#ifdef DEBUG
+void _st_iterate_threads(void);
+#define ST_DEBUG_ITERATE_THREADS() _st_iterate_threads()
+#else
+#define ST_DEBUG_ITERATE_THREADS()
+#endif
+
+#ifdef ST_SWITCH_CB
+#define ST_SWITCH_OUT_CB(_thread)		\
+    if (_st_this_vp.switch_out_cb != NULL &amp;&amp;	\
+        _thread != _st_this_vp.idle_thread &amp;&amp;	\
+        _thread-&gt;state != _ST_ST_ZOMBIE) {	\
+      _st_this_vp.switch_out_cb();		\
+    }
+#define ST_SWITCH_IN_CB(_thread)		\
+    if (_st_this_vp.switch_in_cb != NULL &amp;&amp;	\
+	_thread != _st_this_vp.idle_thread &amp;&amp;	\
+	_thread-&gt;state != _ST_ST_ZOMBIE) {	\
+      _st_this_vp.switch_in_cb();		\
+    }
+#else
+#define ST_SWITCH_OUT_CB(_thread)
+#define ST_SWITCH_IN_CB(_thread)
+#endif
+
+/*
+ * Switch away from the current thread context by saving its state and
+ * calling the thread scheduler
+ */
+#define _ST_SWITCH_CONTEXT(_thread)       \
+    ST_BEGIN_MACRO                        \
+    ST_SWITCH_OUT_CB(_thread);            \
+    if (!MD_SETJMP((_thread)-&gt;context)) { \
+      _st_vp_schedule();                  \
+    }                                     \
+    ST_DEBUG_ITERATE_THREADS();           \
+    ST_SWITCH_IN_CB(_thread);             \
+    ST_END_MACRO
+
+/*
+ * Restore a thread context that was saved by _ST_SWITCH_CONTEXT or
+ * initialized by _ST_INIT_CONTEXT
+ */
+#define _ST_RESTORE_CONTEXT(_thread)   \
+    ST_BEGIN_MACRO                     \
+    _ST_SET_CURRENT_THREAD(_thread);   \
+    MD_LONGJMP((_thread)-&gt;context, 1); \
+    ST_END_MACRO
+
+/*
+ * Initialize the thread context preparing it to execute _main
+ */
+#ifdef MD_INIT_CONTEXT
+#define _ST_INIT_CONTEXT MD_INIT_CONTEXT
+#else
+#error Unknown OS
+#endif
+
+/*
+ * Number of bytes reserved under the stack &quot;bottom&quot;
+ */
+#define _ST_STACK_PAD_SIZE MD_STACK_PAD_SIZE
+
+
+/*****************************************
+ * Forward declarations
+ */
+
+void _st_vp_schedule(void);
+void _st_vp_idle(void);
+void _st_vp_check_clock(void);
+void _st_find_bad_fd(void);
+void *_st_idle_thread_start(void *arg);
+void _st_thread_main(void);
+void _st_thread_cleanup(_st_thread_t *thread);
+void _st_add_sleep_q(_st_thread_t *thread, st_utime_t timeout);
+void _st_del_sleep_q(_st_thread_t *thread);
+_st_stack_t *_st_stack_new(int stack_size);
+void _st_stack_free(_st_stack_t *ts);
+int _st_io_init(void);
+
+st_utime_t st_utime(void);
+_st_cond_t *st_cond_new(void);
+int st_cond_destroy(_st_cond_t *cvar);
+int st_cond_timedwait(_st_cond_t *cvar, st_utime_t timeout);
+int st_cond_signal(_st_cond_t *cvar);
+ssize_t st_read(_st_netfd_t *fd, void *buf, size_t nbyte, st_utime_t timeout);
+ssize_t st_write(_st_netfd_t *fd, const void *buf, size_t nbyte,
+		 st_utime_t timeout);
+int st_poll(struct pollfd *pds, int npds, st_utime_t timeout);
+_st_thread_t *st_thread_create(void *(*start)(void *arg), void *arg,
+			      int joinable, int stk_size);
+
+#endif /* !__ST_COMMON_H__ */
+

Added: upwatch/trunk/st-1.6/docs/fig.gif
===================================================================
(Binary files differ)


Property changes on: upwatch/trunk/st-1.6/docs/fig.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: upwatch/trunk/st-1.6/docs/notes.html
===================================================================
--- upwatch/trunk/st-1.6/docs/notes.html	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/docs/notes.html	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,420 @@
+&lt;HTML&gt;
+&lt;HEAD&gt;
+&lt;TITLE&gt;State Threads Library Programming Notes&lt;/TITLE&gt;
+&lt;/HEAD&gt;
+&lt;BODY BGCOLOR=#FFFFFF&gt;
+&lt;H2&gt;Programming Notes&lt;/H2&gt;
+&lt;P&gt;
+&lt;B&gt;
+&lt;UL&gt;
+&lt;LI&gt;&lt;A HREF=#porting&gt;Porting&lt;/A&gt;&lt;/LI&gt;
+&lt;LI&gt;&lt;A HREF=#signals&gt;Signals&lt;/A&gt;&lt;/LI&gt;
+&lt;LI&gt;&lt;A HREF=#intra&gt;Intra-Process Synchronization&lt;/A&gt;&lt;/LI&gt;
+&lt;LI&gt;&lt;A HREF=#inter&gt;Inter-Process Synchronization&lt;/A&gt;&lt;/LI&gt;
+&lt;LI&gt;&lt;A HREF=#nonnet&gt;Non-Network I/O&lt;/A&gt;&lt;/LI&gt;
+&lt;LI&gt;&lt;A HREF=#timeouts&gt;Timeouts&lt;/A&gt;&lt;/LI&gt;
+&lt;/UL&gt;
+&lt;/B&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;porting&quot;&gt;
+&lt;H3&gt;Porting&lt;/H3&gt;
+The State Threads library uses OS concepts that are available in some
+form on most UNIX platforms, making the library very portable across
+many flavors of UNIX.  However, there are several parts of the library
+that rely on platform-specific features.  Here is the list of such parts:
+&lt;P&gt;
+&lt;UL&gt;
+&lt;LI&gt;&lt;I&gt;Thread context initialization&lt;/I&gt;: Two ingredients of the
+&lt;TT&gt;jmp_buf&lt;/TT&gt;
+data structure (the program counter and the stack pointer) have to be
+manually set in the thread creation routine. The &lt;TT&gt;jmp_buf&lt;/TT&gt; data
+structure is defined in the &lt;TT&gt;setjmp.h&lt;/TT&gt; header file and differs from
+platform to platform.  Usually the program counter is a structure member
+with &lt;TT&gt;PC&lt;/TT&gt; in the name and the stack pointer is a structure member
+with &lt;TT&gt;SP&lt;/TT&gt; in the name.  One can also look in the
+&lt;A HREF=&quot;<A HREF="http://www.mozilla.org/source.html">http://www.mozilla.org/source.html</A>&quot;&gt;Netscape's NSPR library source&lt;/A&gt;
+which already has this code for many UNIX-like platforms
+(&lt;TT&gt;mozilla/nsprpub/pr/include/md/*.h&lt;/TT&gt; files).
+&lt;P&gt;
+Note that on some BSD-derived platforms &lt;TT&gt;_setjmp(3)/_longjmp(3)&lt;/TT&gt;
+calls should be used instead of &lt;TT&gt;setjmp(3)/longjmp(3)&lt;/TT&gt; (that is
+the calls that manipulate only the stack and registers and do &lt;I&gt;not&lt;/I&gt;
+save and restore the process's signal mask).&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;&lt;I&gt;High resolution time function&lt;/I&gt;: Some platforms (IRIX, Solaris)
+provide a high resolution time function based on the free running hardware
+counter.  This function returns the time counted since some arbitrary
+moment in the past (usually machine power up time).  It is not correlated in
+any way to the time of day, and thus is not subject to resetting,
+drifting, etc.  This type of time is ideal for tasks where cheap, accurate
+interval timing is required.  If such a function is not available on a
+particular platform, the &lt;TT&gt;gettimeofday(3)&lt;/TT&gt; function can be used
+(though on some platforms it involves a system call).
+&lt;P&gt;
+&lt;LI&gt;&lt;I&gt;The stack growth direction&lt;/I&gt;: The library needs to know whether the
+stack grows toward lower (down) or higher (up) memory addresses.
+One can write a simple test program that detects the stack growth direction
+on a particular platform.&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;&lt;I&gt;Non-blocking attribute inheritance&lt;/I&gt;: On some platforms (e.g. IRIX)
+the socket created as a result of the &lt;TT&gt;accept(2)&lt;/TT&gt; call inherits the
+non-blocking attribute of the listening socket. One needs to consult the manual
+pages or write a simple test program to see if this applies to a specific
+platform.&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;&lt;I&gt;Anonymous memory mapping&lt;/I&gt;: The library allocates memory segments
+for thread stacks by doing anonymous memory mapping (&lt;TT&gt;mmap(2)&lt;/TT&gt;). This
+mapping is somewhat different on SVR4 and BSD4.3 derived platforms.
+&lt;P&gt;
+The memory mapping can be avoided altogether by using &lt;TT&gt;malloc(3)&lt;/TT&gt; for
+stack allocation.  In this case the &lt;TT&gt;MALLOC_STACK&lt;/TT&gt; macro should be
+defined.&lt;/LI&gt;
+&lt;/UL&gt;
+&lt;P&gt;
+All machine-dependent feature test macros should be defined in the
+&lt;TT&gt;md.h&lt;/TT&gt; header file.
+&lt;P&gt;
+The current version of the library is ported to:
+&lt;UL&gt;
+  &lt;LI&gt;IRIX 6.x (both 32 and 64 bit)&lt;/LI&gt;
+  &lt;LI&gt;Linux (kernel 2.x and glibc 2.x) on x86, Alpha, MIPS and MIPSEL,
+  SPARC, ARM, PowerPC, 68k, HPPA, S390, IA-64, and Opteron (AMD-64)&lt;/LI&gt;
+  &lt;LI&gt;Solaris 2.x (SunOS 5.x) on x86, AMD64, SPARC, and SPARC-64&lt;/LI&gt;
+  &lt;LI&gt;AIX 4.x&lt;/LI&gt;
+  &lt;LI&gt;HP-UX 11 (both 32 and 64 bit)&lt;/LI&gt;
+  &lt;LI&gt;Tru64/OSF1&lt;/LI&gt;
+  &lt;LI&gt;FreeBSD on x86, AMD64, and Alpha&lt;/LI&gt;
+  &lt;LI&gt;OpenBSD on x86, AMD64, Alpha, and SPARC&lt;/LI&gt;
+  &lt;LI&gt;NetBSD on x86, Alpha, SPARC, and VAX&lt;/LI&gt;
+  &lt;LI&gt;MacOS X (Darwin/Tiger)&lt;/LI&gt;
+  &lt;LI&gt;Cygwin&lt;/LI&gt;
+&lt;/UL&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;signals&quot;&gt;
+&lt;H3&gt;Signals&lt;/H3&gt;
+Signal handling in an application using State Threads should be treated the
+same way as in a classical UNIX process application. There is no such
+thing as per-thread signal mask, all threads share the same signal handlers,
+and only asynchronous-safe functions can be used in signal handlers.
+However, there is a way to process signals synchronously by converting a
+signal event to an I/O event: a signal catching function does a write to
+a pipe which will be processed synchronously by a dedicated signal handling
+thread.  The following code demonstrates this technique (error handling is
+omitted for clarity):
+&lt;PRE&gt;
+
+/* Per-process pipe which is used as a signal queue. */
+/* Up to PIPE_BUF/sizeof(int) signals can be queued up. */
+int sig_pipe[2];
+
+/* Signal catching function. */
+/* Converts signal event to I/O event. */
+void sig_catcher(int signo)
+{
+  int err;
+
+  /* Save errno to restore it after the write() */
+  err = errno;
+  /* write() is reentrant/async-safe */
+  write(sig_pipe[1], &amp;signo, sizeof(int));
+  errno = err;
+}
+
+/* Signal processing function. */
+/* This is the &quot;main&quot; function of the signal processing thread. */
+void *sig_process(void *arg)
+{
+  st_netfd_t nfd;
+  int signo;
+
+  nfd = st_netfd_open(sig_pipe[0]);
+
+  for ( ; ; ) {
+    /* Read the next signal from the pipe */
+    st_read(nfd, &amp;signo, sizeof(int), -1);
+
+    /* Process signal synchronously */
+    switch (signo) {
+    case SIGHUP:
+      /* do something here - reread config files, etc. */
+      break;
+    case SIGTERM:
+      /* do something here - cleanup, etc. */
+      break;
+      /*      .
+              .
+         Other signals
+              .
+              .
+      */
+    }
+  }
+
+  return NULL;
+}
+
+int main(int argc, char *argv[])
+{
+  struct sigaction sa;
+        .
+        .
+        .
+
+  /* Create signal pipe */
+  pipe(sig_pipe);
+
+  /* Create signal processing thread */
+  st_thread_create(sig_process, NULL, 0, 0);
+
+  /* Install sig_catcher() as a signal handler */
+  sa.sa_handler = sig_catcher;
+  sigemptyset(&amp;sa.sa_mask);
+  sa.sa_flags = 0;
+  sigaction(SIGHUP, &amp;sa, NULL);
+
+  sa.sa_handler = sig_catcher;
+  sigemptyset(&amp;sa.sa_mask);
+  sa.sa_flags = 0;
+  sigaction(SIGTERM, &amp;sa, NULL);
+
+        .
+        .
+        .
+      
+}
+
+&lt;/PRE&gt;
+&lt;P&gt;
+Note that if multiple processes are used (see below), the signal pipe should
+be initialized after the &lt;TT&gt;fork(2)&lt;/TT&gt; call so that each process has its
+own private pipe.
+&lt;P&gt;
+
+&lt;A NAME=&quot;intra&quot;&gt;
+&lt;H3&gt;Intra-Process Synchronization&lt;/H3&gt;
+Due to the event-driven nature of the library scheduler, the thread context
+switch (process state change) can only happen in a well-known set of
+library functions.  This set includes functions in which a thread may
+&quot;block&quot;:&lt;TT&gt;  &lt;/TT&gt;I/O functions (&lt;TT&gt;st_read(), st_write(), &lt;/TT&gt;etc.),
+sleep functions (&lt;TT&gt;st_sleep(), &lt;/TT&gt;etc.), and thread synchronization
+functions (&lt;TT&gt;st_thread_join(), st_cond_wait(), &lt;/TT&gt;etc.).  As a result,
+process-specific global data need not to be protected by locks since a thread
+cannot be rescheduled while in a critical section (and only one thread at a
+time can access the same memory location).  By the same token,
+non thread-safe functions (in a traditional sense) can be safely used with
+the State Threads.  The library's mutex facilities are practically useless
+for a correctly written application (no blocking functions in critical
+section) and are provided mostly for completeness.  This absence of locking
+greatly simplifies an application design and provides a foundation for
+scalability.
+&lt;P&gt;
+
+&lt;A NAME=&quot;inter&quot;&gt;
+&lt;H3&gt;Inter-Process Synchronization&lt;/H3&gt;
+The State Threads library makes it possible to multiplex a large number
+of simultaneous connections onto a much smaller number of separate 
+processes, where each process uses a many-to-one user-level threading
+implementation (&lt;B&gt;N&lt;/B&gt; of &lt;B&gt;M:1&lt;/B&gt; mappings rather than one &lt;B&gt;M:N&lt;/B&gt;
+mapping used in native threading libraries on some platforms). This design
+is key to the application's scalability.  One can think about it as if a
+set of all threads is partitioned into separate groups (processes) where
+each group has a separate pool of resources (virtual address space, file
+descriptors, etc.).  An application designer has full control of how many
+groups (processes) an application creates and what resources, if any,
+are shared among different groups via standard UNIX inter-process
+communication (IPC) facilities.&lt;P&gt;
+There are several reasons for creating multiple processes:
+&lt;P&gt;
+&lt;UL&gt;
+&lt;LI&gt;To take advantage of multiple hardware entities (CPUs, disks, etc.)
+available in the system (hardware parallelism).&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;To reduce risk of losing a large number of user connections when one of
+the processes crashes. For example, if &lt;B&gt;C&lt;/B&gt; user connections (threads)
+are multiplexed onto &lt;B&gt;P&lt;/B&gt; processes and one of the processes crashes,
+only a fraction (&lt;B&gt;C/P&lt;/B&gt;) of all connections will be lost.&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;To overcome per-process resource limitations imposed by the OS.  For
+example, if &lt;TT&gt;select(2)&lt;/TT&gt; is used for event polling, the number of
+simultaneous connections (threads) per process is
+limited by the &lt;TT&gt;FD_SETSIZE&lt;/TT&gt; parameter (see &lt;TT&gt;select(2)&lt;/TT&gt;).
+If &lt;TT&gt;FD_SETSIZE&lt;/TT&gt; is equal to 1024 and each connection needs one file
+descriptor, then an application should create 10 processes to support 10,000
+simultaneous connections.&lt;/LI&gt;
+&lt;/UL&gt;
+&lt;P&gt;
+Ideally all user sessions are completely independent, so there is no need for
+inter-process communication.  It is always better to have several separate
+smaller process-specific resources (e.g., data caches) than to have one large
+resource shared (and modified) by all processes.  Sometimes, however, there
+is a need to share a common resource among different processes.  In that case,
+standard UNIX IPC facilities can be used.  In addition to that, there is a way
+to synchronize different processes so that only the thread accessing the
+shared resource will be suspended (but not the entire process) if that resource
+is unavailable.  In the following code fragment a pipe is used as a counting
+semaphore for inter-process synchronization:
+&lt;PRE&gt;
+#ifndef PIPE_BUF
+#define PIPE_BUF 512  /* POSIX */
+#endif
+
+/* Semaphore data structure */
+typedef struct ipc_sem {
+  st_netfd_t rdfd;  /* read descriptor */
+  st_netfd_t wrfd;  /* write descriptor */
+} ipc_sem_t;
+
+/* Create and initialize the semaphore. Should be called before fork(2). */
+/* 'value' must be less than PIPE_BUF. */
+/* If 'value' is 1, the semaphore works as mutex. */
+ipc_sem_t *ipc_sem_create(int value)
+{
+  ipc_sem_t *sem;
+  int p[2];
+  char b[PIPE_BUF];
+
+  /* Error checking is omitted for clarity */
+  sem = malloc(sizeof(ipc_sem_t));
+
+  /* Create the pipe */
+  pipe(p);
+  sem-&gt;rdfd = st_netfd_open(p[0]);
+  sem-&gt;wrfd = st_netfd_open(p[1]);
+
+  /* Initialize the semaphore: put 'value' bytes into the pipe */
+  write(p[1], b, value);
+
+  return sem;
+}
+
+/* Try to decrement the &quot;value&quot; of the semaphore. */
+/* If &quot;value&quot; is 0, the calling thread blocks on the semaphore. */
+int ipc_sem_wait(ipc_sem_t *sem)
+{
+  char c;
+
+  /* Read one byte from the pipe */
+  if (st_read(sem-&gt;rdfd, &amp;c, 1, -1) != 1)
+    return -1;
+
+  return 0;
+}
+
+/* Increment the &quot;value&quot; of the semaphore. */
+int ipc_sem_post(ipc_sem_t *sem)
+{
+  char c;
+
+  if (st_write(sem-&gt;wrfd, &amp;c, 1, -1) != 1)
+    return -1;
+
+  return 0;
+}
+
+&lt;/PRE&gt;
+&lt;P&gt;
+
+Generally, the following steps should be followed when writing an application
+using the State Threads library:
+&lt;P&gt;
+&lt;OL&gt;
+&lt;LI&gt;Initialize the library (&lt;TT&gt;st_init()&lt;/TT&gt;).&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;Create resources that will be shared among different processes:
+    create and bind listening sockets, create shared memory segments, IPC
+    channels, synchronization primitives, etc.&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;Create several processes (&lt;TT&gt;fork(2)&lt;/TT&gt;). The parent process should
+    either exit or become a &quot;watchdog&quot; (e.g., it starts a new process when
+    an existing one crashes, does a cleanup upon application termination,
+    etc.).&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;In each child process create a pool of threads
+    (&lt;TT&gt;st_thread_create()&lt;/TT&gt;) to handle user connections.&lt;/LI&gt;
+&lt;/OL&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;nonnet&quot;&gt;
+&lt;H3&gt;Non-Network I/O&lt;/H3&gt;
+
+The State Threads architecture uses non-blocking I/O on
+&lt;TT&gt;st_netfd_t&lt;/TT&gt; objects for concurrent processing of multiple user
+connections.  This architecture has a drawback:  the entire process and
+all its threads may block for the duration of a &lt;I&gt;disk&lt;/I&gt; or other
+non-network I/O operation, whether through State Threads I/O functions,
+direct system calls, or standard I/O functions.  (This is applicable
+mostly to disk &lt;I&gt;reads&lt;/I&gt;; disk &lt;I&gt;writes&lt;/I&gt; are usually performed
+asynchronously -- data goes to the buffer cache to be written to disk
+later.)  Fortunately, disk I/O (unlike network I/O) usually takes a
+finite and predictable amount of time, but this may not be true for
+special devices or user input devices (including stdin).  Nevertheless,
+such I/O reduces throughput of the system and increases response times.
+There are several ways to design an application to overcome this
+drawback:
+
+&lt;P&gt;
+&lt;UL&gt;
+&lt;LI&gt;Create several identical main processes as described above (symmetric
+    architecture).  This will improve CPU utilization and thus improve the
+    overall throughput of the system.&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;Create multiple &quot;helper&quot; processes in addition to the main process that
+    will handle blocking I/O operations (asymmetric architecture).
+    This approach was suggested for Web servers in a
+    &lt;A HREF=&quot;<A HREF="http://www.cs.rice.edu/~vivek/flash99/">http://www.cs.rice.edu/~vivek/flash99/</A>&quot;&gt;paper&lt;/A&gt; by Peter
+    Druschel et al. In this architecture the main process communicates with
+    a helper process via an IPC channel (&lt;TT&gt;pipe(2), socketpair(2)&lt;/TT&gt;).
+    The main process instructs a helper to perform the potentially blocking
+    operation.  Once the operation completes, the helper returns a
+    notification via IPC.
+&lt;/UL&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;timeouts&quot;&gt;
+&lt;H3&gt;Timeouts&lt;/H3&gt;
+
+The &lt;TT&gt;timeout&lt;/TT&gt; parameter to &lt;TT&gt;st_cond_timedwait()&lt;/TT&gt; and the
+I/O functions, and the arguments to &lt;TT&gt;st_sleep()&lt;/TT&gt; and
+&lt;TT&gt;st_usleep()&lt;/TT&gt; specify a maximum time to wait &lt;I&gt;since the last
+context switch&lt;/I&gt; not since the beginning of the function call.
+
+&lt;P&gt;The State Threads' time resolution is actually the time interval
+between context switches.  That time interval may be large in some
+situations, for example, when a single thread does a lot of work
+continuously.  Note that a steady, uninterrupted stream of network I/O
+qualifies for this description; a context switch occurs only when a
+thread blocks.
+
+&lt;P&gt;If a specified I/O timeout is less than the time interval between
+context switches the function may return with a timeout error before
+that amount of time has elapsed since the beginning of the function
+call.  For example, if eight milliseconds have passed since the last
+context switch and an I/O function with a timeout of 10 milliseconds
+blocks, causing a switch, the call may return with a timeout error as
+little as two milliseconds after it was called.  (On Linux,
+&lt;TT&gt;select()&lt;/TT&gt;'s timeout is an &lt;I&gt;upper&lt;/I&gt; bound on the amount of
+time elapsed before select returns.)  Similarly, if 12 ms have passed
+already, the function may return immediately.
+
+&lt;P&gt;In almost all cases I/O timeouts should be used only for detecting a
+broken network connection or for preventing a peer from holding an idle
+connection for too long.  Therefore for most applications realistic I/O
+timeouts should be on the order of seconds.  Furthermore, there's
+probably no point in retrying operations that time out.  Rather than
+retrying simply use a larger timeout in the first place.
+
+&lt;P&gt;The largest valid timeout value is platform-dependent and may be
+significantly less than &lt;TT&gt;INT_MAX&lt;/TT&gt; seconds for &lt;TT&gt;select()&lt;/TT&gt;
+or &lt;TT&gt;INT_MAX&lt;/TT&gt; milliseconds for &lt;TT&gt;poll()&lt;/TT&gt;.  Generally, you
+should not use timeouts exceeding several hours.  Use -1 as a special
+value to indicate infinite timeout or indefinite sleep.
+
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;/BODY&gt;
+&lt;/HTML&gt;
+

Added: upwatch/trunk/st-1.6/docs/reference.html
===================================================================
--- upwatch/trunk/st-1.6/docs/reference.html	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/docs/reference.html	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,2714 @@
+&lt;HTML&gt;
+&lt;HEAD&gt;
+&lt;TITLE&gt;State Threads Library Reference&lt;/TITLE&gt;
+&lt;/HEAD&gt;
+&lt;BODY BGCOLOR=#FFFFFF&gt;
+
+&lt;H2&gt;State Threads Library Reference&lt;/H2&gt;
+
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#types&gt;&lt;B&gt;Types&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_t&gt;st_thread_t&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_t&gt;st_cond_t&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_t&gt;st_mutex_t&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#utime_t&gt;st_utime_t&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_t&gt;st_netfd_t&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#switch_cb_t&gt;st_switch_cb_t&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#errors&gt;&lt;B&gt;Error Handling&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#init&gt;&lt;B&gt;Library Initialization&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#st_init&gt;st_init()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#st_getfdlimit&gt;st_getfdlimit()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#switch_cb_t&gt;&lt;B&gt;st_switch_cb_t&lt;/B&gt; type&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#st_set_switch_in_cb&gt;st_set_switch_in_cb()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#st_set_switch_out_cb&gt;st_set_switch_out_cb()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#threads&gt;&lt;B&gt;Thread Control and Identification&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_t&gt;&lt;B&gt;st_thread_t&lt;/B&gt; type&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_create&gt;st_thread_create()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_exit&gt;st_thread_exit()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_join&gt;st_thread_join()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_self&gt;st_thread_self()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#sleep&gt;st_sleep()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#sleep&gt;st_usleep()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#randomize_stacks&gt;st_randomize_stacks()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#priv&gt;&lt;B&gt;Per-Thread Private Data&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#key_create&gt;st_key_create()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#key_getlimit&gt;st_key_getlimit()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_setspecific&gt;st_thread_setspecific()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#thread_getspecific&gt;st_thread_getspecific()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#sync&gt;&lt;B&gt;Synchronization&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_t&gt;&lt;B&gt;st_cond_t&lt;/B&gt; type&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_new&gt;st_cond_new()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_destroy&gt;st_cond_destroy()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_wait&gt;st_cond_wait()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_timedwait&gt;st_cond_timedwait()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_signal&gt;st_cond_signal()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#cond_broadcast&gt;st_cond_broadcast()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_t&gt;&lt;B&gt;st_mutex_t&lt;/B&gt; type&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_new&gt;st_mutex_new()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_destroy&gt;st_mutex_destroy()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_lock&gt;st_mutex_lock()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_trylock&gt;st_mutex_trylock()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#mutex_unlock&gt;st_mutex_unlock()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#timing&gt;&lt;B&gt;Timing&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt; type&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#utime&gt;st_utime()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#utime_func&gt;st_set_utime_function()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#timecache_set&gt;st_timecache_set()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#time&gt;st_time()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#io&gt;&lt;B&gt;I/O Functions&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt; type&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_open_socket&gt;st_netfd_open_socket()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_free&gt;st_netfd_free()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_close&gt;st_netfd_close()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_fileno&gt;st_netfd_fileno()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_setspecific&gt;st_netfd_setspecific()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_getspecific&gt;st_netfd_getspecific()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_serialize_accept&gt;st_netfd_serialize_accept()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#netfd_poll&gt;st_netfd_poll()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#accept&gt;st_accept()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#connect&gt;st_connect()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#read&gt;st_read()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#read_fully&gt;st_read_fully()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#read_resid&gt;st_read_resid()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#write&gt;st_write()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#write_resid&gt;st_write_resid()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#writev&gt;st_writev()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#recvfrom&gt;st_recvfrom()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#sendto&gt;st_sendto()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#recvmsg&gt;st_recvmsg()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#sendmsg&gt;st_sendmsg()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#open&gt;st_open()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;DL&gt;&lt;DD&gt;&lt;A HREF=#poll&gt;st_poll()&lt;/A&gt;&lt;/DD&gt;&lt;/DL&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#progr&gt;&lt;B&gt;Program Structure&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#block&gt;&lt;B&gt;List of Blocking Functions&lt;/B&gt;&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+
+&lt;A NAME=&quot;types&quot;&gt;
+&lt;H2&gt;Types&lt;/H2&gt;
+&lt;/A&gt;
+The State Thread library defines the following types in the &lt;TT&gt;st.h&lt;/TT&gt;
+header file:
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#thread_t&gt;st_thread_t&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_t&gt;st_cond_t&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_t&gt;st_mutex_t&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#utime_t&gt;st_utime_t&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_t&gt;st_netfd_t&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;thread_t&quot;&gt;
+&lt;H4&gt;st_thread_t&lt;/H4&gt;
+&lt;/A&gt;
+Thread type.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+typedef void *  st_thread_t;
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+
+A thread is represented and identified by a pointer to an opaque data
+structure. This pointer is a required parameter for most of the functions
+that operate on threads.
+&lt;P&gt;
+The thread identifier remains valid until the thread returns from its root
+function and, if the thread was created joinable, is joined.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;cond_t&quot;&gt;
+&lt;H4&gt;st_cond_t&lt;/H4&gt;
+&lt;/A&gt;
+Condition variable type.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+typedef void *  st_cond_t;
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+
+A condition variable is an opaque object identified by a pointer.
+Condition variables provide synchronization primitives to wait for or wake
+up threads waiting for certain conditions to be satisfied.
+&lt;P&gt;
+In the State Threads library there is no need to lock a mutex before
+waiting on a condition variable.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;mutex_t&quot;&gt;
+&lt;H4&gt;st_mutex_t&lt;/H4&gt;
+&lt;/A&gt;
+Mutex type.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+typedef void *  st_mutex_t;
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+
+A mutex is an opaque object identified by a pointer.
+Mutual exclusion locks (mutexes) are used to serialize the execution of
+threads through critical sections of code.
+&lt;P&gt;
+If application using the State Threads library is written with no
+I/O or control yielding in critical sections (that is no
+&lt;A HREF=#block&gt;blocking functions&lt;/A&gt; in critical sections), then there is
+no need for mutexes.&lt;P&gt;
+These mutexes can only be used for intra-process thread synchronization.
+They cannot be used for inter-process synchronization.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;utime_t&quot;&gt;
+&lt;H4&gt;st_utime_t&lt;/H4&gt;
+&lt;/A&gt;
+High resolution time type (&quot;u&quot; stands for &quot;micro&quot;).
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+typedef unsigned long long  st_utime_t;
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+
+This datatype (unsigned 64-bit integer) represents high-resolution real time
+expressed in microseconds since some arbitrary time in the past. It is not
+correlated in any way to the time of day.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;netfd_t&quot;&gt;
+&lt;H4&gt;st_netfd_t&lt;/H4&gt;
+&lt;/A&gt;
+File descriptor type.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+typedef void *  st_netfd_t;
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+
+This datatype typically represents any open end point of network
+communication (socket, end point of a pipe, FIFO, etc.) but can
+encapsulate any open file descriptor.  Objects of this type are
+identified by a pointer to an opaque data structure.
+
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;switch_cb_t&quot;&gt;
+&lt;H4&gt;st_switch_cb_t&lt;/H4&gt;
+&lt;/A&gt;
+Context switch callback function type.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+typedef void (*st_switch_cb_t)(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+
+This datatype is a convenience type for describing a pointer
+to a function that will be called when a thread is set to stop
+or set to run.
+This feature is available only when &lt;TT&gt;ST_SWITCH_CB&lt;/TT&gt; is defined
+in &lt;TT&gt;&lt;st.h&gt;&lt;/TT&gt;.
+
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;errors&quot;&gt;
+&lt;H2&gt;Error Handling&lt;/H2&gt;
+&lt;/A&gt;
+
+All State Threads library non-void functions return on success either a
+non-negative integer or a pointer to a newly created object (constructor-type
+functions). On failure they return either &lt;TT&gt;-1&lt;/TT&gt; or a &lt;TT&gt;NULL&lt;/TT&gt;
+pointer respectively and set global &lt;TT&gt;errno&lt;/TT&gt; to indicate the error.
+It is safe to use &lt;TT&gt;errno&lt;/TT&gt; because it is set right before the function
+return and only one thread at a time can modify its value.&lt;P&gt;
+The &lt;TT&gt;perror(3)&lt;/TT&gt; function can be used to produce an error message on the
+standard error output.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;init&quot;&gt;
+&lt;H2&gt;Library Initialization&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#st_init&gt;st_init()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#st_getfdlimit&gt;st_getfdlimit()&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+These functions operate on a callback function of type
+&lt;A HREF=#switch_cb_t&gt;&lt;B&gt;st_switch_cb_t&lt;/B&gt;&lt;/A&gt;:
+&lt;DD&gt;&lt;A HREF=#st_set_switch_in_cb&gt;st_set_switch_in_cb()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#st_set_switch_out_cb&gt;st_set_switch_out_cb()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;st_init&quot;&gt;
+&lt;H4&gt;st_init()&lt;/H4&gt;
+&lt;/A&gt;
+Initializes the runtime.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_init(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function initializes the library runtime. It should be called near
+the beginning of the application's &lt;TT&gt;main()&lt;/TT&gt; function before any other
+State Threads library function is called.&lt;P&gt;
+Among other things, this function limits the number of open file descriptors
+to the OS imposed per-process maximum number or, if &lt;TT&gt;select(2)&lt;/TT&gt; is
+used, to &lt;TT&gt;FD_SETSIZE&lt;/TT&gt;, whichever is less (&lt;TT&gt;getrlimit(2)&lt;/TT&gt;).
+This limit can be
+retrieved by &lt;A HREF=#st_getfdlimit&gt;st_getfdlimit()&lt;/A&gt;. It also sets the
+disposition of the &lt;TT&gt;SIGPIPE&lt;/TT&gt; signal to &lt;TT&gt;SIG_IGN&lt;/TT&gt; (to be ignored)
+(&lt;TT&gt;signal(5)&lt;/TT&gt;).
+&lt;P&gt;
+Unlike POSIX threads, a new process created by the &lt;TT&gt;fork(2)&lt;/TT&gt; system
+call is an &lt;I&gt;exact&lt;/I&gt; copy of the calling process and all state threads
+which are running in the parent do exist in the child. That means that
+&lt;TT&gt;st_init()&lt;/TT&gt; may be called either before or after multiple processes
+are created by &lt;TT&gt;fork(2)&lt;/TT&gt;.
+&lt;P&gt;
+If the library runtime is not properly initialized (e.g., &lt;TT&gt;st_init()&lt;/TT&gt;
+is accidentally omitted), then the process will receive either an arithmetic
+exception (SIGFPE or SIGTRAP) or segmentation fault (SIGSEGV) signal upon
+new thread creation or the first context switch, respectively.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;st_getfdlimit&quot;&gt;
+&lt;H4&gt;st_getfdlimit()&lt;/H4&gt;
+&lt;/A&gt;
+Returns the maximum number of file descriptors that the calling process
+can open.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_getfdlimit(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The maximum number of file descriptors that the calling process can open.
+If this function is called before the library is successfully initialized by
+&lt;A HREF=#st_init&gt;st_init()&lt;/A&gt;, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function returns the limit on the number of open file descriptors which
+is set by the &lt;A HREF=#st_init&gt;st_init()&lt;/A&gt; function.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;st_set_switch_in_cb&quot;&gt;
+&lt;H4&gt;st_set_switch_in_cb()&lt;/H4&gt;
+&lt;/A&gt;
+&lt;A NAME=&quot;st_set_switch_out_cb&quot;&gt;
+&lt;H4&gt;st_set_switch_out_cb()&lt;/H4&gt;
+&lt;/A&gt;
+Set the optional callback function for thread switches.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_switch_cb_t st_set_switch_in_cb(st_switch_cb_t cb);
+st_switch_cb_t st_set_switch_out_cb(st_switch_cb_t cb);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_set_switch_in_cb()&lt;/TT&gt; and &lt;TT&gt;st_set_switch_out_cb()&lt;/TT&gt; have the
+following parameter:&lt;P&gt;
+&lt;TT&gt;cb&lt;/TT&gt;&lt;P&gt;
+A function to be called when a thread is resumed and stopped respectively.&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The previous callback function pointer.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+These functions set the callback for when a thread is resumed and stopped
+respectively.  After being called any thread switch will call the callback.
+Use a &lt;TT&gt;NULL&lt;/TT&gt; pointer to disable the callback (this is the default).
+Use &lt;A HREF=#thread_self&gt;st_thread_self()&lt;/A&gt; or &lt;A HREF=#priv&gt;thread
+specific data&lt;/A&gt; to differentiate between threads.&lt;P&gt;
+These functions can be called at any time.&lt;P&gt;
+This feature is available only when &lt;TT&gt;ST_SWITCH_CB&lt;/TT&gt; is defined
+in &lt;TT&gt;&lt;st.h&gt;&lt;/TT&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;threads&quot;&gt;
+&lt;H2&gt;Thread Control and Identification&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+These functions operate on a thread object of type
+&lt;A HREF=#thread_t&gt;&lt;B&gt;st_thread_t&lt;/B&gt;&lt;/A&gt;.
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#thread_create&gt;st_thread_create()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#thread_exit&gt;st_thread_exit()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#thread_join&gt;st_thread_join()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#thread_self&gt;st_thread_self()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sleep&gt;st_sleep()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sleep&gt;st_usleep()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#randomize_stacks&gt;st_randomize_stacks()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_create&quot;&gt;
+&lt;H4&gt;st_thread_create()&lt;/H4&gt;
+&lt;/A&gt;
+Creates a new thread.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_thread_t st_thread_create(void *(*start)(void *arg), void *arg,
+                             int joinable, int stack_size);
+
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_thread_create()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;start&lt;/TT&gt;&lt;P&gt;
+A pointer to the thread's start function, which is called as the root of the
+new thread. Return from this function terminates a thread.&lt;P&gt;
+&lt;TT&gt;arg&lt;/TT&gt;&lt;P&gt;
+A pointer to the root function's only parameter.&lt;P&gt;
+&lt;TT&gt;joinable&lt;/TT&gt;&lt;P&gt;
+Specifies whether the thread is joinable or unjoinable. If this parameter
+is zero, the thread is unjoinable. Otherwise, it is joinable.
+See also &lt;A HREF=#thread_join&gt;st_thread_join()&lt;/A&gt;.&lt;P&gt;
+&lt;TT&gt;stack_size&lt;/TT&gt;&lt;P&gt;
+Specifies your preference for the size of the stack, in bytes, associated
+with the newly created thread. If you pass zero in this parameter, the
+default stack size will be used. The default stack size is 128 KB on IA-64
+and 64 KB on all other platforms. On IA-64 only a half of &lt;TT&gt;stack_size&lt;/TT&gt;
+bytes is used for the memory stack. The other half is used for the register
+stack backing store.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new thread identifier is returned (this
+identifier remains valid until the thread returns from its start function).
+Otherwise, &lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function creates a new thread. Note that the total number of threads
+created by the application is limited by the amount of swap space available.
+Upon thread creation, &lt;TT&gt;stack_size&lt;/TT&gt; bytes are reserved on the swap
+space. The stack pages are not actually used (valid) until touched by the
+application.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_exit&quot;&gt;
+&lt;H4&gt;st_thread_exit()&lt;/H4&gt;
+&lt;/A&gt;
+Terminates the calling thread.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+void st_thread_exit(void *retval);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_thread_exit()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;retval&lt;/TT&gt;&lt;P&gt;
+If the thread is joinable, then the value &lt;TT&gt;retval&lt;/TT&gt; may be retrieved
+by &lt;A HREF=#thread_join&gt;st_thread_join()&lt;/A&gt;. If a thread returns from its
+start function, it acts as if it had called &lt;TT&gt;st_thread_exit()&lt;/TT&gt; with 
+&lt;TT&gt;retval&lt;/TT&gt; as the value returned.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Nothing.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function terminates the calling thread. When a thread exits, per-thread
+private data is destroyed by invoking the destructor function for any
+non-&lt;TT&gt;NULL&lt;/TT&gt; thread specific values associated with active keys (see
+&lt;A HREF=#key_create&gt;st_key_create()&lt;/A&gt;). This function is implicitly called
+when a thread returns from its start function.&lt;P&gt;
+When the last thread terminates the process exits with a zero status value.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_join&quot;&gt;
+&lt;H4&gt;st_thread_join()&lt;/H4&gt;
+&lt;/A&gt;
+Blocks the calling thread until a specified thread terminates.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_thread_join(st_thread_t thread, void **retvalp);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_thread_join()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;thread&lt;/TT&gt;&lt;P&gt;
+A valid identifier for the thread that is to be joined.&lt;P&gt;
+&lt;TT&gt;retvalp&lt;/TT&gt;&lt;P&gt;
+If this parameter is not &lt;TT&gt;NULL&lt;/TT&gt;, then the exit value of the
+&lt;TT&gt;thread&lt;/TT&gt; will be placed in the location referenced by this parameter
+(see &lt;A HREF=#thread_exit&gt;st_thread_exit()&lt;/A&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINVAL&lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;Target thread is unjoinable.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINVAL&lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;Other thread already waits on the same
+joinable thread.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EDEADLK &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;Target thread is the same as the
+calling thread.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;Current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function is used to synchronize the termination of a thread and possibly
+retrieve its exit value. Several threads cannot wait for the same thread
+to complete - one of the calling threads operates successfully, and the others
+terminate with the error. The calling thread is not blocked if the target
+thread has already terminated.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_self&quot;&gt;
+&lt;H4&gt;st_thread_self()&lt;/H4&gt;
+&lt;/A&gt;
+Identifies the calling thread.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_thread_t st_thread_self(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Always returns a valid reference to the calling thread - a self-identity.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function identifies the calling thread. This is the same identifier
+that the creating thread obtains from
+&lt;A HREF=#thread_create&gt;st_thread_create()&lt;/A&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_interrupt&quot;&gt;
+&lt;H4&gt;st_thread_interrupt()&lt;/H4&gt;
+&lt;/A&gt;
+Interrupts a target thread.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+void st_thread_interrupt(st_thread_t thread);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_thread_interrupt()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;thread&lt;/TT&gt;&lt;P&gt;
+A valid identifier for the thread being interrupted.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Nothing.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function interrupts (unblocks) a target thread that is blocked in one
+of the &lt;A HREF=#block&gt;blocking functions&lt;/A&gt;. A function that was interrupted
+returns an error and sets &lt;TT&gt;errno&lt;/TT&gt; to &lt;TT&gt;EINTR&lt;/TT&gt;. It is up to
+the target thread to act upon an interrupt (e.g., it may exit or just
+abort the current transaction).&lt;P&gt;
+&lt;B&gt;Note: &lt;/B&gt; State Threads library functions are never interrupted by a
+caught signal. A blocking library function returns an error and sets
+&lt;TT&gt;errno&lt;/TT&gt; to &lt;TT&gt;EINTR&lt;/TT&gt; &lt;I&gt;only&lt;/I&gt; if the current thread was
+interrupted via &lt;TT&gt;st_thread_interrupt()&lt;/TT&gt;.
+&lt;P&gt;
+If a target thread is already runnable or running (e.g., it is a newly
+created thread or calling thread itself), this function will prevent it
+from subsequent blocking. In other words, the interrupt will be &quot;delivered&quot;
+only when a target thread is about to block.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;sleep&quot;&gt;
+&lt;H4&gt;st_sleep(), st_usleep()&lt;/H4&gt;
+&lt;/A&gt;
+Suspends current thread for a specified amount of time.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_sleep(int secs);
+
+int st_usleep(st_utime_t usecs);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_sleep()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;secs&lt;/TT&gt;&lt;P&gt;
+The number of seconds you want the thread to sleep for.
+&lt;P&gt;
+&lt;TT&gt;st_usleep()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;usecs&lt;/TT&gt;&lt;P&gt;
+The number of microseconds you want the thread to sleep for. This parameter
+is a variable of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+These functions suspend the calling thread from execution for a specified
+number of seconds (&lt;TT&gt;st_sleep()&lt;/TT&gt;) or microseconds (&lt;TT&gt;st_usleep()&lt;/TT&gt;).
+&lt;P&gt;
+If zero is passed as a parameter to these functions, the calling thread yields,
+thus potentially allowing another thread to run.
+&lt;P&gt;
+If &lt;TT&gt;-1&lt;/TT&gt; is passed as a parameter to these functions, the calling thread
+will be suspended permanently. It can be resumed again by interrupting it via
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;randomize_stacks&quot;&gt;
+&lt;H4&gt;st_randomize_stacks()&lt;/H4&gt;
+&lt;/A&gt;
+Turns stack base address randomization on or off.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_randomize_stacks(int on);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_randomize_stacks()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;on&lt;/TT&gt;&lt;P&gt;
+If this parameter has a non-zero value, the State Threads library
+randomizes the base addresses of stacks allocated for threads created
+after this call.  Otherwise new threads' stacks are typically page
+aligned.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The previous state of stack randomization (a value of &lt;TT&gt;0&lt;/TT&gt; if it
+was off and a nonzero value otherwise).
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+Randomizing state threads' stack bases may improve cache performance on
+some systems when large numbers of state threads all perform roughly the
+same work, as when they all start from the same root function.  On many
+modern systems the performance increase is negligible.  You should
+compare your application's performance with this feature on and off to
+see if you really need it.
+&lt;P&gt;
+When randomization is enabled, new stacks are allocated one page larger
+to accomodate the randomization.
+&lt;P&gt;
+This call affects only threads created afterward.  It has no effect on
+existing threads.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;priv&quot;&gt;
+&lt;H2&gt;Per-Thread Private Data&lt;/H2&gt;
+&lt;/A&gt;
+These functions allow to associate private data with each of the threads in
+a process.
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#key_create&gt;st_key_create()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#key_getlimit&gt;st_key_getlimit()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#thread_setspecific&gt;st_thread_setspecific()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#thread_getspecific&gt;st_thread_getspecific()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;key_create&quot;&gt;
+&lt;H4&gt;st_key_create()&lt;/H4&gt;
+&lt;/A&gt;
+Creates a key (non-negative integer) that can be used by all
+threads in the process to get and set thread-specific data.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_key_create(int *keyp, void (*destructor)(void *));
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_key_create()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;keyp&lt;/TT&gt;&lt;P&gt;
+The newly created key is returned in the memory pointed to by this parameter.
+The new key can be used with
+&lt;A HREF=#thread_setspecific&gt;st_thread_setspecific()&lt;/A&gt; and
+&lt;A HREF=#thread_getspecific&gt;st_thread_getspecific()&lt;/A&gt;.&lt;P&gt;
+&lt;TT&gt;destructor&lt;/TT&gt;&lt;P&gt;
+Specifies an optional destructor function for the private data associated
+with the key. This function can be specified as &lt;TT&gt;NULL&lt;/TT&gt;.
+Upon thread exit (see &lt;A HREF=#thread_exit&gt;st_thread_exit()&lt;/A&gt;), if a key
+has a non-&lt;TT&gt;NULL&lt;/TT&gt; &lt;TT&gt;destructor&lt;/TT&gt; and has a non-&lt;TT&gt;NULL&lt;/TT&gt; value
+associated with that key, then the &lt;TT&gt;destructor&lt;/TT&gt; function will be
+called with the associated value.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EAGAIN &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The limit on the total number of keys per
+process has been exceeded (see &lt;A HREF=#key_getlimit&gt;st_key_getlimit()&lt;/A&gt;).
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+If this function is successful, every thread in the same process is capable
+of associating private data with the new key. After a new key is created, all
+active threads have the value &lt;TT&gt;NULL&lt;/TT&gt; associated with that key.
+After a new thread is created, the value &lt;TT&gt;NULL&lt;/TT&gt; is associated with
+all keys for that thread.  If a non-&lt;TT&gt;NULL&lt;/TT&gt; destructor function is
+registered with a new key, it will be called at one of two times, as long as
+the private data is not &lt;TT&gt;NULL&lt;/TT&gt;:
+&lt;UL&gt;
+&lt;LI&gt;when replacement private data is set with
+&lt;A HREF=#thread_setspecific&gt;st_thread_setspecific()&lt;/A&gt;&lt;/LI&gt;
+&lt;LI&gt;when a thread exits (see &lt;A HREF=#thread_exit&gt;st_thread_exit()&lt;/A&gt;)&lt;/LI&gt;
+&lt;/UL&gt;
+&lt;P&gt;
+The key maintains independent data values for each binding thread. A thread
+can get access only to its own thread-specific data. There is no way to
+deallocate a private data key once it is allocated.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;key_getlimit&quot;&gt;
+&lt;H4&gt;st_key_getlimit()&lt;/H4&gt;
+&lt;/A&gt;
+Returns the key limit.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_key_getlimit(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The limit on the total number of keys per process.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function can be used to obtain the limit on the total number of keys
+per process (see &lt;A HREF=#key_create&gt;st_key_create()&lt;/A&gt;).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_setspecific&quot;&gt;
+&lt;H4&gt;st_thread_setspecific()&lt;/H4&gt;
+&lt;/A&gt;
+Sets per-thread private data.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_thread_setspecific(int key, void *value);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_thread_setspecific()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;key&lt;/TT&gt;&lt;P&gt;
+This parameter represents a key with which thread-specific data is associated.
+&lt;P&gt;
+&lt;TT&gt;value&lt;/TT&gt;&lt;P&gt;
+The per-thread private data, or more likely, a pointer to the data which is
+associated with &lt;TT&gt;key&lt;/TT&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINVAL &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The specified &lt;TT&gt;key&lt;/TT&gt; is invalid.&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function associates a thread-specific &lt;TT&gt;value&lt;/TT&gt; with &lt;TT&gt;key&lt;/TT&gt;.
+Different threads may bind different values to the same key.&lt;P&gt;
+If the thread already has non-&lt;TT&gt;NULL&lt;/TT&gt; private data associated with
+&lt;TT&gt;key&lt;/TT&gt;, and if the destructor function for that key is not
+&lt;TT&gt;NULL&lt;/TT&gt;, this destructor function will be called before setting the
+new data value.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;thread_getspecific&quot;&gt;
+&lt;H4&gt;st_thread_getspecific()&lt;/H4&gt;
+&lt;/A&gt;
+Retrieves the per-thread private data for the current thread.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+void *st_thread_getspecific(int key);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_thread_getspecific()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;key&lt;/TT&gt;&lt;P&gt;
+This parameter represents a key with which thread-specific data is associated.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The thread-specific data associated with &lt;TT&gt;key&lt;/TT&gt;. If no data is
+associated with &lt;TT&gt;key&lt;/TT&gt;, then &lt;TT&gt;NULL&lt;/TT&gt; is returned.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function returns the calling thread's value that is bound to the
+specified &lt;TT&gt;key&lt;/TT&gt; (see
+&lt;A HREF=#thread_setspecific&gt;st_thread_setspecific()&lt;/A&gt;).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;sync&quot;&gt;
+&lt;H2&gt;Synchronization&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+These functions operate on &lt;A HREF=#cond_t&gt;condition variables&lt;/A&gt;
+and &lt;A HREF=#mutex_t&gt;mutual exclusion locks&lt;/A&gt; (mutexes).&lt;P&gt;
+Functions are provided to wait on a condition variable and to wake up
+(signal) threads that are waiting on the condition variable.
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#cond_new&gt;st_cond_new()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_destroy&gt;st_cond_destroy()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_wait&gt;st_cond_wait()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_timedwait&gt;st_cond_timedwait()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_signal&gt;st_cond_signal()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_broadcast&gt;st_cond_broadcast()&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_new&gt;st_mutex_new()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_destroy&gt;st_mutex_destroy()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_lock&gt;st_mutex_lock()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_trylock&gt;st_mutex_trylock()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_unlock&gt;st_mutex_unlock()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;cond_new&quot;&gt;
+&lt;H4&gt;st_cond_new()&lt;/H4&gt;
+&lt;/A&gt;
+Creates a new condition variable.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_cond_t st_cond_new(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new condition variable identifier is returned.
+Otherwise, &lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function creates a new condition variable.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;cond_destroy&quot;&gt;
+&lt;H4&gt;st_cond_destroy()&lt;/H4&gt;
+&lt;/A&gt;
+Destroys a condition variable.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_cond_destroy(st_cond_t cvar);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_cond_destroy()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;cvar&lt;/TT&gt;&lt;P&gt;
+An identifier of the condition variable object to be destroyed.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EBUSY &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The condition variable is currently being
+used by one or more threads.&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function destroys a condition variable. The caller is responsible for
+ensuring that the condition variable is no longer in use.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;cond_wait&quot;&gt;
+&lt;H4&gt;st_cond_wait()&lt;/H4&gt;
+&lt;/A&gt;
+Waits on a condition.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_cond_wait(st_cond_t cvar);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_cond_wait()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;cvar&lt;/TT&gt;&lt;P&gt;
+The condition variable on which to wait.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function is used to block on a condition variable. A return from this
+function does not guarantee that the condition or event for which the caller
+was waiting actually occurred. It is the responsibility of the caller
+to recheck the condition wait predicate before proceeding.&lt;P&gt;
+&lt;B&gt;Note:&lt;/B&gt; The State Threads library scheduling guarantees that the
+condition cannot change between the checking and blocking, therefore there
+is no need for mutex protection. You must not call any
+&lt;A HREF=#block&gt;blocking functions&lt;/A&gt; between the condition checking and
+the &lt;TT&gt;st_cond_wait()&lt;/TT&gt; call.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;cond_timedwait&quot;&gt;
+&lt;H4&gt;st_cond_timedwait()&lt;/H4&gt;
+&lt;/A&gt;
+Waits on a condition.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_cond_timedwait(st_cond_t cvar, st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_cond_timedwait()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;cvar&lt;/TT&gt;&lt;P&gt;
+The condition variable on which to wait.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+If the number of microseconds specified by this parameter passes before the
+waiting thread is signalled, an error is returned. This parameter is a
+variable of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt;. Note that this
+time value is a &lt;I&gt;time delta&lt;/I&gt;; it is not an &lt;I&gt;absolute time&lt;/I&gt;.
+Also note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since
+the last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred before the thread was
+awakened by &lt;A HREF=#cond_signal&gt;st_cond_signal()&lt;/A&gt; or
+&lt;A HREF=#cond_broadcast&gt;st_cond_broadcast()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function works the same way as &lt;A HREF=#cond_wait&gt;st_cond_wait()&lt;/A&gt;,
+except that an error is returned if the number of microseconds specified by
+&lt;TT&gt;timeout&lt;/TT&gt; passes before the waiting thread is signalled.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;cond_signal&quot;&gt;
+&lt;H4&gt;st_cond_signal()&lt;/H4&gt;
+&lt;/A&gt;
+Unblocks a thread waiting on a condition variable.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_cond_signal(st_cond_t cvar);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_cond_signal()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;cvar&lt;/TT&gt;&lt;P&gt;
+The condition variable to signal.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Always zero.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function unblocks (signals) one of the threads that are blocked on
+&lt;TT&gt;cvar&lt;/TT&gt; at the time of the call.  If no thread is waiting on the
+condition variable, the signal operation is a no-op.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;cond_broadcast&quot;&gt;
+&lt;H4&gt;st_cond_broadcast()&lt;/H4&gt;
+&lt;/A&gt;
+Unblocks all threads waiting on a condition variable.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_cond_broadcast(st_cond_t cvar);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_cond_broadcast()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;cvar&lt;/TT&gt;&lt;P&gt;
+The condition variable to broadcast.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Always zero.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function unblocks all threads blocked on the specified condition
+variable at the time of the call. If no threads are waiting, this operation
+is a no-op.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;mutex_new&quot;&gt;
+&lt;H4&gt;st_mutex_new()&lt;/H4&gt;
+&lt;/A&gt;
+Creates a new mutual exclusion lock (mutex).
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_mutex_t st_mutex_new(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new mutex identifier is returned.
+Otherwise, &lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set to
+indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function creates a new opaque mutual exclusion lock (see
+&lt;A HREF=#mutex_t&gt;&lt;B&gt;st_mutex_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;mutex_destroy&quot;&gt;
+&lt;H4&gt;st_mutex_destroy()&lt;/H4&gt;
+&lt;/A&gt;
+Destroys a specified mutex object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_mutex_destroy(st_mutex_t lock);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_mutex_destroy()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;lock&lt;/TT&gt;&lt;P&gt;
+An identifier of the mutex object to be destroyed.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EBUSY &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The mutex is currently being used by
+other threads.&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function destroys a mutex. The caller is responsible for ensuring
+that the mutex is no longer in use.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;mutex_lock&quot;&gt;
+&lt;H4&gt;st_mutex_lock()&lt;/H4&gt;
+&lt;/A&gt;
+Locks a specified mutex object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_mutex_lock(st_mutex_t lock);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_mutex_lock()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;lock&lt;/TT&gt;&lt;P&gt;
+An identifier of the mutex object to be locked.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EDEADLK &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread already owns the mutex.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+A thread that calls this function will block until it can gain exclusive
+ownership of a mutex, and retains ownership until it calls
+&lt;A HREF=#mutex_unlock&gt;st_mutex_unlock()&lt;/A&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;mutex_trylock&quot;&gt;
+&lt;H4&gt;st_mutex_trylock()&lt;/H4&gt;
+&lt;/A&gt;
+Attempts to acquire a mutex.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_mutex_trylock(st_mutex_t lock);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_mutex_trylock()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;lock&lt;/TT&gt;&lt;P&gt;
+An identifier of the mutex object to be locked.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EBUSY &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The mutex is currently held by another
+thread.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function attempts to acquire a mutex. If the mutex object is locked
+(by any thread, including the current thread), the call returns immediately
+with an error.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;mutex_unlock&quot;&gt;
+&lt;H4&gt;st_mutex_unlock()&lt;/H4&gt;
+&lt;/A&gt;
+Releases a specified mutex object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_mutex_unlock(st_mutex_t lock);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_mutex_unlock()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;lock&lt;/TT&gt;&lt;P&gt;
+An identifier of the mutex object to be unlocked.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EPERM &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread does not own the mutex.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function releases a specified mutex object previously acquired by
+&lt;A HREF=#mutex_lock&gt;st_mutex_lock()&lt;/A&gt; or
+&lt;A HREF=#mutex_trylock&gt;st_mutex_trylock()&lt;/A&gt;. Only the thread that locked
+a mutex should unlock it.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;timing&quot;&gt;
+&lt;H2&gt;Timing&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#utime&gt;st_utime()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#utime_func&gt;st_set_utime_function()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#timecache_set&gt;st_timecache_set()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#time&gt;st_time()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;utime&quot;&gt;
+&lt;H4&gt;st_utime()&lt;/H4&gt;
+&lt;/A&gt;
+Returns current high-resolution time.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_utime_t st_utime(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Current high-resolution time value of type
+&lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function returns the current high-resolution time. Time is expressed as
+microseconds since some arbitrary time in the past. It is not correlated in
+any way to the time of day (see &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;utime_func&quot;&gt;
+&lt;H4&gt;st_set_utime_function()&lt;/H4&gt;
+&lt;/A&gt;
+Set high-resolution time function.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_set_utime_function(st_utime_t (*func)(void));
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_set_utime_function()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;func&lt;/TT&gt;&lt;P&gt;
+This function will be called to get high-resolution time instead of the
+default &lt;A HREF=#utime&gt;st_utime()&lt;/A&gt; function. It must return
+number of microseconds since some arbitrary time in the past.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to &lt;TT&gt;EINVAL&lt;/TT&gt; to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function may be called to replace the default implementation of the
+&lt;A HREF=#utime&gt;st_utime()&lt;/A&gt; function.  It must be called before the ST
+library has been initialized (see &lt;A HREF=#st_init&gt;st_init()&lt;/A&gt;).
+The user-provided function &lt;TT&gt;func&lt;/TT&gt; will be invoked whenever
+&lt;A HREF=#utime&gt;st_utime()&lt;/A&gt; is called to obtain current high-resolution time.
+Replacing default implementation may be useful, for example, for taking
+advantage of high performance CPU cycle counters.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;timecache_set&quot;&gt;
+&lt;H4&gt;st_timecache_set()&lt;/H4&gt;
+&lt;/A&gt;
+Turns the time caching on or off.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_timecache_set(int on);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_timecache_set()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;on&lt;/TT&gt;&lt;P&gt;
+If this parameter has a non-zero value, the time caching is turned on
+(enabled). Otherwise, the time caching is turned off (disabled).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The previous state of time caching (a value of &lt;TT&gt;0&lt;/TT&gt; if it was off and
+a value of &lt;TT&gt;1&lt;/TT&gt; otherwise).
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+The State Threads library has the ability to &quot;cache&quot; the time value that is
+reported by the &lt;TT&gt;time(2)&lt;/TT&gt; system call. If the time caching is enabled
+by calling this function with a non-zero argument, then the result value
+of &lt;TT&gt;time(2)&lt;/TT&gt; will be stored and updated at most once per second. The
+cached time can be retrieved by &lt;A HREF=#time&gt;st_time()&lt;/A&gt;.&lt;P&gt;
+&lt;B&gt;Note:&lt;/B&gt; There are some pathological cases (e.g., very heavy loads during
+application benchmarking) when a single thread runs for a long time without
+giving up control and the cached time value is not updated properly. If you
+&lt;I&gt;always&lt;/I&gt; need &quot;real-time&quot; time values, don't enable the time caching.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;time&quot;&gt;
+&lt;H4&gt;st_time()&lt;/H4&gt;
+&lt;/A&gt;
+Returns the value of time in seconds since 00:00:00 UTC, January 1, 1970.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+time_t st_time(void);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+None.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The value of time in seconds since 00:00:00 UTC, January 1, 1970 as reported
+by the &lt;TT&gt;time(2)&lt;/TT&gt; system call.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+If the time caching was enabled by
+&lt;A HREF=#timecache_set&gt;st_timecache_set()&lt;/A&gt;, then this function returns
+the cached result. Otherwise, it just calls &lt;TT&gt;time(2)&lt;/TT&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;io&quot;&gt;
+&lt;H2&gt;I/O Functions&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+Most State Threads library I/O functions look like corresponding C library
+functions with two exceptions:
+&lt;UL&gt;
+&lt;LI&gt;They operate on file descriptor objects of type
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;.&lt;/LI&gt;
+&lt;LI&gt;They take an additional argument of type
+&lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; which represents an &lt;I&gt;inactivity
+timeout&lt;/I&gt;: if no I/O is possible during this amount of time, I/O functions
+return an error code and set &lt;TT&gt;errno&lt;/TT&gt; to &lt;TT&gt;ETIME&lt;/TT&gt;.
+The boundary values &lt;TT&gt;0&lt;/TT&gt; and &lt;TT&gt;-1&lt;/TT&gt; for this argument indicate
+that the thread should wait no time (function returns immediately) or wait
+forever (never time out), respectively.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;/LI&gt;
+&lt;/UL&gt;
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_open_socket&gt;st_netfd_open_socket()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_free&gt;st_netfd_free()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_close&gt;st_netfd_close()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_fileno&gt;st_netfd_fileno()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_setspecific&gt;st_netfd_setspecific()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_getspecific&gt;st_netfd_getspecific()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_serialize_accept&gt;st_netfd_serialize_accept()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_poll&gt;st_netfd_poll()&lt;/A&gt;&lt;/DD&gt;
+&lt;P&gt;
+&lt;DD&gt;&lt;A HREF=#accept&gt;st_accept()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#connect&gt;st_connect()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#read&gt;st_read()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#read_fully&gt;st_read_fully()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#read_resid&gt;st_read_resid()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#write&gt;st_write()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#write_resid&gt;st_write_resid()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#writev&gt;st_writev()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#recvfrom&gt;st_recvfrom()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sendto&gt;st_sendto()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#recvmsg&gt;st_recvmsg()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sendmsg&gt;st_sendmsg()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#open&gt;st_open()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#poll&gt;st_poll()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_open&quot;&gt;
+&lt;H4&gt;st_netfd_open()&lt;/H4&gt;
+&lt;/A&gt;
+Creates a new file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_netfd_t st_netfd_open(int osfd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_open()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;osfd&lt;/TT&gt;&lt;P&gt;
+
+Any open OS file descriptor; can be obtained from calls to
+functions including, but not restricted to, &lt;TT&gt;pipe(2), socket(3),
+socketpair(3), fcntl(2), dup(2),&lt;/TT&gt; etc.
+
+
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new file descriptor object identifier is
+returned. Otherwise, &lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function creates a new file descriptor object of type
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;.&lt;P&gt;
+
+&lt;B&gt;Note:&lt;/B&gt; Among other things, this function sets a non-blocking
+flag on the underlying OS file descriptor. You should not modify this
+flag directly. Also, once an &lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;
+has been created with a given file descriptor, you should avoid
+passing that descriptor to normal I/O or stdio functions. Since the
+O_NONBLOCK flag is shared across &lt;TT&gt;dup(2)&lt;/TT&gt;, this applies to
+&lt;TT&gt;dup()&lt;/TT&gt;'ed file descriptors as well - for instance, if you pass
+standard output or standard input to &lt;TT&gt;st_netfd_open()&lt;/TT&gt;, then
+you should use &lt;A HREF=#write&gt;st_write()&lt;/A&gt; instead of &lt;TT&gt;write&lt;/TT&gt;
+or &lt;TT&gt;fprintf&lt;/TT&gt; when writing to standard error as well - since all
+three descriptors could point to the same terminal. If necessary, you
+can still use &lt;TT&gt;write&lt;/TT&gt; directly if you remember to check
+&lt;TT&gt;errno&lt;/TT&gt; for &lt;TT&gt;EAGAIN&lt;/TT&gt;, but &lt;TT&gt;fprintf&lt;/TT&gt; and other
+stdio functions should be avoided completely because, at least on
+Linux, the stdio library cannot be made to work reliably with
+non-blocking files. (This only applies to file descriptors which are
+passed to &lt;TT&gt;st_netfd_open()&lt;/TT&gt; or &lt;A
+HREF=#netfd_open_socket&gt;st_netfd_open_socket()&lt;/A&gt;, or which are
+related to such descriptors through &lt;TT&gt;dup()&lt;/TT&gt;; other file
+descriptors are untouched by State Threads.)
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_open_socket&quot;&gt;
+&lt;H4&gt;st_netfd_open_socket()&lt;/H4&gt;
+&lt;/A&gt;
+Creates a new file descriptor object from a socket.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_netfd_t st_netfd_open_socket(int osfd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_open_socket()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;osfd&lt;/TT&gt;&lt;P&gt;
+An open OS file descriptor which is a socket initially obtained from a&lt;TT&gt;
+socket(3) or socketpair(3)&lt;/TT&gt; call.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new file descriptor object identifier is
+returned. Otherwise, &lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function creates a new file descriptor object of type
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt; which represents an open end
+point of network communication.&lt;P&gt;
+Unlike the &lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt; function which may be used
+on OS file descriptors of any origin, &lt;TT&gt;st_netfd_open_socket()&lt;/TT&gt; must
+be used only on sockets. It is slightly more efficient than
+&lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt;.&lt;P&gt;
+&lt;B&gt;Note:&lt;/B&gt; Among other things, this function sets a non-blocking flag
+on the underlying OS socket. You should not modify this flag directly.
+See &lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_free&quot;&gt;
+&lt;H4&gt;st_netfd_free()&lt;/H4&gt;
+&lt;/A&gt;
+Frees a file descriptor object without closing the underlying OS file
+descriptor.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+void st_netfd_free(st_netfd_t fd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_free()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Nothing.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function frees the memory and other resources identified by the
+&lt;TT&gt;fd&lt;/TT&gt; parameter without closing the underlying OS file descriptor.
+Any non-&lt;TT&gt;NULL&lt;/TT&gt; descriptor-specific data is destroyed by invoking
+the specified destructor function (see &lt;A
+HREF=#netfd_setspecific&gt;st_netfd_setspecific()&lt;/A&gt;).&lt;P&gt; A thread should
+not free file descriptor objects that are in use by other threads
+because it may lead to unpredictable results (e.g., a freed file
+descriptor may be reused without other threads knowing that).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_close&quot;&gt;
+&lt;H4&gt;st_netfd_close()&lt;/H4&gt;
+&lt;/A&gt;
+Closes a file descriptor.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_netfd_close(st_netfd_t fd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_close()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function closes the underlying OS file descriptor, frees the memory and
+other resources identified by the &lt;TT&gt;fd&lt;/TT&gt; parameter. Any non-&lt;TT&gt;NULL&lt;/TT&gt;
+descriptor-specific data is destroyed by invoking the specified destructor
+function (see &lt;A HREF=#netfd_setspecific&gt;st_netfd_setspecific()&lt;/A&gt;).&lt;P&gt;
+A thread should not close file descriptor objects that are in use by other
+threads because it may lead to unpredictable results (e.g., a closed
+file descriptor may be reused without other threads knowing that).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_fileno&quot;&gt;
+&lt;H4&gt;st_netfd_fileno()&lt;/H4&gt;
+&lt;/A&gt;
+Returns an underlying OS file descriptor.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_netfd_fileno(st_netfd_t fd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_fileno()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+An underlying OS file descriptor.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function returns the integer OS file descriptor associated with the named
+file descriptor object.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_setspecific&quot;&gt;
+&lt;H4&gt;st_netfd_setspecific()&lt;/H4&gt;
+&lt;/A&gt;
+Sets per-descriptor private data.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+void st_netfd_setspecific(st_netfd_t fd, void *value,
+                          void (*destructor)(void *));
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_setspecific()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A valid file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;TT&gt;value&lt;/TT&gt;&lt;P&gt;
+The per-descriptor private data, or more likely, a pointer to the data which
+is being associated with the named file descriptor object.
+&lt;P&gt;
+&lt;TT&gt;destructor&lt;/TT&gt;&lt;P&gt;
+Specifies an optional destructor function for the private data associated
+with &lt;TT&gt;fd&lt;/TT&gt;. This function can be specified as &lt;TT&gt;NULL&lt;/TT&gt;.
+If &lt;TT&gt;value&lt;/TT&gt; is not &lt;TT&gt;NULL&lt;/TT&gt;, then this destructor function will
+be called with &lt;TT&gt;value&lt;/TT&gt; as an argument upon freeing the file descriptor
+object (see &lt;A HREF=#netfd_free&gt;st_netfd_free()&lt;/A&gt; and
+&lt;A HREF=#netfd_close&gt;st_netfd_close()&lt;/A&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Nothing.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function allows to associate any data with the specified file
+descriptor object (network connection). If a non-&lt;TT&gt;NULL&lt;/TT&gt; destructor
+function is registered, it will be called at one of two times, as long as
+the associated data is not &lt;TT&gt;NULL&lt;/TT&gt;:
+&lt;UL&gt;
+&lt;LI&gt;when private data is replaced by calling
+&lt;TT&gt;st_netfd_setspecific()&lt;/TT&gt; again
+&lt;LI&gt;upon freeing the file descriptor object (see
+&lt;A HREF=#netfd_free&gt;st_netfd_free()&lt;/A&gt; and
+&lt;A HREF=#netfd_close&gt;st_netfd_close()&lt;/A&gt;)
+&lt;/UL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_getspecific&quot;&gt;
+&lt;H4&gt;st_netfd_getspecific()&lt;/H4&gt;
+&lt;/A&gt;
+Retrieves the per-descriptor private data.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+void *st_netfd_getspecific(st_netfd_t fd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_getspecific()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A valid file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+The data associated with the named file descriptor object. If no data is
+associated with &lt;TT&gt;fd&lt;/TT&gt;, then &lt;TT&gt;NULL&lt;/TT&gt; is returned. 
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function allows to retrieve the data that was associated with the
+specified file descriptor object (see
+&lt;A HREF=#netfd_setspecific&gt;st_netfd_setspecific()&lt;/A&gt;).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_serialize_accept&quot;&gt;
+&lt;H4&gt;st_netfd_serialize_accept()&lt;/H4&gt;
+&lt;/A&gt;
+Serializes all subsequent &lt;TT&gt;accept(3)&lt;/TT&gt; calls on a specified file
+descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_netfd_serialize_accept(st_netfd_t fd);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_serialize_accept()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) which has been successfully created
+from a valid listening socket by &lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt; or
+&lt;A HREF=#netfd_open_socket&gt;st_netfd_open_socket()&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+On some platforms (e.g., Solaris 2.5 and possibly other SVR4 implementations)
+&lt;TT&gt;accept(3)&lt;/TT&gt; calls from different processes on
+the same listening socket (see &lt;TT&gt;bind(3)&lt;/TT&gt;, &lt;TT&gt;listen(3)&lt;/TT&gt;) must be
+serialized. This function causes all subsequent &lt;TT&gt;accept(3)&lt;/TT&gt; calls
+made by &lt;A HREF=#accept&gt;st_accept()&lt;/A&gt; on the specified file descriptor
+object to be serialized.
+&lt;P&gt;
+&lt;TT&gt;st_netfd_serialize_accept()&lt;/TT&gt; must be called &lt;I&gt;before&lt;/I&gt;
+creating multiple server processes via &lt;TT&gt;fork(2)&lt;/TT&gt;. If the application
+does not create multiple processes to accept network connections on
+the same listening socket, there is no need to call this function.
+&lt;P&gt;
+&lt;TT&gt;st_netfd_serialize_accept()&lt;/TT&gt; allocates resources that are
+freed upon freeing of the specified file descriptor object (see
+&lt;A HREF=#netfd_free&gt;st_netfd_free()&lt;/A&gt; and
+&lt;A HREF=#netfd_close&gt;st_netfd_close()&lt;/A&gt;).
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;netfd_poll&quot;&gt;
+&lt;H4&gt;st_netfd_poll()&lt;/H4&gt;
+&lt;/A&gt;
+Waits for I/O on a single file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_netfd_poll(st_netfd_t fd, int how, st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_netfd_poll()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).
+&lt;P&gt;
+&lt;TT&gt;how&lt;/TT&gt;&lt;P&gt;
+Specifies I/O events of interest. This parameter can be constructed by
+OR-ing any combination of the following event flags which are defined
+in the &lt;TT&gt;poll.h&lt;/TT&gt; header file:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLIN &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; is readable.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLOUT &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; is is writable.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLPRI &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; has an exception condition.&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+Amount of time in microseconds the call will block waiting for I/O
+to become ready. This parameter is a variable of type
+&lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt;. If this time expires without any
+I/O becoming ready, &lt;TT&gt;st_netfd_poll()&lt;/TT&gt; returns an error and sets
+&lt;TT&gt;errno&lt;/TT&gt; to &lt;TT&gt;ETIME&lt;/TT&gt;.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+If the named file descriptor object is ready for I/O within the specified
+amount of time, a value of &lt;TT&gt;0&lt;/TT&gt; is returned. Otherwise, a value
+of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error:
+&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EBADF &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The underlying OS file descriptor is invalid.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred without any I/O
+becoming ready.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function returns as soon as I/O is ready on the named file descriptor
+object or the specified amount of time expires. The &lt;TT&gt;how&lt;/TT&gt; parameter
+should be set to the I/O events (readable, writable, exception, or some
+combination) that the caller is interested in. If the value of
+&lt;TT&gt;timeout&lt;/TT&gt; is &lt;TT&gt;-1&lt;/TT&gt;, this function blocks until a requested I/O
+event occurs or until the call is interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;accept&quot;&gt;
+&lt;H4&gt;st_accept()&lt;/H4&gt;
+&lt;/A&gt;
+Accepts a connection on a specified file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_netfd_t st_accept(st_netfd_t fd, struct sockaddr *addr, int *addrlen,
+                     st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_accept()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) representing the rendezvous socket
+on which the caller is willing to accept new connections. This object has been
+created from a valid listening socket by
+&lt;A HREF=#netfd_open&gt;st_netfd_open()&lt;/A&gt; or
+&lt;A HREF=#netfd_open_socket&gt;st_netfd_open_socket()&lt;/A&gt;.&lt;P&gt;
+&lt;TT&gt;addr&lt;/TT&gt;&lt;P&gt;
+If this value is non-zero, it is a result parameter that is filled
+in with the address of the connecting entity, as known to the communications
+layer (see &lt;TT&gt;accept(3)&lt;/TT&gt;).&lt;P&gt;
+&lt;TT&gt;addrlen&lt;/TT&gt;&lt;P&gt;
+This parameter should initially contain the amount of space pointed to by
+&lt;TT&gt;addr&lt;/TT&gt;; on return it will contain the actual length (in bytes) of the
+address returned (see &lt;TT&gt;accept(3)&lt;/TT&gt;).&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the accept operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new file descriptor object identifier
+representing the newly accepted connection is returned. Otherwise,
+&lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error.
+Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set by the &lt;TT&gt;accept(3)&lt;/TT&gt;
+call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and no pending
+connection was accepted.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function accepts the first connection from the queue of pending
+connections and creates a new file descriptor object for the newly
+accepted connection. The rendezvous socket can still be used to accept
+more connections.&lt;P&gt;
+&lt;TT&gt;st_accept()&lt;/TT&gt; blocks the calling thread until either a new connection
+is successfully accepted or an error occurs. If no pending connection can
+be accepted before the time limit, this function returns &lt;TT&gt;NULL&lt;/TT&gt;
+and sets &lt;TT&gt;errno&lt;/TT&gt; to &lt;TT&gt;ETIME&lt;/TT&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;connect&quot;&gt;
+&lt;H4&gt;st_connect()&lt;/H4&gt;
+&lt;/A&gt;
+Initiates a connection on a specified file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_connect(st_netfd_t fd, struct sockaddr *addr, int addrlen,
+               st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_connect()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) representing a socket.&lt;P&gt;
+&lt;TT&gt;addr&lt;/TT&gt;&lt;P&gt;
+A pointer to the address of the peer to which the socket is to be connected.
+&lt;P&gt;
+&lt;TT&gt;addrlen&lt;/TT&gt;&lt;P&gt;
+This parameter specifies the amount of space pointed to by &lt;TT&gt;addr&lt;/TT&gt;.
+&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the connect operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a value of &lt;TT&gt;0&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set
+by the &lt;TT&gt;connect(3)&lt;/TT&gt; call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and connection setup
+was not completed.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt; 
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function is usually invoked on a file descriptor object representing
+a TCP socket. Upon completion it establishes a TCP connection to the peer.
+If the underlying OS socket is not bound, it will be bound to an arbitrary
+local address (see &lt;TT&gt;connect(3)&lt;/TT&gt;).&lt;P&gt;
+&lt;TT&gt;st_connect()&lt;/TT&gt; blocks the calling thread until either the connection
+is successfully established or an error occurs. If the connection setup
+cannot complete before the specified time limit, this function fails with
+&lt;TT&gt;errno&lt;/TT&gt; set to &lt;TT&gt;ETIME&lt;/TT&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;read&quot;&gt;
+&lt;H4&gt;st_read()&lt;/H4&gt;
+&lt;/A&gt;
+Reads data from a specified file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+ssize_t st_read(st_netfd_t fd, void *buf, size_t nbyte, st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_read()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).&lt;P&gt;
+&lt;TT&gt;buf&lt;/TT&gt;&lt;P&gt;
+A pointer to a buffer to hold the data read in. On output the buffer
+contains the data.&lt;P&gt;
+&lt;TT&gt;nbyte&lt;/TT&gt;&lt;P&gt;
+The size of &lt;TT&gt;buf&lt;/TT&gt; in bytes.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the read operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer indicating the number of bytes actually
+read is returned (a value of &lt;TT&gt;0&lt;/TT&gt; means the network connection is
+closed or end of file is reached). Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is
+returned and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error.
+Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set by the &lt;TT&gt;read(2)&lt;/TT&gt;
+call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and no data was read.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function blocks the calling thread until it encounters an end-of-stream
+indication, some positive number of bytes (but no more than &lt;TT&gt;nbyte&lt;/TT&gt;
+bytes) are read in, a timeout occurs, or an error occurs.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;read_fully&quot;&gt;
+&lt;H4&gt;st_read_fully()&lt;/H4&gt;
+&lt;/A&gt;
+Reads the specified amount of data in full from a file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+ssize_t st_read_fully(st_netfd_t fd, void *buf, size_t nbyte,
+                      st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_read_fully()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).&lt;P&gt;
+&lt;TT&gt;buf&lt;/TT&gt;&lt;P&gt;
+A pointer to a buffer to hold the data read in. On output the buffer
+contains the data.&lt;P&gt;
+&lt;TT&gt;nbyte&lt;/TT&gt;&lt;P&gt;
+The amount of data to be read in full (in bytes). It must not exceed the
+size of &lt;TT&gt;buf&lt;/TT&gt;.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the
+inactivity timeout (in microseconds).
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer indicating the number of bytes actually
+read is returned (a value less than &lt;TT&gt;nbyte&lt;/TT&gt; means the network
+connection is closed or end of file is reached). Otherwise, a value of
+&lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error.
+Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set by the &lt;TT&gt;read(2)&lt;/TT&gt;
+call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function blocks the calling thread until the specified amount of data
+is read in full, it encounters an end-of-stream indication, a timeout occurs,
+or an error occurs.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;read_resid&quot;&gt;
+&lt;H4&gt;st_read_resid()&lt;/H4&gt;
+&lt;/A&gt;
+Reads the specified amount of data in full from a file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_read_resid(st_netfd_t fd, void *buf, size_t *resid,
+		  st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_read_resid()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).&lt;P&gt;
+&lt;TT&gt;buf&lt;/TT&gt;&lt;P&gt;
+A pointer to a buffer to hold the data read in. On output the buffer
+contains the data.&lt;P&gt;
+&lt;TT&gt;resid&lt;/TT&gt;&lt;P&gt;
+A pointer to a number of bytes.
+On entry, the amount of data to be read in full.
+It must not exceed the size of &lt;TT&gt;buf&lt;/TT&gt;.
+On return, the amount of data remaining to be read.
+(A non-zero returned value means some but not all of the data was read.)&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the
+inactivity timeout (in microseconds).
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success, zero is returned.  &lt;TT&gt;*resid&lt;/TT&gt; may be zero, indicating
+a complete read, or non-zero, indicating the network
+connection is closed or end of file is reached.
+&lt;P&gt;
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned, &lt;TT&gt;*resid&lt;/TT&gt; is non-zero,
+and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error.
+Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set by the &lt;TT&gt;read(2)&lt;/TT&gt;
+call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function blocks the calling thread until the specified amount of data
+is read in full, it encounters an end-of-stream indication, a timeout occurs,
+or an error occurs.  It differs from &lt;TT&gt;st_read_fully()&lt;/TT&gt; only in that
+it allows the caller to know how many bytes were transferred before an error
+occurred.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;write&quot;&gt;
+&lt;H4&gt;st_write()&lt;/H4&gt;
+&lt;/A&gt;
+Writes a buffer of data to a specified file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+ssize_t st_write(st_netfd_t fd, const void *buf, size_t nbyte,
+                 st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_write()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).&lt;P&gt;
+&lt;TT&gt;buf&lt;/TT&gt;&lt;P&gt;
+A pointer to the buffer holding the data to be written.&lt;P&gt;
+&lt;TT&gt;nbyte&lt;/TT&gt;&lt;P&gt;
+The amount of data in bytes to be written from the buffer.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the
+inactivity timeout (in microseconds).
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer equal to &lt;TT&gt;nbyte&lt;/TT&gt; is returned.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set
+by the &lt;TT&gt;write(2)&lt;/TT&gt; call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt; 
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function blocks the calling thread until &lt;I&gt;all&lt;/I&gt; the data is written,
+a timeout occurs, or the write operation fails. The return value is equal to
+either &lt;TT&gt;nbyte&lt;/TT&gt; (on success) or &lt;TT&gt;-1&lt;/TT&gt; (on failure). Note that if
+&lt;TT&gt;st_write()&lt;/TT&gt; returns &lt;TT&gt;-1&lt;/TT&gt;, some data (less than &lt;TT&gt;nbyte&lt;/TT&gt;
+bytes) may have been written before an error occurred.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;write_resid&quot;&gt;
+&lt;H4&gt;st_write_resid()&lt;/H4&gt;
+&lt;/A&gt;
+Writes a buffer of data to a specified file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_write_resid(st_netfd_t fd, const void *buf, size_t *resid,
+                   st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_write_resid()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).&lt;P&gt;
+&lt;TT&gt;buf&lt;/TT&gt;&lt;P&gt;
+A pointer to the buffer holding the data to be written.&lt;P&gt;
+&lt;TT&gt;resid&lt;/TT&gt;&lt;P&gt;
+A pointer to a number of bytes.
+On entry, the amount of data to be written from the buffer.
+On return, the amount of data remaining to be written.
+(A non-zero returned value means some but not all of the data was written.)&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the
+inactivity timeout (in microseconds).
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success, zero is returned and &lt;TT&gt;*resid&lt;/TT&gt; is zero.
+Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned, &lt;TT&gt;*resid&lt;/TT&gt; is non-zero,
+and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as set
+by the &lt;TT&gt;write(2)&lt;/TT&gt; call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt; 
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function blocks the calling thread until &lt;I&gt;all&lt;/I&gt; the data is written,
+a timeout occurs, or the write operation fails. It differs from
+&lt;TT&gt;st_write()&lt;/TT&gt; only in that it allows the caller to know how many bytes
+were transferred before an error occurred.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;writev&quot;&gt;
+&lt;H4&gt;st_writev()&lt;/H4&gt;
+&lt;/A&gt;
+Writes data to a specified file descriptor object from multiple buffers.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+ssize_t st_writev(st_netfd_t fd, const struct iovec *iov, int iov_size,
+                  st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_writev()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;).&lt;P&gt;
+&lt;TT&gt;iov&lt;/TT&gt;&lt;P&gt;
+An array of &lt;TT&gt;iovec&lt;/TT&gt; structures that describe the buffers to write
+from (see &lt;TT&gt;writev(2)&lt;/TT&gt;).&lt;P&gt;
+&lt;TT&gt;iov_size&lt;/TT&gt;&lt;P&gt;
+Number of &lt;TT&gt;iovec&lt;/TT&gt; structures in the &lt;TT&gt;iov&lt;/TT&gt; array.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the
+inactivity timeout (in microseconds).
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer equal to the sum of all the buffer lengths
+is returned. Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt;
+is set to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as
+set by the &lt;TT&gt;writev(2)&lt;/TT&gt; call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function blocks the calling thread until &lt;I&gt;all&lt;/I&gt; the data is written,
+a timeout occurs, or the write operation fails. The return value is equal to
+either the sum of all the buffer lengths (on success) or &lt;TT&gt;-1&lt;/TT&gt; (on
+failure). Note that if &lt;TT&gt;st_writev()&lt;/TT&gt; returns &lt;TT&gt;-1&lt;/TT&gt;, part of the
+data may have been written before an error occurred.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;recvfrom&quot;&gt;
+&lt;H4&gt;st_recvfrom()&lt;/H4&gt;
+&lt;/A&gt;
+Receives bytes from a file descriptor object and stores the sending peer's
+address.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_recvfrom(st_netfd_t fd, void *buf, int len, struct sockaddr *from,
+                int *fromlen, st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_recvfrom()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) representing a UDP socket.&lt;P&gt;
+&lt;TT&gt;buf&lt;/TT&gt;&lt;P&gt;
+A pointer to a buffer to hold the data received.&lt;P&gt;
+&lt;TT&gt;len&lt;/TT&gt;&lt;P&gt;
+The size of &lt;TT&gt;buf&lt;/TT&gt; in bytes.&lt;P&gt;
+&lt;TT&gt;from&lt;/TT&gt;&lt;P&gt;
+If this parameter is not a &lt;TT&gt;NULL&lt;/TT&gt; pointer, the source address of the
+message is filled in (see &lt;TT&gt;recvfrom(3)&lt;/TT&gt;).&lt;P&gt;
+&lt;TT&gt;fromlen&lt;/TT&gt;&lt;P&gt;
+This is a value-result parameter, initialized to the size of the buffer
+associated with &lt;TT&gt;from&lt;/TT&gt;, and modified on return to indicate the actual
+size of the address stored there.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the receive operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer indicating the length of the received
+message in bytes is returned. Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned
+and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt;
+values are the same as set by the &lt;TT&gt;recvfrom(3)&lt;/TT&gt; call with two
+exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and no data was received.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function receives up to a specified number of bytes from the specified
+file descriptor object representing a UDP socket.&lt;P&gt;
+&lt;TT&gt;st_recvfrom()&lt;/TT&gt; blocks the calling thread until one or more bytes are
+transferred, a timeout has occurred, or there is an error. No more than
+&lt;TT&gt;len&lt;/TT&gt; bytes will be transferred.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;sendto&quot;&gt;
+&lt;H4&gt;st_sendto()&lt;/H4&gt;
+&lt;/A&gt;
+Sends bytes to a specified destination.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_sendto(st_netfd_t fd, const void *msg, int len, struct sockaddr *to,
+              int tolen, st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_sendto()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) representing a UDP socket.&lt;P&gt;
+&lt;TT&gt;msg&lt;/TT&gt;&lt;P&gt;
+A pointer to a buffer containing the message to be sent.&lt;P&gt;
+&lt;TT&gt;len&lt;/TT&gt;&lt;P&gt;
+The length of the message to be sent (in bytes).&lt;P&gt;
+&lt;TT&gt;to&lt;/TT&gt;&lt;P&gt;
+A pointer to the address of the destination (see &lt;TT&gt;sendto(3)&lt;/TT&gt;).&lt;P&gt;
+&lt;TT&gt;tolen&lt;/TT&gt;&lt;P&gt;
+This parameter specifies the size of the destination address.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the send operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer indicating the number of bytes sent is
+returned. Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is
+set to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as
+set by the &lt;TT&gt;sendto(3)&lt;/TT&gt; call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and no data was sent.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function sends a specified number of bytes from a file descriptor
+object representing a UDP socket to the specified destination address.
+If no buffer space is available at the underlying OS socket to hold the
+message to be transmitted, then &lt;TT&gt;st_sendto()&lt;/TT&gt; blocks the calling
+thread until the space becomes available, a timeout occurs, or an error
+occurs.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;recvmsg&quot;&gt;
+&lt;H4&gt;st_recvmsg()&lt;/H4&gt;
+&lt;/A&gt;
+Receives a message from a file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_recvmsg(st_netfd_t fd, struct msghdr *msg, int flags,
+               st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_recvmsg()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) representing a UDP socket.&lt;P&gt;
+&lt;TT&gt;msg&lt;/TT&gt;&lt;P&gt;
+A pointer to a &lt;TT&gt;msghdr&lt;/TT&gt; structure to describe the data received.&lt;P&gt;
+&lt;TT&gt;flags&lt;/TT&gt;&lt;P&gt;
+Control flags for &lt;TT&gt;recvmsg(3)&lt;/TT&gt;.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the receive operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer indicating the number of bytes received
+is returned. Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned
+and &lt;TT&gt;errno&lt;/TT&gt; is set to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt;
+values are the same as set by the &lt;TT&gt;recvmsg(3)&lt;/TT&gt; call with two
+exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and no data was received.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function receives bytes from the specified file descriptor object
+representing a UDP socket.  The operation is controlled by the in/out
+&lt;TT&gt;msg&lt;/TT&gt; parameter.&lt;P&gt;
+&lt;TT&gt;st_recvmsg()&lt;/TT&gt; blocks the calling thread until one or more bytes are
+transferred, a timeout has occurred, or there is an error.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;sendmsg&quot;&gt;
+&lt;H4&gt;st_sendmsg()&lt;/H4&gt;
+&lt;/A&gt;
+Sends a message to a file descriptor object.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_sendmsg(st_netfd_t fd, const struct msghdr *msg, int flags,
+               st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_sendmsg()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;fd&lt;/TT&gt;&lt;P&gt;
+A file descriptor object identifier (see
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt;) representing a UDP socket.&lt;P&gt;
+&lt;TT&gt;msg&lt;/TT&gt;&lt;P&gt;
+A pointer to a &lt;TT&gt;msghdr&lt;/TT&gt; structure describing the message to be sent.&lt;P&gt;
+&lt;TT&gt;flags&lt;/TT&gt;&lt;P&gt;
+Control flags for &lt;TT&gt;sendmsg(3)&lt;/TT&gt;.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the time
+limit in microseconds for completion of the send operation.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+On success a non-negative integer indicating the number of bytes sent is
+returned. Otherwise, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is
+set to indicate the error. Possible &lt;TT&gt;errno&lt;/TT&gt; values are the same as
+set by the &lt;TT&gt;sendmsg(3)&lt;/TT&gt; call with two exceptions:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;ETIME &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The timeout occurred and no data was sent.
+&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function sends bytes to a file descriptor object representing a UDP
+socket.  The operation is controlled by the &lt;TT&gt;msg&lt;/TT&gt; parameter.
+If no buffer space is available at the underlying OS socket to hold the
+message to be transmitted, then &lt;TT&gt;st_sendmsg()&lt;/TT&gt; blocks the calling
+thread until the space becomes available, a timeout occurs, or an error
+occurs.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;open&quot;&gt;
+&lt;H4&gt;st_open()&lt;/H4&gt;
+&lt;/A&gt;
+Opens a file for reading, writing, or both.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+st_netfd_t st_open(const char *path, int oflags, mode_t mode);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_open()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;path&lt;/TT&gt;&lt;P&gt;
+The pathname of the file to be opened.&lt;P&gt;
+&lt;TT&gt;oflags&lt;/TT&gt;&lt;P&gt;
+File status flags. These are the same flags that are used by the
+&lt;TT&gt;open(2)&lt;/TT&gt; system call.&lt;P&gt;
+&lt;TT&gt;mode&lt;/TT&gt;&lt;P&gt;
+Access permission bits of the file mode, if the file is created when
+&lt;TT&gt;O_CREAT&lt;/TT&gt; is set in &lt;TT&gt;oflags&lt;/TT&gt; (see &lt;TT&gt;open(2)&lt;/TT&gt;).
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a new file descriptor object identifier is
+returned. Otherwise, &lt;TT&gt;NULL&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error.
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function creates a new file descriptor object of type
+&lt;A HREF=#netfd_t&gt;&lt;B&gt;st_netfd_t&lt;/B&gt;&lt;/A&gt; for the file with the pathname
+&lt;TT&gt;path&lt;/TT&gt;. This object can be freed by
+&lt;A HREF=#netfd_free&gt;st_netfd_free()&lt;/A&gt; or
+&lt;A HREF=#netfd_close&gt;st_netfd_close()&lt;/A&gt;.&lt;P&gt;
+The primary purpose of this function is to open FIFOs (named pipes) or
+other special files in order to create an end point of communication.
+However, it can be used on regular files as well.&lt;P&gt;
+Among other things, this function always sets a non-blocking flag on the
+underlying OS file descriptor, so there is no need to include that flag in
+&lt;TT&gt;oflags&lt;/TT&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;poll&quot;&gt;
+&lt;H4&gt;st_poll()&lt;/H4&gt;
+&lt;/A&gt;
+Detects when I/O is ready for a set of OS file descriptors.
+&lt;P&gt;
+&lt;H5&gt;Syntax&lt;/H5&gt;
+
+&lt;PRE&gt;
+#include &lt;st.h&gt;
+
+int st_poll(struct pollfd *pds, int npds, st_utime_t timeout);
+&lt;/PRE&gt;
+&lt;P&gt;
+&lt;H5&gt;Parameters&lt;/H5&gt;
+&lt;TT&gt;st_poll()&lt;/TT&gt; has the following parameters:&lt;P&gt;
+&lt;TT&gt;pds&lt;/TT&gt;&lt;P&gt;
+A pointer to an array of &lt;TT&gt;pollfd&lt;/TT&gt; structures (see &lt;TT&gt;poll(2)&lt;/TT&gt;).
+&lt;P&gt;
+&lt;TT&gt;npds&lt;/TT&gt;&lt;P&gt;
+The number of elements in the &lt;TT&gt;pds&lt;/TT&gt; array.&lt;P&gt;
+&lt;TT&gt;timeout&lt;/TT&gt;&lt;P&gt;
+A value of type &lt;A HREF=#utime_t&gt;&lt;B&gt;st_utime_t&lt;/B&gt;&lt;/A&gt; specifying the
+amount of time in &lt;I&gt;microseconds&lt;/I&gt; the call will block waiting for I/O
+to become ready. If this time expires without any I/O becoming ready,
+&lt;TT&gt;st_poll()&lt;/TT&gt; returns zero.
+Note that timeouts are measured &lt;A HREF=&quot;notes.html#timeouts&quot;&gt;since the
+last context switch&lt;/A&gt;.
+&lt;P&gt;
+&lt;H5&gt;Returns&lt;/H5&gt;
+Upon successful completion, a non-negative value is returned. A positive
+value indicates the total number of OS file descriptors in &lt;TT&gt;pds&lt;/TT&gt;
+that have events. A value of &lt;TT&gt;0&lt;/TT&gt; indicates that the call timed out.
+Upon failure, a value of &lt;TT&gt;-1&lt;/TT&gt; is returned and &lt;TT&gt;errno&lt;/TT&gt; is set
+to indicate the error:&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;EINTR &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;The current thread was interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+&lt;H5&gt;Description&lt;/H5&gt;
+This function returns as soon as I/O is ready on one or more of the specified
+OS file descriptors. A count of the number of ready descriptors is returned
+unless a timeout occurs, in which case zero is returned.&lt;P&gt;
+The &lt;TT&gt;pollfd&lt;/TT&gt; structure is defined in the &lt;TT&gt;poll.h&lt;/TT&gt; header file
+and contains the following members:&lt;P&gt;
+&lt;PRE&gt;
+    int fd;             /* OS file descriptor */
+    short events;       /* requested events   */
+    short revents;      /* returned events    */
+&lt;/PRE&gt;
+The &lt;TT&gt;events&lt;/TT&gt; field should be set to the I/O events (readable,
+writable, exception, or some combination) that the caller is interested in.
+On return, the &lt;TT&gt;revents&lt;/TT&gt; field is set to indicate what kind of I/O
+is ready on the respective descriptor.&lt;P&gt;
+The &lt;TT&gt;events&lt;/TT&gt; and &lt;TT&gt;revents&lt;/TT&gt; fields are constructed by OR-ing
+any combination of the following event flags (defined in &lt;TT&gt;poll.h&lt;/TT&gt;):
+&lt;P&gt;
+&lt;TABLE BORDER=0&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLIN &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; is readable.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLOUT &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; is is writable.&lt;/TD&gt;&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLPRI &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; has an exception condition.&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;TR&gt;&lt;TD&gt;&lt;TT&gt;POLLNVAL &lt;/TT&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TT&gt;fd&lt;/TT&gt; is bad.&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+The &lt;TT&gt;POLLNVAL&lt;/TT&gt; flag is only valid in the &lt;TT&gt;revents&lt;/TT&gt; field;
+it is not used in the &lt;TT&gt;events&lt;/TT&gt; field.&lt;P&gt;
+Note that unlike the &lt;TT&gt;poll(2)&lt;/TT&gt; call, this function has the
+&lt;TT&gt;timeout&lt;/TT&gt; parameter expressed in microseconds. If the value of
+&lt;TT&gt;timeout&lt;/TT&gt; is &lt;TT&gt;-1&lt;/TT&gt;, this function blocks until a requested I/O
+event occurs or until the call is interrupted by
+&lt;A HREF=#thread_interrupt&gt;st_thread_interrupt()&lt;/A&gt;.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;progr&quot;&gt;
+&lt;H2&gt;Program Structure&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+Generally, the following steps should be followed when writing an application
+using the State Threads library:
+&lt;P&gt;
+&lt;OL&gt;
+&lt;LI&gt;Initialize the library by calling &lt;A HREF=#st_init&gt;st_init()&lt;/A&gt;.&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;Create resources that will be shared among different processes:
+    create and bind listening sockets (see &lt;TT&gt;socket(3)&lt;/TT&gt;,
+    &lt;TT&gt;bind(3)&lt;/TT&gt;, &lt;TT&gt;listen(3)&lt;/TT&gt;,
+    &lt;A HREF=#netfd_open_socket&gt;st_netfd_open_socket()&lt;/A&gt;, and possibly
+    &lt;A HREF=#netfd_serialize_accept&gt;st_netfd_serialize_accept()&lt;/A&gt;),
+    create shared memory segments, inter-process communication (IPC)
+    channels and synchronization primitives (if any).&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;Create several processes via &lt;TT&gt;fork(2)&lt;/TT&gt;. The parent process should
+    either exit or become a &quot;watchdog&quot; (e.g., it starts a new process when
+    an existing one crashes, does a cleanup upon application termination,
+    etc.).&lt;/LI&gt;
+&lt;P&gt;
+&lt;LI&gt;In each child process create a pool of threads (see
+    &lt;A HREF=#thread_create&gt;st_thread_create()&lt;/A&gt;) to handle user
+    connections. Each thread in the pool may accept client connections
+    (&lt;A HREF=#accept&gt;st_accept()&lt;/A&gt;), connect to other servers
+    (&lt;A HREF=#connect&gt;st_connect()&lt;/A&gt;), perform various network I/O
+    (&lt;A HREF=#read&gt;st_read()&lt;/A&gt;, &lt;A HREF=#write&gt;st_write()&lt;/A&gt;, etc.).&lt;/LI&gt;
+&lt;/OL&gt;
+&lt;P&gt;
+Note that only State Threads library &lt;A HREF=#io&gt;I/O functions&lt;/A&gt; should
+be used for a network I/O: any other I/O calls may block the calling process
+indefinitely. For example, standard I/O functions (&lt;TT&gt;fgets(3)&lt;/TT&gt;,
+&lt;TT&gt;fread(3)&lt;/TT&gt;, &lt;TT&gt;fwrite(3)&lt;/TT&gt;, &lt;TT&gt;fprintf(3)&lt;/TT&gt;, etc.) call
+&lt;TT&gt;read(2)&lt;/TT&gt; and &lt;TT&gt;write(2)&lt;/TT&gt; directly and therefore should not be
+used on sockets or pipes.
+&lt;P&gt;
+Also note that for short &lt;A
+HREF=&quot;notes.html#timeouts&quot;&gt;timeouts&lt;/A&gt; to work the program
+should do context switches (for example by calling
+&lt;TT&gt;st_usleep()&lt;/TT&gt;) on a regular basis.
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;A NAME=&quot;block&quot;&gt;
+&lt;H2&gt;List of Blocking Functions&lt;/H2&gt;
+&lt;/A&gt;
+&lt;P&gt;
+The thread context switch (process state change) can &lt;I&gt;only&lt;/I&gt; happen
+in a well-known set of blocking functions.
+Only the following functions can block the calling thread:
+&lt;P&gt;
+&lt;DL&gt;
+&lt;DD&gt;&lt;A HREF=#thread_join&gt;st_thread_join()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sleep&gt;st_sleep()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sleep&gt;st_usleep()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_wait&gt;st_cond_wait()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#cond_timedwait&gt;st_cond_timedwait()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#mutex_lock&gt;st_mutex_lock()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#netfd_poll&gt;st_netfd_poll()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#accept&gt;st_accept()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#connect&gt;st_connect()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#read&gt;st_read()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#read_fully&gt;st_read_fully()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#read_resid&gt;st_read_resid()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#write&gt;st_write()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#write_resid&gt;st_write_resid()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#writev&gt;st_writev()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#recvfrom&gt;st_recvfrom()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sendto&gt;st_sendto()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#recvmsg&gt;st_recvmsg()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#sendmsg&gt;st_sendmsg()&lt;/A&gt;&lt;/DD&gt;
+&lt;DD&gt;&lt;A HREF=#poll&gt;st_poll()&lt;/A&gt;&lt;/DD&gt;
+&lt;/DL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;/BODY&gt;
+&lt;/HTML&gt;
+

Added: upwatch/trunk/st-1.6/docs/st.html
===================================================================
--- upwatch/trunk/st-1.6/docs/st.html	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/docs/st.html	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,491 @@
+&lt;HTML&gt;
+&lt;HEAD&gt;
+&lt;TITLE&gt;State Threads for Internet Applications&lt;/TITLE&gt;
+&lt;/HEAD&gt;
+&lt;BODY BGCOLOR=#FFFFFF&gt;
+&lt;H2&gt;State Threads for Internet Applications&lt;/H2&gt;
+&lt;H3&gt;Introduction&lt;/H3&gt;
+&lt;P&gt;
+State Threads is an application library which provides a
+foundation for writing fast and highly scalable Internet Applications
+on UNIX-like platforms.  It combines the simplicity of the multithreaded 
+programming paradigm, in which one thread supports each simultaneous 
+connection, with the performance and scalability of an event-driven 
+state machine architecture.&lt;/P&gt;
+
+&lt;H3&gt;1. Definitions&lt;/H3&gt;
+&lt;P&gt;
+&lt;A NAME=&quot;IA&quot;&gt;
+&lt;H4&gt;1.1 Internet Applications&lt;/H4&gt;
+&lt;P&gt;
+An &lt;I&gt;Internet Application&lt;/I&gt; (IA) is either a server or client network
+application that accepts connections from clients and may or may not 
+connect to servers.  In an IA the arrival or departure of network data
+often controls processing (that is, IA is a &lt;I&gt;data-driven&lt;/I&gt; application).
+For each connection, an IA does some finite amount of work 
+involving data exchange with its peer, where its peer may be either 
+a client or a server.
+The typical transaction steps of an IA are to accept a connection,
+read a request, do some finite and predictable amount of work to 
+process the request, then write a response to the peer that sent the 
+request.  One example of an IA is a Web server; 
+the most general example of an IA is a proxy server, because it both 
+accepts connections from clients and connects to other servers.&lt;/P&gt;
+&lt;P&gt;
+We assume that the performance of an IA is constrained by available CPU
+cycles rather than network bandwidth or disk I/O (that is, CPU
+is a bottleneck resource).
+&lt;P&gt;
+
+&lt;H4&gt;1.2 Performance and Scalability&lt;/H4&gt;
+&lt;P&gt;
+The &lt;I&gt;performance&lt;/I&gt; of an IA is usually evaluated as its
+throughput measured in transactions per second or bytes per second (one
+can be converted to the other, given the average transaction size).  There are
+several benchmarks that can be used to measure throughput of Web serving
+applications for specific workloads (such as 
+&lt;A HREF=&quot;<A HREF="http://www.spec.org/osg/web96/">http://www.spec.org/osg/web96/</A>&quot;&gt;SPECweb96&lt;/A&gt;,
+&lt;A HREF=&quot;<A HREF="http://www.mindcraft.com/webstone/">http://www.mindcraft.com/webstone/</A>&quot;&gt;WebStone&lt;/A&gt;,
+&lt;A HREF=&quot;<A HREF="http://www.zdnet.com/zdbop/webbench/">http://www.zdnet.com/zdbop/webbench/</A>&quot;&gt;WebBench&lt;/A&gt;).
+Although there is no common definition for &lt;I&gt;scalability&lt;/I&gt;, in general it
+expresses the ability of an application to sustain its performance when some
+external condition changes.  For IAs this external condition is either the
+number of clients (also known as &quot;users,&quot; &quot;simultaneous connections,&quot; or &quot;load
+generators&quot;) or the underlying hardware system size (number of CPUs, memory
+size, and so on).  Thus there are two types of scalability: &lt;I&gt;load
+scalability&lt;/I&gt; and &lt;I&gt;system scalability&lt;/I&gt;, respectively.
+&lt;P&gt;
+The figure below shows how the throughput of an idealized IA changes with
+the increasing number of clients (solid blue line).  Initially the throughput
+grows linearly (the slope represents the maximal throughput that one client
+can provide). Within this initial range, the IA is underutilized and CPUs are
+partially idle.  Further increase in the number of clients leads to a system
+saturation, and the throughput gradually stops growing as all CPUs become fully
+utilized.  After that point, the throughput stays flat because there are no
+more CPU cycles available.
+In the real world, however, each simultaneous connection
+consumes some computational and memory resources, even when idle, and this
+overhead grows with the number of clients.  Therefore, the throughput of the
+real world IA starts dropping after some point (dashed blue line in the figure
+below).  The rate at which the throughput drops depends, among other things, on
+application design.
+&lt;P&gt;
+We say that an application has a good &lt;I&gt;load scalability&lt;/I&gt; if it can
+sustain its throughput over a wide range of loads.
+Interestingly, the &lt;A HREF=&quot;<A HREF="http://www.spec.org/osg/web99/">http://www.spec.org/osg/web99/</A>&quot;&gt;SPECweb99&lt;/A&gt;
+benchmark somewhat reflects the Web server's load scalability because it
+measures the number of clients (load generators) given a mandatory minimal
+throughput per client (that is, it measures the server's &lt;I&gt;capacity&lt;/I&gt;).
+This is unlike &lt;A HREF=&quot;<A HREF="http://www.spec.org/osg/web96/">http://www.spec.org/osg/web96/</A>&quot;&gt;SPECweb96&lt;/A&gt; and
+other benchmarks that use the throughput as their main metric (see the figure
+below).
+&lt;P&gt;
+&lt;CENTER&gt;&lt;IMG SRC=&quot;fig.gif&quot; ALT=&quot;Figure: Throughput vs. Number of clients&quot;&gt;
+&lt;/CENTER&gt;
+&lt;P&gt;
+&lt;I&gt;System scalability&lt;/I&gt; is the ability of an application to sustain its
+performance per hardware unit (such as a CPU) with the increasing number of
+these units.  In other words, good system scalability means that doubling the
+number of processors will roughly double the application's throughput (dashed
+green line).  We assume here that the underlying operating system also scales
+well.  Good system scalability allows you to initially run an application on 
+the smallest system possible, while retaining the ability to move that
+application to a larger system if necessary, without excessive effort or
+expense.  That is, an application need not be rewritten or even undergo a
+major porting effort when changing system size.
+&lt;P&gt;
+Although scalability and performance are more important in the case of server
+IAs, they should also be considered for some client applications (such as 
+benchmark load generators).
+&lt;P&gt;
+
+&lt;H4&gt;1.3 Concurrency&lt;/H4&gt;
+&lt;P&gt;
+Concurrency reflects the parallelism in a system.  The two unrelated types 
+are &lt;I&gt;virtual&lt;/I&gt; concurrency and &lt;I&gt;real&lt;/I&gt; concurrency.
+&lt;UL&gt;
+&lt;LI&gt;Virtual (or apparent) concurrency is the number of simultaneous
+connections that a system supports.
+&lt;BR&gt;&lt;BR&gt;
+&lt;LI&gt;Real concurrency is the number of hardware devices, including
+CPUs, network cards, and disks, that actually allow a system to perform 
+tasks in parallel.
+&lt;/UL&gt;
+&lt;P&gt;
+An IA must provide virtual concurrency in order to serve many users
+simultaneously.
+To achieve maximum performance and scalability in doing so, the number of
+programming entities than an IA creates to be scheduled by the OS kernel
+should be
+kept close to (within an order of magnitude of) the real concurrency found on
+the system. These programming entities scheduled by the kernel are known as
+&lt;I&gt;kernel execution vehicles&lt;/I&gt;. Examples of kernel execution vehicles
+include Solaris lightweight processes and IRIX kernel threads.
+In other words, the number of kernel execution vehicles should be dictated by
+the system size and not by the number of simultaneous connections.
+&lt;P&gt;
+
+&lt;H3&gt;2. Existing Architectures&lt;/H3&gt;
+&lt;P&gt;
+There are a few different architectures that are commonly used by IAs. 
+These include the &lt;I&gt;Multi-Process&lt;/I&gt;, 
+&lt;I&gt;Multi-Threaded&lt;/I&gt;, and &lt;I&gt;Event-Driven State Machine&lt;/I&gt; 
+architectures.
+&lt;P&gt;
+&lt;H4&gt;2.1 Multi-Process Architecture&lt;/H4&gt;
+&lt;P&gt;
+In the Multi-Process (MP) architecture, an individual process is 
+dedicated to each simultaneous connection.
+A process performs all of a transaction's initialization steps 
+and services a connection completely before moving on to service 
+a new connection.
+&lt;P&gt;
+User sessions in IAs are relatively independent; therefore, no 
+synchronization between processes handling different connections is
+necessary.  Because each process has its own private address space,
+this architecture is very robust. If a process serving one of the connections
+crashes, the other sessions will not be affected.  However, to serve many
+concurrent connections, an equal number of processes must be employed.
+Because processes are kernel entities (and are in fact the heaviest ones), 
+the number of kernel entities will be at least as large as the number of 
+concurrent sessions. On most systems, good performance will not be achieved 
+when more than a few hundred processes are created because of the high 
+context-switching overhead. In other words, MP applications have poor load 
+scalability.
+&lt;P&gt;
+On the other hand, MP applications have very good system scalability, because
+no resources are shared among different processes and there is no
+synchronization overhead.
+&lt;P&gt;
+The Apache Web Server 1.x (&lt;A HREF=#refs1&gt;[Reference 1]&lt;/A&gt;) uses the MP 
+architecture on UNIX systems.
+&lt;P&gt;
+&lt;H4&gt;2.2 Multi-Threaded Architecture&lt;/H4&gt;
+&lt;P&gt;
+In the Multi-Threaded (MT) architecture, multiple independent threads 
+of control are employed within a single shared address space.  Like a 
+process in the MP architecture, each thread performs all of a
+transaction's initialization steps and services a connection completely
+before moving on to service a new connection.
+&lt;P&gt;
+Many modern UNIX operating systems implement a &lt;I&gt;many-to-few&lt;/I&gt; model when 
+mapping user-level threads to kernel entities.  In this model, an 
+arbitrarily large number of user-level threads is multiplexed onto a 
+lesser number of kernel execution vehicles.  Kernel execution 
+vehicles are also known as &lt;I&gt;virtual processors&lt;/I&gt;.  Whenever a user-level
+thread makes a blocking system call, the kernel execution vehicle it is using
+will become blocked in the kernel.  If there are no other non-blocked kernel
+execution vehicles and there are other runnable user-level threads, a new
+kernel execution vehicle will be created automatically.  This prevents the
+application from blocking when it can continue to make useful forward
+progress.
+&lt;P&gt;
+Because IAs are by nature network I/O driven, all concurrent sessions block on
+network I/O at various points.  As a result, the number of virtual processors
+created in the kernel grows close to the number of user-level threads
+(or simultaneous connections).  When this occurs, the many-to-few model
+effectively degenerates to a &lt;I&gt;one-to-one&lt;/I&gt; model.  Again, like in
+the MP architecture, the number of kernel execution vehicles is dictated by
+the number of simultaneous connections rather than by number of CPUs.  This
+reduces an application's load scalability.  However, because kernel threads
+(lightweight processes) use fewer resources and are more light-weight than
+traditional UNIX processes, an MT application should scale better with load
+than an MP application.
+&lt;P&gt;
+Unexpectedly, the small number of virtual processors sharing the same address
+space in the MT architecture destroys an application's system scalability
+because of contention among the threads on various locks.  Even if an
+application itself is carefully
+optimized to avoid lock contention around its own global data (a non-trivial
+task), there are still standard library functions and system calls
+that use common resources hidden from the application.  For example,
+on many platforms thread safety of memory allocation routines
+(&lt;TT&gt;malloc(3)&lt;/TT&gt;, &lt;TT&gt;free(3)&lt;/TT&gt;, and so on) is achieved by using a single
+global lock.  Another example is a per-process file descriptor table.
+This common resource table is shared by all kernel execution vehicles within
+the same process and must be protected when one modifies it via
+certain system calls (such as &lt;TT&gt;open(2)&lt;/TT&gt;, &lt;TT&gt;close(2)&lt;/TT&gt;, and so on).
+In addition to that, maintaining the caches coherent
+among CPUs on multiprocessor systems hurts performance when different threads
+running on different CPUs modify data items on the same cache line.
+&lt;P&gt;
+In order to improve load scalability, some applications employ a different
+type of MT architecture:  they create one or more thread(s) &lt;I&gt;per task&lt;/I&gt;
+rather than one thread &lt;I&gt;per connection&lt;/I&gt;.  For example, one small group
+of threads may be responsible for accepting client connections, another 
+for request processing, and yet another for serving responses.  The main
+advantage of this architecture is that it eliminates the tight coupling
+between the number of threads and number of simultaneous connections. However,
+in this architecture, different task-specific thread groups must share common
+work queues that must be protected by mutual exclusion locks (a typical
+producer-consumer problem).  This adds synchronization overhead that causes an
+application to perform badly on multiprocessor systems.  In other words, in
+this architecture, the application's system scalability is sacrificed for the
+sake of load scalability.
+&lt;P&gt;
+Of course, the usual nightmares of threaded programming, including data
+corruption, deadlocks, and race conditions, also make MT architecture (in any
+form) non-simplistic to use.
+&lt;P&gt;
+
+&lt;H4&gt;2.3 Event-Driven State Machine Architecture&lt;/H4&gt;
+&lt;P&gt;
+In the Event-Driven State Machine (EDSM) architecture, a single process
+is employed to concurrently process multiple connections. The basics of this
+architecture are described in Comer and Stevens
+&lt;A HREF=#refs2&gt;[Reference 2]&lt;/A&gt;.
+The EDSM architecture performs one basic data-driven step associated with
+a particular connection at a time, thus multiplexing many concurrent
+connections.  The process operates as a state machine that receives an event
+and then reacts to it.
+&lt;P&gt;
+In the idle state the EDSM calls &lt;TT&gt;select(2)&lt;/TT&gt; or &lt;TT&gt;poll(2)&lt;/TT&gt; to
+wait for network I/O events.  When a particular file descriptor is ready for
+I/O, the EDSM completes the corresponding basic step (usually by invoking a
+handler function) and starts the next one.  This architecture uses
+non-blocking system calls to perform asynchronous network I/O operations.
+For more details on non-blocking I/O see Stevens
+&lt;A HREF=#refs3&gt;[Reference 3]&lt;/A&gt;.
+&lt;P&gt;
+To take advantage of hardware parallelism (real concurrency), multiple
+identical processes may be created.  This is called Symmetric Multi-Process
+EDSM and is used, for example, in the Zeus Web Server
+(&lt;A HREF=#refs4&gt;[Reference 4]&lt;/A&gt;).  To more efficiently multiplex disk I/O,
+special &quot;helper&quot; processes may be created.  This is called Asymmetric
+Multi-Process EDSM and was proposed for Web servers by Druschel
+and others &lt;A HREF=#refs5&gt;[Reference 5]&lt;/A&gt;.
+&lt;P&gt;
+EDSM is probably the most scalable architecture for IAs.
+Because the number of simultaneous connections (virtual concurrency) is
+completely decoupled from the number of kernel execution vehicles (processes),
+this architecture has very good load scalability.  It requires only minimal 
+user-level resources to create and maintain additional connection.
+&lt;P&gt;
+Like MP applications, Multi-Process EDSM has very good system scalability
+because no resources are shared among different processes and there is no
+synchronization overhead.
+&lt;P&gt;
+Unfortunately, the EDSM architecture is monolithic rather than based on the
+concept of threads, so new applications generally need to be implemented from
+the ground up.  In effect, the EDSM architecture simulates threads and their
+stacks the hard way.
+&lt;P&gt;
+
+&lt;H3&gt;3. State Threads Library&lt;/H3&gt;
+&lt;P&gt;
+The State Threads library combines the advantages of all of the above
+architectures.  The interface preserves the programming simplicity of thread
+abstraction, allowing each simultaneous connection to be treated as a separate
+thread of execution within a single process. The underlying implementation is
+close to the EDSM architecture as the state of each particular concurrent
+session is saved in a separate memory segment.
+&lt;P&gt;
+
+&lt;H4&gt;3.1 State Changes and Scheduling&lt;/H4&gt;
+&lt;P&gt;
+The state of each concurrent session includes its stack environment 
+(stack pointer, program counter, CPU registers) and its stack.  Conceptually, 
+a thread context switch can be viewed as a process changing its state.  There 
+are no kernel entities involved other than processes.  
+Unlike other general-purpose threading libraries, the State Threads library
+is fully deterministic.  The thread context switch (process state change) can
+only happen in a well-known set of functions (at I/O points or at explicit
+synchronization points).  As a result, process-specific global data does not
+have to be protected by mutual exclusion locks in most cases.  The entire
+application is free to use all the static variables and non-reentrant library
+functions it wants, greatly simplifying programming and debugging while
+increasing performance.  This is somewhat similar to a &lt;I&gt;co-routine&lt;/I&gt; model
+(co-operatively multitasked threads), except that no explicit yield is needed
+--
+sooner or later, a thread performs a blocking I/O operation and thus surrenders
+control.  All threads of execution (simultaneous connections) have the
+same priority, so scheduling is non-preemptive, like in the EDSM architecture.
+Because IAs are data-driven (processing is limited by the size of network 
+buffers and data arrival rates), scheduling is non-time-slicing.
+&lt;P&gt;
+Only two types of external events are handled by the library's
+scheduler, because only these events can be detected by
+&lt;TT&gt;select(2)&lt;/TT&gt; or &lt;TT&gt;poll(2)&lt;/TT&gt;: I/O events (a file descriptor is ready
+for I/O) and time events
+(some timeout has expired).  However, other types of events (such as
+a signal sent to a process) can also be handled by converting them to I/O
+events.  For example, a signal handling function can perform a write to a pipe
+(&lt;TT&gt;write(2)&lt;/TT&gt; is reentrant/asynchronous-safe), thus converting a signal
+event to an I/O event.
+&lt;P&gt;
+To take advantage of hardware parallelism, as in the EDSM architecture,
+multiple processes can be created in either a symmetric or asymmetric manner.
+Process management is not in the library's scope but instead is left up to the
+application.
+&lt;P&gt;
+There are several general-purpose threading libraries that implement a
+&lt;I&gt;many-to-one&lt;/I&gt; model (many user-level threads to one kernel execution
+vehicle), using the same basic techniques as the State Threads library 
+(non-blocking I/O, event-driven scheduler, and so on).  For an example, see GNU
+Portable Threads (&lt;A HREF=#refs6&gt;[Reference 6]&lt;/A&gt;).  Because they are
+general-purpose, these libraries have different objectives than the State 
+Threads library.  The State Threads library is &lt;I&gt;not&lt;/I&gt; a general-purpose
+threading library,
+but rather an application library that targets only certain types of
+applications (IAs) in order to achieve the highest possible performance and
+scalability for those applications.
+&lt;P&gt;
+
+&lt;H4&gt;3.2 Scalability&lt;/H4&gt;
+&lt;P&gt;
+State threads are very lightweight user-level entities, and therefore creating
+and maintaining user connections requires minimal resources.  An application
+using the State Threads library scales very well with the increasing number
+of connections.
+&lt;P&gt;
+On multiprocessor systems an application should create multiple processes
+to take advantage of hardware parallelism.  Using multiple separate processes
+is the &lt;I&gt;only&lt;/I&gt; way to achieve the highest possible system scalability.
+This is because duplicating per-process resources is the only way to avoid
+significant synchronization overhead on multiprocessor systems.  Creating
+separate UNIX processes naturally offers resource duplication.  Again,
+as in the EDSM architecture, there is no connection between the number of
+simultaneous connections (which may be very large and changes within a wide
+range) and the number of kernel entities (which is usually small and constant).
+In other words, the State Threads library makes it possible to multiplex a
+large number of simultaneous connections onto a much smaller number of
+separate processes, thus allowing an application to scale well with both
+the load and system size.
+&lt;P&gt;
+
+&lt;H4&gt;3.3 Performance&lt;/H4&gt;
+&lt;P&gt;
+Performance is one of the library's main objectives.  The State Threads
+library is implemented to minimize the number of system calls and 
+to make thread creation and context switching as fast as possible.
+For example, per-thread signal mask does not exist (unlike
+POSIX threads), so there is no need to save and restore a process's
+signal mask on every thread context switch. This eliminates two system
+calls per context switch.  Signal events can be handled much more
+efficiently by converting them to I/O events (see above).
+&lt;P&gt;
+
+&lt;H4&gt;3.4 Portability&lt;/H4&gt;
+&lt;P&gt;
+The library uses the same general, underlying concepts as the EDSM 
+architecture, including non-blocking I/O, file descriptors, and 
+I/O multiplexing.  These concepts are available in some form on most 
+UNIX platforms, making the library very portable across many 
+flavors of UNIX.  There are only a few platform-dependent sections in the
+source.
+&lt;P&gt;
+
+&lt;H4&gt;3.5 State Threads and NSPR&lt;/H4&gt;
+&lt;P&gt;
+The State Threads library is a derivative of the Netscape Portable 
+Runtime library (NSPR) &lt;A HREF=#refs7&gt;[Reference 7]&lt;/A&gt;. The primary goal of 
+NSPR is to provide a platform-independent layer for system facilities, 
+where system facilities include threads, thread synchronization, and I/O.
+Performance and scalability are not the main concern of NSPR.  The 
+State Threads library addresses performance and scalability while 
+remaining much smaller than NSPR.  It is contained in 8 source files 
+as opposed to more than 400, but provides all the functionality that 
+is needed to write efficient IAs on UNIX-like platforms.
+&lt;P&gt;
+
+&lt;TABLE CELLPADDING=3&gt;
+&lt;TR&gt;
+&lt;TD&gt;&lt;/TD&gt;
+&lt;TH&gt;NSPR&lt;/TH&gt;
+&lt;TH&gt;State Threads&lt;/TH&gt;
+&lt;/TR&gt;
+&lt;TR&gt;
+&lt;TD&gt;&lt;B&gt;Lines of code&lt;/B&gt;&lt;/TD&gt;
+&lt;TD ALIGN=RIGHT&gt;~150,000&lt;/TD&gt;
+&lt;TD ALIGN=RIGHT&gt;~3000&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;TR&gt;
+&lt;TD&gt;&lt;B&gt;Dynamic library size&nbsp;&nbsp;&lt;BR&gt;(debug version)&lt;/B&gt;&lt;/TD&gt;
+&lt;TD&gt;&lt;/TD&gt;
+&lt;TD&gt;&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;TR&gt;
+&lt;TD&gt;IRIX&lt;/TD&gt;
+&lt;TD ALIGN=RIGHT&gt;~700 KB&lt;/TD&gt;
+&lt;TD ALIGN=RIGHT&gt;~60 KB&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;TR&gt;
+&lt;TD&gt;Linux&lt;/TD&gt;
+&lt;TD ALIGN=RIGHT&gt;~900 KB&lt;/TD&gt;
+&lt;TD ALIGN=RIGHT&gt;~70 KB&lt;/TD&gt;
+&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;P&gt;
+
+&lt;H3&gt;Conclusion&lt;/H3&gt;
+&lt;P&gt;
+State Threads is an application library which provides a foundation for
+writing &lt;A HREF=#IA&gt;Internet Applications&lt;/A&gt;.  To summarize, it has the
+following &lt;I&gt;advantages&lt;/I&gt;:
+&lt;P&gt;
+&lt;UL&gt;
+&lt;LI&gt;It allows the design of fast and highly scalable applications.  An
+application will scale well with both load and number of CPUs.
+&lt;P&gt;
+&lt;LI&gt;It greatly simplifies application programming and debugging because, as a
+rule, no mutual exclusion locking is necessary and the entire application is
+free to use static variables and non-reentrant library functions.
+&lt;/UL&gt;
+&lt;P&gt;
+The library's main &lt;I&gt;limitation&lt;/I&gt;:
+&lt;P&gt;
+&lt;UL&gt;
+&lt;LI&gt;All I/O operations on sockets must use the State Thread library's I/O
+functions because only those functions perform thread scheduling and prevent
+the application's processes from blocking.
+&lt;/UL&gt;
+&lt;P&gt;
+
+&lt;H3&gt;References&lt;/H3&gt;
+&lt;OL&gt;
+&lt;A NAME=&quot;refs1&quot;&gt;
+&lt;LI&gt; Apache Software Foundation,
+&lt;A HREF=&quot;<A HREF="http://www.apache.org">http://www.apache.org</A>&quot;&gt;<A HREF="http://www.apache.org&lt;/A">http://www.apache.org&lt;/A</A>&gt;.
+&lt;A NAME=&quot;refs2&quot;&gt;
+&lt;LI&gt; Douglas E. Comer, David L. Stevens, &lt;I&gt;Internetworking With TCP/IP,
+Vol. III: Client-Server Programming And Applications&lt;/I&gt;, Second Edition,
+Ch. 8, 12.
+&lt;A NAME=&quot;refs3&quot;&gt;
+&lt;LI&gt; W. Richard Stevens, &lt;I&gt;UNIX Network Programming&lt;/I&gt;, Second Edition,
+Vol. 1, Ch. 15.
+&lt;A NAME=&quot;refs4&quot;&gt;
+&lt;LI&gt; Zeus Technology Limited,
+&lt;A HREF=&quot;<A HREF="http://www.zeus.co.uk/">http://www.zeus.co.uk/</A>&quot;&gt;<A HREF="http://www.zeus.co.uk&lt;/A">http://www.zeus.co.uk&lt;/A</A>&gt;.
+&lt;A NAME=&quot;refs5&quot;&gt;
+&lt;LI&gt; Peter Druschel, Vivek S. Pai, Willy Zwaenepoel,
+&lt;A HREF=&quot;<A HREF="http://www.cs.rice.edu/~druschel/usenix99flash.ps.gz">http://www.cs.rice.edu/~druschel/usenix99flash.ps.gz</A>&quot;&gt;
+Flash: An Efficient and Portable Web Server&lt;/A&gt;. In &lt;I&gt;Proceedings of the
+USENIX 1999 Annual Technical Conference&lt;/I&gt;, Monterey, CA, June 1999.
+&lt;A NAME=&quot;refs6&quot;&gt;
+&lt;LI&gt; GNU Portable Threads,
+&lt;A HREF=&quot;<A HREF="http://www.gnu.org/software/pth/">http://www.gnu.org/software/pth/</A>&quot;&gt;<A HREF="http://www.gnu.org/software/pth/&lt;/A">http://www.gnu.org/software/pth/&lt;/A</A>&gt;.
+&lt;A NAME=&quot;refs7&quot;&gt;
+&lt;LI&gt; Netscape Portable Runtime,
+&lt;A HREF=&quot;<A HREF="http://www.mozilla.org/docs/refList/refNSPR/">http://www.mozilla.org/docs/refList/refNSPR/</A>&quot;&gt;<A HREF="http://www.mozilla.org/docs/refList/refNSPR/&lt;/A">http://www.mozilla.org/docs/refList/refNSPR/&lt;/A</A>&gt;.
+&lt;/OL&gt;
+
+&lt;H3&gt;Other resources covering various architectural issues in IAs&lt;/H3&gt;
+&lt;OL START=8&gt;
+&lt;LI&gt; Dan Kegel, &lt;I&gt;The C10K problem&lt;/I&gt;,
+&lt;A HREF=&quot;<A HREF="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</A>&quot;&gt;<A HREF="http://www.kegel.com/c10k.html&lt;/A">http://www.kegel.com/c10k.html&lt;/A</A>&gt;.
+&lt;/LI&gt;
+&lt;LI&gt; James C. Hu, Douglas C. Schmidt, Irfan Pyarali, &lt;I&gt;JAWS: Understanding
+High Performance Web Systems&lt;/I&gt;,
+&lt;A HREF=&quot;<A HREF="http://www.cs.wustl.edu/~jxh/research/research.html">http://www.cs.wustl.edu/~jxh/research/research.html</A>&quot;&gt;<A HREF="http://www.cs.wustl.edu/~jxh/research/research.html&lt;/A">http://www.cs.wustl.edu/~jxh/research/research.html&lt;/A</A>&gt;.&lt;/LI&gt;
+&lt;/OL&gt;
+&lt;P&gt;
+&lt;HR&gt;
+&lt;P&gt;
+
+&lt;CENTER&gt;&lt;FONT SIZE=-1&gt;Portions created by SGI are Copyright &copy; 2000
+Silicon Graphics, Inc.  All rights reserved.&lt;/FONT&gt;&lt;/CENTER&gt;
+&lt;P&gt;
+
+&lt;/BODY&gt;
+&lt;/HTML&gt;
+

Added: upwatch/trunk/st-1.6/docs/timeout_heap.txt
===================================================================
--- upwatch/trunk/st-1.6/docs/timeout_heap.txt	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/docs/timeout_heap.txt	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,60 @@
+How the timeout heap works
+
+As of version 1.5, the State Threads Library represents the queue of
+sleeping threads using a heap data structure rather than a sorted
+linked list.  This improves performance when there is a large number
+of sleeping threads, since insertion into a heap takes O(log N) time
+while insertion into a sorted list takes O(N) time.  For example, in
+one test 1000 threads were created, each thread called st_usleep()
+with a random time interval, and then all the threads where
+immediately interrupted and joined before the sleeps had a chance to
+finish.  The whole process was repeated 1000 times, for a total of a
+million sleep queue insertions and removals.  With the old list-based
+sleep queue, this test took 100 seconds; now it takes only 12 seconds.
+
+Heap data structures are typically based on dynamically resized
+arrays.  However, since the existing ST code base was very nicely
+structured around linking the thread objects into pointer-based lists
+without the need for any auxiliary data structures, implementing the
+heap using a similar nodes-and-pointers based approach seemed more
+appropriate for ST than introducing a separate array.
+
+Thus, the new ST timeout heap works by organizing the existing
+_st_thread_t objects in a balanced binary tree, just as they were
+previously organized into a doubly-linked, sorted list.  The global
+_ST_SLEEPQ variable, formerly a linked list head, is now simply a
+pointer to the root of this tree, and the root node of the tree is the
+thread with the earliest timeout.  Each thread object has two child
+pointers, &quot;left&quot; and &quot;right&quot;, pointing to threads with later timeouts.
+
+Each node in the tree is numbered with an integer index, corresponding
+to the array index in an array-based heap, and the tree is kept fully
+balanced and left-adjusted at all times.  In other words, the tree
+consists of any number of fully populated top levels, followed by a
+single bottom level which may be partially populated, such that any
+existing nodes form a contiguous block to the left and the spaces for
+missing nodes form a contiguous block to the right.  For example, if
+there are nine threads waiting for a timeout, they are numbered and
+arranged in a tree exactly as follows:
+
+              1
+           /     \
+          2       3
+         / \     / \
+        4   5   6   7
+       / \
+      8   9
+
+Each node has either no children, only a left child, or both a left
+and a right child.  Children always time out later than their parents
+(this is called the &quot;heap invariant&quot;), but when a node has two
+children, their mutual order is unspecified - the left child may time
+out before or after the right child.  If a node is numbered N, its
+left child is numbered 2N, and its right child is numbered 2N+1.
+
+There is no pointer from a child to its parent; all pointers point
+downward.  Additions and deletions both work by starting at the root
+and traversing the tree towards the leaves, going left or right
+according to the binary digits forming the index of the destination
+node.  As nodes are added or deleted, existing nodes are rearranged to
+maintain the heap invariant.

Added: upwatch/trunk/st-1.6/examples/Makefile
===================================================================
--- upwatch/trunk/st-1.6/examples/Makefile	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/Makefile	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,111 @@
+#
+# Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+# All Rights Reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met: 
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer. 
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived from
+#    this software without specific prior written permission. 
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+##########################
+# Supported OSes:
+#
+# AIX
+# FREEBSD
+# HPUX
+# HPUX_64
+# IRIX
+# IRIX_64
+# LINUX
+# LINUX_IA64
+# NETBSD
+# OPENBSD
+# OSF1
+# SOLARIS
+# SOLARIS_64
+
+##########################
+
+CC          = cc
+
+SHELL       = /bin/sh
+ECHO        = /bin/echo
+
+DEPTH       = ..
+BUILD       =
+TARGETDIR   =
+
+DEFINES     =
+CFLAGS      =
+OTHER_FLAGS =
+
+OBJDIR      = $(DEPTH)/$(TARGETDIR)
+INCDIR      = $(DEPTH)/$(TARGETDIR)
+LIBST       = $(OBJDIR)/libst.a
+HEADER      = $(INCDIR)/st.h
+
+LIBRESOLV   =
+EXTRALIBS   =
+
+ifeq ($(OS),)
+EXAMPLES    = unknown
+else
+EXAMPLES    = $(OBJDIR)/lookupdns $(OBJDIR)/proxy $(OBJDIR)/server
+endif
+
+
+##########################
+# Platform section.
+#
+
+ifeq (LINUX, $(findstring LINUX, $(OS)))
+LIBRESOLV   = -lresolv
+endif
+
+ifeq (SOLARIS, $(findstring SOLARIS, $(OS)))
+LIBRESOLV   = -lresolv
+EXTRALIBS   = -lsocket -lnsl
+endif
+
+#
+# End of platform section.
+##########################
+
+
+all: $(EXAMPLES)
+
+$(OBJDIR)/lookupdns: lookupdns.c $(OBJDIR)/res.o $(LIBST) $(HEADER)
+	$(CC) $(CFLAGS) -I$(INCDIR) lookupdns.c $(OBJDIR)/res.o $(LIBST) $(LIBRESOLV) $(EXTRALIBS) -o $@
+
+$(OBJDIR)/proxy: proxy.c $(LIBST) $(HEADER)
+	$(CC) $(CFLAGS) -I$(INCDIR) proxy.c $(LIBST) $(EXTRALIBS) -o $@
+
+$(OBJDIR)/server: server.c $(OBJDIR)/error.o $(LIBST) $(HEADER)
+	$(CC) $(CFLAGS) -I$(INCDIR) server.c $(OBJDIR)/error.o $(LIBST) $(EXTRALIBS) -o $@
+
+$(OBJDIR)/%.o: %.c
+	$(CC) $(CFLAGS) -I$(INCDIR) -c $&lt; -o $@
+
+.DEFAULT:
+	@cd $(DEPTH); $(MAKE) $@
+

Added: upwatch/trunk/st-1.6/examples/README
===================================================================
--- upwatch/trunk/st-1.6/examples/README	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/README	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,98 @@
+Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+All Rights Reserved.
+
+
+This directory contains three example programs.
+
+
+---------------------------------------------------------------------------
+
+PROGRAM
+
+    lookupdns
+
+FILES
+
+    lookupdns.c
+    res.c
+
+USAGE
+
+    lookupdns &lt;hostname1&gt; [&lt;hostname2&gt;] ...
+
+DESCRIPTION
+
+    This program performs asynchronous DNS host name resolution and reports
+    IP address for each &lt;hostname&gt; specified as a command line argument.
+    One ST thread is created for each host name.  All threads do host name
+    resolution concurrently.
+
+
+---------------------------------------------------------------------------
+
+PROGRAM
+
+    proxy
+
+FILES
+
+    proxy.c
+
+USAGE
+
+    proxy -l &lt;local_addr&gt; -r &lt;remote_addr&gt; [-p &lt;num_processes&gt;] [-S]
+
+    -l &lt;local_addr&gt;      bind to local address specified as [&lt;host&gt;]:&lt;port&gt;
+    -r &lt;remote_addr&gt;     connect to remote address specified as &lt;host&gt;:&lt;port&gt;
+    -p &lt;num_processes&gt;   create specified number of processes
+    -S                   serialize accept() calls from different processes
+                         on the same listening socket (if needed).
+
+DESCRIPTION
+
+    This program acts as a generic gateway.  It listens for connections to a
+    local address.  Upon accepting a client connection, it connects to the
+    specified remote address and then just pumps the data through without any
+    modification.
+
+
+---------------------------------------------------------------------------
+
+PROGRAM
+
+    server
+
+FILES
+
+    server.c
+    error.c
+
+USAGE
+
+    server -l &lt;log_directory&gt; [&lt;options&gt;]
+
+    -l &lt;log_directory&gt;      open all log files in specified directory.
+
+    Possible options:
+
+    -b &lt;host&gt;:&lt;port&gt;        bind to specified address (multiple addresses
+                            are permitted)
+    -p &lt;num_processes&gt;      create specified number of processes
+    -t &lt;min_thr&gt;:&lt;max_thr&gt;  specify thread limits per listening socket
+                            across all processes
+    -u &lt;user&gt;               change server's user id to specified value
+    -q &lt;backlog&gt;            set max length of pending connections queue
+    -a                      enable access logging
+    -i                      run in interactive mode (useful for debugging)
+    -S                      serialize accept() calls from different processes
+                            on the same listening socket (if needed).
+
+DESCRIPTION
+
+    This program is a general server example.  It accepts a client connection
+    and outputs a short HTML page.  It can be easily adapted to provide
+    other services.
+
+
+---------------------------------------------------------------------------
+

Added: upwatch/trunk/st-1.6/examples/error.c
===================================================================
--- upwatch/trunk/st-1.6/examples/error.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/error.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,168 @@
+/*
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;st.h&quot;
+
+/*
+ * Simple error reporting functions.
+ * Suggested in W. Richard Stevens' &quot;Advanced Programming in UNIX
+ * Environment&quot;.
+ */
+
+#define MAXLINE 4096  /* max line length */
+
+static void err_doit(int, int, const char *, va_list);
+
+
+/*
+ * Nonfatal error related to a system call.
+ * Print a message and return.
+ */
+void err_sys_report(int fd, const char *fmt, ...)
+{
+  va_list ap;
+
+  va_start(ap, fmt);
+  err_doit(fd, 1, fmt, ap);
+  va_end(ap);
+}
+
+
+/*
+ * Fatal error related to a system call.
+ * Print a message and terminate.
+ */
+void err_sys_quit(int fd, const char *fmt, ...)
+{
+  va_list ap;
+
+  va_start(ap, fmt);
+  err_doit(fd, 1, fmt, ap);
+  va_end(ap);
+  exit(1);
+}
+
+
+/*
+ * Fatal error related to a system call.
+ * Print a message, dump core, and terminate.
+ */
+void err_sys_dump(int fd, const char *fmt, ...)
+{
+  va_list ap;
+
+  va_start(ap, fmt);
+  err_doit(fd, 1, fmt, ap);
+  va_end(ap);
+  abort();  /* dump core and terminate */
+  exit(1);  /* shouldn't get here */
+}
+
+
+/*
+ * Nonfatal error unrelated to a system call.
+ * Print a message and return.
+ */
+void err_report(int fd, const char *fmt, ...)
+{
+  va_list ap;
+
+  va_start(ap, fmt);
+  err_doit(fd, 0, fmt, ap);
+  va_end(ap);
+}
+
+
+/*
+ * Fatal error unrelated to a system call.
+ * Print a message and terminate.
+ */
+void err_quit(int fd, const char *fmt, ...)
+{
+  va_list ap;
+
+  va_start(ap, fmt);
+  err_doit(fd, 0, fmt, ap);
+  va_end(ap);
+  exit(1);
+}
+
+
+/*
+ * Return a pointer to a string containing current time.
+ */
+char *err_tstamp(void)
+{
+  static char *months[] = { &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
+                            &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; };
+  static char str[32];
+  static time_t lastt = 0;
+  struct tm *tmp;
+  time_t currt = st_time();
+
+  if (currt == lastt)
+    return str;
+
+  tmp = localtime(&amp;currt);
+  sprintf(str, &quot;[%02d/%s/%d:%02d:%02d:%02d] &quot;, tmp-&gt;tm_mday,
+          months[tmp-&gt;tm_mon], 1900 + tmp-&gt;tm_year, tmp-&gt;tm_hour,
+          tmp-&gt;tm_min, tmp-&gt;tm_sec);
+  lastt = currt;
+
+  return str;
+}
+
+
+/*
+ * Print a message and return to caller.
+ * Caller specifies &quot;errnoflag&quot;.
+ */
+static void err_doit(int fd, int errnoflag, const char *fmt, va_list ap)
+{
+  int errno_save;
+  char buf[MAXLINE];
+
+  errno_save = errno;         /* value caller might want printed   */
+  strcpy(buf, err_tstamp());  /* prepend a message with time stamp */
+  vsprintf(buf + strlen(buf), fmt, ap);
+  if (errnoflag)
+    sprintf(buf + strlen(buf), &quot;: %s\n&quot;, strerror(errno_save));
+  else
+    strcat(buf, &quot;\n&quot;);
+  write(fd, buf, strlen(buf));
+  errno = errno_save;
+}
+

Added: upwatch/trunk/st-1.6/examples/lookupdns.c
===================================================================
--- upwatch/trunk/st-1.6/examples/lookupdns.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/lookupdns.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,103 @@
+/*
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+#include &lt;netdb.h&gt;
+#include &quot;st.h&quot;
+
+#if !defined(NETDB_INTERNAL) &amp;&amp; defined(h_NETDB_INTERNAL)
+#define NETDB_INTERNAL h_NETDB_INTERNAL
+#endif
+
+/* Resolution timeout (in microseconds) */
+#define TIMEOUT (2*1000000LL)
+
+/* External function defined in the res.c file */
+int dns_getaddr(const char *host, struct in_addr *addr, st_utime_t timeout);
+
+
+void *do_resolve(void *host)
+{
+  struct in_addr addr;
+
+  /* Use dns_getaddr() instead of gethostbyname(3) to get IP address */
+  if (dns_getaddr(host, &amp;addr, TIMEOUT) &lt; 0) {
+    fprintf(stderr, &quot;dns_getaddr: can't resolve %s: &quot;, (char *)host);
+    if (h_errno == NETDB_INTERNAL)
+      perror(&quot;&quot;);
+    else
+      herror(&quot;&quot;);
+  } else
+    printf(&quot;%-40s %s\n&quot;, (char *)host, inet_ntoa(addr));
+
+  return NULL;
+}
+
+
+/*
+ * Asynchronous DNS host name resolution. This program creates one
+ * ST thread for each host name (specified as command line arguments).
+ * All threads do host name resolution concurrently.
+ */
+int main(int argc, char *argv[])
+{
+  int i;
+
+  if (argc &lt; 2) {
+    fprintf(stderr, &quot;Usage: %s &lt;hostname1&gt; [&lt;hostname2&gt;] ...\n&quot;, argv[0]);
+    exit(1);
+  }
+
+  if (st_init() &lt; 0) {
+    perror(&quot;st_init&quot;);
+    exit(1);
+  }
+
+  for (i = 1; i &lt; argc; i++) {
+    /* Create a separate thread for each host name */
+    if (st_thread_create(do_resolve, argv[i], 0, 0) == NULL) {
+      perror(&quot;st_thread_create&quot;);
+      exit(1);
+    }
+  }
+
+  st_thread_exit(NULL);
+
+  /* NOTREACHED */
+  return 1;
+}
+

Added: upwatch/trunk/st-1.6/examples/proxy.c
===================================================================
--- upwatch/trunk/st-1.6/examples/proxy.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/proxy.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,367 @@
+/*
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+#include &lt;netdb.h&gt;
+#include &quot;st.h&quot;
+
+#define IOBUFSIZE (16*1024)
+
+#ifndef INADDR_NONE
+#define INADDR_NONE 0xffffffff
+#endif
+
+static char *prog;                     /* Program name   */
+static struct sockaddr_in rmt_addr;    /* Remote address */
+
+static void read_address(const char *str, struct sockaddr_in *sin);
+static void start_daemon(void);
+static int  cpu_count(void);
+static void set_concurrency(int nproc);
+static void *handle_request(void *arg);
+static void print_sys_error(const char *msg);
+
+
+/*
+ * This program acts as a generic gateway. It listens for connections
+ * to a local address ('-l' option). Upon accepting a client connection,
+ * it connects to the specified remote address ('-r' option) and then
+ * just pumps the data through without any modification.
+ */
+int main(int argc, char *argv[])
+{
+  extern char *optarg;
+  int opt, sock, n;
+  int laddr, raddr, num_procs;
+  int serialize_accept = 0;
+  struct sockaddr_in lcl_addr, cli_addr;
+  st_netfd_t cli_nfd, srv_nfd;
+
+  prog = argv[0];
+  num_procs = laddr = raddr = 0;
+
+  /* Parse arguments */
+  while((opt = getopt(argc, argv, &quot;l:r:p:Sh&quot;)) != EOF) {
+    switch (opt) {
+    case 'l':
+      read_address(optarg, &amp;lcl_addr);
+      laddr = 1;
+      break;
+    case 'r':
+      read_address(optarg, &amp;rmt_addr);
+      if (rmt_addr.sin_addr.s_addr == INADDR_ANY) {
+	fprintf(stderr, &quot;%s: invalid remote address: %s\n&quot;, prog, optarg);
+	exit(1);
+      }
+      raddr = 1;
+      break;
+    case 'p':
+      num_procs = atoi(optarg);
+      if (num_procs &lt; 1) {
+	fprintf(stderr, &quot;%s: invalid number of processes: %s\n&quot;, prog, optarg);
+	exit(1);
+      }
+      break;
+    case 'S':
+      /*
+       * Serialization decision is tricky on some platforms. For example,
+       * Solaris 2.6 and above has kernel sockets implementation, so supposedly
+       * there is no need for serialization. The ST library may be compiled
+       * on one OS version, but used on another, so the need for serialization
+       * should be determined at run time by the application. Since it's just
+       * an example, the serialization decision is left up to user.
+       * Only on platforms where the serialization is never needed on any OS
+       * version st_netfd_serialize_accept() is a no-op.
+       */
+      serialize_accept = 1;
+      break;
+    case 'h':
+    case '?':
+      fprintf(stderr, &quot;Usage: %s -l &lt;[host]:port&gt; -r &lt;host:port&gt; &quot;
+	      &quot;[-p &lt;num_processes&gt;] [-S]\n&quot;, prog);
+      exit(1);
+    }
+  }
+  if (!laddr) {
+    fprintf(stderr, &quot;%s: local address required\n&quot;, prog);
+    exit(1);
+  }
+  if (!raddr) {
+    fprintf(stderr, &quot;%s: remote address required\n&quot;, prog);
+    exit(1);
+  }
+  if (num_procs == 0)
+    num_procs = cpu_count();
+
+  fprintf(stderr, &quot;%s: starting proxy daemon on %s:%d\n&quot;, prog,
+	  inet_ntoa(lcl_addr.sin_addr), ntohs(lcl_addr.sin_port));
+
+  /* Start the daemon */
+  start_daemon();
+
+  /* Initialize the ST library */
+  if (st_init() &lt; 0) {
+    print_sys_error(&quot;st_init&quot;);
+    exit(1);
+  }
+
+  /* Create and bind listening socket */
+  if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
+    print_sys_error(&quot;socket&quot;);
+    exit(1);
+  }
+  n = 1;
+  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;n, sizeof(n)) &lt; 0) {
+    print_sys_error(&quot;setsockopt&quot;);
+    exit(1);
+  }
+  if (bind(sock, (struct sockaddr *)&amp;lcl_addr, sizeof(lcl_addr)) &lt; 0) {
+    print_sys_error(&quot;bind&quot;);
+    exit(1);
+  }
+  listen(sock, 128);
+  if ((srv_nfd = st_netfd_open_socket(sock)) == NULL) {
+    print_sys_error(&quot;st_netfd_open&quot;);
+    exit(1);
+  }
+  /* See the comment regarding serialization decision above */
+  if (num_procs &gt; 1 &amp;&amp; serialize_accept &amp;&amp; st_netfd_serialize_accept(srv_nfd)
+      &lt; 0) {
+    print_sys_error(&quot;st_netfd_serialize_accept&quot;);
+    exit(1);
+  }
+
+  /* Start server processes */
+  set_concurrency(num_procs);
+
+  for ( ; ; ) {
+    n = sizeof(cli_addr);
+    cli_nfd = st_accept(srv_nfd, (struct sockaddr *)&amp;cli_addr, &amp;n, -1);
+    if (cli_nfd == NULL) {
+      print_sys_error(&quot;st_accept&quot;);
+      exit(1);
+    }
+    if (st_thread_create(handle_request, cli_nfd, 0, 0) == NULL) {
+      print_sys_error(&quot;st_thread_create&quot;);
+      exit(1);
+    }
+  }
+
+  /* NOTREACHED */
+  return 1;
+}
+
+
+static void read_address(const char *str, struct sockaddr_in *sin)
+{
+  char host[128], *p;
+  struct hostent *hp;
+  short port;
+
+  strcpy(host, str);
+  if ((p = strchr(host, ':')) == NULL) {
+    fprintf(stderr, &quot;%s: invalid address: %s\n&quot;, prog, host);
+    exit(1);
+  }
+  *p++ = '\0';
+  port = (short) atoi(p);
+  if (port &lt; 1) {
+    fprintf(stderr, &quot;%s: invalid port: %s\n&quot;, prog, p);
+    exit(1);
+  }
+
+  memset(sin, 0, sizeof(struct sockaddr_in));
+  sin-&gt;sin_family = AF_INET;
+  sin-&gt;sin_port = htons(port);
+  if (host[0] == '\0') {
+    sin-&gt;sin_addr.s_addr = INADDR_ANY;
+    return;
+  }
+  sin-&gt;sin_addr.s_addr = inet_addr(host);
+  if (sin-&gt;sin_addr.s_addr == INADDR_NONE) {
+    /* not dotted-decimal */
+    if ((hp = gethostbyname(host)) == NULL) {
+      fprintf(stderr, &quot;%s: can't resolve address: %s\n&quot;, prog, host);
+      exit(1);
+    }
+    memcpy(&amp;sin-&gt;sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
+  }
+}
+
+static void *handle_request(void *arg)
+{
+  struct pollfd pds[2];
+  st_netfd_t cli_nfd, rmt_nfd;
+  int sock, n;
+  char buf[IOBUFSIZE];
+
+  cli_nfd = (st_netfd_t) arg;
+  pds[0].fd = st_netfd_fileno(cli_nfd);
+  pds[0].events = POLLIN;
+
+  /* Connect to remote host */
+  if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
+    print_sys_error(&quot;socket&quot;);
+    goto done;
+  }
+  if ((rmt_nfd = st_netfd_open_socket(sock)) == NULL) {
+    print_sys_error(&quot;st_netfd_open_socket&quot;);
+    close(sock);
+    goto done;
+  }
+  if (st_connect(rmt_nfd, (struct sockaddr *)&amp;rmt_addr,
+		 sizeof(rmt_addr), -1) &lt; 0) {
+    print_sys_error(&quot;st_connect&quot;);
+    st_netfd_close(rmt_nfd);
+    goto done;
+  }
+  pds[1].fd = sock;
+  pds[1].events = POLLIN;
+
+  /* Now just pump the data through */
+  for ( ; ; ) {
+    pds[0].revents = 0;
+    pds[1].revents = 0;
+
+    if (st_poll(pds, 2, -1) &lt;= 0) {
+      print_sys_error(&quot;st_poll&quot;);
+      break;
+    }
+
+    if (pds[0].revents &amp; POLLIN) {
+      if ((n = (int) st_read(cli_nfd, buf, IOBUFSIZE, -1)) &lt;= 0)
+        break;
+      if (st_write(rmt_nfd, buf, n, -1) != n)
+        break;
+    }
+
+    if (pds[1].revents &amp; POLLIN) {
+      if ((n = (int) st_read(rmt_nfd, buf, IOBUFSIZE, -1)) &lt;= 0)
+        break;
+      if (st_write(cli_nfd, buf, n, -1) != n)
+        break;
+    }
+  }
+  st_netfd_close(rmt_nfd);
+
+done:
+
+  st_netfd_close(cli_nfd);
+
+  return NULL;
+}
+
+static void start_daemon(void)
+{
+  pid_t pid;
+
+  /* Start forking */
+  if ((pid = fork()) &lt; 0) {
+    print_sys_error(&quot;fork&quot;);
+    exit(1);
+  }
+  if (pid &gt; 0)
+    exit(0);                        /* parent */
+
+  /* First child process */
+  setsid();                         /* become session leader */
+
+  if ((pid = fork()) &lt; 0) {
+    print_sys_error(&quot;fork&quot;);
+    exit(1);
+  }
+  if (pid &gt; 0)                      /* first child */
+    exit(0);
+
+  chdir(&quot;/&quot;);
+  umask(022);
+}
+
+/*
+ * Create separate processes (&quot;virtual processors&quot;). Since it's just an
+ * example, there is no watchdog - the parent just exits leaving children
+ * on their own.
+ */
+static void set_concurrency(int nproc)
+{
+  pid_t pid;
+  int i;
+
+  if (nproc &lt; 1)
+    nproc = 1;
+
+  for (i = 0; i &lt; nproc; i++) {
+    if ((pid = fork()) &lt; 0) {
+      print_sys_error(&quot;fork&quot;);
+      exit(1);
+    }
+    /* Child returns */
+    if (pid == 0)
+      return;
+  }
+
+  /* Parent just exits */
+  exit(0);
+}
+
+static int cpu_count(void)
+{
+  int n;
+
+#if defined (_SC_NPROCESSORS_ONLN)
+  n = (int) sysconf(_SC_NPROCESSORS_ONLN);
+#elif defined (_SC_NPROC_ONLN)
+  n = (int) sysconf(_SC_NPROC_ONLN);
+#elif defined (HPUX)
+#include &lt;sys/mpctl.h&gt;
+  n = mpctl(MPC_GETNUMSPUS, 0, 0);
+#else
+  n = -1;
+  errno = ENOSYS;
+#endif
+
+  return n;
+}
+
+static void print_sys_error(const char *msg)
+{
+  fprintf(stderr, &quot;%s: %s: %s\n&quot;, prog, msg, strerror(errno));
+}
+

Added: upwatch/trunk/st-1.6/examples/res.c
===================================================================
--- upwatch/trunk/st-1.6/examples/res.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/res.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 1985, 1988, 1993
+ *    The Regents of the University of California.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if defined (DARWIN)
+#define BIND_8_COMPAT
+#endif
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/nameser.h&gt;
+#include &lt;resolv.h&gt;
+#include &lt;netdb.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;st.h&quot;
+
+#define MAXPACKET 1024
+
+#if !defined(NETDB_INTERNAL) &amp;&amp; defined(h_NETDB_INTERNAL)
+#define NETDB_INTERNAL h_NETDB_INTERNAL
+#endif
+
+/* New in Solaris 7 */
+#ifdef ns_get16
+#define _getshort(cp) ns_get16(cp)
+#endif
+
+typedef union {
+    HEADER hdr;
+    u_char buf[MAXPACKET];
+} querybuf_t;
+
+
+static int parse_answer(querybuf_t *ans, int len, struct in_addr *addr)
+{
+  char buf[MAXPACKET];
+  HEADER *ahp;
+  u_char *cp, *eoa;
+  int type, n;
+
+  ahp = &amp;ans-&gt;hdr;
+  eoa = ans-&gt;buf + len;
+  cp = ans-&gt;buf + sizeof(HEADER);
+
+  while (ahp-&gt;qdcount &gt; 0) {
+    ahp-&gt;qdcount--;
+    cp += dn_skipname(cp, eoa) + QFIXEDSZ;
+  }
+  while (ahp-&gt;ancount &gt; 0 &amp;&amp; cp &lt; eoa) {
+    ahp-&gt;ancount--;
+    if ((n = dn_expand(ans-&gt;buf, eoa, cp, buf, sizeof(buf))) &lt; 0)
+      break;
+    cp += n;
+    type = _getshort(cp);
+    cp += 8;
+    n = _getshort(cp);
+    cp += 2;
+    if (type == T_CNAME) {
+      cp += n;
+      continue;
+    }
+    memcpy(addr, cp, n);
+    return 0;
+  }
+
+  h_errno = TRY_AGAIN;
+  return -1;
+}
+
+
+static int query_domain(st_netfd_t nfd, const char *name, struct in_addr *addr,
+			st_utime_t timeout)
+{
+  querybuf_t qbuf;
+  u_char *buf = qbuf.buf;
+  HEADER *hp = &amp;qbuf.hdr;
+  int blen = sizeof(qbuf);
+  int i, len, id;
+
+  for (i = 0; i &lt; _res.nscount; i++) {
+    len = res_mkquery(QUERY, name, C_IN, T_A, NULL, 0, NULL, buf, blen);
+    if (len &lt;= 0) {
+      h_errno = NO_RECOVERY;
+      return -1;
+    }
+    id = hp-&gt;id;
+
+    if (st_sendto(nfd, buf, len, (struct sockaddr *)&amp;(_res.nsaddr_list[i]),
+		  sizeof(struct sockaddr), timeout) != len) {
+      h_errno = NETDB_INTERNAL;
+      /* EINTR means interrupt by other thread, NOT by a caught signal */
+      if (errno == EINTR)
+	return -1;
+      continue;
+    }
+
+    /* Wait for reply */
+    do {
+      len = st_recvfrom(nfd, buf, blen, NULL, NULL, timeout);
+      if (len &lt;= 0)
+	break;
+    } while (id != hp-&gt;id);
+
+    if (len &lt; HFIXEDSZ) {
+      h_errno = NETDB_INTERNAL;
+      if (len &gt;= 0)
+	errno = EMSGSIZE;
+      else if (errno == EINTR)  /* see the comment above */
+	return -1;
+      continue;
+    }
+
+    hp-&gt;ancount = ntohs(hp-&gt;ancount);
+    hp-&gt;qdcount = ntohs(hp-&gt;qdcount);
+    if ((hp-&gt;rcode != NOERROR) || (hp-&gt;ancount == 0)) {
+      switch (hp-&gt;rcode) {
+      case NXDOMAIN:
+	h_errno = HOST_NOT_FOUND;
+	break;
+      case SERVFAIL:
+	h_errno = TRY_AGAIN;
+	break;
+      case NOERROR:
+	h_errno = NO_DATA;
+	break;
+      case FORMERR:
+      case NOTIMP:
+      case REFUSED:
+      default:
+	h_errno = NO_RECOVERY;
+      }
+      continue;
+    }
+
+    if (parse_answer(&amp;qbuf, len, addr) == 0)
+      return 0;
+  }
+
+  return -1;
+}
+
+
+#define CLOSE_AND_RETURN(ret) \
+  {                           \
+    n = errno;                \
+    st_netfd_close(nfd);      \
+    errno = n;                \
+    return (ret);             \
+  }
+
+
+int dns_getaddr(const char *host, struct in_addr *addr, st_utime_t timeout)
+{
+  char name[MAXDNAME], **domain;
+  const char *cp;
+  int s, n, maxlen, dots;
+  int trailing_dot, tried_as_is;
+  st_netfd_t nfd;
+
+  if ((_res.options &amp; RES_INIT) == 0 &amp;&amp; res_init() == -1) {
+    h_errno = NETDB_INTERNAL;
+    return -1;
+  }
+  if (_res.options &amp; RES_USEVC) {
+    h_errno = NETDB_INTERNAL;
+    errno = ENOSYS;
+    return -1;
+  }
+  if (!host || *host == '\0') {
+    h_errno = HOST_NOT_FOUND;
+    return -1;
+  }
+
+  /* Create UDP socket */
+  if ((s = socket(PF_INET, SOCK_DGRAM, 0)) &lt; 0) {
+    h_errno = NETDB_INTERNAL;
+    return -1;
+  }
+  if ((nfd = st_netfd_open_socket(s)) == NULL) {
+    h_errno = NETDB_INTERNAL;
+    n = errno;
+    close(s);
+    errno = n;
+    return -1;
+  }
+
+  maxlen = sizeof(name) - 1;
+  n = 0;
+  dots = 0;
+  trailing_dot = 0;
+  tried_as_is = 0;
+
+  for (cp = host; *cp &amp;&amp; n &lt; maxlen; cp++) {
+    dots += (*cp == '.');
+    name[n++] = *cp;
+  }
+  if (name[n - 1] == '.')
+    trailing_dot = 1;
+
+  /*
+   * If there are dots in the name already, let's just give it a try
+   * 'as is'.  The threshold can be set with the &quot;ndots&quot; option.
+   */
+  if (dots &gt;= _res.ndots) {
+    if (query_domain(nfd, host, addr, timeout) == 0)
+      CLOSE_AND_RETURN(0);
+    if (h_errno == NETDB_INTERNAL &amp;&amp; errno == EINTR)
+      CLOSE_AND_RETURN(-1);
+    tried_as_is = 1;
+  }
+
+  /*
+   * We do at least one level of search if
+   *     - there is no dot and RES_DEFNAME is set, or
+   *     - there is at least one dot, there is no trailing dot,
+   *       and RES_DNSRCH is set.
+   */
+  if ((!dots &amp;&amp; (_res.options &amp; RES_DEFNAMES)) ||
+      (dots &amp;&amp; !trailing_dot &amp;&amp; (_res.options &amp; RES_DNSRCH))) {
+    name[n++] = '.';
+    for (domain = _res.dnsrch; *domain; domain++) {
+      strncpy(name + n, *domain, maxlen - n);
+      if (query_domain(nfd, name, addr, timeout) == 0)
+	CLOSE_AND_RETURN(0);
+      if (h_errno == NETDB_INTERNAL &amp;&amp; errno == EINTR)
+	CLOSE_AND_RETURN(-1);
+      if (!(_res.options &amp; RES_DNSRCH))
+	break;
+    }
+  }
+
+  /*
+   * If we have not already tried the name &quot;as is&quot;, do that now.
+   * note that we do this regardless of how many dots were in the
+   * name or whether it ends with a dot.
+   */
+  if (!tried_as_is) {
+    if (query_domain(nfd, host, addr, timeout) == 0)
+      CLOSE_AND_RETURN(0);
+  }
+
+  CLOSE_AND_RETURN(-1);
+}
+

Added: upwatch/trunk/st-1.6/examples/server.c
===================================================================
--- upwatch/trunk/st-1.6/examples/server.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/examples/server.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,1023 @@
+/*
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;time.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/wait.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+#include &lt;netdb.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;pwd.h&gt;
+#include &quot;st.h&quot;
+
+
+/******************************************************************
+ * Server configuration parameters
+ */
+
+/* Log files */
+#define PID_FILE    &quot;pid&quot;
+#define ERRORS_FILE &quot;errors&quot;
+#define ACCESS_FILE &quot;access&quot;
+
+/* Default server port */
+#define SERV_PORT_DEFAULT 8000
+
+/* Socket listen queue size */
+#define LISTENQ_SIZE_DEFAULT 256
+
+/* Max number of listening sockets (&quot;hardware virtual servers&quot;) */
+#define MAX_BIND_ADDRS 16
+
+/* Max number of &quot;spare&quot; threads per process per socket */
+#define MAX_WAIT_THREADS_DEFAULT 8
+
+/* Number of file descriptors needed to handle one client session */
+#define FD_PER_THREAD 2
+
+/* Access log buffer flushing interval (in seconds) */
+#define ACCLOG_FLUSH_INTERVAL 30
+
+/* Request read timeout (in seconds) */
+#define REQUEST_TIMEOUT 30
+
+
+/******************************************************************
+ * Global data
+ */
+
+struct socket_info {
+  st_netfd_t nfd;               /* Listening socket                     */
+  char *addr;                   /* Bind address                         */
+  int port;                     /* Port                                 */
+  int wait_threads;             /* Number of threads waiting to accept  */
+  int busy_threads;             /* Number of threads processing request */
+  int rqst_count;               /* Total number of processed requests   */
+} srv_socket[MAX_BIND_ADDRS];   /* Array of listening sockets           */
+
+static int sk_count = 0;        /* Number of listening sockets          */
+
+static int vp_count = 0;        /* Number of server processes (VPs)     */
+static pid_t *vp_pids;          /* Array of VP pids                     */
+
+static int my_index = -1;       /* Current process index */
+static pid_t my_pid = -1;       /* Current process pid   */
+
+static st_netfd_t sig_pipe[2];  /* Signal pipe           */
+
+/*
+ * Configuration flags/parameters
+ */
+static int interactive_mode = 0;
+static int serialize_accept = 0;
+static int log_access       = 0;
+static char *logdir     = NULL;
+static char *username   = NULL;
+static int listenq_size = LISTENQ_SIZE_DEFAULT;
+static int errfd        = STDERR_FILENO;
+
+/*
+ * Thread throttling parameters (all numbers are per listening socket).
+ * Zero values mean use default.
+ */
+static int max_threads = 0;       /* Max number of threads         */
+static int max_wait_threads = 0;  /* Max number of &quot;spare&quot; threads */
+static int min_wait_threads = 2;  /* Min number of &quot;spare&quot; threads */
+
+
+/******************************************************************
+ * Useful macros
+ */
+
+#ifndef INADDR_NONE
+#define INADDR_NONE 0xffffffff
+#endif
+
+#define SEC2USEC(s) ((s)*1000000LL)
+
+#define WAIT_THREADS(i)  (srv_socket[i].wait_threads)
+#define BUSY_THREADS(i)  (srv_socket[i].busy_threads)
+#define TOTAL_THREADS(i) (WAIT_THREADS(i) + BUSY_THREADS(i))
+#define RQST_COUNT(i)    (srv_socket[i].rqst_count)
+
+
+/******************************************************************
+ * Forward declarations
+ */
+
+static void usage(const char *progname);
+static void parse_arguments(int argc, char *argv[]);
+static void start_daemon(void);
+static void set_thread_throttling(void);
+static void create_listeners(void);
+static void change_user(void);
+static void open_log_files(void);
+static void start_processes(void);
+static void wdog_sighandler(int signo);
+static void child_sighandler(int signo);
+static void install_sighandlers(void);
+static void start_threads(void);
+static void *process_signals(void *arg);
+static void *flush_acclog_buffer(void *arg);
+static void *handle_connections(void *arg);
+static void dump_server_info(void);
+
+static void Signal(int sig, void (*handler)(int));
+static int cpu_count(void);
+
+extern void handle_session(long srv_socket_index, st_netfd_t cli_nfd);
+extern void load_configs(void);
+extern void logbuf_open(void);
+extern void logbuf_flush(void);
+extern void logbuf_close(void);
+
+/* Error reporting functions defined in the error.c file */
+extern void err_sys_report(int fd, const char *fmt, ...);
+extern void err_sys_quit(int fd, const char *fmt, ...);
+extern void err_sys_dump(int fd, const char *fmt, ...);
+extern void err_report(int fd, const char *fmt, ...);
+extern void err_quit(int fd, const char *fmt, ...);
+
+
+/*
+ * General server example: accept a client connection and do something.
+ * This program just outputs a short HTML page, but can be easily adapted
+ * to do other things.
+ *
+ * This server creates a constant number of processes (&quot;virtual processors&quot;
+ * or VPs) and replaces them when they die. Each virtual processor manages
+ * its own independent set of state threads (STs), the number of which varies
+ * with load against the server. Each state thread listens to exactly one
+ * listening socket. The initial process becomes the watchdog, waiting for
+ * children (VPs) to die or for a signal requesting termination or restart.
+ * Upon receiving a restart signal (SIGHUP), all VPs close and then reopen
+ * log files and reload configuration. All currently active connections remain
+ * active. It is assumed that new configuration affects only request
+ * processing and not the general server parameters such as number of VPs,
+ * thread limits, bind addresses, etc. Those are specified as command line
+ * arguments, so the server has to be stopped and then started again in order
+ * to change them.
+ *
+ * Each state thread loops processing connections from a single listening
+ * socket. Only one ST runs on a VP at a time, and VPs do not share memory,
+ * so no mutual exclusion locking is necessary on any data, and the entire
+ * server is free to use all the static variables and non-reentrant library
+ * functions it wants, greatly simplifying programming and debugging and
+ * increasing performance (for example, it is safe to ++ and -- all global
+ * counters or call inet_ntoa(3) without any mutexes). The current thread on
+ * each VP maintains equilibrium on that VP, starting a new thread or
+ * terminating itself if the number of spare threads exceeds the lower or
+ * upper limit.
+ *
+ * All I/O operations on sockets must use the State Thread library's I/O
+ * functions because only those functions prevent blocking of the entire VP
+ * process and perform state thread scheduling.
+ */
+int main(int argc, char *argv[])
+{
+  /* Parse command-line options */
+  parse_arguments(argc, argv);
+
+  /* Allocate array of server pids */
+  if ((vp_pids = calloc(vp_count, sizeof(pid_t))) == NULL)
+    err_sys_quit(errfd, &quot;ERROR: calloc failed&quot;);
+
+  /* Start the daemon */
+  if (!interactive_mode)
+    start_daemon();
+
+  /* Initialize the ST library */
+  if (st_init() &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: initialization failed: st_init&quot;);
+
+  /* Set thread throttling parameters */
+  set_thread_throttling();
+
+  /* Create listening sockets */
+  create_listeners();
+
+  /* Change the user */
+  if (username)
+    change_user();
+
+  /* Open log files */
+  open_log_files();
+
+  /* Start server processes (VPs) */
+  start_processes();
+
+  /* Turn time caching on */
+  st_timecache_set(1);
+
+  /* Install signal handlers */
+  install_sighandlers();
+
+  /* Load configuration from config files */
+  load_configs();
+
+  /* Start all threads */
+  start_threads();
+
+  /* Become a signal processing thread */
+  process_signals(NULL);
+
+  /* NOTREACHED */
+  return 1;
+}
+
+
+/******************************************************************/
+
+static void usage(const char *progname)
+{
+  fprintf(stderr, &quot;Usage: %s -l &lt;log_directory&gt; [&lt;options&gt;]\n\n&quot;
+	  &quot;Possible options:\n\n&quot;
+	  &quot;\t-b &lt;host&gt;:&lt;port&gt;        Bind to specified address. Multiple&quot;
+	  &quot; addresses\n&quot;
+	  &quot;\t                        are permitted.\n&quot;
+	  &quot;\t-p &lt;num_processes&gt;      Create specified number of processes.\n&quot;
+	  &quot;\t-t &lt;min_thr&gt;:&lt;max_thr&gt;  Specify thread limits per listening&quot;
+	  &quot; socket\n&quot;
+	  &quot;\t                        across all processes.\n&quot;
+	  &quot;\t-u &lt;user&gt;               Change server's user id to specified&quot;
+	  &quot; value.\n&quot;
+	  &quot;\t-q &lt;backlog&gt;            Set max length of pending connections&quot;
+	  &quot; queue.\n&quot;
+	  &quot;\t-a                      Enable access logging.\n&quot;
+	  &quot;\t-i                      Run in interactive mode.\n&quot;
+	  &quot;\t-S                      Serialize all accept() calls.\n&quot;
+	  &quot;\t-h                      Print this message.\n&quot;,
+	  progname);
+  exit(1);
+}
+
+
+/******************************************************************/
+
+static void parse_arguments(int argc, char *argv[])
+{
+  extern char *optarg;
+  int opt;
+  char *c;
+
+  while ((opt = getopt(argc, argv, &quot;b:p:l:t:u:q:aiSh&quot;)) != EOF) {
+    switch (opt) {
+    case 'b':
+      if (sk_count &gt;= MAX_BIND_ADDRS)
+	err_quit(errfd, &quot;ERROR: max number of bind addresses (%d) exceeded&quot;,
+		 MAX_BIND_ADDRS);
+      if ((c = strdup(optarg)) == NULL)
+	err_sys_quit(errfd, &quot;ERROR: strdup&quot;);
+      srv_socket[sk_count++].addr = c;
+      break;
+    case 'p':
+      vp_count = atoi(optarg);
+      if (vp_count &lt; 1)
+	err_quit(errfd, &quot;ERROR: invalid number of processes: %s&quot;, optarg);
+      break;
+    case 'l':
+      logdir = optarg;
+      break;
+    case 't':
+      max_wait_threads = (int) strtol(optarg, &amp;c, 10);
+      if (*c++ == ':')
+	max_threads = atoi(c);
+      if (max_wait_threads &lt; 0 || max_threads &lt; 0)
+	err_quit(errfd, &quot;ERROR: invalid number of threads: %s&quot;, optarg);
+      break;
+    case 'u':
+      username = optarg;
+      break;
+    case 'q':
+      listenq_size = atoi(optarg);
+      if (listenq_size &lt; 1)
+	err_quit(errfd, &quot;ERROR: invalid listen queue size: %s&quot;, optarg);
+      break;
+    case 'a':
+      log_access = 1;
+      break;
+    case 'i':
+      interactive_mode = 1;
+      break;
+    case 'S':
+      /*
+       * Serialization decision is tricky on some platforms. For example,
+       * Solaris 2.6 and above has kernel sockets implementation, so supposedly
+       * there is no need for serialization. The ST library may be compiled
+       * on one OS version, but used on another, so the need for serialization
+       * should be determined at run time by the application. Since it's just
+       * an example, the serialization decision is left up to user.
+       * Only on platforms where the serialization is never needed on any OS
+       * version st_netfd_serialize_accept() is a no-op.
+       */
+      serialize_accept = 1;
+      break;
+    case 'h':
+    case '?':
+      usage(argv[0]);
+    }
+  }
+
+  if (logdir == NULL &amp;&amp; !interactive_mode) {
+    err_report(errfd, &quot;ERROR: logging directory is required\n&quot;);
+    usage(argv[0]);
+  }
+
+  if (getuid() == 0 &amp;&amp; username == NULL)
+    err_report(errfd, &quot;WARNING: running as super-user!&quot;);
+
+  if (vp_count == 0 &amp;&amp; (vp_count = cpu_count()) &lt; 1)
+    vp_count = 1;
+
+  if (sk_count == 0) {
+    sk_count = 1;
+    srv_socket[0].addr = &quot;0.0.0.0&quot;;
+  }
+}
+
+
+/******************************************************************/
+
+static void start_daemon(void)
+{
+  pid_t pid;
+
+  /* Start forking */
+  if ((pid = fork()) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: fork&quot;);
+  if (pid &gt; 0)
+    exit(0);                  /* parent */
+
+  /* First child process */
+  setsid();                   /* become session leader */
+
+  if ((pid = fork()) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: fork&quot;);
+  if (pid &gt; 0)                /* first child */
+    exit(0);
+
+  umask(022);
+
+  if (chdir(logdir) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: can't change directory to %s: chdir&quot;, logdir);
+}
+
+
+/******************************************************************
+ * For simplicity, the minimal size of thread pool is considered
+ * as a maximum number of spare threads (max_wait_threads) that
+ * will be created upon server startup. The pool size can grow up
+ * to the max_threads value. Note that this is a per listening
+ * socket limit. It is also possible to limit the total number of
+ * threads for all sockets rather than impose a per socket limit.
+ */
+
+static void set_thread_throttling(void)
+{
+  /*
+   * Calculate total values across all processes.
+   * All numbers are per listening socket.
+   */
+  if (max_wait_threads == 0)
+    max_wait_threads = MAX_WAIT_THREADS_DEFAULT * vp_count;
+  /* Assuming that each client session needs FD_PER_THREAD file descriptors */
+  if (max_threads == 0)
+    max_threads = (st_getfdlimit() * vp_count) / FD_PER_THREAD / sk_count;
+  if (max_wait_threads &gt; max_threads)
+    max_wait_threads = max_threads;
+
+  /*
+   * Now calculate per-process values.
+   */
+  if (max_wait_threads % vp_count)
+    max_wait_threads = max_wait_threads / vp_count + 1;
+  else
+    max_wait_threads = max_wait_threads / vp_count;
+  if (max_threads % vp_count)
+    max_threads = max_threads / vp_count + 1;
+  else
+    max_threads = max_threads / vp_count;
+
+  if (min_wait_threads &gt; max_wait_threads)
+    min_wait_threads = max_wait_threads;
+}
+
+
+/******************************************************************/
+
+static void create_listeners(void)
+{
+  int i, n, sock;
+  char *c;
+  struct sockaddr_in serv_addr;
+  struct hostent *hp;
+  short port;
+
+  for (i = 0; i &lt; sk_count; i++) {
+    port = 0;
+    if ((c = strchr(srv_socket[i].addr, ':')) != NULL) {
+      *c++ = '\0';
+      port = (short) atoi(c);
+    }
+    if (srv_socket[i].addr[0] == '\0')
+      srv_socket[i].addr = &quot;0.0.0.0&quot;;
+    if (port == 0)
+      port = SERV_PORT_DEFAULT;
+
+    /* Create server socket */
+    if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0)
+      err_sys_quit(errfd, &quot;ERROR: can't create socket: socket&quot;);
+    n = 1;
+    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;n, sizeof(n)) &lt; 0)
+      err_sys_quit(errfd, &quot;ERROR: can't set SO_REUSEADDR: setsockopt&quot;);
+    memset(&amp;serv_addr, 0, sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_port = htons(port);
+    serv_addr.sin_addr.s_addr = inet_addr(srv_socket[i].addr);
+    if (serv_addr.sin_addr.s_addr == INADDR_NONE) {
+      /* not dotted-decimal */
+      if ((hp = gethostbyname(srv_socket[i].addr)) == NULL)
+	err_quit(errfd, &quot;ERROR: can't resolve address: %s&quot;,
+		 srv_socket[i].addr);
+      memcpy(&amp;serv_addr.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
+    }
+    srv_socket[i].port = port;
+
+    /* Do bind and listen */
+    if (bind(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)
+      err_sys_quit(errfd, &quot;ERROR: can't bind to address %s, port %d&quot;,
+		   srv_socket[i].addr, port);
+    if (listen(sock, listenq_size) &lt; 0)
+      err_sys_quit(errfd, &quot;ERROR: listen&quot;);
+
+    /* Create file descriptor object from OS socket */
+    if ((srv_socket[i].nfd = st_netfd_open_socket(sock)) == NULL)
+      err_sys_quit(errfd, &quot;ERROR: st_netfd_open_socket&quot;);
+    /*
+     * On some platforms (e.g. IRIX, Linux) accept() serialization is never
+     * needed for any OS version.  In that case st_netfd_serialize_accept()
+     * is just a no-op. Also see the comment above.
+     */
+    if (serialize_accept &amp;&amp; st_netfd_serialize_accept(srv_socket[i].nfd) &lt; 0)
+      err_sys_quit(errfd, &quot;ERROR: st_netfd_serialize_accept&quot;);
+  }
+}
+
+
+/******************************************************************/
+
+static void change_user(void)
+{
+  struct passwd *pw;
+
+  if ((pw = getpwnam(username)) == NULL)
+    err_quit(errfd, &quot;ERROR: can't find user '%s': getpwnam failed&quot;, username);
+
+  if (setgid(pw-&gt;pw_gid) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: can't change group id: setgid&quot;);
+  if (setuid(pw-&gt;pw_uid) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: can't change user id: setuid&quot;);
+
+  err_report(errfd, &quot;INFO: changed process user id to '%s'&quot;, username);
+}
+
+
+/******************************************************************/
+
+static void open_log_files(void)
+{
+  int fd;
+  char str[32];
+
+  if (interactive_mode)
+    return;
+
+  /* Open access log */
+  if (log_access)
+    logbuf_open();
+
+  /* Open and write pid to pid file */
+  if ((fd = open(PID_FILE, O_CREAT | O_WRONLY | O_TRUNC, 0644)) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: can't open pid file: open&quot;);
+  sprintf(str, &quot;%d\n&quot;, (int)getpid());
+  if (write(fd, str, strlen(str)) != strlen(str))
+    err_sys_quit(errfd, &quot;ERROR: can't write to pid file: write&quot;);
+  close(fd);
+
+  /* Open error log file */
+  if ((fd = open(ERRORS_FILE, O_CREAT | O_WRONLY | O_APPEND, 0644)) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: can't open error log file: open&quot;);
+  errfd = fd;
+
+  err_report(errfd, &quot;INFO: starting the server...&quot;);
+}
+
+
+/******************************************************************/
+
+static void start_processes(void)
+{
+  int i, status;
+  pid_t pid;
+  sigset_t mask, omask;
+
+  if (interactive_mode) {
+    my_index = 0;
+    my_pid = getpid();
+    return;
+  }
+
+  for (i = 0; i &lt; vp_count; i++) {
+    if ((pid = fork()) &lt; 0) {
+      err_sys_report(errfd, &quot;ERROR: can't create process: fork&quot;);
+      if (i == 0)
+	exit(1);
+      err_report(errfd, &quot;WARN: started only %d processes out of %d&quot;, i,
+		 vp_count);
+      vp_count = i;
+      break;
+    }
+    if (pid == 0) {
+      my_index = i;
+      my_pid = getpid();
+      /* Child returns to continue in main() */
+      return;
+    }
+    vp_pids[i] = pid;
+  }
+
+  /*
+   * Parent process becomes a &quot;watchdog&quot; and never returns to main().
+   */
+
+  /* Install signal handlers */
+  Signal(SIGTERM, wdog_sighandler);  /* terminate */
+  Signal(SIGHUP,  wdog_sighandler);  /* restart   */
+  Signal(SIGUSR1, wdog_sighandler);  /* dump info */
+
+  /* Now go to sleep waiting for a child termination or a signal */
+  for ( ; ; ) {
+    if ((pid = wait(&amp;status)) &lt; 0) {
+      if (errno == EINTR)
+	continue;
+      err_sys_quit(errfd, &quot;ERROR: watchdog: wait&quot;);
+    }
+    /* Find index of the exited child */
+    for (i = 0; i &lt; vp_count; i++) {
+      if (vp_pids[i] == pid)
+	break;
+    }
+
+    /* Block signals while printing and forking */
+    sigemptyset(&amp;mask);
+    sigaddset(&amp;mask, SIGTERM);
+    sigaddset(&amp;mask, SIGHUP);
+    sigaddset(&amp;mask, SIGUSR1);
+    sigprocmask(SIG_BLOCK, &amp;mask, &amp;omask);
+
+    if (WIFEXITED(status))
+      err_report(errfd, &quot;WARN: watchdog: process %d (pid %d) exited&quot;
+		 &quot; with status %d&quot;, i, pid, WEXITSTATUS(status));
+    else if (WIFSIGNALED(status))
+      err_report(errfd, &quot;WARN: watchdog: process %d (pid %d) terminated&quot;
+		 &quot; by signal %d&quot;, i, pid, WTERMSIG(status));
+    else if (WIFSTOPPED(status))
+      err_report(errfd, &quot;WARN: watchdog: process %d (pid %d) stopped&quot;
+		 &quot; by signal %d&quot;, i, pid, WSTOPSIG(status));
+    else
+      err_report(errfd, &quot;WARN: watchdog: process %d (pid %d) terminated:&quot;
+		 &quot; unknown termination reason&quot;, i, pid);
+
+    /* Fork another VP */
+    if ((pid = fork()) &lt; 0) {
+      err_sys_report(errfd, &quot;ERROR: watchdog: can't create process: fork&quot;);
+    } else if (pid == 0) {
+      my_index = i;
+      my_pid = getpid();
+      /* Child returns to continue in main() */
+      return;
+    }
+    vp_pids[i] = pid;
+
+    /* Restore the signal mask */
+    sigprocmask(SIG_SETMASK, &amp;omask, NULL);
+  }
+}
+
+
+/******************************************************************/
+
+static void wdog_sighandler(int signo)
+{
+  int i, err;
+
+  /* Save errno */
+  err = errno;
+  /* Forward the signal to all children */
+  for (i = 0; i &lt; vp_count; i++) {
+    if (vp_pids[i] &gt; 0)
+      kill(vp_pids[i], signo);
+  }
+  /*
+   * It is safe to do pretty much everything here because process is
+   * sleeping in wait() which is async-safe.
+   */
+  switch (signo) {
+  case SIGHUP:
+    err_report(errfd, &quot;INFO: watchdog: caught SIGHUP&quot;);
+    /* Reopen log files - needed for log rotation */
+    if (log_access) {
+      logbuf_close();
+      logbuf_open();
+    }
+    close(errfd);
+    if ((errfd = open(ERRORS_FILE, O_CREAT | O_WRONLY | O_APPEND, 0644)) &lt; 0)
+      err_sys_quit(STDERR_FILENO, &quot;ERROR: watchdog: open&quot;);
+    break;
+  case SIGTERM:
+    /* Non-graceful termination */
+    err_report(errfd, &quot;INFO: watchdog: caught SIGTERM, terminating&quot;);
+    unlink(PID_FILE);
+    exit(0);
+  case SIGUSR1:
+    err_report(errfd, &quot;INFO: watchdog: caught SIGUSR1&quot;);
+    break;
+  default:
+    err_report(errfd, &quot;INFO: watchdog: caught signal %d&quot;, signo);
+  }
+  /* Restore errno */
+  errno = err;
+}
+
+
+/******************************************************************/
+
+static void install_sighandlers(void)
+{
+  sigset_t mask;
+  int p[2];
+
+  /* Create signal pipe */
+  if (pipe(p) &lt; 0)
+    err_sys_quit(errfd, &quot;ERROR: process %d (pid %d): can't create&quot;
+		 &quot; signal pipe: pipe&quot;, my_index, my_pid);
+  if ((sig_pipe[0] = st_netfd_open(p[0])) == NULL ||
+      (sig_pipe[1] = st_netfd_open(p[1])) == NULL)
+    err_sys_quit(errfd, &quot;ERROR: process %d (pid %d): can't create&quot;
+		 &quot; signal pipe: st_netfd_open&quot;, my_index, my_pid);
+
+  /* Install signal handlers */
+  Signal(SIGTERM, child_sighandler);  /* terminate */
+  Signal(SIGHUP,  child_sighandler);  /* restart   */
+  Signal(SIGUSR1, child_sighandler);  /* dump info */
+
+  /* Unblock signals */
+  sigemptyset(&amp;mask);
+  sigaddset(&amp;mask, SIGTERM);
+  sigaddset(&amp;mask, SIGHUP);
+  sigaddset(&amp;mask, SIGUSR1);
+  sigprocmask(SIG_UNBLOCK, &amp;mask, NULL);
+}
+
+
+/******************************************************************/
+
+static void child_sighandler(int signo)
+{
+  int err, fd;
+
+  err = errno;
+  fd = st_netfd_fileno(sig_pipe[1]);
+
+  /* write() is async-safe */
+  if (write(fd, &amp;signo, sizeof(int)) != sizeof(int))
+    err_sys_quit(errfd, &quot;ERROR: process %d (pid %d): child's signal&quot;
+		 &quot; handler: write&quot;, my_index, my_pid);
+  errno = err;
+}
+
+
+/******************************************************************
+ * The &quot;main&quot; function of the signal processing thread.
+ */
+
+/* ARGSUSED */
+static void *process_signals(void *arg)
+{
+  int signo;
+
+  for ( ; ; ) {
+    /* Read the next signal from the signal pipe */
+    if (st_read(sig_pipe[0], &amp;signo, sizeof(int), -1) != sizeof(int))
+      err_sys_quit(errfd, &quot;ERROR: process %d (pid %d): signal processor:&quot;
+		   &quot; st_read&quot;, my_index, my_pid);
+
+    switch (signo) {
+    case SIGHUP:
+      err_report(errfd, &quot;INFO: process %d (pid %d): caught SIGHUP,&quot;
+		 &quot; reloading configuration&quot;, my_index, my_pid);
+      if (interactive_mode) {
+	load_configs();
+	break;
+      }
+      /* Reopen log files - needed for log rotation */
+      if (log_access) {
+	logbuf_flush();
+	logbuf_close();
+	logbuf_open();
+      }
+      close(errfd);
+      if ((errfd = open(ERRORS_FILE, O_CREAT | O_WRONLY | O_APPEND, 0644)) &lt; 0)
+	err_sys_quit(STDERR_FILENO, &quot;ERROR: process %d (pid %d): signal&quot;
+		     &quot; processor: open&quot;, my_index, my_pid);
+      /* Reload configuration */
+      load_configs();
+      break;
+    case SIGTERM:
+      /*
+       * Terminate ungracefully since it is generally not known how long
+       * it will take to gracefully complete all client sessions.
+       */
+      err_report(errfd, &quot;INFO: process %d (pid %d): caught SIGTERM,&quot;
+		 &quot; terminating&quot;, my_index, my_pid);
+      if (log_access)
+	logbuf_flush();
+      exit(0);
+    case SIGUSR1:
+      err_report(errfd, &quot;INFO: process %d (pid %d): caught SIGUSR1&quot;,
+		 my_index, my_pid);
+      /* Print server info to stderr */
+      dump_server_info();
+      break;
+    default:
+      err_report(errfd, &quot;INFO: process %d (pid %d): caught signal %d&quot;,
+		 my_index, my_pid, signo);
+    }
+  }
+
+  /* NOTREACHED */
+  return NULL;
+}
+
+
+/******************************************************************
+ * The &quot;main&quot; function of the access log flushing thread.
+ */
+
+/* ARGSUSED */
+static void *flush_acclog_buffer(void *arg)
+{
+  for ( ; ; ) {
+    st_sleep(ACCLOG_FLUSH_INTERVAL);
+    logbuf_flush();
+  }
+
+  /* NOTREACHED */
+  return NULL;
+}
+
+
+/******************************************************************/
+
+static void start_threads(void)
+{
+  long i, n;
+
+  /* Create access log flushing thread */
+  if (log_access &amp;&amp; st_thread_create(flush_acclog_buffer, NULL, 0, 0) == NULL)
+    err_sys_quit(errfd, &quot;ERROR: process %d (pid %d): can't create&quot;
+		 &quot; log flushing thread&quot;, my_index, my_pid);
+
+  /* Create connections handling threads */
+  for (i = 0; i &lt; sk_count; i++) {
+    err_report(errfd, &quot;INFO: process %d (pid %d): starting %d threads&quot;
+	       &quot; on %s:%d&quot;, my_index, my_pid, max_wait_threads,
+	       srv_socket[i].addr, srv_socket[i].port);
+    WAIT_THREADS(i) = 0;
+    BUSY_THREADS(i) = 0;
+    RQST_COUNT(i) = 0;
+    for (n = 0; n &lt; max_wait_threads; n++) {
+      if (st_thread_create(handle_connections, (void *)i, 0, 0) != NULL)
+	WAIT_THREADS(i)++;
+      else
+	err_sys_report(errfd, &quot;ERROR: process %d (pid %d): can't create&quot;
+		       &quot; thread&quot;, my_index, my_pid);
+    }
+    if (WAIT_THREADS(i) == 0)
+      exit(1);
+  }
+}
+
+
+/******************************************************************/
+
+static void *handle_connections(void *arg)
+{
+  st_netfd_t srv_nfd, cli_nfd;
+  struct sockaddr_in from;
+  int fromlen;
+  long i = (long) arg;
+
+  srv_nfd = srv_socket[i].nfd;
+  fromlen = sizeof(from);
+
+  while (WAIT_THREADS(i) &lt;= max_wait_threads) {
+    cli_nfd = st_accept(srv_nfd, (struct sockaddr *)&amp;from, &amp;fromlen, -1);
+    if (cli_nfd == NULL) {
+      err_sys_report(errfd, &quot;ERROR: can't accept connection: st_accept&quot;);
+      continue;
+    }
+    /* Save peer address, so we can retrieve it later */
+    st_netfd_setspecific(cli_nfd, &amp;from.sin_addr, NULL);
+
+    WAIT_THREADS(i)--;
+    BUSY_THREADS(i)++;
+    if (WAIT_THREADS(i) &lt; min_wait_threads &amp;&amp; TOTAL_THREADS(i) &lt; max_threads) {
+      /* Create another spare thread */
+      if (st_thread_create(handle_connections, (void *)i, 0, 0) != NULL)
+	WAIT_THREADS(i)++;
+      else
+	err_sys_report(errfd, &quot;ERROR: process %d (pid %d): can't create&quot;
+		       &quot; thread&quot;, my_index, my_pid);
+    }
+
+    handle_session(i, cli_nfd);
+
+    st_netfd_close(cli_nfd);
+    WAIT_THREADS(i)++;
+    BUSY_THREADS(i)--;
+  }
+
+  WAIT_THREADS(i)--;
+  return NULL;
+}
+
+
+/******************************************************************/
+
+static void dump_server_info(void)
+{
+  char *buf;
+  int i, len;
+
+  if ((buf = malloc(sk_count * 512)) == NULL) {
+    err_sys_report(errfd, &quot;ERROR: malloc failed&quot;);
+    return;
+  }
+
+  len = sprintf(buf, &quot;\n\nProcess #%d (pid %d):\n&quot;, my_index, (int)my_pid);
+  for (i = 0; i &lt; sk_count; i++) {
+    len += sprintf(buf + len, &quot;\nListening Socket #%d:\n&quot;
+		   &quot;-------------------------\n&quot;
+		   &quot;Address                    %s:%d\n&quot;
+		   &quot;Thread limits (min/max)    %d/%d\n&quot;
+		   &quot;Waiting threads            %d\n&quot;
+		   &quot;Busy threads               %d\n&quot;
+		   &quot;Requests served            %d\n&quot;,
+		   i, srv_socket[i].addr, srv_socket[i].port,
+		   max_wait_threads, max_threads,
+		   WAIT_THREADS(i), BUSY_THREADS(i), RQST_COUNT(i));
+  }
+
+  write(STDERR_FILENO, buf, len);
+  free(buf);
+}
+
+
+/******************************************************************
+ * Stubs
+ */
+
+/*
+ * Session handling function stub. Just dumps small HTML page.
+ */
+void handle_session(long srv_socket_index, st_netfd_t cli_nfd)
+{
+  static char resp[] = &quot;HTTP/1.0 200 OK\r\nContent-type: text/html\r\n&quot;
+                       &quot;Connection: close\r\n\r\n&lt;H2&gt;It worked!&lt;/H2&gt;\n&quot;;
+  char buf[512];
+  int n = sizeof(resp) - 1;
+  struct in_addr *from = st_netfd_getspecific(cli_nfd);
+
+  if (st_read(cli_nfd, buf, sizeof(buf), SEC2USEC(REQUEST_TIMEOUT)) &lt; 0) {
+    err_sys_report(errfd, &quot;WARN: can't read request from %s: st_read&quot;,
+		   inet_ntoa(*from));
+    return;
+  }
+  if (st_write(cli_nfd, resp, n, -1) != n) {
+    err_sys_report(errfd, &quot;WARN: can't write response to %s: st_write&quot;,
+		   inet_ntoa(*from));
+    return;
+  }
+
+  RQST_COUNT(srv_socket_index)++;
+}
+
+
+/*
+ * Configuration loading function stub.
+ */
+void load_configs(void)
+{
+  err_report(errfd, &quot;INFO: process %d (pid %d): configuration loaded&quot;,
+	     my_index, my_pid);
+}
+
+
+/*
+ * Buffered access logging methods.
+ * Note that stdio functions (fopen(3), fprintf(3), fflush(3), etc.) cannot
+ * be used if multiple VPs are created since these functions can flush buffer
+ * at any point and thus write only partial log record to disk.
+ * Also, it is completely safe for all threads of the same VP to write to
+ * the same log buffer without any mutex protection (one buffer per VP, of
+ * course).
+ */
+void logbuf_open(void)
+{
+
+}
+
+
+void logbuf_flush(void)
+{
+
+}
+
+
+void logbuf_close(void)
+{
+
+}
+
+
+/******************************************************************
+ * Small utility functions
+ */
+
+static void Signal(int sig, void (*handler)(int))
+{
+  struct sigaction sa;
+
+  sa.sa_handler = handler;
+  sigemptyset(&amp;sa.sa_mask);
+  sa.sa_flags = 0;
+  sigaction(sig, &amp;sa, NULL);
+}
+
+static int cpu_count(void)
+{
+  int n;
+
+#if defined (_SC_NPROCESSORS_ONLN)
+  n = (int) sysconf(_SC_NPROCESSORS_ONLN);
+#elif defined (_SC_NPROC_ONLN)
+  n = (int) sysconf(_SC_NPROC_ONLN);
+#elif defined (HPUX)
+#include &lt;sys/mpctl.h&gt;
+  n = mpctl(MPC_GETNUMSPUS, 0, 0);
+#else
+  n = -1;
+  errno = ENOSYS;
+#endif
+
+  return n;
+}
+
+/******************************************************************/
+

Added: upwatch/trunk/st-1.6/extensions/Makefile
===================================================================
--- upwatch/trunk/st-1.6/extensions/Makefile	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/Makefile	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,91 @@
+#
+# Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+# All Rights Reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met: 
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer. 
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+#    contributors may be used to endorse or promote products derived from
+#    this software without specific prior written permission. 
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+CC          = cc
+
+SHELL       = /bin/sh
+ECHO        = /bin/echo
+
+DEPTH       = ..
+BUILD       =
+TARGETDIR   = obj
+
+DEFINES     =
+OTHER_FLAGS =
+CFLAGS      =
+
+OBJDIR      = $(DEPTH)/$(TARGETDIR)
+INCDIR      = $(DEPTH)/$(TARGETDIR)
+
+LIBRESOLV   =
+EXTRALIBS   =
+
+SLIBRARY    = $(OBJDIR)/libstx.a
+OBJS        = $(OBJDIR)/dnscache.o $(OBJDIR)/dnsres.o $(OBJDIR)/lrucache.o
+
+
+CFLAGS      += -Wall -I$(INCDIR)
+AR          = ar
+ARFLAGS     = rv
+RANLIB      = ranlib
+
+
+##########################
+# Platform section.
+#
+
+ifeq (LINUX, $(findstring LINUX, $(OS)))
+LIBRESOLV   = -lresolv
+endif
+
+ifeq ($(OS), SOLARIS)
+LIBRESOLV   = -lresolv
+EXTRALIBS   = -lsocket -lnsl
+endif
+
+#
+# End of platform section.
+##########################
+
+
+all: $(SLIBRARY)
+
+$(SLIBRARY): $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+	$(RANLIB) $@
+
+$(OBJDIR)/%.o: %.c stx.h common.h
+	$(CC) $(CFLAGS) -c $&lt; -o $@
+
+clean:
+	rm -rf $(OBJS) $(SLIBRARY)
+
+#.DEFAULT:
+#	@cd $(DEPTH); $(MAKE) $@
+

Added: upwatch/trunk/st-1.6/extensions/README
===================================================================
--- upwatch/trunk/st-1.6/extensions/README	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/README	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,42 @@
+This directory contains extensions to the core State Threads Library
+that were contributed by users.  All files hereunder are not part of the
+State Threads Library itself.  They are provided as-is, without warranty
+or support, and under whatever license terms their authors provided.  To
+contribute your own extensions, just mail them to the project
+administrators or to one of the project's mailing lists; see
+state-threads.sourceforge.net.  Please indicate the license terms under
+which the project may distribute your contribution.
+
+========================================================================
+
+stx_fileio
+----------
+Contributed by Jeff &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">jlb-st at houseofdistraction.com</A>&gt;, 4 Nov 2002.
+
+Provides non-blocking random access file reading capability for
+programs using the State Threads library.  There is one public function:
+
+ssize_t stx_file_read(st_netfd_t fd, off_t offset,
+                      void *buf, size_t nbytes, st_utime_t timeout);
+
+The implementation is not optimal in that the data is copied at least once
+more than should be necessary.  Its usefulness is limited to cases where
+random access to a file is required and where starvation of other threads
+is unacceptable.
+
+The particular application which motivated this implementation was a UDP
+file transfer protocol.  Because the OS does very little buffering of UDP
+traffic it is important that UDP transmission threads are not starved for
+periods of time which are long relative to the interval required to
+maintain a steady send rate.
+
+Licensed under the same dual MPL/GPL as core State Threads.
+
+========================================================================
+
+stx_dns
+-------
+
+Documentation coming.
+
+========================================================================

Added: upwatch/trunk/st-1.6/extensions/common.h
===================================================================
--- upwatch/trunk/st-1.6/extensions/common.h	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/common.h	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,77 @@
+#ifndef _STX_COMMON_H_
+#define _STX_COMMON_H_
+
+#include &lt;stddef.h&gt;
+#include &lt;stdlib.h&gt;
+
+
+#define STX_BEGIN_MACRO  {
+#define STX_END_MACRO    }
+
+
+/*****************************************
+ * Circular linked list definitions
+ */
+
+typedef struct _stx_clist {
+  struct _stx_clist *next;
+  struct _stx_clist *prev;
+} stx_clist_t;
+
+/* Insert element &quot;_e&quot; into the list, before &quot;_l&quot; */
+#define STX_CLIST_INSERT_BEFORE(_e,_l) \
+    STX_BEGIN_MACRO              \
+        (_e)-&gt;next = (_l);       \
+        (_e)-&gt;prev = (_l)-&gt;prev; \
+        (_l)-&gt;prev-&gt;next = (_e); \
+        (_l)-&gt;prev = (_e);       \
+    STX_END_MACRO
+
+/* Insert element &quot;_e&quot; into the list, after &quot;_l&quot; */
+#define STX_CLIST_INSERT_AFTER(_e,_l) \
+    STX_BEGIN_MACRO              \
+        (_e)-&gt;next = (_l)-&gt;next; \
+        (_e)-&gt;prev = (_l);       \
+        (_l)-&gt;next-&gt;prev = (_e); \
+        (_l)-&gt;next = (_e);       \
+    STX_END_MACRO
+
+/* Append an element &quot;_e&quot; to the end of the list &quot;_l&quot; */
+#define STX_CLIST_APPEND_LINK(_e,_l) STX_CLIST_INSERT_BEFORE(_e,_l)
+
+/* Remove the element &quot;_e&quot; from it's circular list */
+#define STX_CLIST_REMOVE_LINK(_e)      \
+    STX_BEGIN_MACRO                    \
+        (_e)-&gt;prev-&gt;next = (_e)-&gt;next; \
+        (_e)-&gt;next-&gt;prev = (_e)-&gt;prev; \
+    STX_END_MACRO
+
+/* Return the head/tail of the list */
+#define STX_CLIST_HEAD(_l) (_l)-&gt;next
+#define STX_CLIST_TAIL(_l) (_l)-&gt;prev
+
+/* Return non-zero if the given circular list &quot;_l&quot; is empty, */
+/* zero if the circular list is not empty */
+#define STX_CLIST_IS_EMPTY(_l) \
+    ((_l)-&gt;next == (_l))
+
+/* Initialize a circular list */
+#define STX_CLIST_INIT_CLIST(_l) \
+    STX_BEGIN_MACRO        \
+        (_l)-&gt;next = (_l); \
+        (_l)-&gt;prev = (_l); \
+    STX_END_MACRO
+
+
+/*****************************************
+ * Useful macros
+ */
+
+#ifndef offsetof
+#define offsetof(type, identifier) ((size_t)&amp;(((type *)0)-&gt;identifier))
+#endif
+
+#define STX_MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
+
+#endif /* !_STX_COMMON_H_ */
+

Added: upwatch/trunk/st-1.6/extensions/dnscache.c
===================================================================
--- upwatch/trunk/st-1.6/extensions/dnscache.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/dnscache.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,190 @@
+#include &quot;stx.h&quot;
+#include &quot;common.h&quot;
+
+
+/*****************************************
+ * Basic types definitions
+ */
+
+typedef struct _stx_dns_data {
+    struct in_addr *addrs;
+    int num_addrs;
+    int cur;
+    time_t expires;
+} stx_dns_data_t;
+
+
+#define MAX_HOST_ADDRS 1024
+
+static struct in_addr addr_list[MAX_HOST_ADDRS];
+
+stx_cache_t *_stx_dns_cache = NULL;
+
+extern int _stx_dns_ttl;
+extern int _stx_dns_getaddrlist(const char *hostname, struct in_addr *addrs,
+				int *num_addrs, st_utime_t timeout);
+
+
+static unsigned long hash_hostname(const void *key)
+{
+    const char *name = (const char *)key;
+    unsigned long hash = 0;
+
+    while (*name)
+	hash = (hash &lt;&lt; 4) - hash + *name++; /* hash = hash * 15 + *name++ */
+
+    return hash;
+}
+
+static void cleanup_entry(void *key, void *data)
+{
+    if (key)
+	free(key);
+
+    if (data) {
+	if (((stx_dns_data_t *)data)-&gt;addrs)
+	    free(((stx_dns_data_t *)data)-&gt;addrs);
+	free(data);
+    }
+}
+
+static int lookup_entry(const char *host, struct in_addr *addrs,
+			int *num_addrs, int rotate)
+{
+    stx_cache_entry_t *entry;
+    stx_dns_data_t *data;
+    int n;
+
+    entry = stx_cache_entry_lookup(_stx_dns_cache, host);
+    if (entry) {
+	data = (stx_dns_data_t *)stx_cache_entry_getdata(entry);
+	if (st_time() &lt;= data-&gt;expires) {
+	    if (*num_addrs == 1) {
+		if (rotate) {
+		    *addrs = data-&gt;addrs[data-&gt;cur++];
+		    if (data-&gt;cur &gt;= data-&gt;num_addrs)
+			data-&gt;cur = 0;
+		} else {
+		    *addrs = data-&gt;addrs[0];
+		}
+	    } else {
+		n = STX_MIN(*num_addrs, data-&gt;num_addrs);
+		memcpy(addrs, data-&gt;addrs, n * sizeof(*addrs));
+		*num_addrs = n;
+	    }
+
+	    stx_cache_entry_release(_stx_dns_cache, entry);
+	    return 1;
+	}
+
+	/*
+	 * Cache entry expired: decrement its refcount and purge it from cache.
+	 */
+	stx_cache_entry_release(_stx_dns_cache, entry);
+	stx_cache_entry_delete(_stx_dns_cache, entry);
+    }
+
+    return 0;
+}
+
+static void insert_entry(const char *host, struct in_addr *addrs, int count)
+{
+    stx_cache_entry_t *entry;
+    stx_dns_data_t *data;
+    char *key;
+    size_t n;
+
+    if (_stx_dns_ttl &gt; 0) {
+	key = strdup(host);
+	data = (stx_dns_data_t *)malloc(sizeof(stx_dns_data_t));
+	n = count * sizeof(*addrs);
+	if (data) {
+	    data-&gt;addrs = (struct in_addr *)malloc(n);
+	    if (data-&gt;addrs)
+		memcpy(data-&gt;addrs, addrs, n);
+	    data-&gt;num_addrs = count;
+	    data-&gt;cur = 0;
+	    data-&gt;expires = st_time() + _stx_dns_ttl;
+	}
+	entry = stx_cache_entry_create(key, data, strlen(host) + 1 +
+				       sizeof(stx_dns_data_t) + n +
+				       stx_cache_entry_sizeof());
+	if (key &amp;&amp; data &amp;&amp; data-&gt;addrs &amp;&amp; entry &amp;&amp;
+	    stx_cache_entry_insert(_stx_dns_cache, entry) == 0) {
+	    stx_cache_entry_release(_stx_dns_cache, entry);
+	    return;
+	}
+
+	if (entry)
+	    stx_cache_entry_delete(_stx_dns_cache, entry);
+	else
+	    cleanup_entry(key, data);
+    }
+}
+
+
+
+int _stx_dns_cache_getaddrlist(const char *hostname, struct in_addr *addrs,
+			       int *num_addrs, st_utime_t timeout,
+			       int rotate)
+{
+    char host[128];
+    int n, count;
+
+    if (!_stx_dns_cache)
+	return _stx_dns_getaddrlist(hostname, addrs, num_addrs, timeout);
+
+    for (n = 0; n &lt; sizeof(host) - 1 &amp;&amp; hostname[n]; n++) {
+	host[n] = tolower(hostname[n]);
+    }
+    host[n] = '\0';
+
+    if (lookup_entry(host, addrs, num_addrs, rotate))
+	return 0;
+
+    count = MAX_HOST_ADDRS;
+    if (_stx_dns_getaddrlist(host, addr_list, &amp;count, timeout) &lt; 0)
+	return -1;
+    n = STX_MIN(*num_addrs, count);
+    memcpy(addrs, addr_list, n * sizeof(*addrs));
+    *num_addrs = n;
+
+    insert_entry(host, addr_list, count);
+    return 0;
+}
+
+
+int stx_dns_cache_init(size_t max_size, size_t max_bytes, size_t hash_size)
+{
+    _stx_dns_cache = stx_cache_create(max_size, max_bytes, hash_size,
+				  hash_hostname,
+				  (long (*)(const void *, const void *))strcmp,
+				  cleanup_entry);
+    if (!_stx_dns_cache)
+	return -1;
+
+    return 0;
+}
+
+void stx_dns_cache_getinfo(stx_cache_info_t *info)
+{
+    if (_stx_dns_cache)
+	stx_cache_getinfo(_stx_dns_cache, info);
+    else
+	memset(info, 0, sizeof(stx_cache_info_t));
+}	
+
+int stx_dns_getaddrlist(const char *hostname, struct in_addr *addrs,
+			int *num_addrs, st_utime_t timeout)
+{
+    return _stx_dns_cache_getaddrlist(hostname, addrs, num_addrs, timeout, 0);
+}
+
+int stx_dns_getaddr(const char *hostname, struct in_addr *addr,
+		    st_utime_t timeout)
+{
+    int n = 1;
+
+    return _stx_dns_cache_getaddrlist(hostname, addr, &amp;n, timeout, 1);
+}
+

Added: upwatch/trunk/st-1.6/extensions/dnsres.c
===================================================================
--- upwatch/trunk/st-1.6/extensions/dnsres.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/dnsres.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 1985, 1988, 1993
+ *    The Regents of the University of California.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Silicon Graphics, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &quot;stx.h&quot;
+
+#define MAXPACKET 1024
+
+#if !defined(NETDB_INTERNAL) &amp;&amp; defined(h_NETDB_INTERNAL)
+#define NETDB_INTERNAL h_NETDB_INTERNAL
+#endif
+
+/* New in Solaris 7 */
+#ifdef ns_get16
+#define _getshort(cp) ns_get16(cp)
+#define _getlong(cp)  ns_get32(cp)
+#endif
+
+typedef union {
+    HEADER hdr;
+    u_char buf[MAXPACKET];
+} querybuf_t;
+
+int _stx_dns_ttl;
+
+
+static int parse_answer(querybuf_t *ans, int len, struct in_addr *addrs,
+			int *num_addrs)
+{
+    char buf[MAXPACKET];
+    HEADER *ahp;
+    u_char *cp, *eoa;
+    int type, n, i;
+
+    ahp = &amp;ans-&gt;hdr;
+    eoa = ans-&gt;buf + len;
+    cp = ans-&gt;buf + sizeof(HEADER);
+    h_errno = TRY_AGAIN;
+    _stx_dns_ttl = -1;
+    i = 0;
+
+    while (ahp-&gt;qdcount &gt; 0) {
+	ahp-&gt;qdcount--;
+	cp += dn_skipname(cp, eoa) + QFIXEDSZ;
+    }
+    while (ahp-&gt;ancount &gt; 0 &amp;&amp; cp &lt; eoa &amp;&amp; i &lt; *num_addrs) {
+	ahp-&gt;ancount--;
+	if ((n = dn_expand(ans-&gt;buf, eoa, cp, buf, sizeof(buf))) &lt; 0)
+	    return -1;
+	cp += n;
+	if (cp + 4 + 4 + 2 &gt;= eoa)
+	    return -1;
+	type = _getshort(cp);
+	cp += 4;
+	if (type == T_A)
+	    _stx_dns_ttl = _getlong(cp);
+	cp += 4;
+	n = _getshort(cp);
+	cp += 2;
+	if (type == T_A) {
+	    if (n &gt; sizeof(*addrs) || cp + n &gt; eoa)
+		return -1;
+	    memcpy(&amp;addrs[i++], cp, n);
+	}
+	cp += n;
+    }
+
+    *num_addrs = i;
+    return 0;
+}
+
+
+static int query_domain(st_netfd_t nfd, const char *name,
+			struct in_addr *addrs, int *num_addrs,
+			st_utime_t timeout)
+{
+    querybuf_t qbuf;
+    u_char *buf = qbuf.buf;
+    HEADER *hp = &amp;qbuf.hdr;
+    int blen = sizeof(qbuf);
+    int i, len, id;
+
+    for (i = 0; i &lt; _res.nscount; i++) {
+	len = res_mkquery(QUERY, name, C_IN, T_A, NULL, 0, NULL, buf, blen);
+	if (len &lt;= 0) {
+	    h_errno = NO_RECOVERY;
+	    return -1;
+	}
+	id = hp-&gt;id;
+
+	if (st_sendto(nfd, buf, len, (struct sockaddr *)&amp;(_res.nsaddr_list[i]),
+		      sizeof(struct sockaddr), timeout) != len) {
+	    h_errno = NETDB_INTERNAL;
+	    /* EINTR means interrupt by other thread, NOT by a caught signal */
+	    if (errno == EINTR)
+		return -1;
+	    continue;
+	}
+
+	/* Wait for reply */
+	do {
+	    len = st_recvfrom(nfd, buf, blen, NULL, NULL, timeout);
+	    if (len &lt;= 0)
+		break;
+	} while (id != hp-&gt;id);
+
+	if (len &lt; HFIXEDSZ) {
+	    h_errno = NETDB_INTERNAL;
+	    if (len &gt;= 0)
+		errno = EMSGSIZE;
+	    else if (errno == EINTR)  /* see the comment above */
+		return -1;
+	    continue;
+	}
+
+	hp-&gt;ancount = ntohs(hp-&gt;ancount);
+	hp-&gt;qdcount = ntohs(hp-&gt;qdcount);
+	if ((hp-&gt;rcode != NOERROR) || (hp-&gt;ancount == 0)) {
+	    switch (hp-&gt;rcode) {
+	    case NXDOMAIN:
+		h_errno = HOST_NOT_FOUND;
+		break;
+	    case SERVFAIL:
+		h_errno = TRY_AGAIN;
+		break;
+	    case NOERROR:
+		h_errno = NO_DATA;
+		break;
+	    case FORMERR:
+	    case NOTIMP:
+	    case REFUSED:
+	    default:
+		h_errno = NO_RECOVERY;
+	    }
+	    continue;
+	}
+
+	if (parse_answer(&amp;qbuf, len, addrs, num_addrs) == 0)
+	    return 0;
+    }
+
+    return -1;
+}
+
+
+#define CLOSE_AND_RETURN(ret) \
+  {                           \
+    n = errno;                \
+    st_netfd_close(nfd);      \
+    errno = n;                \
+    return (ret);             \
+  }
+
+
+int _stx_dns_getaddrlist(const char *host, struct in_addr *addrs,
+                         int *num_addrs, st_utime_t timeout)
+{
+    char name[MAXDNAME], **domain;
+    const char *cp;
+    int s, n, maxlen, dots;
+    int trailing_dot, tried_as_is;
+    st_netfd_t nfd;
+
+    if ((_res.options &amp; RES_INIT) == 0 &amp;&amp; res_init() == -1) {
+	h_errno = NETDB_INTERNAL;
+	return -1;
+    }
+    if (_res.options &amp; RES_USEVC) {
+	h_errno = NETDB_INTERNAL;
+	errno = ENOSYS;
+	return -1;
+    }
+    if (!host || *host == '\0') {
+	h_errno = HOST_NOT_FOUND;
+	return -1;
+    }
+
+    /* Create UDP socket */
+    if ((s = socket(PF_INET, SOCK_DGRAM, 0)) &lt; 0) {
+	h_errno = NETDB_INTERNAL;
+	return -1;
+    }
+    if ((nfd = st_netfd_open_socket(s)) == NULL) {
+	h_errno = NETDB_INTERNAL;
+	n = errno;
+	close(s);
+	errno = n;
+	return -1;
+    }
+
+    maxlen = sizeof(name) - 1;
+    n = 0;
+    dots = 0;
+    trailing_dot = 0;
+    tried_as_is = 0;
+
+    for (cp = host; *cp &amp;&amp; n &lt; maxlen; cp++) {
+	dots += (*cp == '.');
+	name[n++] = *cp;
+    }
+    if (name[n - 1] == '.')
+	trailing_dot = 1;
+
+    /*
+     * If there are dots in the name already, let's just give it a try
+     * 'as is'.  The threshold can be set with the &quot;ndots&quot; option.
+     */
+    if (dots &gt;= _res.ndots) {
+	if (query_domain(nfd, host, addrs, num_addrs, timeout) == 0)
+	    CLOSE_AND_RETURN(0);
+	if (h_errno == NETDB_INTERNAL &amp;&amp; errno == EINTR)
+	    CLOSE_AND_RETURN(-1);
+	tried_as_is = 1;
+    }
+
+    /*
+     * We do at least one level of search if
+     *     - there is no dot and RES_DEFNAME is set, or
+     *     - there is at least one dot, there is no trailing dot,
+     *       and RES_DNSRCH is set.
+     */
+    if ((!dots &amp;&amp; (_res.options &amp; RES_DEFNAMES)) ||
+	(dots &amp;&amp; !trailing_dot &amp;&amp; (_res.options &amp; RES_DNSRCH))) {
+	name[n++] = '.';
+	for (domain = _res.dnsrch; *domain; domain++) {
+	    strncpy(name + n, *domain, maxlen - n);
+	    if (query_domain(nfd, name, addrs, num_addrs, timeout) == 0)
+		CLOSE_AND_RETURN(0);
+	    if (h_errno == NETDB_INTERNAL &amp;&amp; errno == EINTR)
+		CLOSE_AND_RETURN(-1);
+	    if (!(_res.options &amp; RES_DNSRCH))
+		break;
+	}
+    }
+
+    /*
+     * If we have not already tried the name &quot;as is&quot;, do that now.
+     * note that we do this regardless of how many dots were in the
+     * name or whether it ends with a dot.
+     */
+    if (!tried_as_is) {
+	if (query_domain(nfd, host, addrs, num_addrs, timeout) == 0)
+	    CLOSE_AND_RETURN(0);
+    }
+
+    CLOSE_AND_RETURN(-1);
+}
+

Added: upwatch/trunk/st-1.6/extensions/lrucache.c
===================================================================
--- upwatch/trunk/st-1.6/extensions/lrucache.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/lrucache.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,343 @@
+#include &quot;stx.h&quot;
+#include &quot;common.h&quot;
+
+
+/*****************************************
+ * Basic types definitions
+ */
+
+struct _stx_centry {
+  void               *key;           /* key for doing lookups */
+  void               *data;          /* data in the cache */
+  size_t             weight;         /* &quot;weight&quot; of this entry */
+  struct _stx_centry *next;          /* next entry */
+  struct _stx_centry **pthis;
+  stx_clist_t        lru_link;       /* for putting this entry on LRU list */
+  int                ref_count;      /* use count for this entry */
+  int                delete_pending; /* pending delete flag */
+};
+
+struct _stx_cache {
+  size_t	    max_size;    /* max size of cache */
+  size_t            cur_size;    /* current size of cache */
+
+  size_t            max_weight;  /* cache capacity */
+  size_t            cur_weight;  /* current total &quot;weight&quot; of all entries */
+
+  size_t	    hash_size;   /* size of hash table */
+  stx_cache_entry_t **table;     /* hash table for this cache */
+
+  stx_clist_t       lru_list;    /* least-recently-used list */
+
+  /* Cache stats */
+  unsigned long     hits;        /* num cache hits */
+  unsigned long     lookups;     /* num cache lookups */
+  unsigned long     inserts;     /* num inserts */
+  unsigned long     deletes;     /* num deletes */
+
+  /* Functions */
+  unsigned long (*key_hash_fn)(const void *);
+  long          (*key_cmp_fn)(const void *, const void *);
+  void          (*cleanup_fn)(void *, void *);
+};
+
+
+#define STX_CACHE_ENTRY_PTR(_qp) \
+  ((stx_cache_entry_t *)((char *)(_qp) - offsetof(stx_cache_entry_t, lru_link)))
+
+
+/*****************************************
+ * Cache methods
+ */
+
+stx_cache_t *stx_cache_create(size_t max_size, size_t max_weight,
+			      size_t hash_size,
+			      unsigned long (*key_hash_fn)(const void *key),
+			      long (*key_cmp_fn)(const void *key1,
+						 const void *key2),
+			      void (*cleanup_fn)(void *key, void *data))
+{
+    stx_cache_t *newcache;
+
+    newcache = (stx_cache_t *)calloc(1, sizeof(stx_cache_t));
+    if (newcache == NULL)
+	return NULL;
+    newcache-&gt;table = (stx_cache_entry_t **)calloc(hash_size,
+					         sizeof(stx_cache_entry_t *));
+    if (newcache-&gt;table == NULL) {
+	free(newcache);
+	return NULL;
+    }
+
+    newcache-&gt;max_size = max_size;
+    newcache-&gt;max_weight = max_weight;
+    newcache-&gt;hash_size = hash_size;
+    STX_CLIST_INIT_CLIST(&amp;(newcache-&gt;lru_list));
+    newcache-&gt;key_hash_fn = key_hash_fn;
+    newcache-&gt;key_cmp_fn = key_cmp_fn;
+    newcache-&gt;cleanup_fn = cleanup_fn;
+
+    return newcache;
+}
+
+
+void stx_cache_empty(stx_cache_t *cache)
+{
+    size_t i;
+    stx_cache_entry_t *entry, *next_entry;
+
+    for (i = 0; i &lt; cache-&gt;hash_size; i++) {
+	entry = cache-&gt;table[i];
+	while (entry) {
+	    next_entry = entry-&gt;next;
+	    stx_cache_entry_delete(cache, entry);
+	    entry = next_entry;
+	}
+    }
+}
+
+
+void stx_cache_traverse(stx_cache_t *cache,
+			void (*callback)(void *key, void *data))
+{
+    size_t i;
+    stx_cache_entry_t *entry;
+
+    for (i = 0; i &lt; cache-&gt;hash_size; i++) {
+	for (entry = cache-&gt;table[i]; entry; entry = entry-&gt;next) {
+	    if (!entry-&gt;delete_pending)
+		(*callback)(entry-&gt;key, entry-&gt;data);
+	}
+    }
+}
+
+
+void stx_cache_traverse_lru(stx_cache_t *cache,
+			    void (*callback)(void *key, void *data),
+			    unsigned int n)
+{
+    stx_clist_t *q;
+    stx_cache_entry_t *entry;
+
+    for (q = STX_CLIST_HEAD(&amp;cache-&gt;lru_list); q != &amp;cache-&gt;lru_list &amp;&amp; n;
+	 q = q-&gt;next, n--) {
+	entry = STX_CACHE_ENTRY_PTR(q);
+	(*callback)(entry-&gt;key, entry-&gt;data);
+    }
+}
+
+
+void stx_cache_traverse_mru(stx_cache_t *cache,
+			    void (*callback)(void *key, void *data),
+			    unsigned int n)
+{
+    stx_clist_t *q;
+    stx_cache_entry_t *entry;
+
+    for (q = STX_CLIST_TAIL(&amp;cache-&gt;lru_list); q != &amp;cache-&gt;lru_list &amp;&amp; n;
+	 q = q-&gt;prev, n--) {
+	entry = STX_CACHE_ENTRY_PTR(q);
+	(*callback)(entry-&gt;key, entry-&gt;data);
+    }
+}
+
+
+size_t stx_cache_getsize(stx_cache_t *cache)
+{
+    return cache-&gt;cur_size;
+}
+
+
+size_t stx_cache_getweight(stx_cache_t *cache)
+{
+    return cache-&gt;cur_weight;
+}
+
+
+void stx_cache_getinfo(stx_cache_t *cache, stx_cache_info_t *info)
+{
+    info-&gt;max_size = cache-&gt;max_size;
+    info-&gt;max_weight = cache-&gt;max_weight;
+    info-&gt;hash_size = cache-&gt;hash_size;
+    info-&gt;cur_size = cache-&gt;cur_size;
+    info-&gt;cur_weight = cache-&gt;cur_weight;
+    info-&gt;hits = cache-&gt;hits;
+    info-&gt;lookups = cache-&gt;lookups;
+    info-&gt;inserts = cache-&gt;inserts;
+    info-&gt;deletes = cache-&gt;deletes;
+}
+
+
+/*****************************************
+ * Cache entry methods
+ */
+
+stx_cache_entry_t *stx_cache_entry_create(void *key, void *data,
+					  size_t weight)
+{
+    stx_cache_entry_t *newentry;
+
+    newentry = (stx_cache_entry_t *)calloc(1, sizeof(stx_cache_entry_t));
+    if (newentry == NULL)
+	return NULL;
+
+    newentry-&gt;key = key;
+    newentry-&gt;data = data;
+    newentry-&gt;weight = weight;
+
+    return newentry;
+}
+
+
+void stx_cache_entry_delete(stx_cache_t *cache, stx_cache_entry_t *entry)
+{
+    entry-&gt;delete_pending = 1;
+
+    if (entry-&gt;ref_count &gt; 0)
+	return;
+
+    if (entry-&gt;pthis) {
+	*entry-&gt;pthis = entry-&gt;next;
+	if (entry-&gt;next)
+	    entry-&gt;next-&gt;pthis = entry-&gt;pthis;
+
+	cache-&gt;cur_size--;
+	cache-&gt;cur_weight -= entry-&gt;weight;
+	cache-&gt;deletes++;
+	STX_CLIST_REMOVE_LINK(&amp;(entry-&gt;lru_link));
+    }
+
+    if (cache-&gt;cleanup_fn)
+	cache-&gt;cleanup_fn(entry-&gt;key, entry-&gt;data);
+
+    entry-&gt;pthis = NULL;
+    entry-&gt;key   = NULL;
+    entry-&gt;data  = NULL;
+    free(entry);
+}
+
+
+stx_cache_entry_t *stx_cache_entry_lookup(stx_cache_t *cache, const void *key)
+{
+    unsigned long bucket;
+    stx_cache_entry_t *entry;
+
+    cache-&gt;lookups++;
+    bucket = cache-&gt;key_hash_fn(key) % cache-&gt;hash_size;
+    for (entry = cache-&gt;table[bucket]; entry; entry = entry-&gt;next) {
+	if (!entry-&gt;delete_pending &amp;&amp; cache-&gt;key_cmp_fn(key, entry-&gt;key) == 0)
+	    break;
+    }
+    if (entry) {
+	cache-&gt;hits++;
+	if (entry-&gt;ref_count == 0)
+	    STX_CLIST_REMOVE_LINK(&amp;(entry-&gt;lru_link));
+	entry-&gt;ref_count++;
+    }
+
+    return entry;
+}
+
+
+void stx_cache_entry_release(stx_cache_t *cache, stx_cache_entry_t *entry)
+{
+    if (entry-&gt;ref_count == 0)
+	return;
+
+    entry-&gt;ref_count--;
+
+    if (entry-&gt;ref_count == 0) {
+	STX_CLIST_APPEND_LINK(&amp;(entry-&gt;lru_link), &amp;(cache-&gt;lru_list));
+	if (entry-&gt;delete_pending)
+	    stx_cache_entry_delete(cache, entry);
+    }
+}
+
+
+int stx_cache_entry_insert(stx_cache_t *cache, stx_cache_entry_t *entry)
+{
+    stx_cache_entry_t *old_entry;
+    unsigned long bucket;
+
+    /*
+     * If cache capacity is exceeded, try to remove LRU entries till there is
+     * enough room or LRU list is empty.
+     */
+    while (cache-&gt;cur_weight + entry-&gt;weight &gt; cache-&gt;max_weight) {
+	old_entry = stx_cache_entry_getlru(cache);
+	if (!old_entry) {
+	    /* cache capacity is exceeded and all entries are in use */
+	    return -1;
+	}
+	stx_cache_entry_delete(cache, old_entry);
+    }
+
+    /* If cache size is exceeded, remove LRU entry */
+    if (cache-&gt;cur_size &gt;= cache-&gt;max_size) {
+	old_entry = stx_cache_entry_getlru(cache);
+	if (!old_entry) {
+	    /* cache size is exceeded and all entries are in use */
+	    return -1;
+	}
+	stx_cache_entry_delete(cache, old_entry);
+    }
+
+    /* Don't add duplicate entries in the cache */
+    bucket = cache-&gt;key_hash_fn(entry-&gt;key) % cache-&gt;hash_size;
+    for (old_entry = cache-&gt;table[bucket]; old_entry;
+	 old_entry = old_entry-&gt;next) {
+	if (!old_entry-&gt;delete_pending &amp;&amp;
+	    cache-&gt;key_cmp_fn(entry-&gt;key, old_entry-&gt;key) == 0)
+	    break;
+    }
+    if (old_entry)
+	stx_cache_entry_delete(cache, old_entry);
+
+    /* Insert in the hash table */
+    entry-&gt;next = cache-&gt;table[bucket];
+    cache-&gt;table[bucket] = entry;
+    entry-&gt;pthis = &amp;cache-&gt;table[bucket];
+    if (entry-&gt;next)
+	entry-&gt;next-&gt;pthis = &amp;entry-&gt;next;
+    entry-&gt;ref_count++;
+
+    cache-&gt;inserts++;
+    cache-&gt;cur_size++;
+    cache-&gt;cur_weight += entry-&gt;weight;
+
+    return 0;
+}
+
+
+stx_cache_entry_t *stx_cache_entry_getlru(stx_cache_t *cache)
+{
+    if (STX_CLIST_IS_EMPTY(&amp;(cache-&gt;lru_list)))
+	return NULL;
+
+    return STX_CACHE_ENTRY_PTR(STX_CLIST_HEAD(&amp;(cache-&gt;lru_list)));
+}
+
+
+int stx_cache_entry_sizeof(void)
+{
+    return (int)sizeof(stx_cache_entry_t);
+}
+
+
+void *stx_cache_entry_getdata(stx_cache_entry_t *entry)
+{
+    return entry-&gt;data;
+}
+
+
+void *stx_cache_entry_getkey(stx_cache_entry_t *entry)
+{
+    return entry-&gt;key;
+}
+
+
+size_t stx_cache_entry_getweight(stx_cache_entry_t *entry)
+{
+    return entry-&gt;weight;
+}
+

Added: upwatch/trunk/st-1.6/extensions/print_stk.patch
===================================================================
--- upwatch/trunk/st-1.6/extensions/print_stk.patch	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/print_stk.patch	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,367 @@
+Michael Abd-El-Malek contributed this patch.  He wrote:
+----------------------------------------
+Hello,
+
+This is a patch that enables programmatically dumping the stack of  
+every thread.  This has been useful in debugging deadlocks, etc...   
+Our usage model is that the SIGUSR2 handler calls the new  
+_st_print_thread_stacks function, which dumps the stack for all  
+threads.  A convenient feature is that for thread stacks that are the  
+same (which is common for application with a lot of worker threads  
+waiting for work), only one stack trace is printed, along with a  
+count of how many threads have that same stack.
+
+I use the glibc backtrace function to get the backtrace, and then use  
+popen to execute addr2line and convert memory addresses to file  
+names, function names, and line numbers.  If glibc isn't available,  
+_st_print_thread_stacks just prints a warning.  And this feature is  
+only available if DEBUG is turned on.
+
+We've found this feature extremely helpful when debugging.
+
+The patch can be a bit more robust (it assumes addr2line exists).   
+But I didn't want to go through the hassle of doing this, if the  
+StateThreads community doesn't want to use this patch.  (In our  
+environment, addr2line will always be there.)
+
+Cheers,
+Mike
+----------------------------------------
+Invoking complex functions from a signal handler is not recommended,
+plus this patch changes the behavior of existing API hooks.  It will
+not become part of State Threads proper but you may find it useful
+nonetheless.  This patch applies to st-1.5.2.
+
+diff -Nur Makefile.1.5.2 Makefile
+--- Makefile.1.5.2	Wed Sep  7 14:19:50 2005
++++ Makefile	Wed Sep  7 14:33:08 2005
+@@ -255,7 +255,8 @@
+               $(TARGETDIR)/stk.o   \
+               $(TARGETDIR)/sync.o  \
+               $(TARGETDIR)/key.o   \
+-              $(TARGETDIR)/io.o
++              $(TARGETDIR)/io.o    \
++	      $(TARGETDIR)/backtrace.o
+ OBJS        += $(EXTRA_OBJS)
+ HEADER      = $(TARGETDIR)/st.h
+ SLIBRARY    = $(TARGETDIR)/libst.a
+diff -Nur backtrace.c.1.5.2 backtrace.c
+--- backtrace.c.1.5.2	Wed Dec 31 16:00:00 1969
++++ backtrace.c	Wed Sep  7 13:40:21 2005
+@@ -0,0 +1,211 @@
++/*
++ * The contents of this file are subject to the Mozilla Public
++ * License Version 1.1 (the &quot;License&quot;); you may not use this file
++ * except in compliance with the License. You may obtain a copy of
++ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
++ *
++ * Software distributed under the License is distributed on an &quot;AS
++ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
++ * implied. See the License for the specific language governing
++ * rights and limitations under the License.
++ *
++ * Contributor(s):  Michael Abd-El-Malek (<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">mabdelmalek at cmu.edu</A>)
++ *                  Carnegie Mellon University
++ *
++ * Alternatively, the contents of this file may be used under the
++ * terms of the GNU General Public License Version 2 or later (the
++ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable
++ * instead of those above.  If you wish to allow use of your
++ * version of this file only under the terms of the GPL and not to
++ * allow others to use your version of this file under the MPL,
++ * indicate your decision by deleting the provisions above and
++ * replace them with the notice and other provisions required by
++ * the GPL.  If you do not delete the provisions above, a recipient
++ * may use your version of this file under either the MPL or the
++ * GPL.
++ */
++
++
++
++/*
++ * This file contains routines for printing a stack trace of all threads.
++ * Only works when DEBUG is defined and where glibc is available, since it
++ * provides the backtrace() function.
++ */
++
++#define _GNU_SOURCE  /* to get program_invocation_name */
++
++#include &lt;stdio.h&gt;
++#include &lt;stdlib.h&gt;
++
++
++#if defined(DEBUG) &amp;&amp; defined(__GLIBC__)
++
++#include &lt;errno.h&gt;
++#include &quot;common.h&quot;
++#include &lt;execinfo.h&gt;
++#include &lt;inttypes.h&gt;
++#include &lt;string.h&gt;
++
++
++/* The maximum number of frames to get a stack trace for.  If a thread has more
++ * frames than this, then we only show the latest X frames. */
++#define MAX_NUM_FRAMES 64
++
++
++typedef struct thread_stack_s {
++   uint32_t        num_frames;
++   void*           addresses[MAX_NUM_FRAMES]; /* frame pointers */
++   char*           locations[MAX_NUM_FRAMES]; /* file/function/line numbers  */
++   uint32_t        num_matches;
++
++   struct thread_stack_s* next;
++} thread_stack_t;
++
++static thread_stack_t* stacks = NULL;
++
++
++/* Converts the function's memory addresses to function names, file names, and
++ * line numbers.  Calls binutil's addr2line program. */
++static void get_symbol_names(thread_stack_t *stack)
++{
++     char program_to_run[1024], function[256], filename_lineno[256], temp[19];
++     FILE* output;
++     int num_bytes_left;
++     uint32_t i;
++
++     /* Construct the arguments to addr2line */
++     num_bytes_left = sizeof(program_to_run);
++     num_bytes_left -= snprintf(program_to_run, sizeof(program_to_run),
++                                &quot;addr2line -fCe %s&quot;, program_invocation_name);
++     for (i = 0; i &lt; stack-&gt;num_frames &amp;&amp; num_bytes_left &gt; 0; ++i) {
++         num_bytes_left -= snprintf(temp, sizeof(temp), &quot; %p&quot;, stack-&gt;addresses[i]);
++         strncat(program_to_run, temp, num_bytes_left);
++     }
++
++     /* Use popen to execute addr2line and read its ouput */
++     output = popen(program_to_run, &quot;r&quot;);
++     for (i = 0; i &lt; stack-&gt;num_frames; ++i) {
++         char* function_listing = (char*) malloc(512);
++         fscanf(output, &quot;%255s\n&quot;, function);
++         fscanf(output, &quot;%255s\n&quot;, filename_lineno);
++         snprintf(function_listing, 512, &quot;%s at %s&quot;, function, filename_lineno);
++         stack-&gt;locations[i] = function_listing;
++     }
++     pclose(output);
++}
++
++
++static void print_stack(thread_stack_t* stack)
++{
++     int skip_offset = 0, cmp_len;
++     uint32_t i;
++
++     /* Get the function names/filenames/line numbers */
++     get_symbol_names(stack);
++
++     cmp_len = strlen(&quot;_st_iterate_threads_helper&quot;);
++
++     /* Print the backtrace */
++     for (i = 0; i &lt; stack-&gt;num_frames; ++i) {
++         /* Skip frames we don't have location info for */
++         if (!strncmp(stack-&gt;locations[i], &quot;??&quot;, 2)) {
++             continue;
++         }
++
++         /* Skip the frames that are used for printing the stack trace */
++         if (skip_offset) {
++             printf(&quot;\t#%2d %s %p\n&quot;, i - skip_offset, stack-&gt;locations[i],
++                    stack-&gt;addresses[i]);
++         } else if (!strncmp(stack-&gt;locations[i], &quot;_st_iterate_threads_helper&quot;,
++                             cmp_len)) {
++             skip_offset = i + 1;
++         }
++     }
++}
++
++
++static void add_current_thread_stack(void)
++{
++     thread_stack_t *new_stack = malloc(sizeof(thread_stack_t));
++     thread_stack_t *search;
++
++     /* Call glibc function to get the backtrace */
++     new_stack-&gt;num_frames = backtrace(new_stack-&gt;addresses, MAX_NUM_FRAMES);
++
++     /* Check if we have another stacks that is equivalent.  If so, then coaelsce
++      *  two stacks into one, to minimize output to user. */
++     search = stacks;
++     while (search) {
++         if (search-&gt;num_frames == new_stack-&gt;num_frames &amp;&amp;
++             !memcmp(search-&gt;addresses, new_stack-&gt;addresses,
++                     search-&gt;num_frames * sizeof(void*))) {
++             /* Found an existing stack that is the same as this thread's stack */
++             ++search-&gt;num_matches;
++             free(new_stack);
++             return;
++         } else {
++             search = search-&gt;next;
++         }
++     }
++
++     /* This is a new stack.  Add it to the list of stacks. */
++     new_stack-&gt;num_matches = 1;
++     new_stack-&gt;next = stacks;
++     stacks = new_stack;
++}
++
++static void print_stack_frames(void)
++{
++     while (stacks) {
++         printf(&quot;\n%u thread(s) with this backtrace:\n&quot;, stacks-&gt;num_matches);
++         print_stack(stacks);
++         stacks = stacks-&gt;next;
++     }
++     printf(&quot;\n&quot;);
++}
++
++static void free_stacks(void)
++{
++     uint32_t i;
++     while (stacks) {
++         thread_stack_t *next = stacks-&gt;next;
++         for (i = 0; i &lt; stacks-&gt;num_frames; ++i) {
++             free(stacks-&gt;locations[i]);
++         }
++         free(stacks);
++         stacks = next;
++     }
++     stacks = NULL;
++}
++
++
++static void st_print_thread_stack(_st_thread_t *thread, int start_flag,
++                                   int end_flag)
++{
++     if (end_flag == 0) {
++         add_current_thread_stack();
++     } else {
++         print_stack_frames();
++     }
++}
++
++
++void _st_print_thread_stacks(int ignore)
++{
++     _st_iterate_threads_flag = 1;
++     _st_iterate_threads_helper(st_print_thread_stack);
++     _st_iterate_threads_flag = 0;
++
++     /* Deallocate memory */
++     free_stacks();
++}
++
++#else  /* defined(DEBUG) &amp;&amp; defined(__GLIBC__) */
++
++void _st_print_thread_stacks(int ignore)
++{
++     printf(&quot;%s: need DEBUG mode and glibc-specific functions to read stack.\n&quot;,
++            __FUNCTION__);
++}
++#endif /* defined(DEBUG) &amp;&amp; defined(__GLIBC__) */
+diff -Nur common.h.1.5.2 common.h
+--- common.h.1.5.2	Wed Sep  7 14:18:37 2005
++++ common.h	Wed Sep  7 14:35:36 2005
+@@ -371,8 +371,18 @@
+  */
+ 
+ #ifdef DEBUG
+-void _st_iterate_threads(void);
+-#define ST_DEBUG_ITERATE_THREADS() _st_iterate_threads()
++typedef void(*_st_func_ptr_t)(_st_thread_t *thread,
++                              int           start_flag,
++                              int           end_flag);
++/* Pointer to function that will be called on thread switch */
++extern _st_func_ptr_t _st_iterate_func_ptr;
++extern int _st_iterate_threads_flag;
++/* Thread iteration function that will call an arbitrary function */
++extern void _st_iterate_threads_helper(_st_func_ptr_t func);
++#define ST_DEBUG_ITERATE_THREADS()                               \
++          if (_st_iterate_func_ptr) {                            \
++              _st_iterate_threads_helper(_st_iterate_func_ptr);  \
++          }
+ #else
+ #define ST_DEBUG_ITERATE_THREADS()
+ #endif
+diff -Nur public.h.1.5.2 public.h
+--- public.h.1.5.2	Wed Sep  7 11:46:58 2005
++++ public.h	Wed Sep  7 13:38:46 2005
+@@ -171,8 +171,10 @@
+ extern st_netfd_t st_open(const char *path, int oflags, mode_t mode);
+ 
+ #ifdef DEBUG
+-extern void _st_show_thread_stack(st_thread_t thread, const char *messg);
++extern void _st_show_thread_stack(st_thread_t thread, int start_flag,
++				  int end_flag);
+ extern void _st_iterate_threads(void);
++extern void _st_print_thread_stacks(int ignore);
+ #endif
+ 
+ #ifdef __cplusplus
+diff -Nur sched.c.1.5.2 sched.c
+--- sched.c.1.5.2	Wed Sep  7 10:48:05 2005
++++ sched.c	Wed Sep  7 13:38:46 2005
+@@ -919,16 +919,13 @@
+ 
+ 
+ #ifdef DEBUG
+-/* ARGSUSED */
+-void _st_show_thread_stack(_st_thread_t *thread, const char *messg)
+-{
+-
+-}
+-
+ /* To be set from debugger */
+ int _st_iterate_threads_flag = 0;
++/* Thread iteration function that will call an arbitrary function */
++_st_func_ptr_t _st_iterate_func_ptr = NULL;
+ 
+-void _st_iterate_threads(void)
++/* This function iterates over all threads, calling &quot;func&quot; for each thread. */
++void _st_iterate_threads_helper(_st_func_ptr_t func)
+ {
+   static _st_thread_t *thread = NULL;
+   static jmp_buf orig_jb, save_jb;
+@@ -944,16 +941,20 @@
+ 
+   if (thread) {
+     memcpy(thread-&gt;context, save_jb, sizeof(jmp_buf));
+-    _st_show_thread_stack(thread, NULL);
++    func(thread, 0, 0);
+   } else {
+     if (MD_SETJMP(orig_jb)) {
+       _st_iterate_threads_flag = 0;
++      _st_iterate_func_ptr = NULL;
+       thread = NULL;
+-      _st_show_thread_stack(thread, &quot;Iteration completed&quot;);
++      /* Last thread to iterate through  */
++      func(thread, 0, 1);
+       return;
+     }
++    /* First thread to iterate through  */
+     thread = _ST_CURRENT_THREAD();
+-    _st_show_thread_stack(thread, &quot;Iteration started&quot;);
++    _st_iterate_func_ptr = func;
++    func(thread, 1, 0);
+   }
+ 
+   q = thread-&gt;tlink.next;
+@@ -966,5 +967,17 @@
+   memcpy(save_jb, thread-&gt;context, sizeof(jmp_buf));
+   MD_LONGJMP(thread-&gt;context, 1);
+ }
++
++/* ARGSUSED */
++void _st_show_thread_stack(_st_thread_t *thread, int start_flag, int end_flag)
++{
++}
++
++/* Iterate over threads inside debugger; see st/README */
++void _st_iterate_threads(void)
++{
++  _st_iterate_threads_helper(_st_show_thread_stack);
++}
++
+ #endif /* DEBUG */
+ 

Added: upwatch/trunk/st-1.6/extensions/stx.h
===================================================================
--- upwatch/trunk/st-1.6/extensions/stx.h	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/stx.h	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,91 @@
+#ifndef _STX_H_
+#define _STX_H_
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/nameser.h&gt;
+#include &lt;resolv.h&gt;
+#include &lt;netdb.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;st.h&quot;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/*****************************************
+ * Basic types definitions
+ */
+
+typedef struct _stx_centry stx_cache_entry_t;
+typedef struct _stx_cache  stx_cache_t;
+
+/* This is public type */
+typedef struct _stx_cache_info {
+  size_t max_size;
+  size_t max_weight;
+  size_t hash_size;
+  size_t cur_size;
+  size_t cur_weight;
+  unsigned long hits;
+  unsigned long lookups;
+  unsigned long inserts;
+  unsigned long deletes;
+} stx_cache_info_t;
+
+
+/*****************************************
+ * Cache and cache entry methods
+ */
+
+stx_cache_t *stx_cache_create(size_t max_size, size_t max_weight,
+			      size_t hash_size,
+			      unsigned long (*key_hash_fn)(const void *key),
+			      long (*key_cmp_fn)(const void *key1,
+						 const void *key2),
+			      void (*cleanup_fn)(void *key, void *data));
+void stx_cache_empty(stx_cache_t *cache);
+void stx_cache_traverse(stx_cache_t *cache,
+			void (*callback)(void *key, void *data));
+void stx_cache_traverse_lru(stx_cache_t *, void (*)(void *, void *),
+			    unsigned int);
+void stx_cache_traverse_mru(stx_cache_t *, void (*)(void *, void *),
+			    unsigned int);
+void stx_cache_getinfo(stx_cache_t *cache, stx_cache_info_t *info);
+size_t stx_cache_getsize(stx_cache_t *cache);
+size_t stx_cache_getweight(stx_cache_t *cache);
+
+
+stx_cache_entry_t *stx_cache_entry_create(void *key, void *data,
+					  size_t weight);
+void stx_cache_entry_delete(stx_cache_t *cache, stx_cache_entry_t *entry);
+stx_cache_entry_t *stx_cache_entry_lookup(stx_cache_t *cache, const void *key);
+void stx_cache_entry_release(stx_cache_t *, stx_cache_entry_t *);
+int stx_cache_entry_insert(stx_cache_t *cache, stx_cache_entry_t *entry);
+stx_cache_entry_t *stx_cache_entry_getlru(stx_cache_t *cache);
+int stx_cache_entry_sizeof(void);
+void *stx_cache_entry_getdata(stx_cache_entry_t *entry);
+void *stx_cache_entry_getkey(stx_cache_entry_t *entry);
+size_t stx_cache_entry_getweight(stx_cache_entry_t *entry);
+
+
+int stx_dns_cache_init(size_t max_size, size_t max_bytes, size_t hash_size);
+void stx_dns_cache_getinfo(stx_cache_info_t *info);
+int stx_dns_getaddrlist(const char *hostname, struct in_addr *addrs,
+			int *num_addrs, st_utime_t timeout);
+int stx_dns_getaddr(const char *hostname, struct in_addr *addr,
+		    st_utime_t timeout);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_STX_H_ */
+

Added: upwatch/trunk/st-1.6/extensions/stx_fileio.c
===================================================================
--- upwatch/trunk/st-1.6/extensions/stx_fileio.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/stx_fileio.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,196 @@
+/*
+ * File I/O extension to the State Threads Library.
+ */
+
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the file I/O extension to the State Threads Library.
+ * 
+ * The Initial Developer of the Original Code is Jeff
+ * &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">jlb-st at houseofdistraction.com</A>&gt;.  Portions created by the Initial
+ * Developer are Copyright (C) 2002 the Initial Developer.  All Rights
+ * Reserved.
+ * 
+ * Contributor(s): (none)
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+#include &lt;stdlib.h&gt;
+
+#include &quot;stx_fileio.h&quot;
+
+#define STX_FILEIO_SIGNUM SIGUSR2
+
+typedef struct {
+    st_netfd_t data_fd;
+    st_netfd_t control_fd;
+    pid_t pid;
+} fileio_data_t;
+
+#define FILEREADER_MAX_READ 1024
+
+typedef struct {
+    off_t offset;
+    ssize_t nbytes;
+} file_reader_cb_t;
+
+/**
+ * Fork a process to read a file and return its pid.  Receives
+ * offset/length commands from control stream and sends corresponding data
+ * to out stream.  A zero length on the control stream signals an end.
+ *
+ * @param fd stream from which to read
+ * @param control_out receives the file descriptor to which control commands can be sent
+ * @param fd_out receives the file descriptor from which the output of the command can be read.
+ * @return PID of the process created to execute the command
+ */
+pid_t
+file_reader(int fd, int *fd_control, int *fd_out)
+{
+    pid_t pid;
+    int control_pipe[2], out_pipe[2];
+
+    if (pipe(control_pipe) &lt; 0 || pipe(out_pipe) &lt; 0)
+        return (pid_t)-1;
+
+    pid = fork();
+    if (pid == (pid_t) -1)
+    {
+        close(control_pipe[0]);
+        close(control_pipe[1]);
+        close(out_pipe[0]);
+        close(out_pipe[1]);
+        return pid;
+    }
+    else if (pid == (pid_t) 0)
+    {
+        // child
+        off_t pos = 0;
+        file_reader_cb_t cb;
+        char buf[FILEREADER_MAX_READ];
+        if (fd == -1)
+            _exit(EXIT_FAILURE);
+
+        while (sizeof(cb) == read(control_pipe[0], &amp;cb, sizeof(cb))) {
+            ssize_t nb;
+            if (0 &gt;= cb.nbytes)
+                goto clean_exit;
+            if (pos != cb.offset) {
+                pos = lseek(fd, cb.offset, SEEK_SET);
+                if (pos == (off_t)-1)
+                    break;
+            }
+            nb = read(fd, buf, cb.nbytes);
+            if (nb == (ssize_t)-1)
+                break;
+            pos += nb;
+            write(out_pipe[1], (char *)&amp;nb, sizeof(nb));
+            write(out_pipe[1], buf, nb);
+        }
+        perror(&quot;ERROR: file_reader: &quot;);
+    clean_exit:
+        close(control_pipe[0]);
+        close(control_pipe[1]);
+        close(out_pipe[0]);
+        close(out_pipe[1]);
+        _exit(EXIT_SUCCESS);
+    }
+
+    // parent
+    close(out_pipe[1]);
+    close(control_pipe[0]);
+    *fd_out = out_pipe[0];
+    *fd_control = control_pipe[1];
+    return pid;
+}
+
+/**
+ * fileio_data_t destructor callback
+ */
+static void
+fileio_data_destructor(void *dat_in)
+{
+    if (dat_in) {
+        fileio_data_t *dat = (fileio_data_t *)dat_in;
+        file_reader_cb_t cb;
+        cb.offset = 0;
+        cb.nbytes = 0;
+        st_write(dat-&gt;control_fd, (char *)&amp;cb, sizeof(cb), (st_utime_t)-1);
+        waitpid(dat-&gt;pid, NULL, 0);
+        st_netfd_close(dat-&gt;control_fd);
+        st_netfd_close(dat-&gt;data_fd);
+        free(dat_in);
+    }
+}
+
+/**
+ * Retrieve fileio_data_t struct from an st descriptor.  Create and store
+ * a new one if needed.
+ */
+static fileio_data_t *get_fileio_data(st_netfd_t fd)
+{
+    fileio_data_t *dat = (fileio_data_t *)st_netfd_getspecific(fd);
+    if (!dat) {
+        int fd_control, fd_out;
+        pid_t pid = file_reader(st_netfd_fileno(fd), &amp;fd_control, &amp;fd_out);
+        if (pid != (pid_t)-1) {
+            dat = (fileio_data_t *)calloc(1, sizeof(fileio_data_t));
+            dat-&gt;control_fd = st_netfd_open(fd_control);
+            dat-&gt;data_fd = st_netfd_open(fd_out);
+            dat-&gt;pid = pid;
+            st_netfd_setspecific(fd, dat, fileio_data_destructor);
+        }
+    }
+    return dat;
+}
+
+/**
+ * Read data from the specified section of a file.  Uses a forked
+ * file_reader process to do the actual reading so as to avoid causing all
+ * State Threads to block.
+ *
+ * @param fd must refer to a seekable file.
+ * @param offset absolute offset within the file
+ * @param buf output buffer
+ * @param nbytes size of the output buffer
+ * @param timeout
+ */
+ssize_t
+stx_file_read(st_netfd_t fd, off_t offset, void *buf, size_t nbytes, st_utime_t timeout)
+{
+    fileio_data_t *dat = get_fileio_data(fd);
+    if (dat) {
+        file_reader_cb_t cb;
+        ssize_t ret = (ssize_t)-1;
+        cb.offset = offset;
+        cb.nbytes = nbytes;
+        st_write(dat-&gt;control_fd, (char *)&amp;cb, sizeof(cb), timeout);
+        if (sizeof(ret) == st_read(dat-&gt;data_fd, (char *)&amp;ret, sizeof(ret), timeout) &amp;&amp; 0 &lt; ret &amp;&amp; ret &lt;= nbytes) {
+            return st_read(dat-&gt;data_fd, buf, ret, timeout);
+        } else {
+            return ret;
+        }
+    }
+
+    return (ssize_t)-1;
+}

Added: upwatch/trunk/st-1.6/extensions/stx_fileio.h
===================================================================
--- upwatch/trunk/st-1.6/extensions/stx_fileio.h	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/stx_fileio.h	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,52 @@
+/*
+ * File I/O extension to the State Threads Library.
+ */
+
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the file I/O extension to the State Threads Library.
+ * 
+ * The Initial Developer of the Original Code is Jeff
+ * &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">jlb-st at houseofdistraction.com</A>&gt;.  Portions created by the Initial
+ * Developer are Copyright (C) 2002 the Initial Developer.  All Rights
+ * Reserved.
+ * 
+ * Contributor(s): (none)
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+#ifndef __STX_FILEIO_H__
+#define __STX_FILEIO_H__
+
+#include &lt;st.h&gt;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+extern ssize_t stx_file_read(st_netfd_t fd, off_t offset, void *buf, size_t nbytes, st_utime_t timeout);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !__STX_FILEIO_H__ */

Added: upwatch/trunk/st-1.6/extensions/testdns.c
===================================================================
--- upwatch/trunk/st-1.6/extensions/testdns.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/extensions/testdns.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,112 @@
+#include &quot;stx.h&quot;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+
+
+#define MAX_ADDRS 128
+#define TIMEOUT (4*1000000LL)
+
+static void do_resolve(const char *host)
+{
+    struct in_addr addrs[MAX_ADDRS];
+    int i, n = MAX_ADDRS;
+
+    if (stx_dns_getaddrlist(host, addrs, &amp;n, TIMEOUT) &lt; 0) {
+	fprintf(stderr, &quot;stx_dns_getaddrlist: can't resolve %s: &quot;, host);
+	if (h_errno == NETDB_INTERNAL)
+	    perror(&quot;&quot;);
+	else
+	    herror(&quot;&quot;);
+    } else {
+	if (n &gt; 0)
+	    printf(&quot;%-40s %s\n&quot;, (char *)host, inet_ntoa(addrs[0]));
+	for (i = 1; i &lt; n; i++)
+	    printf(&quot;%-40s %s\n&quot;, &quot;&quot;, inet_ntoa(addrs[i]));
+    }
+}
+
+static void show_info(void)
+{
+    stx_cache_info_t info;
+
+    stx_dns_cache_getinfo(&amp;info);
+    printf(&quot;DNS cache info:\n\n&quot;);
+    printf(&quot;max_size:  %8d\n&quot;, (int)info.max_size);
+    printf(&quot;capacity:  %8d bytes\n&quot;, (int)info.max_weight);
+    printf(&quot;hash_size: %8d\n&quot;, (int)info.hash_size);
+    printf(&quot;cur_size:  %8d\n&quot;
+	   &quot;cur_mem:   %8d bytes\n&quot;
+	   &quot;hits:      %8d\n&quot;
+	   &quot;lookups:   %8d\n&quot;
+	   &quot;inserts:   %8d\n&quot;
+	   &quot;deletes:   %8d\n&quot;,
+	   (int)info.cur_size, (int)info.cur_weight, (int)info.hits,
+	   (int)info.lookups, (int)info.inserts, (int)info.deletes);
+}
+
+extern stx_cache_t *_stx_dns_cache;
+
+static void printhost(void *host, void *data)
+{
+    printf(&quot;%s\n&quot;, (char *)host);
+}
+
+static void show_lru(void)
+{
+    printf(&quot;LRU hosts:\n\n&quot;);
+    stx_cache_traverse_lru(_stx_dns_cache, printhost, 10);
+}
+
+static void show_mru(void)
+{
+    printf(&quot;MRU hosts:\n\n&quot;);
+    stx_cache_traverse_mru(_stx_dns_cache, printhost, 10);
+}
+
+static void flush_cache(void)
+{
+    stx_cache_empty(_stx_dns_cache);
+    printf(&quot;DNS cache is empty\n&quot;);
+}
+
+
+int main()
+{
+    char line[256];
+    char str[sizeof(line)];
+
+    st_init();
+    stx_dns_cache_init(100, 10000, 101);
+
+    for ( ; ; ) {
+	fputs(&quot;&gt; &quot;, stdout);
+	fflush(stdout);
+	if (!fgets(line, sizeof(line), stdin))
+	    break;
+	if (sscanf(line, &quot;%s&quot;, str) != 1)
+	    continue;
+	if (strcmp(str, &quot;exit&quot;) == 0 || strcmp(str, &quot;quit&quot;) == 0)
+	    break;
+	if (strcmp(str, &quot;info&quot;) == 0) {
+	    show_info();
+	    continue;
+	}
+	if (strcmp(str, &quot;lru&quot;) == 0) {
+	    show_lru();
+	    continue;
+	}
+	if (strcmp(str, &quot;mru&quot;) == 0) {
+	    show_mru();
+	    continue;
+	}
+	if (strcmp(str, &quot;flush&quot;) == 0) {
+	    flush_cache();
+	    continue;
+	}
+
+	do_resolve(str);
+    }
+
+    return 0;
+}
+

Added: upwatch/trunk/st-1.6/ia64asm.S
===================================================================
--- upwatch/trunk/st-1.6/ia64asm.S	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/ia64asm.S	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,283 @@
+/*
+ * Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * The internal __jmp_buf layout is different from one used
+ * by setjmp()/longjmp().
+ *
+ *       Offset   Description
+ *       ------   -----------
+ *       0x000    stack pointer (r12)
+ *       0x008    gp (r1)
+ *       0x010    caller's unat
+ *       0x018    fpsr
+ *       0x020    r4
+ *       0x028    r5
+ *       0x030    r6
+ *       0x038    r7
+ *       0x040    rp (b0)
+ *       0x048    b1
+ *       0x050    b2
+ *       0x058    b3
+ *       0x060    b4
+ *       0x068    b5
+ *       0x070    ar.pfs
+ *       0x078    ar.lc
+ *       0x080    pr
+ *       0x088    ar.bsp
+ *       0x090    ar.unat
+ *       0x098    &amp;__jmp_buf
+ *       0x0a0    ar.rsc
+ *       0x0a8    ar.rnat
+ *       0x0b0     f2
+ *       0x0c0     f3
+ *       0x0d0     f4
+ *       0x0e0     f5
+ *       0x0f0    f16
+ *       0x100    f17
+ *       0x110    f18
+ *       0x120    f19
+ *       0x130    f20
+ *       0x130    f21
+ *       0x140    f22
+ *       0x150    f23
+ *       0x160    f24
+ *       0x170    f25
+ *       0x180    f26
+ *       0x190    f27
+ *       0x1a0    f28
+ *       0x1b0    f29
+ *       0x1c0    f30
+ *       0x1d0    f31
+ *
+ * Note that the address of __jmp_buf is saved but not used: we assume
+ * that the jmp_buf data structure is never moved around in memory.
+ */
+
+/*
+ * Implemented according to &quot;IA-64 Software Conventions and Runtime
+ * Architecture Guide&quot;, Chapter 10: &quot;Context Management&quot;.
+ */
+
+        .text
+        .psr abi64
+        .psr lsb
+        .lsb
+
+        /* _ia64_cxt_save(__jmp_buf env) */
+        .align 32
+        .global _ia64_cxt_save
+        .proc _ia64_cxt_save
+_ia64_cxt_save:
+        alloc r14 = ar.pfs,1,0,0,0
+        mov r16 = ar.unat
+        ;;
+        mov r17 = ar.fpsr
+        mov r2 = in0
+        add r3 = 8,in0
+        ;;
+        st8.spill.nta [r2] = sp,16    // r12 (sp)
+        ;;
+        st8.spill.nta [r3] = gp,16    // r1  (gp)
+        ;;
+        st8.nta [r2] = r16,16         // save caller's unat
+        st8.nta [r3] = r17,16         // save fpsr
+        add r8 = 0xb0,in0
+        ;;   
+        st8.spill.nta [r2] = r4,16    // r4
+        ;;
+        st8.spill.nta [r3] = r5,16    // r5
+        add r9 = 0xc0,in0
+        ;;
+        stf.spill.nta [r8] = f2,32
+        stf.spill.nta [r9] = f3,32
+	mov r15 = rp
+        ;;
+        stf.spill.nta [r8] = f4,32
+        stf.spill.nta [r9] = f5,32
+        mov r17 = b1
+        ;;
+        stf.spill.nta [r8] = f16,32
+        stf.spill.nta [r9] = f17,32
+        mov r18 = b2
+        ;;
+        stf.spill.nta [r8] = f18,32
+        stf.spill.nta [r9] = f19,32
+        mov r19 = b3
+        ;;
+        stf.spill.nta [r8] = f20,32
+        stf.spill.nta [r9] = f21,32
+        mov r20 = b4
+        ;;
+        stf.spill.nta [r8] = f22,32
+        stf.spill.nta [r9] = f23,32
+        mov r21 = b5
+        ;;
+        stf.spill.nta [r8] = f24,32
+        stf.spill.nta [r9] = f25,32
+        mov r22 = ar.lc
+        ;;
+        stf.spill.nta [r8] = f26,32
+        stf.spill.nta [r9] = f27,32
+        mov r24 = pr
+        ;;
+        stf.spill.nta [r8] = f28,32
+        stf.spill.nta [r9] = f29,32
+        ;;
+        stf.spill.nta [r8] = f30
+        stf.spill.nta [r9] = f31
+
+        st8.spill.nta [r2] = r6,16    // r6
+        ;;
+        st8.spill.nta [r3] = r7,16    // r7
+        ;;
+        mov r23 = ar.bsp
+        mov r25 = ar.unat
+
+        st8.nta [r2] = r15,16         // b0
+        st8.nta [r3] = r17,16         // b1
+        ;;
+        st8.nta [r2] = r18,16         // b2
+        st8.nta [r3] = r19,16         // b3
+	mov r26 = ar.rsc
+        ;;
+        st8.nta [r2] = r20,16         // b4
+        st8.nta [r3] = r21,16         // b5
+        ;;
+        st8.nta [r2] = r14,16         // ar.pfs
+        st8.nta [r3] = r22,16         // ar.lc
+        ;;
+        st8.nta [r2] = r24,16         // pr
+        st8.nta [r3] = r23,16         // ar.bsp
+        ;;
+        st8.nta [r2] = r25,16         // ar.unat
+        st8.nta [r3] = in0,16         // &amp;__jmp_buf (just in case)
+        ;;
+        st8.nta [r2] = r26            // ar.rsc
+	;;
+	flushrs                       // flush dirty regs to backing store
+        ;;
+	and r27 = ~0x3,r26            // clear ar.rsc.mode
+	;;
+	mov ar.rsc = r27              // put RSE in enforced lazy mode
+	;;
+	mov r28 = ar.rnat
+	;;
+	st8.nta [r3] = r28            // ar.rnat
+	mov ar.rsc = r26              // restore ar.rsc
+	;;
+        mov r8 = 0
+        br.ret.sptk.few b0
+        .endp _ia64_cxt_save
+
+
+/****************************************************************/
+
+        /* _ia64_cxt_restore(__jmp_buf env, int val) */
+        .global _ia64_cxt_restore
+        .proc _ia64_cxt_restore
+_ia64_cxt_restore:
+        alloc r8 = ar.pfs,2,0,0,0
+        add r2 = 0x88,in0             // r2 &lt;- &amp;jmpbuf.ar_bsp
+	mov r16 = ar.rsc
+	;;
+	flushrs                       // flush dirty regs to backing store
+        ;;
+	and r17 = ~0x3,r16            // clear ar.rsc.mode
+	;;
+	mov ar.rsc = r17              // put RSE in enforced lazy mode
+        ;;
+	invala                        // invalidate the ALAT
+	;;
+        ld8 r23 = [r2],8              // r23 &lt;- jmpbuf.ar_bsp
+        ;;
+	mov ar.bspstore = r23         // write BSPSTORE
+        ld8 r25 = [r2],24             // r25 &lt;- jmpbuf.ar_unat
+	;;
+	ld8 r26 = [r2],-8             // r26 &lt;- jmpbuf.ar_rnat
+        ;;
+	mov ar.rnat = r26             // write RNAT
+	ld8 r27 = [r2]                // r27 &lt;- jmpbuf.ar_rsc
+	;;
+	mov ar.rsc = r27              // write RSE control
+        mov r2 = in0
+	;;
+	mov ar.unat = r25             // write ar.unat
+	add r3 = 8,in0
+        ;;
+        ld8.fill.nta sp = [r2],16     // r12 (sp)
+        ld8.fill.nta gp = [r3],16     // r1  (gp)
+        ;;
+        ld8.nta r16 = [r2],16         // caller's unat
+        ld8.nta r17 = [r3],16         // fpsr
+        ;;
+        ld8.fill.nta r4 = [r2],16     // r4
+        ld8.fill.nta r5 = [r3],16     // r5
+        ;;
+        ld8.fill.nta r6 = [r2],16     // r6
+        ld8.fill.nta r7 = [r3],16     // r7
+        ;;
+        mov ar.unat = r16             // restore caller's unat
+        mov ar.fpsr = r17             // restore fpsr
+        ;;
+        ld8.nta r16 = [r2],16         // b0
+        ld8.nta r17 = [r3],16         // b1
+        ;;
+        ld8.nta r18 = [r2],16         // b2
+        ld8.nta r19 = [r3],16         // b3
+        ;;
+        ld8.nta r20 = [r2],16         // b4
+        ld8.nta r21 = [r3],16         // b5
+        ;;
+        ld8.nta r11 = [r2],16         // ar.pfs
+        ld8.nta r22 = [r3],72         // ar.lc
+        ;;
+        ld8.nta r24 = [r2],48         // pr
+        mov b0 = r16
+        ;;
+        ldf.fill.nta f2 = [r2],32
+        ldf.fill.nta f3 = [r3],32
+        mov b1 = r17
+        ;;
+        ldf.fill.nta f4 = [r2],32
+        ldf.fill.nta f5 = [r3],32
+        mov b2 = r18
+        ;;
+        ldf.fill.nta f16 = [r2],32
+        ldf.fill.nta f17 = [r3],32
+        mov b3 = r19
+        ;;
+        ldf.fill.nta f18 = [r2],32
+        ldf.fill.nta f19 = [r3],32
+        mov b4 = r20
+        ;;
+        ldf.fill.nta f20 = [r2],32
+        ldf.fill.nta f21 = [r3],32
+        mov b5 = r21
+        ;;
+        ldf.fill.nta f22 = [r2],32
+        ldf.fill.nta f23 = [r3],32
+        mov ar.lc = r22
+        ;;
+        ldf.fill.nta f24 = [r2],32
+        ldf.fill.nta f25 = [r3],32
+        cmp.eq p6,p7 = 0,in1
+        ;;
+        ldf.fill.nta f26 = [r2],32
+        ldf.fill.nta f27 = [r3],32
+        mov ar.pfs = r11
+        ;;
+        ldf.fill.nta f28 = [r2],32
+        ldf.fill.nta f29 = [r3],32
+        ;;
+        ldf.fill.nta f30 = [r2]
+        ldf.fill.nta f31 = [r3]
+(p6)    mov r8 = 1
+(p7)    mov r8 = in1
+
+        mov pr = r24,-1
+        br.ret.sptk.few b0
+        .endp _ia64_cxt_restore
+
+/****************************************************************/
+

Added: upwatch/trunk/st-1.6/io.c
===================================================================
--- upwatch/trunk/st-1.6/io.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/io.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,699 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;sys/uio.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;sys/resource.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;common.h&quot;
+
+
+#if EAGAIN != EWOULDBLOCK
+#define _IO_NOT_READY_ERROR  ((errno == EAGAIN) || (errno == EWOULDBLOCK))
+#else
+#define _IO_NOT_READY_ERROR  (errno == EAGAIN)
+#endif
+
+#define _LOCAL_MAXIOV  16
+
+/* File descriptor object free list */
+static _st_netfd_t *_st_netfd_freelist = NULL;
+/* Maximum number of file descriptors that the process can open */
+static int _st_osfd_limit = -1;
+
+static void _st_netfd_free_aux_data(_st_netfd_t *fd);
+
+int _st_io_init(void)
+{
+  struct sigaction sigact;
+  struct rlimit rlim;
+
+  /* Ignore SIGPIPE */
+  sigact.sa_handler = SIG_IGN;
+  sigemptyset(&amp;sigact.sa_mask);
+  sigact.sa_flags = 0;
+  if (sigaction(SIGPIPE, &amp;sigact, NULL) &lt; 0)
+    return -1;
+
+  /* Set maximum number of open file descriptors */
+  if (getrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; 0)
+    return -1;
+#ifndef USE_POLL
+  if (rlim.rlim_max &gt; FD_SETSIZE)
+    rlim.rlim_max = FD_SETSIZE;
+#endif
+  rlim.rlim_cur = rlim.rlim_max;
+  if (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; 0)
+    return -1;
+  _st_osfd_limit = (int) rlim.rlim_max;
+
+  return 0;
+}
+
+
+int st_getfdlimit(void)
+{
+  return _st_osfd_limit;
+}
+
+
+void st_netfd_free(_st_netfd_t *fd)
+{
+  if (!fd-&gt;inuse)
+    return;
+
+  fd-&gt;inuse = 0;
+  if (fd-&gt;aux_data)
+    _st_netfd_free_aux_data(fd);
+  if (fd-&gt;private_data &amp;&amp; fd-&gt;destructor)
+    (*(fd-&gt;destructor))(fd-&gt;private_data);
+  fd-&gt;private_data = NULL;
+  fd-&gt;destructor = NULL;
+  fd-&gt;next = _st_netfd_freelist;
+  _st_netfd_freelist = fd;
+}
+
+
+static _st_netfd_t *_st_netfd_new(int osfd, int nonblock, int is_socket)
+{
+  _st_netfd_t *fd;
+  int flags = 1;
+
+#ifndef USE_POLL
+  if (osfd &gt;= FD_SETSIZE) {
+    errno = EMFILE;
+    return NULL;
+  }
+#endif
+
+  if (_st_netfd_freelist) {
+    fd = _st_netfd_freelist;
+    _st_netfd_freelist = _st_netfd_freelist-&gt;next;
+  } else {
+    fd = calloc(1, sizeof(_st_netfd_t));
+    if (!fd)
+      return NULL;
+  }
+
+  fd-&gt;osfd = osfd;
+  fd-&gt;inuse = 1;
+  fd-&gt;next = NULL;
+
+  if (nonblock) {
+    /* Use just one system call */
+    if (is_socket &amp;&amp; ioctl(osfd, FIONBIO, &amp;flags) != -1)
+      return fd;
+    /* Do it the Posix way */
+    if ((flags = fcntl(osfd, F_GETFL, 0)) &lt; 0 ||
+	fcntl(osfd, F_SETFL, flags | O_NONBLOCK) &lt; 0) {
+      st_netfd_free(fd);
+      return NULL;
+    }
+  }
+
+  return fd;
+}
+
+
+_st_netfd_t *st_netfd_open(int osfd)
+{
+  return _st_netfd_new(osfd, 1, 0);
+}
+
+
+_st_netfd_t *st_netfd_open_socket(int osfd)
+{
+  return _st_netfd_new(osfd, 1, 1);
+}
+
+
+int st_netfd_close(_st_netfd_t *fd)
+{
+  st_netfd_free(fd);
+  return close(fd-&gt;osfd);
+}
+
+
+int st_netfd_fileno(_st_netfd_t *fd)
+{
+  return (fd-&gt;osfd);
+}
+
+
+void st_netfd_setspecific(_st_netfd_t *fd, void *value,
+			  _st_destructor_t destructor)
+{
+  if (value != fd-&gt;private_data) {
+    /* Free up previously set non-NULL data value */
+    if (fd-&gt;private_data &amp;&amp; fd-&gt;destructor)
+      (*(fd-&gt;destructor))(fd-&gt;private_data);
+  }
+  fd-&gt;private_data = value;
+  fd-&gt;destructor = destructor;
+}
+
+
+void *st_netfd_getspecific(_st_netfd_t *fd)
+{
+  return (fd-&gt;private_data);
+}
+
+
+/*
+ * Wait for I/O on a single descriptor.
+ */
+int st_netfd_poll(_st_netfd_t *fd, int how, st_utime_t timeout)
+{
+  struct pollfd pd;
+  int n;
+
+  pd.fd = fd-&gt;osfd;
+  pd.events = (short) how;
+  pd.revents = 0;
+
+  if ((n = st_poll(&amp;pd, 1, timeout)) &lt; 0)
+    return -1;
+  if (n == 0) {
+    /* Timed out */
+    errno = ETIME;
+    return -1;
+  }
+  if (pd.revents &amp; POLLNVAL) {
+    errno = EBADF;
+    return -1;
+  }
+
+  return 0;
+}
+
+
+#ifdef MD_ALWAYS_UNSERIALIZED_ACCEPT
+/* No-op */
+int st_netfd_serialize_accept(_st_netfd_t *fd)
+{
+  fd-&gt;aux_data = NULL;
+  return 0;
+}
+
+/* No-op */
+static void _st_netfd_free_aux_data(_st_netfd_t *fd)
+{
+  fd-&gt;aux_data = NULL;
+}
+
+_st_netfd_t *st_accept(_st_netfd_t *fd, struct sockaddr *addr, int *addrlen,
+		       st_utime_t timeout)
+{
+  int osfd, err;
+  _st_netfd_t *newfd;
+
+  while ((osfd = accept(fd-&gt;osfd, addr, (socklen_t *)addrlen)) &lt; 0) {
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return NULL;
+    /* Wait until the socket becomes readable */
+    if (st_netfd_poll(fd, POLLIN, timeout) &lt; 0)
+      return NULL;
+  }
+
+  /* On some platforms the new socket created by accept() inherits */
+  /* the nonblocking attribute of the listening socket */
+#if defined (MD_ACCEPT_NB_INHERITED)
+  newfd = _st_netfd_new(osfd, 0, 1);
+#elif defined (MD_ACCEPT_NB_NOT_INHERITED)
+  newfd = _st_netfd_new(osfd, 1, 1);
+#else
+#error Unknown OS
+#endif
+
+  if (!newfd) {
+    err = errno;
+    close(osfd);
+    errno = err;
+  }
+
+  return newfd;
+}
+
+#else /* MD_ALWAYS_UNSERIALIZED_ACCEPT */
+/*
+ * On some platforms accept() calls from different processes
+ * on the same listen socket must be serialized.
+ * The following code serializes accept()'s without process blocking.
+ * A pipe is used as an inter-process semaphore.
+ */
+int st_netfd_serialize_accept(_st_netfd_t *fd)
+{
+  _st_netfd_t **p;
+  int osfd[2], err;
+
+  if (fd-&gt;aux_data) {
+    errno = EINVAL;
+    return -1;
+  }
+  if ((p = (_st_netfd_t **)calloc(2, sizeof(_st_netfd_t *))) == NULL)
+    return -1;
+  if (pipe(osfd) &lt; 0) {
+    free(p);
+    return -1;
+  }
+  if ((p[0] = st_netfd_open(osfd[0])) != NULL &amp;&amp;
+      (p[1] = st_netfd_open(osfd[1])) != NULL &amp;&amp;
+      write(osfd[1], &quot; &quot;, 1) == 1) {
+    fd-&gt;aux_data = p;
+    return 0;
+  }
+  /* Error */
+  err = errno;
+  if (p[0])
+    st_netfd_free(p[0]);
+  if (p[1])
+    st_netfd_free(p[1]);
+  close(osfd[0]);
+  close(osfd[1]);
+  free(p);
+  errno = err;
+
+  return -1;
+}
+
+static void _st_netfd_free_aux_data(_st_netfd_t *fd)
+{
+  _st_netfd_t **p = (_st_netfd_t **) fd-&gt;aux_data;
+
+  st_netfd_close(p[0]);
+  st_netfd_close(p[1]);
+  free(p);
+  fd-&gt;aux_data = NULL;
+}
+
+_st_netfd_t *st_accept(_st_netfd_t *fd, struct sockaddr *addr, int *addrlen,
+		       st_utime_t timeout)
+{
+  int osfd, err;
+  _st_netfd_t *newfd;
+  _st_netfd_t **p = (_st_netfd_t **) fd-&gt;aux_data;
+  ssize_t n;
+  char c;
+
+  for ( ; ; ) {
+    if (p == NULL) {
+      osfd = accept(fd-&gt;osfd, addr, (socklen_t *)addrlen);
+    } else {
+      /* Get the lock */
+      n = st_read(p[0], &amp;c, 1, timeout);
+      if (n &lt; 0)
+	return NULL;
+      ST_ASSERT(n == 1);
+      /* Got the lock */
+      osfd = accept(fd-&gt;osfd, addr, (socklen_t *)addrlen);
+      /* Unlock */
+      err = errno;
+      n = st_write(p[1], &amp;c, 1, timeout);
+      ST_ASSERT(n == 1);
+      errno = err;
+    }
+    if (osfd &gt;= 0)
+      break;
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return NULL;
+    /* Wait until the socket becomes readable */
+    if (st_netfd_poll(fd, POLLIN, timeout) &lt; 0)
+      return NULL;
+  }
+
+  /* On some platforms the new socket created by accept() inherits */
+  /* the nonblocking attribute of the listening socket */
+#if defined (MD_ACCEPT_NB_INHERITED)
+  newfd = _st_netfd_new(osfd, 0, 1);
+#elif defined (MD_ACCEPT_NB_NOT_INHERITED)
+  newfd = _st_netfd_new(osfd, 1, 1);
+#else
+#error Unknown OS
+#endif
+
+  if (!newfd) {
+    err = errno;
+    close(osfd);
+    errno = err;
+  }
+
+  return newfd;
+}
+#endif /* MD_ALWAYS_UNSERIALIZED_ACCEPT */
+
+
+int st_connect(_st_netfd_t *fd, const struct sockaddr *addr, int addrlen,
+	       st_utime_t timeout)
+{
+  int n, err = 0;
+
+  while (connect(fd-&gt;osfd, addr, addrlen) &lt; 0) {
+    if (errno != EINTR) {
+      /*
+       * On some platforms, if connect() is interrupted (errno == EINTR)
+       * after the kernel binds the socket, a subsequent connect()
+       * attempt will fail with errno == EADDRINUSE.  Ignore EADDRINUSE
+       * iff connect() was previously interrupted.  See Rich Stevens'
+       * &quot;UNIX Network Programming,&quot; Vol. 1, 2nd edition, p. 413
+       * (&quot;Interrupted connect&quot;).
+       */
+      if (errno != EINPROGRESS &amp;&amp; (errno != EADDRINUSE || err == 0))
+	return -1;
+      /* Wait until the socket becomes writable */
+      if (st_netfd_poll(fd, POLLOUT, timeout) &lt; 0)
+	return -1;
+      /* Try to find out whether the connection setup succeeded or failed */
+      n = sizeof(int);
+      if (getsockopt(fd-&gt;osfd, SOL_SOCKET, SO_ERROR, (char *)&amp;err,
+		     (socklen_t *)&amp;n) &lt; 0)
+	return -1;
+      if (err) {
+	errno = err;
+	return -1;
+      }
+      break;
+    }
+    err = 1;
+  }
+
+  return 0;
+}
+
+
+ssize_t st_read(_st_netfd_t *fd, void *buf, size_t nbyte, st_utime_t timeout)
+{
+  ssize_t n;
+
+  while ((n = read(fd-&gt;osfd, buf, nbyte)) &lt; 0) {
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return -1;
+    /* Wait until the socket becomes readable */
+    if (st_netfd_poll(fd, POLLIN, timeout) &lt; 0)
+      return -1;
+  }
+
+  return n;
+}
+
+
+int st_read_resid(_st_netfd_t *fd, void *buf, size_t *resid,
+		  st_utime_t timeout)
+{
+  ssize_t n;
+
+  while (*resid &gt; 0) {
+    if ((n = read(fd-&gt;osfd, buf, *resid)) &lt; 0) {
+      if (errno == EINTR)
+	continue;
+      if (!_IO_NOT_READY_ERROR)
+	return -1;
+    } else {
+      *resid -= n;
+      if (*resid == 0 || n == 0)
+	break;
+      buf = (void *)((char *)buf + n);
+    }
+    /* Wait until the socket becomes readable */
+    if (st_netfd_poll(fd, POLLIN, timeout) &lt; 0)
+      return -1;
+  }
+
+  return 0;
+}
+
+
+ssize_t st_read_fully(_st_netfd_t *fd, void *buf, size_t nbyte,
+		      st_utime_t timeout)
+{
+  size_t resid = nbyte;
+  return st_read_resid(fd, buf, &amp;resid, timeout) == 0 ?
+    (ssize_t) (nbyte - resid) : -1;
+}
+
+
+int st_write_resid(_st_netfd_t *fd, const void *buf, size_t *resid,
+		   st_utime_t timeout)
+{
+  ssize_t n;
+
+  while (*resid &gt; 0) {
+    if ((n = write(fd-&gt;osfd, buf, *resid)) &lt; 0) {
+      if (errno == EINTR)
+	continue;
+      if (!_IO_NOT_READY_ERROR)
+	return -1;
+    } else {
+      *resid -= n;
+      if (*resid == 0)
+	break;
+      buf = (const void *)((const char *)buf + n);
+    }
+    /* Wait until the socket becomes writable */
+    if (st_netfd_poll(fd, POLLOUT, timeout) &lt; 0)
+      return -1;
+  }
+
+  return 0;
+}
+
+
+ssize_t st_write(_st_netfd_t *fd, const void *buf, size_t nbyte,
+		 st_utime_t timeout)
+{
+  size_t resid = nbyte;
+  return st_write_resid(fd, buf, &amp;resid, timeout) == 0 ?
+    (ssize_t) (nbyte - resid) : -1;
+}
+
+
+ssize_t st_writev(_st_netfd_t *fd, const struct iovec *iov, int iov_size,
+		  st_utime_t timeout)
+{
+  ssize_t n, rv;
+  size_t nleft, nbyte;
+  int index, iov_cnt;
+  struct iovec *tmp_iov;
+  struct iovec local_iov[_LOCAL_MAXIOV];
+
+  /* Calculate the total number of bytes to be sent */
+  nbyte = 0;
+  for (index = 0; index &lt; iov_size; index++)
+    nbyte += iov[index].iov_len;
+
+  rv = (ssize_t)nbyte;
+  nleft = nbyte;
+  tmp_iov = (struct iovec *) iov;	/* we promise not to modify iov */
+  iov_cnt = iov_size;
+
+  while (nleft &gt; 0) {
+    if (iov_cnt == 1) {
+      if (st_write(fd, tmp_iov[0].iov_base, nleft, timeout) != nleft)
+	rv = -1;
+      break;
+    }
+    if ((n = writev(fd-&gt;osfd, tmp_iov, iov_cnt)) &lt; 0) {
+      if (errno == EINTR)
+	continue;
+      if (!_IO_NOT_READY_ERROR) {
+	rv = -1;
+	break;
+      }
+    } else {
+      if (n == nleft)
+	break;
+      nleft -= n;
+      /* Find the next unwritten vector */
+      n = (ssize_t)(nbyte - nleft);
+      for (index = 0; n &gt;= iov[index].iov_len; index++)
+	n -= iov[index].iov_len;
+
+      if (tmp_iov == iov) {
+	/* Must copy iov's around */
+	if (iov_size - index &lt;= _LOCAL_MAXIOV) {
+	  tmp_iov = local_iov;
+	} else {
+	  tmp_iov = calloc(1, (iov_size - index) * sizeof(struct iovec));
+	  if (tmp_iov == NULL)
+	    return -1;
+	}
+      }
+
+      /* Fill in the first partial read */
+      tmp_iov[0].iov_base = &amp;(((char *)iov[index].iov_base)[n]);
+      tmp_iov[0].iov_len = iov[index].iov_len - n;
+      index++;
+      /* Copy the remaining vectors */
+      for (iov_cnt = 1; index &lt; iov_size; iov_cnt++, index++) {
+	tmp_iov[iov_cnt].iov_base = iov[index].iov_base;
+	tmp_iov[iov_cnt].iov_len = iov[index].iov_len;
+      }
+    }
+    /* Wait until the socket becomes writable */
+    if (st_netfd_poll(fd, POLLOUT, timeout) &lt; 0) {
+      rv = -1;
+      break;
+    }
+  }
+
+  if (tmp_iov != iov &amp;&amp; tmp_iov != local_iov)
+    free(tmp_iov);
+
+  return rv;
+}
+
+
+/*
+ * Simple I/O functions for UDP.
+ */
+int st_recvfrom(_st_netfd_t *fd, void *buf, int len, struct sockaddr *from,
+		int *fromlen, st_utime_t timeout)
+{
+  int n;
+
+  while ((n = recvfrom(fd-&gt;osfd, buf, len, 0, from, (socklen_t *)fromlen))
+	 &lt; 0) {
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return -1;
+    /* Wait until the socket becomes readable */
+    if (st_netfd_poll(fd, POLLIN, timeout) &lt; 0)
+      return -1;
+  }
+
+  return n;
+}
+
+
+int st_sendto(_st_netfd_t *fd, const void *msg, int len,
+	      const struct sockaddr *to, int tolen, st_utime_t timeout)
+{
+  int n;
+
+  while ((n = sendto(fd-&gt;osfd, msg, len, 0, to, tolen)) &lt; 0) {
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return -1;
+    /* Wait until the socket becomes writable */
+    if (st_netfd_poll(fd, POLLOUT, timeout) &lt; 0)
+      return -1;
+  }
+
+  return n;
+}
+
+
+int st_recvmsg(_st_netfd_t *fd, struct msghdr *msg, int flags,
+	       st_utime_t timeout)
+{
+  int n;
+
+  while ((n = recvmsg(fd-&gt;osfd, msg, flags)) &lt; 0) {
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return -1;
+    /* Wait until the socket becomes readable */
+    if (st_netfd_poll(fd, POLLIN, timeout) &lt; 0)
+      return -1;
+  }
+
+  return n;
+}
+
+
+int st_sendmsg(_st_netfd_t *fd, const struct msghdr *msg, int flags,
+	       st_utime_t timeout)
+{
+  int n;
+
+  while ((n = sendmsg(fd-&gt;osfd, msg, flags)) &lt; 0) {
+    if (errno == EINTR)
+      continue;
+    if (!_IO_NOT_READY_ERROR)
+      return -1;
+    /* Wait until the socket becomes writable */
+    if (st_netfd_poll(fd, POLLOUT, timeout) &lt; 0)
+      return -1;
+  }
+
+  return n;
+}
+
+
+
+/*
+ * To open FIFOs or other special files.
+ */
+_st_netfd_t *st_open(const char *path, int oflags, mode_t mode)
+{
+  int osfd, err;
+  _st_netfd_t *newfd;
+
+  while ((osfd = open(path, oflags | O_NONBLOCK, mode)) &lt; 0) {
+    if (errno != EINTR)
+      return NULL;
+  }
+
+  newfd = _st_netfd_new(osfd, 0, 0);
+  if (!newfd) {
+    err = errno;
+    close(osfd);
+    errno = err;
+  }
+
+  return newfd;
+}
+

Added: upwatch/trunk/st-1.6/key.c
===================================================================
--- upwatch/trunk/st-1.6/key.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/key.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,121 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;common.h&quot;
+
+
+/*
+ * Destructor table for per-thread private data
+ */
+static _st_destructor_t _st_destructors[ST_KEYS_MAX];
+static int key_max = 0;
+
+
+/*
+ * Return a key to be used for thread specific data
+ */
+int st_key_create(int *keyp, _st_destructor_t destructor)
+{
+  if (key_max &gt;= ST_KEYS_MAX) {
+    errno = EAGAIN;
+    return -1;
+  }
+
+  *keyp = key_max++;
+  _st_destructors[*keyp] = destructor;
+
+  return 0;
+}
+
+
+int st_key_getlimit(void)
+{
+  return ST_KEYS_MAX;
+}
+
+
+int st_thread_setspecific(int key, void *value)
+{
+  _st_thread_t *me = _ST_CURRENT_THREAD();
+
+  if (key &lt; 0 || key &gt;= key_max) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  if (value != me-&gt;private_data[key]) {
+    /* free up previously set non-NULL data value */
+    if (me-&gt;private_data[key] &amp;&amp; _st_destructors[key]) {
+      (*_st_destructors[key])(me-&gt;private_data[key]);
+    }
+    me-&gt;private_data[key] = value;
+  }
+
+  return 0;
+}
+
+
+void *st_thread_getspecific(int key)
+{
+  if (key &lt; 0 || key &gt;= key_max)
+    return NULL;
+
+  return ((_ST_CURRENT_THREAD())-&gt;private_data[key]);
+}
+
+
+/*
+ * Free up all per-thread private data
+ */
+void _st_thread_cleanup(_st_thread_t *thread)
+{
+  int key;
+
+  for (key = 0; key &lt; key_max; key++) {
+    if (thread-&gt;private_data[key] &amp;&amp; _st_destructors[key]) {
+      (*_st_destructors[key])(thread-&gt;private_data[key]);
+      thread-&gt;private_data[key] = NULL;
+    }
+  }
+}
+

Added: upwatch/trunk/st-1.6/libst.def
===================================================================
--- upwatch/trunk/st-1.6/libst.def	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/libst.def	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,51 @@
+EXPORTS
+    st_accept @62
+    st_cond_broadcast @63
+    st_cond_destroy @64
+    st_cond_new @65
+    st_cond_signal @66
+    st_cond_timedwait @67
+    st_cond_wait @68
+    st_connect @69
+    st_getfdlimit @70
+    st_init @71
+    st_key_create @72
+    st_key_getlimit @73
+    st_mutex_destroy @74
+    st_mutex_lock @75
+    st_mutex_new @76
+    st_mutex_trylock @77
+    st_mutex_unlock @78
+    st_netfd_close @79
+    st_netfd_fileno @80
+    st_netfd_free @81
+    st_netfd_getspecific @82
+    st_netfd_open @83
+    st_netfd_open_socket @84
+    st_netfd_poll @85
+    st_netfd_serialize_accept @86
+    st_netfd_setspecific @87
+    st_open @88
+    st_poll @89
+    st_randomize_stacks @90
+    st_read @91
+    st_read_fully @92
+    st_read_resid @93
+    st_recvfrom @94
+    st_sendto @95
+    st_sleep @96
+    st_thread_create @97
+    st_thread_exit @98
+    st_thread_getspecific @99
+    st_thread_interrupt @100
+    st_thread_join @101
+    st_thread_self @102
+    st_thread_setspecific @103
+    st_time @104
+    st_timecache_set @105
+    st_usleep @106
+    st_utime @107
+    st_utime_last_clock @108
+    st_write @109
+    st_write_resid @110
+    st_writev @111

Added: upwatch/trunk/st-1.6/md.h
===================================================================
--- upwatch/trunk/st-1.6/md.h	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/md.h	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,585 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#ifndef __ST_MD_H__
+#define __ST_MD_H__
+
+#if defined(ETIMEDOUT) &amp;&amp; !defined(ETIME)
+#define ETIME ETIMEDOUT
+#endif
+
+#if defined(MAP_ANONYMOUS) &amp;&amp; !defined(MAP_ANON)
+#define MAP_ANON MAP_ANONYMOUS
+#endif
+
+#ifndef MAP_FAILED
+#define MAP_FAILED -1
+#endif
+
+/*****************************************
+ * Platform specifics
+ */
+
+#if defined (AIX)
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_SYSV_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#ifndef MD_HAVE_SOCKLEN_T
+#define MD_HAVE_SOCKLEN_T
+#define socklen_t unsigned long
+#endif
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main) \
+  ST_BEGIN_MACRO                             \
+  if (MD_SETJMP((_thread)-&gt;context))         \
+    _main();                                 \
+  (_thread)-&gt;context[3] = (long) (_sp);      \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()                        \
+  timebasestruct_t rt;                        \
+  (void) read_real_time(&amp;rt, TIMEBASE_SZ);    \
+  (void) time_base_to_time(&amp;rt, TIMEBASE_SZ); \
+  return (rt.tb_high * 1000000LL + rt.tb_low / 1000)
+
+#elif defined (CYGWIN)
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_NOT_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) setjmp(env)
+#define MD_LONGJMP(env, val) longjmp(env, val)
+
+#define MD_JB_SP  7
+
+#define MD_GET_SP(_t) (_t)-&gt;context[MD_JB_SP]
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main) \
+  ST_BEGIN_MACRO                             \
+  if (MD_SETJMP((_thread)-&gt;context))         \
+    _main();                                 \
+  MD_GET_SP(_thread) = (long) (_sp);         \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (DARWIN)
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#if defined(__ppc__)
+#define MD_JB_SP  0
+#else
+#error Unknown CPU architecture
+#endif
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main)   \
+  ST_BEGIN_MACRO                               \
+  if (MD_SETJMP((_thread)-&gt;context))           \
+    _main();                                   \
+  (_thread)-&gt;context[MD_JB_SP] = (long) (_sp); \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (FREEBSD)
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#if defined(__i386__)
+#define MD_JB_SP   2
+#elif defined(__alpha__)
+#define MD_JB_SP  34
+#elif defined(__amd64__)
+#define MD_JB_SP   2
+#else
+#error Unknown CPU architecture
+#endif
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main)          \
+  ST_BEGIN_MACRO                                      \
+  if (MD_SETJMP((_thread)-&gt;context))                  \
+    _main();                                          \
+  (_thread)-&gt;context[0]._jb[MD_JB_SP] = (long) (_sp); \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (HPUX)
+
+#define MD_STACK_GROWS_UP
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#ifndef __LP64__
+/* 32-bit mode (ILP32 data model) */
+#define MD_INIT_CONTEXT(_thread, _sp, _main)        \
+  ST_BEGIN_MACRO                                    \
+  if (MD_SETJMP((_thread)-&gt;context))                \
+    _main();                                        \
+  ((long *)((_thread)-&gt;context))[1] = (long) (_sp); \
+  ST_END_MACRO
+#else
+/* 64-bit mode (LP64 data model) */
+#define MD_STACK_PAD_SIZE 256
+/* Last stack frame must be preserved */
+#define MD_INIT_CONTEXT(_thread, _sp, _main)                     \
+  ST_BEGIN_MACRO                                                 \
+  if (MD_SETJMP((_thread)-&gt;context))                             \
+    _main();                                                     \
+  memcpy((char *)(_sp) - MD_STACK_PAD_SIZE,                      \
+         ((char **)((_thread)-&gt;context))[1] - MD_STACK_PAD_SIZE, \
+         MD_STACK_PAD_SIZE);                                     \
+  ((long *)((_thread)-&gt;context))[1] = (long) (_sp);              \
+  ST_END_MACRO
+#endif /* !__LP64__ */
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (IRIX)
+
+#include &lt;sys/syssgi.h&gt;
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_SYSV_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) setjmp(env)
+#define MD_LONGJMP(env, val) longjmp(env, val)
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main) \
+  ST_BEGIN_MACRO                             \
+  (void) MD_SETJMP((_thread)-&gt;context);      \
+  (_thread)-&gt;context[JB_SP] = (long) (_sp);  \
+  (_thread)-&gt;context[JB_PC] = (long) _main;  \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()                         \
+  static int inited = 0;                       \
+  static clockid_t clock_id = CLOCK_SGI_CYCLE; \
+  struct timespec ts;                          \
+  if (!inited) {                               \
+    if (syssgi(SGI_CYCLECNTR_SIZE) &lt; 64)       \
+      clock_id = CLOCK_REALTIME;               \
+    inited = 1;                                \
+  }                                            \
+  (void) clock_gettime(clock_id, &amp;ts);         \
+  return (ts.tv_sec * 1000000LL + ts.tv_nsec / 1000)
+
+/*
+ * Cap the stack by zeroing out the saved return address register
+ * value. This allows libexc, used by SpeedShop, to know when to stop
+ * backtracing since it won't find main, start, or any other known
+ * stack root function in a state thread's stack. Without this libexc
+ * traces right off the stack and crashes.
+ * The function preamble stores ra at 8(sp), this stores zero there.
+ * N.B. This macro is compiler/ABI dependent. It must change if ANY more
+ * automatic variables are added to the _st_thread_main() routine, because
+ * the address where ra is stored will change.
+ */
+#if !defined(__GNUC__) &amp;&amp; defined(_MIPS_SIM) &amp;&amp; _MIPS_SIM != _ABIO32
+#define MD_CAP_STACK(var_addr) \
+  (((volatile __uint64_t *)(var_addr))[1] = 0)
+#endif
+
+#elif defined (LINUX)
+
+/*
+ * These are properties of the linux kernel and are the same on every
+ * flavor and architecture.
+ */
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_NOT_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+/*
+ * All architectures and flavors of linux have the gettimeofday
+ * function but if you know of a faster way, use it.
+ */
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#if defined(__ia64__)
+#define MD_STACK_GROWS_DOWN
+
+/*
+ * IA-64 architecture.  Besides traditional memory call stack, IA-64
+ * uses general register stack.  Thus each thread needs a backing store
+ * for register stack in addition to memory stack.  Standard
+ * setjmp()/longjmp() cannot be used for thread context switching
+ * because their implementation implicitly assumes that only one
+ * register stack exists.
+ */
+#define MD_SETJMP(env) _ia64_cxt_save(env)
+#define MD_LONGJMP(env, val) _ia64_cxt_restore(env, val)
+
+extern int _ia64_cxt_save(jmp_buf env);
+extern void _ia64_cxt_restore(jmp_buf env, int val);
+
+#define MD_STACK_PAD_SIZE 128
+/* Last register stack frame must be preserved */
+#define MD_INIT_CONTEXT(_thread, _sp, _bsp, _main)                       \
+  ST_BEGIN_MACRO                                                         \
+  if (MD_SETJMP((_thread)-&gt;context))                                     \
+    _main();                                                             \
+  memcpy((char *)(_bsp) - MD_STACK_PAD_SIZE,                             \
+         (char *)(_thread)-&gt;context[0].__jmpbuf[17] - MD_STACK_PAD_SIZE, \
+         MD_STACK_PAD_SIZE);                                             \
+  (_thread)-&gt;context[0].__jmpbuf[0]  = (long) (_sp);                     \
+  (_thread)-&gt;context[0].__jmpbuf[17] = (long) (_bsp);                    \
+  ST_END_MACRO
+
+#elif defined(__mips__)
+#define MD_STACK_GROWS_DOWN
+
+#define MD_SETJMP(env) setjmp(env)
+#define MD_LONGJMP(env, val) longjmp(env, val)
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main)               \
+  ST_BEGIN_MACRO                                           \
+  MD_SETJMP((_thread)-&gt;context);                           \
+  _thread-&gt;context[0].__jmpbuf[0].__pc = (__ptr_t) _main;  \
+  _thread-&gt;context[0].__jmpbuf[0].__sp = _sp;              \
+  ST_END_MACRO
+  
+#else /* Not IA-64 or mips everyone else just uses setjmp/longjmp */
+
+/*
+ * On linux, there are a few styles of jmpbuf format.  These vary based
+ * on architecture/glibc combination.
+ */
+ 
+/*
+ * However, all of these architectures will be using setjmp/longjmp.
+ */
+#define MD_SETJMP(env) setjmp(env)
+#define MD_LONGJMP(env, val) longjmp(env, val)
+ 
+/*
+ * Most of the glibc based toggles were lifted from:
+ * mozilla/nsprpub/pr/include/md/_linux.h
+ */
+
+#if defined(__powerpc__)
+#define MD_STACK_GROWS_DOWN
+
+#if (__GLIBC__ &gt; 2) || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 1)
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[JB_GPR1]   
+#else
+/* not an error but certainly cause for caution */
+#error &quot;Untested use of old glibc on powerpc&quot;
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[0].__misc[0]
+#endif /* glibc 2.1 or later */
+
+#elif defined(__alpha)
+#define MD_STACK_GROWS_DOWN
+
+#if defined(__GLIBC__) &amp;&amp; __GLIBC__ &gt;= 2
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[JB_SP]
+#else
+/* not an error but certainly cause for caution */
+#error &quot;Untested use of old glibc on alpha&quot;
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[0].__sp
+#endif
+
+#elif defined(__mc68000__)
+#define MD_STACK_GROWS_DOWN
+
+/* m68k still uses old style sigjmp_buf */
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[0].__sp
+
+#elif defined(__sparc__)
+#define MD_STACK_GROWS_DOWN
+
+#if defined(__GLIBC__) &amp;&amp; __GLIBC__ &gt;= 2
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[JB_SP]
+#else
+/* not an error but certainly cause for caution */
+#error &quot;Untested use of old glic on sparc -- also using odd mozilla derived __fp&quot;
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[0].__fp
+#endif
+
+#elif defined(__i386__)
+#define MD_STACK_GROWS_DOWN
+
+#if defined(__GLIBC__) &amp;&amp; __GLIBC__ &gt;= 2
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[JB_SP]
+#else
+/* not an error but certainly cause for caution */
+#error &quot;Untested use of old glibc on i386&quot;
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[0].__sp
+#endif
+
+#elif defined(__amd64__)
+#define MD_STACK_GROWS_DOWN
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[JB_RSP]
+
+#elif defined(__arm__)
+#define MD_STACK_GROWS_DOWN
+
+#if defined(__GLIBC__) &amp;&amp; __GLIBC__ &gt;= 2
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[20]
+#else
+#error &quot;ARM/Linux pre-glibc2 not supported yet&quot;
+#endif /* defined(__GLIBC__) &amp;&amp; __GLIBC__ &gt;= 2 */
+
+#elif defined(__s390__)
+#define MD_STACK_GROWS_DOWN
+
+/* There is no JB_SP in glibc at this time. (glibc 2.2.5)
+ */
+#define MD_GET_SP(_t) (_t)-&gt;context[0].__jmpbuf[0].__gregs[9]
+
+#elif defined(__hppa__)
+#define MD_STACK_GROWS_UP
+
+/* yes, this is gross, unfortunately at the moment (2002/08/01) there is
+ * a bug in hppa's glibc header definition for JB_SP, so we can't
+ * use that...
+ */
+#define MD_GET_SP(_t) (*(long *)(((char *)&amp;(_t)-&gt;context[0].__jmpbuf[0]) + 76))
+
+#else
+#error &quot;Unknown CPU architecture&quot;
+#endif /* Cases with common MD_INIT_CONTEXT and different SP locations */
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main) \
+  ST_BEGIN_MACRO                             \
+  if (MD_SETJMP((_thread)-&gt;context))         \
+    _main();                                 \
+  MD_GET_SP(_thread) = (long) (_sp);         \
+  ST_END_MACRO
+
+#endif /* Cases with different MD_INIT_CONTEXT */
+
+#elif defined (NETBSD)
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+#define MD_HAVE_SOCKLEN_T
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#if defined(__i386__)
+#define MD_JB_SP   2
+#elif defined(__alpha__)
+#define MD_JB_SP  34
+#elif defined(__sparc__)
+#define MD_JB_SP   0
+#elif defined(__vax__)
+#define MD_JB_SP   2
+#else
+#error Unknown CPU architecture
+#endif
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main)   \
+  ST_BEGIN_MACRO                               \
+  if (MD_SETJMP((_thread)-&gt;context))           \
+    _main();                                   \
+  (_thread)-&gt;context[MD_JB_SP] = (long) (_sp); \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (OPENBSD)
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_BSD_ANON_MMAP
+#define MD_ACCEPT_NB_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#if defined(__i386__)
+#define MD_JB_SP   2
+#elif defined(__alpha__)
+#define MD_JB_SP  34
+#elif defined(__sparc__)
+#define MD_JB_SP   0
+#elif defined(__amd64__)
+#define MD_JB_SP   6
+#else
+#error Unknown CPU architecture
+#endif
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main)   \
+  ST_BEGIN_MACRO                               \
+  if (MD_SETJMP((_thread)-&gt;context))           \
+    _main();                                   \
+  (_thread)-&gt;context[MD_JB_SP] = (long) (_sp); \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (OSF1)
+
+#include &lt;signal.h&gt;
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_SYSV_ANON_MMAP
+#define MD_ACCEPT_NB_NOT_INHERITED
+#define MD_ALWAYS_UNSERIALIZED_ACCEPT
+
+#define MD_SETJMP(env) _setjmp(env)
+#define MD_LONGJMP(env, val) _longjmp(env, val)
+
+#define MD_INIT_CONTEXT(_thread, _sp, _main)                         \
+  ST_BEGIN_MACRO                                                     \
+  if (MD_SETJMP((_thread)-&gt;context))                                 \
+    _main();                                                         \
+  ((struct sigcontext *)((_thread)-&gt;context))-&gt;sc_sp = (long) (_sp); \
+  ST_END_MACRO
+
+#define MD_GET_UTIME()            \
+  struct timeval tv;              \
+  (void) gettimeofday(&amp;tv, NULL); \
+  return (tv.tv_sec * 1000000LL + tv.tv_usec)
+
+#elif defined (SOLARIS)
+
+#include &lt;sys/filio.h&gt;
+extern int getpagesize(void);
+
+#define MD_STACK_GROWS_DOWN
+#define MD_USE_SYSV_ANON_MMAP
+#define MD_ACCEPT_NB_NOT_INHERITED
+
+#define MD_SETJMP(env) setjmp(env)
+#define MD_LONGJMP(env, val) longjmp(env, val)
+
+#if defined(sparc) || defined(__sparc)
+#ifdef _LP64
+#define MD_STACK_PAD_SIZE 4095
+#endif
+#define MD_INIT_CONTEXT(_thread, _sp, _main) \
+  ST_BEGIN_MACRO                             \
+  (void) MD_SETJMP((_thread)-&gt;context);      \
+  (_thread)-&gt;context[1] = (long) (_sp);      \
+  (_thread)-&gt;context[2] = (long) _main;      \
+  ST_END_MACRO
+#elif defined(i386) || defined(__i386)
+#define MD_INIT_CONTEXT(_thread, _sp, _main) \
+  ST_BEGIN_MACRO                             \
+  (void) MD_SETJMP((_thread)-&gt;context);      \
+  (_thread)-&gt;context[4] = (long) (_sp);      \
+  (_thread)-&gt;context[5] = (long) _main;      \
+  ST_END_MACRO
+#elif defined(__amd64__)
+#define MD_INIT_CONTEXT(_thread, _sp, _main)   \
+  ST_BEGIN_MACRO                               \
+  if (MD_SETJMP((_thread)-&gt;context))           \
+    _main();                                   \
+  (_thread)-&gt;context[6] = (long) (_sp); \
+  ST_END_MACRO
+#else
+#error Unknown CPU architecture
+#endif
+
+#define MD_GET_UTIME() \
+  return (gethrtime() / 1000)
+
+#else
+#error Unknown OS
+#endif /* OS */
+
+#ifndef MD_STACK_PAD_SIZE
+#define MD_STACK_PAD_SIZE 128
+#endif
+
+#if !defined(MD_HAVE_SOCKLEN_T) &amp;&amp; !defined(socklen_t)
+#define socklen_t int
+#endif
+
+#ifndef MD_CAP_STACK
+#define MD_CAP_STACK(var_addr)
+#endif
+
+#endif /* !__ST_MD_H__ */
+

Added: upwatch/trunk/st-1.6/osguess.sh
===================================================================
--- upwatch/trunk/st-1.6/osguess.sh	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/osguess.sh	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,46 @@
+#
+# This script can be used to automatically guess target OS.
+# It requires the config.guess utility which is a part of GNU Autoconf.
+# GNU Autoconf can be downloaded from <A HREF="ftp://ftp.gnu.org/gnu/autoconf/">ftp://ftp.gnu.org/gnu/autoconf/</A>
+#
+# Use &quot;default&quot; as a make target for automatic builds.
+#
+
+
+# Specify path to the config.guess utility (unless set via environment)
+#CONFIG_GUESS_PATH=
+
+
+if [ x&quot;$CONFIG_GUESS_PATH&quot; = x ]; then
+  echo &quot;Error: CONFIG_GUESS_PATH variable is not set&quot;
+  exit 1
+fi
+
+if [ ! -f &quot;$CONFIG_GUESS_PATH/config.guess&quot; ]; then
+  echo &quot;Can't find $CONFIG_GUESS_PATH/config.guess utility. Wrong path?&quot;
+  exit 1
+fi
+
+sys_info=`/bin/sh $CONFIG_GUESS_PATH/config.guess`
+
+echo &quot;Building for $sys_info&quot;
+
+case &quot;$sys_info&quot; in
+  *-ibm-aix4*     ) OS=AIX        ;;
+  *-freebsd*      ) OS=FREEBSD    ;;
+  hppa*-hp-hpux11*) OS=HPUX       ;;
+  *-sgi-irix6*    ) OS=IRIX       ;;
+  ia64-*-linux*   ) OS=LINUX_IA64 ;;
+  *-linux*        ) OS=LINUX      ;;
+  *-netbsd*       ) OS=NETBSD     ;;
+  *-openbsd*      ) OS=OPENBSD    ;;
+  *-dec-osf*      ) OS=OSF1       ;;
+  *-solaris2*     ) OS=SOLARIS    ;;
+  *-darwin*       ) OS=DARWIN     ;;
+  *               ) OS=
+                    echo &quot;Sorry, unsupported OS&quot;
+                    exit 1        ;;
+esac
+
+echo &quot;Making with OS=$OS&quot;
+

Added: upwatch/trunk/st-1.6/public.h
===================================================================
--- upwatch/trunk/st-1.6/public.h	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/public.h	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,183 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+#ifndef __ST_THREAD_H__
+#define __ST_THREAD_H__
+
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/uio.h&gt;
+#include &lt;time.h&gt;
+#include &lt;errno.h&gt;
+
+/* Undefine this to remove the context switch callback feature. */
+#define ST_SWITCH_CB
+
+#if defined(__MACH__) &amp;&amp; defined(__APPLE__)
+struct pollfd
+{
+	int fd;
+	short events;
+	short revents;
+};
+
+#define POLLIN          0x0001          /* fd is readable */
+#define POLLPRI         0x0002          /* high priority info at fd */
+#define POLLOUT         0x0004          /* fd is writeable (won't block) */
+#define POLLRDNORM      0x0040          /* normal data is readable */
+#define POLLWRNORM      POLLOUT
+#define POLLRDBAND      0x0080          /* out-of-band data is readable */
+#define POLLWRBAND      0x0100          /* out-of-band data is writeable */
+
+#define POLLNORM        POLLRDNORM
+
+#define POLLERR         0x0008          /* fd has error condition */
+#define POLLHUP         0x0010          /* fd has been hung up on */
+#define POLLNVAL        0x0020          /* invalid pollfd entry */
+
+#define POLLREMOVE      0x0800  /* remove a cached poll fd from /dev/poll */
+
+#else
+#include &lt;poll.h&gt;
+#endif
+
+#ifndef ETIME
+#define ETIME ETIMEDOUT
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef unsigned long long  st_utime_t;
+typedef struct _st_thread * st_thread_t;
+typedef struct _st_cond *   st_cond_t;
+typedef struct _st_mutex *  st_mutex_t;
+typedef struct _st_netfd *  st_netfd_t;
+#ifdef ST_SWITCH_CB
+typedef void (*st_switch_cb_t)(void);
+#endif
+
+extern int st_init(void);
+extern int st_getfdlimit(void);
+#ifdef ST_SWITCH_CB
+extern st_switch_cb_t st_set_switch_in_cb(st_switch_cb_t cb);
+extern st_switch_cb_t st_set_switch_out_cb(st_switch_cb_t cb);
+#endif
+
+extern st_thread_t st_thread_self(void);
+extern void st_thread_exit(void *retval);
+extern int st_thread_join(st_thread_t thread, void **retvalp);
+extern void st_thread_interrupt(st_thread_t thread);
+extern st_thread_t st_thread_create(void *(*start)(void *arg), void *arg,
+				    int joinable, int stack_size);
+extern int st_randomize_stacks(int on);
+extern int st_set_utime_function(st_utime_t (*func)(void));
+
+extern st_utime_t st_utime(void);
+extern st_utime_t st_utime_last_clock(void);
+extern int st_timecache_set(int on);
+extern time_t st_time(void);
+extern int st_usleep(st_utime_t usecs);
+extern int st_sleep(int secs);
+extern st_cond_t st_cond_new(void);
+extern int st_cond_destroy(st_cond_t cvar);
+extern int st_cond_timedwait(st_cond_t cvar, st_utime_t timeout);
+extern int st_cond_wait(st_cond_t cvar);
+extern int st_cond_signal(st_cond_t cvar);
+extern int st_cond_broadcast(st_cond_t cvar);
+extern st_mutex_t st_mutex_new(void);
+extern int st_mutex_destroy(st_mutex_t lock);
+extern int st_mutex_lock(st_mutex_t lock);
+extern int st_mutex_unlock(st_mutex_t lock);
+extern int st_mutex_trylock(st_mutex_t lock);
+
+extern int st_key_create(int *keyp, void (*destructor)(void *));
+extern int st_key_getlimit(void);
+extern int st_thread_setspecific(int key, void *value);
+extern void *st_thread_getspecific(int key);
+
+extern st_netfd_t st_netfd_open(int osfd);
+extern st_netfd_t st_netfd_open_socket(int osfd);
+extern void st_netfd_free(st_netfd_t fd);
+extern int st_netfd_close(st_netfd_t fd);
+extern int st_netfd_fileno(st_netfd_t fd);
+extern void st_netfd_setspecific(st_netfd_t fd, void *value,
+				 void (*destructor)(void *));
+extern void *st_netfd_getspecific(st_netfd_t fd);
+extern int st_netfd_serialize_accept(st_netfd_t fd);
+extern int st_netfd_poll(st_netfd_t fd, int how, st_utime_t timeout);
+
+extern int st_poll(struct pollfd *pds, int npds, st_utime_t timeout);
+extern st_netfd_t st_accept(st_netfd_t fd, struct sockaddr *addr, int *addrlen,
+			    st_utime_t timeout);
+extern int st_connect(st_netfd_t fd, const struct sockaddr *addr, int addrlen,
+		      st_utime_t timeout);
+extern ssize_t st_read(st_netfd_t fd, void *buf, size_t nbyte,
+		       st_utime_t timeout);
+extern ssize_t st_read_fully(st_netfd_t fd, void *buf, size_t nbyte,
+			     st_utime_t timeout);
+extern int st_read_resid(st_netfd_t fd, void *buf, size_t *resid,
+			 st_utime_t timeout);
+extern ssize_t st_write(st_netfd_t fd, const void *buf, size_t nbyte,
+			st_utime_t timeout);
+extern int st_write_resid(st_netfd_t fd, const void *buf, size_t *resid,
+			  st_utime_t timeout);
+extern ssize_t st_writev(st_netfd_t fd, const struct iovec *iov, int iov_size,
+			 st_utime_t timeout);
+extern int st_recvfrom(st_netfd_t fd, void *buf, int len,
+		       struct sockaddr *from, int *fromlen,
+		       st_utime_t timeout);
+extern int st_sendto(st_netfd_t fd, const void *msg, int len,
+		     const struct sockaddr *to, int tolen, st_utime_t timeout);
+extern int st_recvmsg(st_netfd_t fd, struct msghdr *msg, int flags,
+		      st_utime_t timeout);
+extern int st_sendmsg(st_netfd_t fd, const struct msghdr *msg, int flags,
+		      st_utime_t timeout);
+extern st_netfd_t st_open(const char *path, int oflags, mode_t mode);
+
+#ifdef DEBUG
+extern void _st_show_thread_stack(st_thread_t thread, const char *messg);
+extern void _st_iterate_threads(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__ST_THREAD_H__ */
+

Added: upwatch/trunk/st-1.6/sched.c
===================================================================
--- upwatch/trunk/st-1.6/sched.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/sched.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,970 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;common.h&quot;
+
+
+/* Global data */
+_st_vp_t _st_this_vp;           /* This VP */
+_st_thread_t *_st_this_thread;  /* Current thread */
+int _st_active_count = 0;       /* Active thread count */
+
+time_t _st_curr_time = 0;       /* Current time as returned by time(2) */
+st_utime_t _st_last_tset;       /* Last time it was fetched */
+
+
+int st_poll(struct pollfd *pds, int npds, st_utime_t timeout)
+{
+  struct pollfd *pd;
+  struct pollfd *epd = pds + npds;
+  _st_pollq_t pq;
+  _st_thread_t *me = _ST_CURRENT_THREAD();
+  int n;
+
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+#ifndef USE_POLL
+  for (pd = pds; pd &lt; epd; pd++) {
+    if (pd-&gt;events &amp; POLLIN) {
+      FD_SET(pd-&gt;fd, &amp;_ST_FD_READ_SET);
+      _ST_FD_READ_CNT(pd-&gt;fd)++;
+    }
+    if (pd-&gt;events &amp; POLLOUT) {
+      FD_SET(pd-&gt;fd, &amp;_ST_FD_WRITE_SET);
+      _ST_FD_WRITE_CNT(pd-&gt;fd)++;
+    }
+    if (pd-&gt;events &amp; POLLPRI) {
+      FD_SET(pd-&gt;fd, &amp;_ST_FD_EXCEPTION_SET);
+      _ST_FD_EXCEPTION_CNT(pd-&gt;fd)++;
+    }
+    if (_ST_MAX_OSFD &lt; pd-&gt;fd)
+      _ST_MAX_OSFD = pd-&gt;fd;
+  }
+#else
+  _ST_OSFD_CNT += npds;
+#endif  /* !USE_POLL */
+
+  pq.pds = pds;
+  pq.npds = npds;
+  pq.thread = me;
+  pq.on_ioq = 1;
+  _ST_ADD_IOQ(pq);
+  if (timeout != ST_UTIME_NO_TIMEOUT)
+    _ST_ADD_SLEEPQ(me, timeout);
+  me-&gt;state = _ST_ST_IO_WAIT;
+
+  _ST_SWITCH_CONTEXT(me);
+
+  n = 0;
+  if (pq.on_ioq) {
+    /* If we timed out, the pollq might still be on the ioq. Remove it */
+    _ST_DEL_IOQ(pq);
+#ifndef USE_POLL
+    for (pd = pds; pd &lt; epd; pd++) {
+      if (pd-&gt;events &amp; POLLIN) {
+	if (--_ST_FD_READ_CNT(pd-&gt;fd) == 0)
+	  FD_CLR(pd-&gt;fd, &amp;_ST_FD_READ_SET);
+      }
+      if (pd-&gt;events &amp; POLLOUT) {
+	if (--_ST_FD_WRITE_CNT(pd-&gt;fd) == 0)
+	  FD_CLR(pd-&gt;fd, &amp;_ST_FD_WRITE_SET);
+      }
+      if (pd-&gt;events &amp; POLLPRI) {
+	if (--_ST_FD_EXCEPTION_CNT(pd-&gt;fd) == 0)
+	  FD_CLR(pd-&gt;fd, &amp;_ST_FD_EXCEPTION_SET);
+      }
+    }
+#else
+    _ST_OSFD_CNT -= npds;
+    ST_ASSERT(_ST_OSFD_CNT &gt;= 0);
+#endif  /* !USE_POLL */
+  } else {
+    /* Count the number of ready descriptors */
+    for (pd = pds; pd &lt; epd; pd++) {
+      if (pd-&gt;revents)
+	n++;
+    }
+  }
+
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+  return n;
+}
+
+
+void _st_vp_schedule(void)
+{
+  _st_thread_t *thread;
+
+  if (_ST_RUNQ.next != &amp;_ST_RUNQ) {
+    /* Pull thread off of the run queue */
+    thread = _ST_THREAD_PTR(_ST_RUNQ.next);
+    _ST_DEL_RUNQ(thread);
+  } else {
+    /* If there are no threads to run, switch to the idle thread */
+    thread = _st_this_vp.idle_thread;
+  }
+  ST_ASSERT(thread-&gt;state == _ST_ST_RUNNABLE);
+
+  /* Resume the thread */
+  thread-&gt;state = _ST_ST_RUNNING;
+  _ST_RESTORE_CONTEXT(thread);
+}
+
+
+/*
+ * Initialize this Virtual Processor
+ */
+int st_init(void)
+{
+  _st_thread_t *thread;
+
+  if (_st_active_count) {
+    /* Already initialized */
+    return 0;
+  }
+
+  if (_st_io_init() &lt; 0)
+    return -1;
+
+  memset(&amp;_st_this_vp, 0, sizeof(_st_vp_t));
+
+  ST_INIT_CLIST(&amp;_ST_RUNQ);
+  ST_INIT_CLIST(&amp;_ST_IOQ);
+  ST_INIT_CLIST(&amp;_ST_ZOMBIEQ);
+#ifdef DEBUG
+  ST_INIT_CLIST(&amp;_ST_THREADQ);
+#endif
+
+#ifndef USE_POLL
+  _st_this_vp.maxfd = -1;
+#else
+  _ST_POLLFDS = (struct pollfd *) malloc(ST_MIN_POLLFDS_SIZE *
+					 sizeof(struct pollfd));
+  if (!_ST_POLLFDS)
+    return -1;
+  _ST_POLLFDS_SIZE = ST_MIN_POLLFDS_SIZE;
+#endif  /* !USE_POLL */
+  _st_this_vp.pagesize = getpagesize();
+  _st_this_vp.last_clock = st_utime();
+
+  /*
+   * Create idle thread
+   */
+  _st_this_vp.idle_thread = st_thread_create(_st_idle_thread_start,
+					     NULL, 0, 0);
+  if (!_st_this_vp.idle_thread)
+    return -1;
+  _st_this_vp.idle_thread-&gt;flags = _ST_FL_IDLE_THREAD;
+  _st_active_count--;
+  _ST_DEL_RUNQ(_st_this_vp.idle_thread);
+
+  /*
+   * Initialize primordial thread
+   */
+  thread = (_st_thread_t *) calloc(1, sizeof(_st_thread_t) +
+				   (ST_KEYS_MAX * sizeof(void *)));
+  if (!thread)
+    return -1;
+  thread-&gt;private_data = (void **) (thread + 1);
+  thread-&gt;state = _ST_ST_RUNNING;
+  thread-&gt;flags = _ST_FL_PRIMORDIAL;
+  _ST_SET_CURRENT_THREAD(thread);
+  _st_active_count++;
+#ifdef DEBUG
+  _ST_ADD_THREADQ(thread);
+#endif
+
+  return 0;
+}
+
+#ifdef ST_SWITCH_CB
+st_switch_cb_t st_set_switch_in_cb(st_switch_cb_t cb)
+{
+  st_switch_cb_t ocb = _st_this_vp.switch_in_cb;
+  _st_this_vp.switch_in_cb = cb;
+  return ocb;
+}
+
+st_switch_cb_t st_set_switch_out_cb(st_switch_cb_t cb)
+{
+  st_switch_cb_t ocb = _st_this_vp.switch_out_cb;
+  _st_this_vp.switch_out_cb = cb;
+  return ocb;
+}
+#endif
+
+/*
+ * Start function for the idle thread
+ */
+/* ARGSUSED */
+void *_st_idle_thread_start(void *arg)
+{
+  _st_thread_t *me = _ST_CURRENT_THREAD();
+
+  while (_st_active_count &gt; 0) {
+    /* Idle vp till I/O is ready or the smallest timeout expired */
+    _st_vp_idle();
+
+    /* Check sleep queue for expired threads */
+    _st_vp_check_clock();
+
+    me-&gt;state = _ST_ST_RUNNABLE;
+    _ST_SWITCH_CONTEXT(me);
+  }
+
+  /* No more threads */
+  exit(0);
+
+  /* NOTREACHED */
+  return NULL;
+}
+
+
+#ifndef USE_POLL
+/* select() is used to poll file descriptors */
+void _st_vp_idle(void)
+{
+  struct timeval timeout, *tvp;
+  fd_set r, w, e;
+  fd_set *rp, *wp, *ep;
+  int nfd, pq_max_osfd, osfd;
+  _st_clist_t *q;
+  st_utime_t min_timeout;
+  _st_pollq_t *pq;
+  int notify;
+  struct pollfd *pds, *epds;
+  short events, revents;
+
+  /*
+   * Assignment of fd_sets
+   */
+  r = _ST_FD_READ_SET;
+  w = _ST_FD_WRITE_SET;
+  e = _ST_FD_EXCEPTION_SET;
+
+  rp = &r;
+  wp = &w;
+  ep = &e;
+
+  if (_ST_SLEEPQ == NULL) {
+    tvp = NULL;
+  } else {
+    min_timeout = (_ST_SLEEPQ-&gt;due &lt;= _ST_LAST_CLOCK) ? 0 :
+      (_ST_SLEEPQ-&gt;due - _ST_LAST_CLOCK);
+    timeout.tv_sec  = (int) (min_timeout / 1000000);
+    timeout.tv_usec = (int) (min_timeout % 1000000);
+    tvp = &timeout;
+  }
+
+  /* Check for I/O operations */
+  nfd = select(_ST_MAX_OSFD + 1, rp, wp, ep, tvp);
+
+  /* Notify threads that are associated with the selected descriptors */
+  if (nfd &gt; 0) {
+    _ST_MAX_OSFD = -1;
+    for (q = _ST_IOQ.next; q != &amp;_ST_IOQ; q = q-&gt;next) {
+      pq = _ST_POLLQUEUE_PTR(q);
+      notify = 0;
+      epds = pq-&gt;pds + pq-&gt;npds;
+      pq_max_osfd = -1;
+      
+      for (pds = pq-&gt;pds; pds &lt; epds; pds++) {
+	osfd = pds-&gt;fd;
+	events = pds-&gt;events;
+	revents = 0;
+	ST_ASSERT(osfd &gt;= 0 || events == 0);
+	if ((events &amp; POLLIN) &amp;&amp; FD_ISSET(osfd, rp)) {
+	  revents |= POLLIN;
+	}
+	if ((events &amp; POLLOUT) &amp;&amp; FD_ISSET(osfd, wp)) {
+	  revents |= POLLOUT;
+	}
+	if ((events &amp; POLLPRI) &amp;&amp; FD_ISSET(osfd, ep)) {
+	  revents |= POLLPRI;
+	}
+	pds-&gt;revents = revents;
+	if (revents) {
+	  notify = 1;
+	}
+	if (osfd &gt; pq_max_osfd) {
+	  pq_max_osfd = osfd;
+	}
+      }
+      if (notify) {
+	ST_REMOVE_LINK(&amp;pq-&gt;links);
+	pq-&gt;on_ioq = 0;
+	/*
+	 * Decrement the count of descriptors for each descriptor/event
+	 * because this I/O request is being removed from the ioq
+	 */
+	for (pds = pq-&gt;pds; pds &lt; epds; pds++) {
+	  osfd = pds-&gt;fd;
+	  events = pds-&gt;events;
+	  if (events &amp; POLLIN) {
+	    if (--_ST_FD_READ_CNT(osfd) == 0) {
+	      FD_CLR(osfd, &amp;_ST_FD_READ_SET);
+	    }
+	  }
+	  if (events &amp; POLLOUT) {
+	    if (--_ST_FD_WRITE_CNT(osfd) == 0) {
+	      FD_CLR(osfd, &amp;_ST_FD_WRITE_SET);
+	    }
+	  }
+	  if (events &amp; POLLPRI) {
+	    if (--_ST_FD_EXCEPTION_CNT(osfd) == 0) {
+	      FD_CLR(osfd, &amp;_ST_FD_EXCEPTION_SET);
+	    }
+	  }
+	}
+
+	if (pq-&gt;thread-&gt;flags &amp; _ST_FL_ON_SLEEPQ)
+	  _ST_DEL_SLEEPQ(pq-&gt;thread);
+	pq-&gt;thread-&gt;state = _ST_ST_RUNNABLE;
+	_ST_ADD_RUNQ(pq-&gt;thread);
+      } else {
+	if (_ST_MAX_OSFD &lt; pq_max_osfd)
+	  _ST_MAX_OSFD = pq_max_osfd;
+      }
+    }
+  } else if (nfd &lt; 0) {
+    /*
+     * It can happen when a thread closes file descriptor
+     * that is being used by some other thread
+     */
+    if (errno == EBADF)
+      _st_find_bad_fd();
+  }
+}
+
+
+void _st_find_bad_fd(void)
+{
+  _st_clist_t *q;
+  _st_pollq_t *pq;
+  int notify;
+  struct pollfd *pds, *epds;
+  int pq_max_osfd, osfd;
+  short events;
+
+  _ST_MAX_OSFD = -1;
+
+  for (q = _ST_IOQ.next; q != &amp;_ST_IOQ; q = q-&gt;next) {
+    pq = _ST_POLLQUEUE_PTR(q);
+    notify = 0;
+    epds = pq-&gt;pds + pq-&gt;npds;
+    pq_max_osfd = -1;
+      
+    for (pds = pq-&gt;pds; pds &lt; epds; pds++) {
+      osfd = pds-&gt;fd;
+      pds-&gt;revents = 0;
+      ST_ASSERT(osfd &gt;= 0 || pds-&gt;events == 0);
+      if (pds-&gt;events == 0)
+	continue;
+      if (fcntl(osfd, F_GETFL, 0) &lt; 0) {
+	pds-&gt;revents = POLLNVAL;
+	notify = 1;
+      }
+      if (osfd &gt; pq_max_osfd) {
+	pq_max_osfd = osfd;
+      }
+    }
+
+    if (notify) {
+      ST_REMOVE_LINK(&amp;pq-&gt;links);
+      pq-&gt;on_ioq = 0;
+      /*
+       * Decrement the count of descriptors for each descriptor/event
+       * because this I/O request is being removed from the ioq
+       */
+      for (pds = pq-&gt;pds; pds &lt; epds; pds++) {
+	osfd = pds-&gt;fd;
+	events = pds-&gt;events;
+	if (events &amp; POLLIN) {
+	  if (--_ST_FD_READ_CNT(osfd) == 0) {
+	    FD_CLR(osfd, &amp;_ST_FD_READ_SET);
+	  }
+	}
+	if (events &amp; POLLOUT) {
+	  if (--_ST_FD_WRITE_CNT(osfd) == 0) {
+	    FD_CLR(osfd, &amp;_ST_FD_WRITE_SET);
+	  }
+	}
+	if (events &amp; POLLPRI) {
+	  if (--_ST_FD_EXCEPTION_CNT(osfd) == 0) {
+	    FD_CLR(osfd, &amp;_ST_FD_EXCEPTION_SET);
+	  }
+	}
+      }
+
+      if (pq-&gt;thread-&gt;flags &amp; _ST_FL_ON_SLEEPQ)
+	_ST_DEL_SLEEPQ(pq-&gt;thread);
+      pq-&gt;thread-&gt;state = _ST_ST_RUNNABLE;
+      _ST_ADD_RUNQ(pq-&gt;thread);
+    } else {
+      if (_ST_MAX_OSFD &lt; pq_max_osfd)
+	_ST_MAX_OSFD = pq_max_osfd;
+    }
+  }
+}
+
+#else  /* !USE_POLL */
+/* poll() is used to poll file descriptors */
+void _st_vp_idle(void)
+{
+  int timeout, nfd;
+  _st_clist_t *q;
+  st_utime_t min_timeout;
+  _st_pollq_t *pq;
+  struct pollfd *pds, *epds, *pollfds;
+
+  /*
+   * Build up the array of struct pollfd to wait on.
+   * If existing array is not big enough, release it and allocate a new one.
+   */
+  ST_ASSERT(_ST_OSFD_CNT &gt;= 0);
+  if (_ST_OSFD_CNT &gt; _ST_POLLFDS_SIZE) {
+    free(_ST_POLLFDS);
+    _ST_POLLFDS = (struct pollfd *) malloc((_ST_OSFD_CNT + 10) *
+					   sizeof(struct pollfd));
+    ST_ASSERT(_ST_POLLFDS != NULL);
+    _ST_POLLFDS_SIZE = _ST_OSFD_CNT + 10;
+  }
+  pollfds = _ST_POLLFDS;
+
+  /* Gather all descriptors into one array */
+  for (q = _ST_IOQ.next; q != &amp;_ST_IOQ; q = q-&gt;next) {
+    pq = _ST_POLLQUEUE_PTR(q);
+    memcpy(pollfds, pq-&gt;pds, sizeof(struct pollfd) * pq-&gt;npds);
+    pollfds += pq-&gt;npds;
+  }
+  ST_ASSERT(pollfds &lt;= _ST_POLLFDS + _ST_POLLFDS_SIZE);
+
+  if (_ST_SLEEPQ == NULL) {
+    timeout = -1;
+  } else {
+    if (_ST_SLEEPQ-&gt;due &lt;= _st_this_vp.last_clock)
+      min_timeout = 0;
+    else
+      min_timeout = _ST_SLEEPQ-&gt;due - _st_this_vp.last_clock;
+    timeout = (int) (min_timeout / 1000);
+  }
+
+  /* Check for I/O operations */
+  nfd = poll(_ST_POLLFDS, _ST_OSFD_CNT, timeout);
+
+  /* Notify threads that are associated with the selected descriptors */
+  if (nfd &gt; 0) {
+    pollfds = _ST_POLLFDS;
+    for (q = _ST_IOQ.next; q != &amp;_ST_IOQ; q = q-&gt;next) {
+      pq = _ST_POLLQUEUE_PTR(q);
+      epds = pollfds + pq-&gt;npds;
+      for (pds = pollfds; pds &lt; epds; pds++)
+	if (pds-&gt;revents &amp;&amp; pds-&gt;fd &gt;= 0)   /* poll ignores negative fd's */
+	  break;
+      if (pds &lt; epds) {
+	memcpy(pq-&gt;pds, pollfds, sizeof(struct pollfd) * pq-&gt;npds);
+        ST_REMOVE_LINK(&amp;pq-&gt;links);
+        pq-&gt;on_ioq = 0;
+
+        if (pq-&gt;thread-&gt;flags &amp; _ST_FL_ON_SLEEPQ)
+          _ST_DEL_SLEEPQ(pq-&gt;thread);
+        pq-&gt;thread-&gt;state = _ST_ST_RUNNABLE;
+        _ST_ADD_RUNQ(pq-&gt;thread);
+
+	_ST_OSFD_CNT -= pq-&gt;npds;
+	ST_ASSERT(_ST_OSFD_CNT &gt;= 0);
+      }
+      pollfds = epds;
+    }
+  }
+}
+
+#endif  /* !USE_POLL */
+
+
+void st_thread_exit(void *retval)
+{
+  _st_thread_t *thread = _ST_CURRENT_THREAD();
+
+  thread-&gt;retval = retval;
+  _st_thread_cleanup(thread);
+  _st_active_count--;
+  if (thread-&gt;term) {
+    /* Put thread on the zombie queue */
+    thread-&gt;state = _ST_ST_ZOMBIE;
+    _ST_ADD_ZOMBIEQ(thread);
+
+    /* Notify on our termination condition variable */
+    st_cond_signal(thread-&gt;term);
+
+    /* Switch context and come back later */
+    _ST_SWITCH_CONTEXT(thread);
+
+    /* Continue the cleanup */
+    st_cond_destroy(thread-&gt;term);
+    thread-&gt;term = NULL;
+  }
+
+#ifdef DEBUG
+  _ST_DEL_THREADQ(thread);
+#endif
+
+  if (!(thread-&gt;flags &amp; _ST_FL_PRIMORDIAL))
+    _st_stack_free(thread-&gt;stack);
+
+  /* Find another thread to run */
+  _ST_SWITCH_CONTEXT(thread);
+  /* Not going to land here */
+}
+
+
+int st_thread_join(_st_thread_t *thread, void **retvalp)
+{
+  _st_cond_t *term = thread-&gt;term;
+
+  /* Can't join a non-joinable thread */
+  if (term == NULL) {
+    errno = EINVAL;
+    return -1;
+  }
+  if (_ST_CURRENT_THREAD() == thread) {
+    errno = EDEADLK;
+    return -1;
+  }
+
+  /* Multiple threads can't wait on the same joinable thread */
+  if (term-&gt;wait_q.next != &amp;term-&gt;wait_q) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  while (thread-&gt;state != _ST_ST_ZOMBIE) {
+    if (st_cond_timedwait(term, ST_UTIME_NO_TIMEOUT) != 0)
+      return -1;
+  }
+
+  if (retvalp)
+    *retvalp = thread-&gt;retval;
+
+  /*
+   * Remove target thread from the zombie queue and make it runnable.
+   * When it gets scheduled later, it will do the clean up.
+   */
+  thread-&gt;state = _ST_ST_RUNNABLE;
+  _ST_DEL_ZOMBIEQ(thread);
+  _ST_ADD_RUNQ(thread);
+
+  return 0;
+}
+
+
+void _st_thread_main(void)
+{
+  _st_thread_t *thread = _ST_CURRENT_THREAD();
+
+  /*
+   * Cap the stack by zeroing out the saved return address register
+   * value. This allows some debugging/profiling tools to know when
+   * to stop unwinding the stack. It's a no-op on most platforms.
+   */
+  MD_CAP_STACK(&amp;thread);
+
+  /* Run thread main */
+  thread-&gt;retval = (*thread-&gt;start)(thread-&gt;arg);
+
+  /* All done, time to go away */
+  st_thread_exit(thread-&gt;retval);
+}
+
+
+/*
+ * Insert &quot;thread&quot; into the timeout heap, in the position
+ * specified by thread-&gt;heap_index.  See docs/timeout_heap.txt
+ * for details about the timeout heap.
+ */
+static _st_thread_t **heap_insert(_st_thread_t *thread) {
+  int target = thread-&gt;heap_index;
+  int s = target;
+  _st_thread_t **p = &amp;_ST_SLEEPQ;
+  int bits = 0;
+  int bit;
+  int index = 1;
+
+  while (s) {
+    s &gt;&gt;= 1;
+    bits++;
+  }
+  for (bit = bits - 2; bit &gt;= 0; bit--) {
+    if (thread-&gt;due &lt; (*p)-&gt;due) {
+      _st_thread_t *t = *p;
+      thread-&gt;left = t-&gt;left;
+      thread-&gt;right = t-&gt;right;
+      *p = thread;
+      thread-&gt;heap_index = index;
+      thread = t;
+    }
+    index &lt;&lt;= 1;
+    if (target &amp; (1 &lt;&lt; bit)) {
+      p = &amp;((*p)-&gt;right);
+      index |= 1;
+    } else {
+      p = &amp;((*p)-&gt;left);
+    }
+  }
+  thread-&gt;heap_index = index;
+  *p = thread;
+  thread-&gt;left = thread-&gt;right = NULL;
+  return p;
+}
+
+/*
+ * Delete &quot;thread&quot; from the timeout heap.
+ */
+static void heap_delete(_st_thread_t *thread) {
+  _st_thread_t *t, **p;
+  int bits = 0;
+  int s, bit;
+
+  /* First find and unlink the last heap element */
+  p = &amp;_ST_SLEEPQ;
+  s = _ST_SLEEPQ_SIZE;
+  while (s) {
+    s &gt;&gt;= 1;
+    bits++;
+  }
+  for (bit = bits - 2; bit &gt;= 0; bit--) {
+    if (_ST_SLEEPQ_SIZE &amp; (1 &lt;&lt; bit)) {
+      p = &amp;((*p)-&gt;right);
+    } else {
+      p = &amp;((*p)-&gt;left);
+    }
+  }
+  t = *p;
+  *p = NULL;
+  --_ST_SLEEPQ_SIZE;
+  if (t != thread) {
+    /*
+     * Insert the unlinked last element in place of the element we are deleting
+     */
+    t-&gt;heap_index = thread-&gt;heap_index;
+    p = heap_insert(t);
+    t = *p;
+    t-&gt;left = thread-&gt;left;
+    t-&gt;right = thread-&gt;right;
+
+    /*
+     * Reestablish the heap invariant.
+     */
+    for (;;) {
+      _st_thread_t *y; /* The younger child */
+      int index_tmp;
+      if (t-&gt;left == NULL)
+	break;
+      else if (t-&gt;right == NULL)
+	y = t-&gt;left;
+      else if (t-&gt;left-&gt;due &lt; t-&gt;right-&gt;due)
+	y = t-&gt;left;
+      else
+	y = t-&gt;right;
+      if (t-&gt;due &gt; y-&gt;due) {
+	_st_thread_t *tl = y-&gt;left;
+	_st_thread_t *tr = y-&gt;right;
+	*p = y;
+	if (y == t-&gt;left) {
+	  y-&gt;left = t;
+	  y-&gt;right = t-&gt;right;
+	  p = &amp;y-&gt;left;
+	} else {
+	  y-&gt;left = t-&gt;left;
+	  y-&gt;right = t;
+	  p = &amp;y-&gt;right;
+	}
+	t-&gt;left = tl;
+	t-&gt;right = tr;
+	index_tmp = t-&gt;heap_index;
+	t-&gt;heap_index = y-&gt;heap_index;
+	y-&gt;heap_index = index_tmp;
+      } else {
+	break;
+      }
+    }
+  }
+  thread-&gt;left = thread-&gt;right = NULL;
+}
+
+
+void _st_add_sleep_q(_st_thread_t *thread, st_utime_t timeout)
+{
+  thread-&gt;due = _ST_LAST_CLOCK + timeout;
+  thread-&gt;flags |= _ST_FL_ON_SLEEPQ;
+  thread-&gt;heap_index = ++_ST_SLEEPQ_SIZE;
+  heap_insert(thread);
+}
+
+
+void _st_del_sleep_q(_st_thread_t *thread)
+{
+  heap_delete(thread);
+  thread-&gt;flags &amp;= ~_ST_FL_ON_SLEEPQ;
+}
+
+
+void _st_vp_check_clock(void)
+{
+  _st_thread_t *thread;
+  st_utime_t elapsed, now;
+ 
+  now = st_utime();
+  elapsed = now - _ST_LAST_CLOCK;
+  _ST_LAST_CLOCK = now;
+
+  if (_st_curr_time &amp;&amp; now - _st_last_tset &gt; 999000) {
+    _st_curr_time = time(NULL);
+    _st_last_tset = now;
+  }
+
+  while (_ST_SLEEPQ != NULL) {
+    thread = _ST_SLEEPQ;
+    ST_ASSERT(thread-&gt;flags &amp; _ST_FL_ON_SLEEPQ);
+    if (thread-&gt;due &gt; now)
+      break;
+    _ST_DEL_SLEEPQ(thread);
+
+    /* If thread is waiting on condition variable, set the time out flag */
+    if (thread-&gt;state == _ST_ST_COND_WAIT)
+      thread-&gt;flags |= _ST_FL_TIMEDOUT;
+
+    /* Make thread runnable */
+    ST_ASSERT(!(thread-&gt;flags &amp; _ST_FL_IDLE_THREAD));
+    thread-&gt;state = _ST_ST_RUNNABLE;
+    _ST_ADD_RUNQ(thread);
+  }
+}
+
+
+void st_thread_interrupt(_st_thread_t *thread)
+{
+  /* If thread is already dead */
+  if (thread-&gt;state == _ST_ST_ZOMBIE)
+    return;
+
+  thread-&gt;flags |= _ST_FL_INTERRUPT;
+
+  if (thread-&gt;state == _ST_ST_RUNNING || thread-&gt;state == _ST_ST_RUNNABLE)
+    return;
+
+  if (thread-&gt;flags &amp; _ST_FL_ON_SLEEPQ)
+    _ST_DEL_SLEEPQ(thread);
+
+  /* Make thread runnable */
+  thread-&gt;state = _ST_ST_RUNNABLE;
+  _ST_ADD_RUNQ(thread);
+}
+
+
+_st_thread_t *st_thread_create(void *(*start)(void *arg), void *arg,
+			       int joinable, int stk_size)
+{
+  _st_thread_t *thread;
+  _st_stack_t *stack;
+  void **ptds;
+  char *sp;
+#ifdef __ia64__
+  char *bsp;
+#endif
+
+  /* Adjust stack size */
+  if (stk_size == 0)
+    stk_size = ST_DEFAULT_STACK_SIZE;
+  stk_size = ((stk_size + _ST_PAGE_SIZE - 1) / _ST_PAGE_SIZE) * _ST_PAGE_SIZE;
+  stack = _st_stack_new(stk_size);
+  if (!stack)
+    return NULL;
+
+  /* Allocate thread object and per-thread data off the stack */
+#if defined (MD_STACK_GROWS_DOWN)
+  sp = stack-&gt;stk_top;
+#ifdef __ia64__
+  /*
+   * The stack segment is split in the middle. The upper half is used
+   * as backing store for the register stack which grows upward.
+   * The lower half is used for the traditional memory stack which
+   * grows downward. Both stacks start in the middle and grow outward
+   * from each other.
+   */
+  sp -= (stk_size &gt;&gt; 1);
+  bsp = sp;
+  /* Make register stack 64-byte aligned */
+  if ((unsigned long)bsp &amp; 0x3f)
+    bsp = bsp + (0x40 - ((unsigned long)bsp &amp; 0x3f));
+  stack-&gt;bsp = bsp + _ST_STACK_PAD_SIZE;
+#endif
+  sp = sp - (ST_KEYS_MAX * sizeof(void *));
+  ptds = (void **) sp;
+  sp = sp - sizeof(_st_thread_t);
+  thread = (_st_thread_t *) sp;
+
+  /* Make stack 64-byte aligned */
+  if ((unsigned long)sp &amp; 0x3f)
+    sp = sp - ((unsigned long)sp &amp; 0x3f);
+  stack-&gt;sp = sp - _ST_STACK_PAD_SIZE;
+#elif defined (MD_STACK_GROWS_UP)
+  sp = stack-&gt;stk_bottom;
+  thread = (_st_thread_t *) sp;
+  sp = sp + sizeof(_st_thread_t);
+  ptds = (void **) sp;
+  sp = sp + (ST_KEYS_MAX * sizeof(void *));
+
+  /* Make stack 64-byte aligned */
+  if ((unsigned long)sp &amp; 0x3f)
+    sp = sp + (0x40 - ((unsigned long)sp &amp; 0x3f));
+  stack-&gt;sp = sp + _ST_STACK_PAD_SIZE;
+#else
+#error Unknown OS
+#endif
+
+  memset(thread, 0, sizeof(_st_thread_t));
+  memset(ptds, 0, ST_KEYS_MAX * sizeof(void *));
+
+  /* Initialize thread */
+  thread-&gt;private_data = ptds;
+  thread-&gt;stack = stack;
+  thread-&gt;start = start;
+  thread-&gt;arg = arg;
+
+#ifndef __ia64__
+  _ST_INIT_CONTEXT(thread, stack-&gt;sp, _st_thread_main);
+#else
+  _ST_INIT_CONTEXT(thread, stack-&gt;sp, stack-&gt;bsp, _st_thread_main);
+#endif
+
+  /* If thread is joinable, allocate a termination condition variable */
+  if (joinable) {
+    thread-&gt;term = st_cond_new();
+    if (thread-&gt;term == NULL) {
+      _st_stack_free(thread-&gt;stack);
+      return NULL;
+    }
+  }
+
+  /* Make thread runnable */
+  thread-&gt;state = _ST_ST_RUNNABLE;
+  _st_active_count++;
+  _ST_ADD_RUNQ(thread);
+#ifdef DEBUG
+  _ST_ADD_THREADQ(thread);
+#endif
+
+  return thread;
+}
+
+
+_st_thread_t *st_thread_self(void)
+{
+  return _ST_CURRENT_THREAD();
+}
+
+
+#ifdef DEBUG
+/* ARGSUSED */
+void _st_show_thread_stack(_st_thread_t *thread, const char *messg)
+{
+
+}
+
+/* To be set from debugger */
+int _st_iterate_threads_flag = 0;
+
+void _st_iterate_threads(void)
+{
+  static _st_thread_t *thread = NULL;
+  static jmp_buf orig_jb, save_jb;
+  _st_clist_t *q;
+
+  if (!_st_iterate_threads_flag) {
+    if (thread) {
+      memcpy(thread-&gt;context, save_jb, sizeof(jmp_buf));
+      MD_LONGJMP(orig_jb, 1);
+    }
+    return;
+  }
+
+  if (thread) {
+    memcpy(thread-&gt;context, save_jb, sizeof(jmp_buf));
+    _st_show_thread_stack(thread, NULL);
+  } else {
+    if (MD_SETJMP(orig_jb)) {
+      _st_iterate_threads_flag = 0;
+      thread = NULL;
+      _st_show_thread_stack(thread, &quot;Iteration completed&quot;);
+      return;
+    }
+    thread = _ST_CURRENT_THREAD();
+    _st_show_thread_stack(thread, &quot;Iteration started&quot;);
+  }
+
+  q = thread-&gt;tlink.next;
+  if (q == &amp;_ST_THREADQ)
+    q = q-&gt;next;
+  ST_ASSERT(q != &amp;_ST_THREADQ);
+  thread = _ST_THREAD_THREADQ_PTR(q);
+  if (thread == _ST_CURRENT_THREAD())
+    MD_LONGJMP(orig_jb, 1);
+  memcpy(save_jb, thread-&gt;context, sizeof(jmp_buf));
+  MD_LONGJMP(thread-&gt;context, 1);
+}
+#endif /* DEBUG */
+

Added: upwatch/trunk/st-1.6/st.pc.in
===================================================================
--- upwatch/trunk/st-1.6/st.pc.in	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/st.pc.in	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+Name: libst
+Description: State Thread Library
+Version: @VERSION@
+Libs: -L${libdir} -lst
+Cflags: -I${includedir}

Added: upwatch/trunk/st-1.6/st.spec
===================================================================
--- upwatch/trunk/st-1.6/st.spec	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/st.spec	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,79 @@
+Summary:	State Threads Library
+Name:		st
+Version:	1.6
+Release:	1
+Copyright:	MPL 1.2 or GPL 2+
+Packager:	Wesley W. Terpstra &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">wesley at terpstra.ca</A>&gt;
+Source:		<A HREF="http://prdownloads.sourceforge.net/state-threads/st-%{version">http://prdownloads.sourceforge.net/state-threads/st-%{version</A>}.tar.gz
+Prefix:		/usr
+BuildRoot:	/tmp/%{name}-%{version}-build
+Group:		Development/Libraries
+
+%description
+The State Threads library has an interface similar to POSIX threads.
+
+However, the threads are actually all run in-process. This type of
+threading allows for controlled schedualing points. It is highly useful 
+for designing robust and extremely scalable internet applications since
+there is no resource contention and locking is generally unnecessary.
+
+It can be combined with traditional threading or multiple process
+parallelism to take advantage of multiple processors.
+
+See: &lt;<A HREF="http://state-threads.sourceforge.net/docs/st.html">http://state-threads.sourceforge.net/docs/st.html</A>&gt; for further
+information about how state threads improve performance.
+
+%package -n libst-devel
+Summary:	State Threads Library - Development Files
+Group:		Development/Libraries
+Requires:	libst1
+
+%description -n libst-devel
+Development headers and documentation for libst
+
+%package -n libst1
+Summary:	State Threads Library - Shared Libs Major 1
+Group:		System/Libraries
+
+%description -n libst1
+Shared libraries for running applications linked against api version 1.
+
+%prep
+%setup -q
+
+%build
+make CONFIG_GUESS_PATH=/usr/share/automake default-optimized
+
+%install
+if [ -d ${RPM_BUILD_ROOT} ]; then rm -rf ${RPM_BUILD_ROOT}; fi
+
+mkdir -m 0755 -p ${RPM_BUILD_ROOT}/%{prefix}/lib/pkgconfig
+mkdir -m 0755 -p ${RPM_BUILD_ROOT}/%{prefix}/include
+mkdir -m 0755 -p ${RPM_BUILD_ROOT}/%{prefix}/share/doc/libst-devel
+cp -a obj/libst.* ${RPM_BUILD_ROOT}/%{prefix}/lib
+cp -a obj/st.h    ${RPM_BUILD_ROOT}/%{prefix}/include
+sed &quot;s*@prefix@*%{prefix}*g&quot; &lt;st.pc &gt;${RPM_BUILD_ROOT}/%{prefix}/lib/pkgconfig/st.pc
+cp -a docs/*      ${RPM_BUILD_ROOT}/%{prefix}/share/doc/libst-devel/
+cp -a examples    ${RPM_BUILD_ROOT}/%{prefix}/share/doc/libst-devel/
+
+%post -n libst1
+/sbin/ldconfig %{prefix}/lib
+
+%files -n libst1
+%defattr(-,root,root)
+%{prefix}/lib/lib*.so.*
+
+%files -n libst-devel
+%defattr(-,root,root)
+%{prefix}/include/*
+%{prefix}/lib/lib*.a
+%{prefix}/lib/lib*.so
+%{prefix}/lib/pkgconfig/st.pc
+%{prefix}/share/doc/libst-devel/*
+
+%clean
+if [ -d ${RPM_BUILD_ROOT} ]; then rm -rf ${RPM_BUILD_ROOT}; fi
+
+%changelog
+* Wed Dec 26 2001 Wesley W. Terpstra &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/upwatch-commits">wesley at terpstra.ca</A>&gt;
+- first rpms for libst-1.3.tar.gz

Added: upwatch/trunk/st-1.6/stk.c
===================================================================
--- upwatch/trunk/st-1.6/stk.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/stk.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,173 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/mman.h&gt;
+#include &quot;common.h&quot;
+
+
+/* How much space to leave between the stacks, at each end */
+#define REDZONE	_ST_PAGE_SIZE
+
+_st_clist_t _st_free_stacks = ST_INIT_STATIC_CLIST(&amp;_st_free_stacks);
+int _st_num_free_stacks = 0;
+int _st_randomize_stacks = 0;
+
+static char *_st_new_stk_segment(int size);
+
+_st_stack_t *_st_stack_new(int stack_size)
+{
+  _st_clist_t *qp;
+  _st_stack_t *ts;
+  int extra;
+
+  for (qp = _st_free_stacks.next; qp != &amp;_st_free_stacks; qp = qp-&gt;next) {
+    ts = _ST_THREAD_STACK_PTR(qp);
+    if (ts-&gt;stk_size &gt;= stack_size) {
+      /* Found a stack that is big enough */
+      ST_REMOVE_LINK(&amp;ts-&gt;links);
+      _st_num_free_stacks--;
+      ts-&gt;links.next = NULL;
+      ts-&gt;links.prev = NULL;
+      return ts;
+    }
+  }
+
+  /* Make a new thread stack object. */
+  if ((ts = (_st_stack_t *)calloc(1, sizeof(_st_stack_t))) == NULL)
+    return NULL;
+  extra = _st_randomize_stacks ? _ST_PAGE_SIZE : 0;
+  ts-&gt;vaddr_size = stack_size + 2*REDZONE + extra;
+  ts-&gt;vaddr = _st_new_stk_segment(ts-&gt;vaddr_size);
+  if (!ts-&gt;vaddr) {
+    free(ts);
+    return NULL;
+  }
+  ts-&gt;stk_size = stack_size;
+  ts-&gt;stk_bottom = ts-&gt;vaddr + REDZONE;
+  ts-&gt;stk_top = ts-&gt;stk_bottom + stack_size;
+
+#ifdef DEBUG
+  mprotect(ts-&gt;vaddr, REDZONE, PROT_NONE);
+  mprotect(ts-&gt;stk_top + extra, REDZONE, PROT_NONE);
+#endif
+
+  if (extra) {
+    long offset = (random() % extra) &amp; ~0xf;
+
+    ts-&gt;stk_bottom += offset;
+    ts-&gt;stk_top += offset;
+  }
+
+  return ts;
+}
+
+
+/*
+ * Free the stack for the current thread
+ */
+void _st_stack_free(_st_stack_t *ts)
+{
+  if (!ts)
+    return;
+
+  /* Put the stack on the free list */
+  ST_APPEND_LINK(&amp;ts-&gt;links, _st_free_stacks.prev);
+  _st_num_free_stacks++;
+}
+
+
+static char *_st_new_stk_segment(int size)
+{
+#ifdef MALLOC_STACK
+  void *vaddr = malloc(size);
+#else
+  static int zero_fd = -1;
+  int mmap_flags = MAP_PRIVATE;
+  void *vaddr;
+
+#if defined (MD_USE_SYSV_ANON_MMAP)
+  if (zero_fd &lt; 0) {
+    if ((zero_fd = open(&quot;/dev/zero&quot;, O_RDWR, 0)) &lt; 0)
+      return NULL;
+    fcntl(zero_fd, F_SETFD, FD_CLOEXEC);
+  }
+#elif defined (MD_USE_BSD_ANON_MMAP)
+  mmap_flags |= MAP_ANON;
+#else
+#error Unknown OS
+#endif
+
+  vaddr = mmap(NULL, size, PROT_READ | PROT_WRITE, mmap_flags, zero_fd, 0);
+  if (vaddr == (void *)MAP_FAILED)
+    return NULL;
+
+#endif /* MALLOC_STACK */
+
+  return (char *)vaddr;
+}
+
+
+/* Not used */
+#if 0
+void _st_delete_stk_segment(char *vaddr, int size)
+{
+#ifdef MALLOC_STACK
+  free(vaddr);
+#else
+  (void) munmap(vaddr, size);
+#endif
+}
+#endif
+
+int st_randomize_stacks(int on)
+{
+  int wason = _st_randomize_stacks;
+
+  _st_randomize_stacks = on;
+  if (on)
+    srandom((unsigned int) st_utime());
+
+  return wason;
+}

Added: upwatch/trunk/st-1.6/sync.c
===================================================================
--- upwatch/trunk/st-1.6/sync.c	2006-04-05 15:14:44 UTC (rev 549)
+++ upwatch/trunk/st-1.6/sync.c	2006-04-05 16:29:20 UTC (rev 550)
@@ -0,0 +1,368 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the &quot;License&quot;); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
+ * 
+ * Software distributed under the License is distributed on an &quot;AS
+ * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape Portable Runtime library.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):  Silicon Graphics, Inc.
+ * 
+ * Portions created by SGI are Copyright (C) 2000-2001 Silicon
+ * Graphics, Inc.  All Rights Reserved.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * &quot;GPL&quot;), in which case the provisions of the GPL are applicable 
+ * instead of those above.  If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+
+/*
+ * This file is derived directly from Netscape Communications Corporation,
+ * and consists of extensive modifications made during the year(s) 1999-2000.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;time.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;common.h&quot;
+
+
+extern time_t _st_curr_time;
+extern st_utime_t _st_last_tset;
+extern int _st_active_count;
+
+static st_utime_t (*_st_utime)(void) = NULL;
+
+
+/*****************************************
+ * Time functions
+ */
+
+st_utime_t st_utime(void)
+{
+  if (_st_utime == NULL) {
+#ifdef MD_GET_UTIME
+    MD_GET_UTIME();
+#else
+#error Unknown OS
+#endif
+  }
+
+  return (*_st_utime)();
+}
+
+
+int st_set_utime_function(st_utime_t (*func)(void))
+{
+  if (_st_active_count) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  _st_utime = func;
+
+  return 0;
+}
+
+
+st_utime_t st_utime_last_clock(void)
+{
+  return _ST_LAST_CLOCK;
+}
+
+
+int st_timecache_set(int on)
+{
+  int wason = (_st_curr_time) ? 1 : 0;
+
+  if (on) {
+    _st_curr_time = time(NULL);
+    _st_last_tset = st_utime();
+  } else
+    _st_curr_time = 0;
+
+  return wason;
+}
+
+
+time_t st_time(void)
+{
+  if (_st_curr_time)
+    return _st_curr_time;
+
+  return time(NULL);
+}
+
+
+int st_usleep(st_utime_t usecs)
+{
+  _st_thread_t *me = _ST_CURRENT_THREAD();
+
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+  if (usecs != ST_UTIME_NO_TIMEOUT) {
+    me-&gt;state = _ST_ST_SLEEPING;
+    _ST_ADD_SLEEPQ(me, usecs);
+  } else
+    me-&gt;state = _ST_ST_SUSPENDED;
+
+  _ST_SWITCH_CONTEXT(me);
+
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int st_sleep(int secs)
+{
+  return st_usleep((secs &gt;= 0) ? secs * 1000000LL : ST_UTIME_NO_TIMEOUT);
+}
+
+
+/*****************************************
+ * Condition variable functions
+ */
+
+_st_cond_t *st_cond_new(void)
+{
+  _st_cond_t *cvar;
+
+  cvar = (_st_cond_t *) calloc(1, sizeof(_st_cond_t));
+  if (cvar) {
+    ST_INIT_CLIST(&amp;cvar-&gt;wait_q);
+  }
+
+  return cvar;
+}
+
+
+int st_cond_destroy(_st_cond_t *cvar)
+{
+  if (cvar-&gt;wait_q.next != &amp;cvar-&gt;wait_q) {
+    errno = EBUSY;
+    return -1;
+  }
+
+  free(cvar);
+
+  return 0;
+}
+
+
+int st_cond_timedwait(_st_cond_t *cvar, st_utime_t timeout)
+{
+  _st_thread_t *me = _ST_CURRENT_THREAD();
+  int rv;
+
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+  /* Put caller thread on the condition variable's wait queue */
+  me-&gt;state = _ST_ST_COND_WAIT;
+  ST_APPEND_LINK(&amp;me-&gt;wait_links, &amp;cvar-&gt;wait_q);
+
+  if (timeout != ST_UTIME_NO_TIMEOUT)
+    _ST_ADD_SLEEPQ(me, timeout);
+
+  _ST_SWITCH_CONTEXT(me);
+
+  ST_REMOVE_LINK(&amp;me-&gt;wait_links);
+  rv = 0;
+
+  if (me-&gt;flags &amp; _ST_FL_TIMEDOUT) {
+    me-&gt;flags &amp;= ~_ST_FL_TIMEDOUT;
+    errno = ETIME;
+    rv = -1;
+  }
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    rv = -1;
+  }
+
+  return rv;
+}
+
+
+int st_cond_wait(_st_cond_t *cvar)
+{
+  return st_cond_timedwait(cvar, ST_UTIME_NO_TIMEOUT);
+}
+
+
+static int _st_cond_signal(_st_cond_t *cvar, int broadcast)
+{
+  _st_thread_t *thread;
+  _st_clist_t *q;
+
+  for (q = cvar-&gt;wait_q.next; q != &amp;cvar-&gt;wait_q; q = q-&gt;next) {
+    thread = _ST_THREAD_WAITQ_PTR(q);
+    if (thread-&gt;state == _ST_ST_COND_WAIT) {
+      if (thread-&gt;flags &amp; _ST_FL_ON_SLEEPQ)
+	_ST_DEL_SLEEPQ(thread);
+
+      /* Make thread runnable */
+      thread-&gt;state = _ST_ST_RUNNABLE;
+      _ST_ADD_RUNQ(thread);
+      if (!broadcast)
+	break;
+    }
+  }
+
+  return 0;
+}
+
+
+int st_cond_signal(_st_cond_t *cvar)
+{
+  return _st_cond_signal(cvar, 0);
+}
+
+
+int st_cond_broadcast(_st_cond_t *cvar)
+{
+  return _st_cond_signal(cvar, 1);
+}
+
+
+/*****************************************
+ * Mutex functions
+ */
+
+_st_mutex_t *st_mutex_new(void)
+{
+  _st_mutex_t *lock;
+
+  lock = (_st_mutex_t *) calloc(1, sizeof(_st_mutex_t));
+  if (lock) {
+    ST_INIT_CLIST(&amp;lock-&gt;wait_q);
+    lock-&gt;owner = NULL;
+  }
+
+  return lock;
+}
+
+
+int st_mutex_destroy(_st_mutex_t *lock)
+{
+  if (lock-&gt;owner != NULL || lock-&gt;wait_q.next != &amp;lock-&gt;wait_q) {
+    errno = EBUSY;
+    return -1;
+  }
+
+  free(lock);
+
+  return 0;
+}
+
+
+int st_mutex_lock(_st_mutex_t *lock)
+{
+  _st_thread_t *me = _ST_CURRENT_THREAD();
+
+  if (me-&gt;flags &amp; _ST_FL_INTERRUPT) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+  if (lock-&gt;owner == NULL) {
+    /* Got the mutex */
+    lock-&gt;owner = me;
+    return 0;
+  }
+
+  if (lock-&gt;owner == me) {
+    errno = EDEADLK;
+    return -1;
+  }
+
+  /* Put caller thread on the mutex's wait queue */
+  me-&gt;state = _ST_ST_LOCK_WAIT;
+  ST_APPEND_LINK(&amp;me-&gt;wait_links, &amp;lock-&gt;wait_q);
+
+  _ST_SWITCH_CONTEXT(me);
+
+  ST_REMOVE_LINK(&amp;me-&gt;wait_links);
+
+  if ((me-&gt;flags &amp; _ST_FL_INTERRUPT) &amp;&amp; lock-&gt;owner != me) {
+    me-&gt;flags &amp;= ~_ST_FL_INTERRUPT;
+    errno = EINTR;
+    return -1;
+  }
+
+  return 0;
+}
+
+
+int st_mutex_unlock(_st_mutex_t *lock)
+{
+  _st_thread_t *thread;
+  _st_clist_t *q;
+
+  if (lock-&gt;owner != _ST_CURRENT_THREAD()) {
+    errno = EPERM;
+    return -1;
+  }
+
+  for (q = lock-&gt;wait_q.next; q != &amp;lock-&gt;wait_q; q = q-&gt;next) {
+    thread = _ST_THREAD_WAITQ_PTR(q);
+    if (thread-&gt;state == _ST_ST_LOCK_WAIT) {
+      lock-&gt;owner = thread;
+      /* Make thread runnable */
+      thread-&gt;state = _ST_ST_RUNNABLE;
+      _ST_ADD_RUNQ(thread);
+      return 0;
+    }
+  }
+
+  /* No threads waiting on this mutex */
+  lock-&gt;owner = NULL;
+
+  return 0;
+}
+
+
+int st_mutex_trylock(_st_mutex_t *lock)
+{
+  if (lock-&gt;owner != NULL) {
+    errno = EBUSY;
+    return -1;
+  }
+
+  /* Got the mutex */
+  lock-&gt;owner = _ST_CURRENT_THREAD();
+
+  return 0;
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000080.html">[Upwatch-commits] r549 - upwatch/trunk/uw_sysstat/uw_sysstat.d/syslog
</A></li>
	<LI>Next message: <A HREF="000083.html">[Upwatch-commits] r551 - in upwatch/trunk: . cfg libstatgrab-0.13 libstatgrab-0.13/docs libstatgrab-0.13/docs/libstatgrab libstatgrab-0.13/docs/saidar libstatgrab-0.13/docs/statgrab libstatgrab-0.13/examples libstatgrab-0.13/src libstatgrab-0.13/src/libstatgrab libstatgrab-0.13/src/saidar libstatgrab-0.13/src/statgrab util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#82">[ date ]</a>
              <a href="thread.html#82">[ thread ]</a>
              <a href="subject.html#82">[ subject ]</a>
              <a href="author.html#82">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/upwatch-commits">More information about the Upwatch-commits
mailing list</a><br>
</body></html>
